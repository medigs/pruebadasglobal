(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn2, res) => function __init() {
    return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/jquery/dist/jquery.js
  var require_jquery = __commonJS({
    "node_modules/jquery/dist/jquery.js"(exports, module) {
      (function(global, factory) {
        "use strict";
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = global.document ? factory(global, true) : function(w2) {
            if (!w2.document) {
              throw new Error("jQuery requires a window with a document");
            }
            return factory(w2);
          };
        } else {
          factory(global);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
        "use strict";
        var arr = [];
        var getProto = Object.getPrototypeOf;
        var slice = arr.slice;
        var flat = arr.flat ? function(array) {
          return arr.flat.call(array);
        } : function(array) {
          return arr.concat.apply([], array);
        };
        var push = arr.push;
        var indexOf2 = arr.indexOf;
        var class2type = {};
        var toString = class2type.toString;
        var hasOwn = class2type.hasOwnProperty;
        var fnToString = hasOwn.toString;
        var ObjectFunctionString = fnToString.call(Object);
        var support = {};
        var isFunction = function isFunction2(obj) {
          return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
        };
        var isWindow = function isWindow2(obj) {
          return obj != null && obj === obj.window;
        };
        var document2 = window2.document;
        var preservedScriptAttributes = {
          type: true,
          src: true,
          nonce: true,
          noModule: true
        };
        function DOMEval(code, node, doc) {
          doc = doc || document2;
          var i2, val, script = doc.createElement("script");
          script.text = code;
          if (node) {
            for (i2 in preservedScriptAttributes) {
              val = node[i2] || node.getAttribute && node.getAttribute(i2);
              if (val) {
                script.setAttribute(i2, val);
              }
            }
          }
          doc.head.appendChild(script).parentNode.removeChild(script);
        }
        function toType2(obj) {
          if (obj == null) {
            return obj + "";
          }
          return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        }
        var version = "3.7.1", rhtmlSuffix = /HTML$/i, jQuery6 = function(selector, context) {
          return new jQuery6.fn.init(selector, context);
        };
        jQuery6.fn = jQuery6.prototype = {
          // The current version of jQuery being used
          jquery: version,
          constructor: jQuery6,
          // The default length of a jQuery object is 0
          length: 0,
          toArray: function() {
            return slice.call(this);
          },
          // Get the Nth element in the matched element set OR
          // Get the whole matched element set as a clean array
          get: function(num) {
            if (num == null) {
              return slice.call(this);
            }
            return num < 0 ? this[num + this.length] : this[num];
          },
          // Take an array of elements and push it onto the stack
          // (returning the new matched element set)
          pushStack: function(elems) {
            var ret = jQuery6.merge(this.constructor(), elems);
            ret.prevObject = this;
            return ret;
          },
          // Execute a callback for every element in the matched set.
          each: function(callback) {
            return jQuery6.each(this, callback);
          },
          map: function(callback) {
            return this.pushStack(jQuery6.map(this, function(elem, i2) {
              return callback.call(elem, i2, elem);
            }));
          },
          slice: function() {
            return this.pushStack(slice.apply(this, arguments));
          },
          first: function() {
            return this.eq(0);
          },
          last: function() {
            return this.eq(-1);
          },
          even: function() {
            return this.pushStack(jQuery6.grep(this, function(_elem, i2) {
              return (i2 + 1) % 2;
            }));
          },
          odd: function() {
            return this.pushStack(jQuery6.grep(this, function(_elem, i2) {
              return i2 % 2;
            }));
          },
          eq: function(i2) {
            var len = this.length, j2 = +i2 + (i2 < 0 ? len : 0);
            return this.pushStack(j2 >= 0 && j2 < len ? [this[j2]] : []);
          },
          end: function() {
            return this.prevObject || this.constructor();
          },
          // For internal use only.
          // Behaves like an Array's method, not like a jQuery method.
          push,
          sort: arr.sort,
          splice: arr.splice
        };
        jQuery6.extend = jQuery6.fn.extend = function() {
          var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i2 = 1, length = arguments.length, deep = false;
          if (typeof target === "boolean") {
            deep = target;
            target = arguments[i2] || {};
            i2++;
          }
          if (typeof target !== "object" && !isFunction(target)) {
            target = {};
          }
          if (i2 === length) {
            target = this;
            i2--;
          }
          for (; i2 < length; i2++) {
            if ((options = arguments[i2]) != null) {
              for (name in options) {
                copy = options[name];
                if (name === "__proto__" || target === copy) {
                  continue;
                }
                if (deep && copy && (jQuery6.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                  src = target[name];
                  if (copyIsArray && !Array.isArray(src)) {
                    clone = [];
                  } else if (!copyIsArray && !jQuery6.isPlainObject(src)) {
                    clone = {};
                  } else {
                    clone = src;
                  }
                  copyIsArray = false;
                  target[name] = jQuery6.extend(deep, clone, copy);
                } else if (copy !== void 0) {
                  target[name] = copy;
                }
              }
            }
          }
          return target;
        };
        jQuery6.extend({
          // Unique for each copy of jQuery on the page
          expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
          // Assume jQuery is ready without the ready module
          isReady: true,
          error: function(msg) {
            throw new Error(msg);
          },
          noop: function() {
          },
          isPlainObject: function(obj) {
            var proto, Ctor;
            if (!obj || toString.call(obj) !== "[object Object]") {
              return false;
            }
            proto = getProto(obj);
            if (!proto) {
              return true;
            }
            Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
            return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
          },
          isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
              return false;
            }
            return true;
          },
          // Evaluates a script in a provided context; falls back to the global one
          // if not specified.
          globalEval: function(code, options, doc) {
            DOMEval(code, { nonce: options && options.nonce }, doc);
          },
          each: function(obj, callback) {
            var length, i2 = 0;
            if (isArrayLike(obj)) {
              length = obj.length;
              for (; i2 < length; i2++) {
                if (callback.call(obj[i2], i2, obj[i2]) === false) {
                  break;
                }
              }
            } else {
              for (i2 in obj) {
                if (callback.call(obj[i2], i2, obj[i2]) === false) {
                  break;
                }
              }
            }
            return obj;
          },
          // Retrieve the text value of an array of DOM nodes
          text: function(elem) {
            var node, ret = "", i2 = 0, nodeType = elem.nodeType;
            if (!nodeType) {
              while (node = elem[i2++]) {
                ret += jQuery6.text(node);
              }
            }
            if (nodeType === 1 || nodeType === 11) {
              return elem.textContent;
            }
            if (nodeType === 9) {
              return elem.documentElement.textContent;
            }
            if (nodeType === 3 || nodeType === 4) {
              return elem.nodeValue;
            }
            return ret;
          },
          // results is for internal usage only
          makeArray: function(arr2, results) {
            var ret = results || [];
            if (arr2 != null) {
              if (isArrayLike(Object(arr2))) {
                jQuery6.merge(
                  ret,
                  typeof arr2 === "string" ? [arr2] : arr2
                );
              } else {
                push.call(ret, arr2);
              }
            }
            return ret;
          },
          inArray: function(elem, arr2, i2) {
            return arr2 == null ? -1 : indexOf2.call(arr2, elem, i2);
          },
          isXMLDoc: function(elem) {
            var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
            return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
          },
          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          merge: function(first, second) {
            var len = +second.length, j2 = 0, i2 = first.length;
            for (; j2 < len; j2++) {
              first[i2++] = second[j2];
            }
            first.length = i2;
            return first;
          },
          grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i2 = 0, length = elems.length, callbackExpect = !invert;
            for (; i2 < length; i2++) {
              callbackInverse = !callback(elems[i2], i2);
              if (callbackInverse !== callbackExpect) {
                matches.push(elems[i2]);
              }
            }
            return matches;
          },
          // arg is for internal usage only
          map: function(elems, callback, arg) {
            var length, value, i2 = 0, ret = [];
            if (isArrayLike(elems)) {
              length = elems.length;
              for (; i2 < length; i2++) {
                value = callback(elems[i2], i2, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            } else {
              for (i2 in elems) {
                value = callback(elems[i2], i2, arg);
                if (value != null) {
                  ret.push(value);
                }
              }
            }
            return flat(ret);
          },
          // A global GUID counter for objects
          guid: 1,
          // jQuery.support is not used in Core but other projects attach their
          // properties to it so it needs to exist.
          support
        });
        if (typeof Symbol === "function") {
          jQuery6.fn[Symbol.iterator] = arr[Symbol.iterator];
        }
        jQuery6.each(
          "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
          function(_i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase();
          }
        );
        function isArrayLike(obj) {
          var length = !!obj && "length" in obj && obj.length, type = toType2(obj);
          if (isFunction(obj) || isWindow(obj)) {
            return false;
          }
          return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
        }
        function nodeName(elem, name) {
          return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        }
        var pop = arr.pop;
        var sort = arr.sort;
        var splice = arr.splice;
        var whitespace = "[\\x20\\t\\r\\n\\f]";
        var rtrimCSS = new RegExp(
          "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
          "g"
        );
        jQuery6.contains = function(a2, b2) {
          var bup = b2 && b2.parentNode;
          return a2 === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
          // IE doesn't have `contains` on SVG.
          (a2.contains ? a2.contains(bup) : a2.compareDocumentPosition && a2.compareDocumentPosition(bup) & 16));
        };
        var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
        function fcssescape(ch, asCodePoint) {
          if (asCodePoint) {
            if (ch === "\0") {
              return "\uFFFD";
            }
            return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
          }
          return "\\" + ch;
        }
        jQuery6.escapeSelector = function(sel) {
          return (sel + "").replace(rcssescape, fcssescape);
        };
        var preferredDoc = document2, pushNative = push;
        (function() {
          var i2, Expr, outermostContext, sortInput, hasDuplicate, push2 = pushNative, document3, documentElement2, documentIsHTML, rbuggyQSA, matches, expando = jQuery6.expando, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a2, b2) {
            if (a2 === b2) {
              hasDuplicate = true;
            }
            return 0;
          }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
          "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
          `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rleadingCombinator = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            ID: new RegExp("^#(" + identifier + ")"),
            CLASS: new RegExp("^\\.(" + identifier + ")"),
            TAG: new RegExp("^(" + identifier + "|[*])"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            CHILD: new RegExp(
              "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)",
              "i"
            ),
            bool: new RegExp("^(?:" + booleans + ")$", "i"),
            // For use in libraries implementing .is()
            // We use this for POS matching in `select`
            needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
          }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape2, nonHex) {
            var high = "0x" + escape2.slice(1) - 65536;
            if (nonHex) {
              return nonHex;
            }
            return high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
          }, unloadHandler = function() {
            setDocument();
          }, inDisabledFieldset = addCombinator(
            function(elem) {
              return elem.disabled === true && nodeName(elem, "fieldset");
            },
            { dir: "parentNode", next: "legend" }
          );
          function safeActiveElement() {
            try {
              return document3.activeElement;
            } catch (err) {
            }
          }
          try {
            push2.apply(
              arr = slice.call(preferredDoc.childNodes),
              preferredDoc.childNodes
            );
            arr[preferredDoc.childNodes.length].nodeType;
          } catch (e2) {
            push2 = {
              apply: function(target, els) {
                pushNative.apply(target, slice.call(els));
              },
              call: function(target) {
                pushNative.apply(target, slice.call(arguments, 1));
              }
            };
          }
          function find(selector, context, results, seed) {
            var m2, i3, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
            results = results || [];
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
              return results;
            }
            if (!seed) {
              setDocument(context);
              context = context || document3;
              if (documentIsHTML) {
                if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                  if (m2 = match[1]) {
                    if (nodeType === 9) {
                      if (elem = context.getElementById(m2)) {
                        if (elem.id === m2) {
                          push2.call(results, elem);
                          return results;
                        }
                      } else {
                        return results;
                      }
                    } else {
                      if (newContext && (elem = newContext.getElementById(m2)) && find.contains(context, elem) && elem.id === m2) {
                        push2.call(results, elem);
                        return results;
                      }
                    }
                  } else if (match[2]) {
                    push2.apply(results, context.getElementsByTagName(selector));
                    return results;
                  } else if ((m2 = match[3]) && context.getElementsByClassName) {
                    push2.apply(results, context.getElementsByClassName(m2));
                    return results;
                  }
                }
                if (!nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                  newSelector = selector;
                  newContext = context;
                  if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                    newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                    if (newContext != context || !support.scope) {
                      if (nid = context.getAttribute("id")) {
                        nid = jQuery6.escapeSelector(nid);
                      } else {
                        context.setAttribute("id", nid = expando);
                      }
                    }
                    groups = tokenize2(selector);
                    i3 = groups.length;
                    while (i3--) {
                      groups[i3] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i3]);
                    }
                    newSelector = groups.join(",");
                  }
                  try {
                    push2.apply(
                      results,
                      newContext.querySelectorAll(newSelector)
                    );
                    return results;
                  } catch (qsaError) {
                    nonnativeSelectorCache(selector, true);
                  } finally {
                    if (nid === expando) {
                      context.removeAttribute("id");
                    }
                  }
                }
              }
            }
            return select(selector.replace(rtrimCSS, "$1"), context, results, seed);
          }
          function createCache() {
            var keys = [];
            function cache2(key, value) {
              if (keys.push(key + " ") > Expr.cacheLength) {
                delete cache2[keys.shift()];
              }
              return cache2[key + " "] = value;
            }
            return cache2;
          }
          function markFunction(fn2) {
            fn2[expando] = true;
            return fn2;
          }
          function assert(fn2) {
            var el = document3.createElement("fieldset");
            try {
              return !!fn2(el);
            } catch (e2) {
              return false;
            } finally {
              if (el.parentNode) {
                el.parentNode.removeChild(el);
              }
              el = null;
            }
          }
          function createInputPseudo(type) {
            return function(elem) {
              return nodeName(elem, "input") && elem.type === type;
            };
          }
          function createButtonPseudo(type) {
            return function(elem) {
              return (nodeName(elem, "input") || nodeName(elem, "button")) && elem.type === type;
            };
          }
          function createDisabledPseudo(disabled) {
            return function(elem) {
              if ("form" in elem) {
                if (elem.parentNode && elem.disabled === false) {
                  if ("label" in elem) {
                    if ("label" in elem.parentNode) {
                      return elem.parentNode.disabled === disabled;
                    } else {
                      return elem.disabled === disabled;
                    }
                  }
                  return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                  elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
                }
                return elem.disabled === disabled;
              } else if ("label" in elem) {
                return elem.disabled === disabled;
              }
              return false;
            };
          }
          function createPositionalPseudo(fn2) {
            return markFunction(function(argument) {
              argument = +argument;
              return markFunction(function(seed, matches2) {
                var j2, matchIndexes = fn2([], seed.length, argument), i3 = matchIndexes.length;
                while (i3--) {
                  if (seed[j2 = matchIndexes[i3]]) {
                    seed[j2] = !(matches2[j2] = seed[j2]);
                  }
                }
              });
            });
          }
          function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
          }
          function setDocument(node) {
            var subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
            if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
              return document3;
            }
            document3 = doc;
            documentElement2 = document3.documentElement;
            documentIsHTML = !jQuery6.isXMLDoc(document3);
            matches = documentElement2.matches || documentElement2.webkitMatchesSelector || documentElement2.msMatchesSelector;
            if (documentElement2.msMatchesSelector && // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
              subWindow.addEventListener("unload", unloadHandler);
            }
            support.getById = assert(function(el) {
              documentElement2.appendChild(el).id = jQuery6.expando;
              return !document3.getElementsByName || !document3.getElementsByName(jQuery6.expando).length;
            });
            support.disconnectedMatch = assert(function(el) {
              return matches.call(el, "*");
            });
            support.scope = assert(function() {
              return document3.querySelectorAll(":scope");
            });
            support.cssHas = assert(function() {
              try {
                document3.querySelector(":has(*,:jqfake)");
                return false;
              } catch (e2) {
                return true;
              }
            });
            if (support.getById) {
              Expr.filter.ID = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                  return elem.getAttribute("id") === attrId;
                };
              };
              Expr.find.ID = function(id, context) {
                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                  var elem = context.getElementById(id);
                  return elem ? [elem] : [];
                }
              };
            } else {
              Expr.filter.ID = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                  var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                  return node2 && node2.value === attrId;
                };
              };
              Expr.find.ID = function(id, context) {
                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                  var node2, i3, elems, elem = context.getElementById(id);
                  if (elem) {
                    node2 = elem.getAttributeNode("id");
                    if (node2 && node2.value === id) {
                      return [elem];
                    }
                    elems = context.getElementsByName(id);
                    i3 = 0;
                    while (elem = elems[i3++]) {
                      node2 = elem.getAttributeNode("id");
                      if (node2 && node2.value === id) {
                        return [elem];
                      }
                    }
                  }
                  return [];
                }
              };
            }
            Expr.find.TAG = function(tag, context) {
              if (typeof context.getElementsByTagName !== "undefined") {
                return context.getElementsByTagName(tag);
              } else {
                return context.querySelectorAll(tag);
              }
            };
            Expr.find.CLASS = function(className, context) {
              if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                return context.getElementsByClassName(className);
              }
            };
            rbuggyQSA = [];
            assert(function(el) {
              var input;
              documentElement2.appendChild(el).innerHTML = "<a id='" + expando + "' href='' disabled='disabled'></a><select id='" + expando + "-\r\\' disabled='disabled'><option selected=''></option></select>";
              if (!el.querySelectorAll("[selected]").length) {
                rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
              }
              if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                rbuggyQSA.push("~=");
              }
              if (!el.querySelectorAll("a#" + expando + "+*").length) {
                rbuggyQSA.push(".#.+[+~]");
              }
              if (!el.querySelectorAll(":checked").length) {
                rbuggyQSA.push(":checked");
              }
              input = document3.createElement("input");
              input.setAttribute("type", "hidden");
              el.appendChild(input).setAttribute("name", "D");
              documentElement2.appendChild(el).disabled = true;
              if (el.querySelectorAll(":disabled").length !== 2) {
                rbuggyQSA.push(":enabled", ":disabled");
              }
              input = document3.createElement("input");
              input.setAttribute("name", "");
              el.appendChild(input);
              if (!el.querySelectorAll("[name='']").length) {
                rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`);
              }
            });
            if (!support.cssHas) {
              rbuggyQSA.push(":has");
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            sortOrder = function(a2, b2) {
              if (a2 === b2) {
                hasDuplicate = true;
                return 0;
              }
              var compare = !a2.compareDocumentPosition - !b2.compareDocumentPosition;
              if (compare) {
                return compare;
              }
              compare = (a2.ownerDocument || a2) == (b2.ownerDocument || b2) ? a2.compareDocumentPosition(b2) : (
                // Otherwise we know they are disconnected
                1
              );
              if (compare & 1 || !support.sortDetached && b2.compareDocumentPosition(a2) === compare) {
                if (a2 === document3 || a2.ownerDocument == preferredDoc && find.contains(preferredDoc, a2)) {
                  return -1;
                }
                if (b2 === document3 || b2.ownerDocument == preferredDoc && find.contains(preferredDoc, b2)) {
                  return 1;
                }
                return sortInput ? indexOf2.call(sortInput, a2) - indexOf2.call(sortInput, b2) : 0;
              }
              return compare & 4 ? -1 : 1;
            };
            return document3;
          }
          find.matches = function(expr, elements) {
            return find(expr, null, null, elements);
          };
          find.matchesSelector = function(elem, expr) {
            setDocument(elem);
            if (documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
              try {
                var ret = matches.call(elem, expr);
                if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
                // fragment in IE 9
                elem.document && elem.document.nodeType !== 11) {
                  return ret;
                }
              } catch (e2) {
                nonnativeSelectorCache(expr, true);
              }
            }
            return find(expr, document3, null, [elem]).length > 0;
          };
          find.contains = function(context, elem) {
            if ((context.ownerDocument || context) != document3) {
              setDocument(context);
            }
            return jQuery6.contains(context, elem);
          };
          find.attr = function(elem, name) {
            if ((elem.ownerDocument || elem) != document3) {
              setDocument(elem);
            }
            var fn2 = Expr.attrHandle[name.toLowerCase()], val = fn2 && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn2(elem, name, !documentIsHTML) : void 0;
            if (val !== void 0) {
              return val;
            }
            return elem.getAttribute(name);
          };
          find.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
          };
          jQuery6.uniqueSort = function(results) {
            var elem, duplicates = [], j2 = 0, i3 = 0;
            hasDuplicate = !support.sortStable;
            sortInput = !support.sortStable && slice.call(results, 0);
            sort.call(results, sortOrder);
            if (hasDuplicate) {
              while (elem = results[i3++]) {
                if (elem === results[i3]) {
                  j2 = duplicates.push(i3);
                }
              }
              while (j2--) {
                splice.call(results, duplicates[j2], 1);
              }
            }
            sortInput = null;
            return results;
          };
          jQuery6.fn.uniqueSort = function() {
            return this.pushStack(jQuery6.uniqueSort(slice.apply(this)));
          };
          Expr = jQuery6.expr = {
            // Can be adjusted by the user
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
              ">": { dir: "parentNode", first: true },
              " ": { dir: "parentNode" },
              "+": { dir: "previousSibling", first: true },
              "~": { dir: "previousSibling" }
            },
            preFilter: {
              ATTR: function(match) {
                match[1] = match[1].replace(runescape, funescape);
                match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
                if (match[2] === "~=") {
                  match[3] = " " + match[3] + " ";
                }
                return match.slice(0, 4);
              },
              CHILD: function(match) {
                match[1] = match[1].toLowerCase();
                if (match[1].slice(0, 3) === "nth") {
                  if (!match[3]) {
                    find.error(match[0]);
                  }
                  match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                  match[5] = +(match[7] + match[8] || match[3] === "odd");
                } else if (match[3]) {
                  find.error(match[0]);
                }
                return match;
              },
              PSEUDO: function(match) {
                var excess, unquoted = !match[6] && match[2];
                if (matchExpr.CHILD.test(match[0])) {
                  return null;
                }
                if (match[3]) {
                  match[2] = match[4] || match[5] || "";
                } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
                (excess = tokenize2(unquoted, true)) && // advance to the next closing parenthesis
                (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                  match[0] = match[0].slice(0, excess);
                  match[2] = unquoted.slice(0, excess);
                }
                return match.slice(0, 3);
              }
            },
            filter: {
              TAG: function(nodeNameSelector) {
                var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                return nodeNameSelector === "*" ? function() {
                  return true;
                } : function(elem) {
                  return nodeName(elem, expectedNodeName);
                };
              },
              CLASS: function(className) {
                var pattern = classCache[className + " "];
                return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                  return pattern.test(
                    typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                  );
                });
              },
              ATTR: function(name, operator, check) {
                return function(elem) {
                  var result = find.attr(elem, name);
                  if (result == null) {
                    return operator === "!=";
                  }
                  if (!operator) {
                    return true;
                  }
                  result += "";
                  if (operator === "=") {
                    return result === check;
                  }
                  if (operator === "!=") {
                    return result !== check;
                  }
                  if (operator === "^=") {
                    return check && result.indexOf(check) === 0;
                  }
                  if (operator === "*=") {
                    return check && result.indexOf(check) > -1;
                  }
                  if (operator === "$=") {
                    return check && result.slice(-check.length) === check;
                  }
                  if (operator === "~=") {
                    return (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1;
                  }
                  if (operator === "|=") {
                    return result === check || result.slice(0, check.length + 1) === check + "-";
                  }
                  return false;
                };
              },
              CHILD: function(type, what, _argument, first, last) {
                var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
                return first === 1 && last === 0 ? (
                  // Shortcut for :nth-*(n)
                  function(elem) {
                    return !!elem.parentNode;
                  }
                ) : function(elem, _context, xml) {
                  var cache2, outerCache, node, nodeIndex, start3, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                  if (parent) {
                    if (simple) {
                      while (dir2) {
                        node = elem;
                        while (node = node[dir2]) {
                          if (ofType ? nodeName(node, name) : node.nodeType === 1) {
                            return false;
                          }
                        }
                        start3 = dir2 = type === "only" && !start3 && "nextSibling";
                      }
                      return true;
                    }
                    start3 = [forward ? parent.firstChild : parent.lastChild];
                    if (forward && useCache) {
                      outerCache = parent[expando] || (parent[expando] = {});
                      cache2 = outerCache[type] || [];
                      nodeIndex = cache2[0] === dirruns && cache2[1];
                      diff = nodeIndex && cache2[2];
                      node = nodeIndex && parent.childNodes[nodeIndex];
                      while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                      (diff = nodeIndex = 0) || start3.pop()) {
                        if (node.nodeType === 1 && ++diff && node === elem) {
                          outerCache[type] = [dirruns, nodeIndex, diff];
                          break;
                        }
                      }
                    } else {
                      if (useCache) {
                        outerCache = elem[expando] || (elem[expando] = {});
                        cache2 = outerCache[type] || [];
                        nodeIndex = cache2[0] === dirruns && cache2[1];
                        diff = nodeIndex;
                      }
                      if (diff === false) {
                        while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start3.pop()) {
                          if ((ofType ? nodeName(node, name) : node.nodeType === 1) && ++diff) {
                            if (useCache) {
                              outerCache = node[expando] || (node[expando] = {});
                              outerCache[type] = [dirruns, diff];
                            }
                            if (node === elem) {
                              break;
                            }
                          }
                        }
                      }
                    }
                    diff -= last;
                    return diff === first || diff % first === 0 && diff / first >= 0;
                  }
                };
              },
              PSEUDO: function(pseudo, argument) {
                var args, fn2 = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find.error("unsupported pseudo: " + pseudo);
                if (fn2[expando]) {
                  return fn2(argument);
                }
                if (fn2.length > 1) {
                  args = [pseudo, pseudo, "", argument];
                  return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                    var idx, matched = fn2(seed, argument), i3 = matched.length;
                    while (i3--) {
                      idx = indexOf2.call(seed, matched[i3]);
                      seed[idx] = !(matches2[idx] = matched[i3]);
                    }
                  }) : function(elem) {
                    return fn2(elem, 0, args);
                  };
                }
                return fn2;
              }
            },
            pseudos: {
              // Potentially complex pseudos
              not: markFunction(function(selector) {
                var input = [], results = [], matcher = compile(selector.replace(rtrimCSS, "$1"));
                return matcher[expando] ? markFunction(function(seed, matches2, _context, xml) {
                  var elem, unmatched = matcher(seed, null, xml, []), i3 = seed.length;
                  while (i3--) {
                    if (elem = unmatched[i3]) {
                      seed[i3] = !(matches2[i3] = elem);
                    }
                  }
                }) : function(elem, _context, xml) {
                  input[0] = elem;
                  matcher(input, null, xml, results);
                  input[0] = null;
                  return !results.pop();
                };
              }),
              has: markFunction(function(selector) {
                return function(elem) {
                  return find(selector, elem).length > 0;
                };
              }),
              contains: markFunction(function(text) {
                text = text.replace(runescape, funescape);
                return function(elem) {
                  return (elem.textContent || jQuery6.text(elem)).indexOf(text) > -1;
                };
              }),
              // "Whether an element is represented by a :lang() selector
              // is based solely on the element's language value
              // being equal to the identifier C,
              // or beginning with the identifier C immediately followed by "-".
              // The matching of C against the element's language value is performed case-insensitively.
              // The identifier C does not have to be a valid language name."
              // https://www.w3.org/TR/selectors/#lang-pseudo
              lang: markFunction(function(lang) {
                if (!ridentifier.test(lang || "")) {
                  find.error("unsupported lang: " + lang);
                }
                lang = lang.replace(runescape, funescape).toLowerCase();
                return function(elem) {
                  var elemLang;
                  do {
                    if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                      elemLang = elemLang.toLowerCase();
                      return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                    }
                  } while ((elem = elem.parentNode) && elem.nodeType === 1);
                  return false;
                };
              }),
              // Miscellaneous
              target: function(elem) {
                var hash3 = window2.location && window2.location.hash;
                return hash3 && hash3.slice(1) === elem.id;
              },
              root: function(elem) {
                return elem === documentElement2;
              },
              focus: function(elem) {
                return elem === safeActiveElement() && document3.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);
              },
              // Boolean properties
              enabled: createDisabledPseudo(false),
              disabled: createDisabledPseudo(true),
              checked: function(elem) {
                return nodeName(elem, "input") && !!elem.checked || nodeName(elem, "option") && !!elem.selected;
              },
              selected: function(elem) {
                if (elem.parentNode) {
                  elem.parentNode.selectedIndex;
                }
                return elem.selected === true;
              },
              // Contents
              empty: function(elem) {
                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                  if (elem.nodeType < 6) {
                    return false;
                  }
                }
                return true;
              },
              parent: function(elem) {
                return !Expr.pseudos.empty(elem);
              },
              // Element/input types
              header: function(elem) {
                return rheader.test(elem.nodeName);
              },
              input: function(elem) {
                return rinputs.test(elem.nodeName);
              },
              button: function(elem) {
                return nodeName(elem, "input") && elem.type === "button" || nodeName(elem, "button");
              },
              text: function(elem) {
                var attr;
                return nodeName(elem, "input") && elem.type === "text" && // Support: IE <10 only
                // New HTML5 attribute values (e.g., "search") appear
                // with elem.type === "text"
                ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
              },
              // Position-in-collection
              first: createPositionalPseudo(function() {
                return [0];
              }),
              last: createPositionalPseudo(function(_matchIndexes, length) {
                return [length - 1];
              }),
              eq: createPositionalPseudo(function(_matchIndexes, length, argument) {
                return [argument < 0 ? argument + length : argument];
              }),
              even: createPositionalPseudo(function(matchIndexes, length) {
                var i3 = 0;
                for (; i3 < length; i3 += 2) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              }),
              odd: createPositionalPseudo(function(matchIndexes, length) {
                var i3 = 1;
                for (; i3 < length; i3 += 2) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              }),
              lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                var i3;
                if (argument < 0) {
                  i3 = argument + length;
                } else if (argument > length) {
                  i3 = length;
                } else {
                  i3 = argument;
                }
                for (; --i3 >= 0; ) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              }),
              gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                var i3 = argument < 0 ? argument + length : argument;
                for (; ++i3 < length; ) {
                  matchIndexes.push(i3);
                }
                return matchIndexes;
              })
            }
          };
          Expr.pseudos.nth = Expr.pseudos.eq;
          for (i2 in { radio: true, checkbox: true, file: true, password: true, image: true }) {
            Expr.pseudos[i2] = createInputPseudo(i2);
          }
          for (i2 in { submit: true, reset: true }) {
            Expr.pseudos[i2] = createButtonPseudo(i2);
          }
          function setFilters() {
          }
          setFilters.prototype = Expr.filters = Expr.pseudos;
          Expr.setFilters = new setFilters();
          function tokenize2(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) {
              return parseOnly ? 0 : cached.slice(0);
            }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
              if (!matched || (match = rcomma.exec(soFar))) {
                if (match) {
                  soFar = soFar.slice(match[0].length) || soFar;
                }
                groups.push(tokens = []);
              }
              matched = false;
              if (match = rleadingCombinator.exec(soFar)) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  // Cast descendant combinators to space
                  type: match[0].replace(rtrimCSS, " ")
                });
                soFar = soFar.slice(matched.length);
              }
              for (type in Expr.filter) {
                if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                  matched = match.shift();
                  tokens.push({
                    value: matched,
                    type,
                    matches: match
                  });
                  soFar = soFar.slice(matched.length);
                }
              }
              if (!matched) {
                break;
              }
            }
            if (parseOnly) {
              return soFar.length;
            }
            return soFar ? find.error(selector) : (
              // Cache the tokens
              tokenCache(selector, groups).slice(0)
            );
          }
          function toSelector(tokens) {
            var i3 = 0, len = tokens.length, selector = "";
            for (; i3 < len; i3++) {
              selector += tokens[i3].value;
            }
            return selector;
          }
          function addCombinator(matcher, combinator, base) {
            var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
            return combinator.first ? (
              // Check against closest ancestor/preceding element
              function(elem, context, xml) {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    return matcher(elem, context, xml);
                  }
                }
                return false;
              }
            ) : (
              // Check against all ancestor/preceding elements
              function(elem, context, xml) {
                var oldCache, outerCache, newCache = [dirruns, doneName];
                if (xml) {
                  while (elem = elem[dir2]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                      if (matcher(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                } else {
                  while (elem = elem[dir2]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                      outerCache = elem[expando] || (elem[expando] = {});
                      if (skip && nodeName(elem, skip)) {
                        elem = elem[dir2] || elem;
                      } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                        return newCache[2] = oldCache[2];
                      } else {
                        outerCache[key] = newCache;
                        if (newCache[2] = matcher(elem, context, xml)) {
                          return true;
                        }
                      }
                    }
                  }
                }
                return false;
              }
            );
          }
          function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
              var i3 = matchers.length;
              while (i3--) {
                if (!matchers[i3](elem, context, xml)) {
                  return false;
                }
              }
              return true;
            } : matchers[0];
          }
          function multipleContexts(selector, contexts, results) {
            var i3 = 0, len = contexts.length;
            for (; i3 < len; i3++) {
              find(selector, contexts[i3], results);
            }
            return results;
          }
          function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i3 = 0, len = unmatched.length, mapped = map != null;
            for (; i3 < len; i3++) {
              if (elem = unmatched[i3]) {
                if (!filter || filter(elem, context, xml)) {
                  newUnmatched.push(elem);
                  if (mapped) {
                    map.push(i3);
                  }
                }
              }
            }
            return newUnmatched;
          }
          function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
              postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
              postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
              var temp, i3, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
                selector || "*",
                context.nodeType ? [context] : context,
                []
              ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems;
              if (matcher) {
                matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ? (
                  // ...intermediate processing is necessary
                  []
                ) : (
                  // ...otherwise use results directly
                  results
                );
                matcher(matcherIn, matcherOut, context, xml);
              } else {
                matcherOut = matcherIn;
              }
              if (postFilter) {
                temp = condense(matcherOut, postMap);
                postFilter(temp, [], context, xml);
                i3 = temp.length;
                while (i3--) {
                  if (elem = temp[i3]) {
                    matcherOut[postMap[i3]] = !(matcherIn[postMap[i3]] = elem);
                  }
                }
              }
              if (seed) {
                if (postFinder || preFilter) {
                  if (postFinder) {
                    temp = [];
                    i3 = matcherOut.length;
                    while (i3--) {
                      if (elem = matcherOut[i3]) {
                        temp.push(matcherIn[i3] = elem);
                      }
                    }
                    postFinder(null, matcherOut = [], temp, xml);
                  }
                  i3 = matcherOut.length;
                  while (i3--) {
                    if ((elem = matcherOut[i3]) && (temp = postFinder ? indexOf2.call(seed, elem) : preMap[i3]) > -1) {
                      seed[temp] = !(results[temp] = elem);
                    }
                  }
                }
              } else {
                matcherOut = condense(
                  matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
                );
                if (postFinder) {
                  postFinder(null, results, matcherOut, xml);
                } else {
                  push2.apply(results, matcherOut);
                }
              }
            });
          }
          function matcherFromTokens(tokens) {
            var checkContext, matcher, j2, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i3 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
              return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
              return indexOf2.call(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [function(elem, context, xml) {
              var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
              checkContext = null;
              return ret;
            }];
            for (; i3 < len; i3++) {
              if (matcher = Expr.relative[tokens[i3].type]) {
                matchers = [addCombinator(elementMatcher(matchers), matcher)];
              } else {
                matcher = Expr.filter[tokens[i3].type].apply(null, tokens[i3].matches);
                if (matcher[expando]) {
                  j2 = ++i3;
                  for (; j2 < len; j2++) {
                    if (Expr.relative[tokens[j2].type]) {
                      break;
                    }
                  }
                  return setMatcher(
                    i3 > 1 && elementMatcher(matchers),
                    i3 > 1 && toSelector(
                      // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                      tokens.slice(0, i3 - 1).concat({ value: tokens[i3 - 2].type === " " ? "*" : "" })
                    ).replace(rtrimCSS, "$1"),
                    matcher,
                    i3 < j2 && matcherFromTokens(tokens.slice(i3, j2)),
                    j2 < len && matcherFromTokens(tokens = tokens.slice(j2)),
                    j2 < len && toSelector(tokens)
                  );
                }
                matchers.push(matcher);
              }
            }
            return elementMatcher(matchers);
          }
          function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
              var elem, j2, matcher, matchedCount = 0, i3 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
              if (outermost) {
                outermostContext = context == document3 || context || outermost;
              }
              for (; i3 !== len && (elem = elems[i3]) != null; i3++) {
                if (byElement && elem) {
                  j2 = 0;
                  if (!context && elem.ownerDocument != document3) {
                    setDocument(elem);
                    xml = !documentIsHTML;
                  }
                  while (matcher = elementMatchers[j2++]) {
                    if (matcher(elem, context || document3, xml)) {
                      push2.call(results, elem);
                      break;
                    }
                  }
                  if (outermost) {
                    dirruns = dirrunsUnique;
                  }
                }
                if (bySet) {
                  if (elem = !matcher && elem) {
                    matchedCount--;
                  }
                  if (seed) {
                    unmatched.push(elem);
                  }
                }
              }
              matchedCount += i3;
              if (bySet && i3 !== matchedCount) {
                j2 = 0;
                while (matcher = setMatchers[j2++]) {
                  matcher(unmatched, setMatched, context, xml);
                }
                if (seed) {
                  if (matchedCount > 0) {
                    while (i3--) {
                      if (!(unmatched[i3] || setMatched[i3])) {
                        setMatched[i3] = pop.call(results);
                      }
                    }
                  }
                  setMatched = condense(setMatched);
                }
                push2.apply(results, setMatched);
                if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                  jQuery6.uniqueSort(results);
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
                outermostContext = contextBackup;
              }
              return unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
          }
          function compile(selector, match) {
            var i3, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
              if (!match) {
                match = tokenize2(selector);
              }
              i3 = match.length;
              while (i3--) {
                cached = matcherFromTokens(match[i3]);
                if (cached[expando]) {
                  setMatchers.push(cached);
                } else {
                  elementMatchers.push(cached);
                }
              }
              cached = compilerCache(
                selector,
                matcherFromGroupMatchers(elementMatchers, setMatchers)
              );
              cached.selector = selector;
            }
            return cached;
          }
          function select(selector, context, results, seed) {
            var i3, tokens, token, type, find2, compiled = typeof selector === "function" && selector, match = !seed && tokenize2(selector = compiled.selector || selector);
            results = results || [];
            if (match.length === 1) {
              tokens = match[0] = match[0].slice(0);
              if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                context = (Expr.find.ID(
                  token.matches[0].replace(runescape, funescape),
                  context
                ) || [])[0];
                if (!context) {
                  return results;
                } else if (compiled) {
                  context = context.parentNode;
                }
                selector = selector.slice(tokens.shift().value.length);
              }
              i3 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
              while (i3--) {
                token = tokens[i3];
                if (Expr.relative[type = token.type]) {
                  break;
                }
                if (find2 = Expr.find[type]) {
                  if (seed = find2(
                    token.matches[0].replace(runescape, funescape),
                    rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                  )) {
                    tokens.splice(i3, 1);
                    selector = seed.length && toSelector(tokens);
                    if (!selector) {
                      push2.apply(results, seed);
                      return results;
                    }
                    break;
                  }
                }
              }
            }
            (compiled || compile(selector, match))(
              seed,
              context,
              !documentIsHTML,
              results,
              !context || rsibling.test(selector) && testContext(context.parentNode) || context
            );
            return results;
          }
          support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
          setDocument();
          support.sortDetached = assert(function(el) {
            return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
          });
          jQuery6.find = find;
          jQuery6.expr[":"] = jQuery6.expr.pseudos;
          jQuery6.unique = jQuery6.uniqueSort;
          find.compile = compile;
          find.select = select;
          find.setDocument = setDocument;
          find.tokenize = tokenize2;
          find.escape = jQuery6.escapeSelector;
          find.getText = jQuery6.text;
          find.isXML = jQuery6.isXMLDoc;
          find.selectors = jQuery6.expr;
          find.support = jQuery6.support;
          find.uniqueSort = jQuery6.uniqueSort;
        })();
        var dir = function(elem, dir2, until) {
          var matched = [], truncate = until !== void 0;
          while ((elem = elem[dir2]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
              if (truncate && jQuery6(elem).is(until)) {
                break;
              }
              matched.push(elem);
            }
          }
          return matched;
        };
        var siblings = function(n2, elem) {
          var matched = [];
          for (; n2; n2 = n2.nextSibling) {
            if (n2.nodeType === 1 && n2 !== elem) {
              matched.push(n2);
            }
          }
          return matched;
        };
        var rneedsContext = jQuery6.expr.match.needsContext;
        var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
        function winnow(elements, qualifier, not) {
          if (isFunction(qualifier)) {
            return jQuery6.grep(elements, function(elem, i2) {
              return !!qualifier.call(elem, i2, elem) !== not;
            });
          }
          if (qualifier.nodeType) {
            return jQuery6.grep(elements, function(elem) {
              return elem === qualifier !== not;
            });
          }
          if (typeof qualifier !== "string") {
            return jQuery6.grep(elements, function(elem) {
              return indexOf2.call(qualifier, elem) > -1 !== not;
            });
          }
          return jQuery6.filter(qualifier, elements, not);
        }
        jQuery6.filter = function(expr, elems, not) {
          var elem = elems[0];
          if (not) {
            expr = ":not(" + expr + ")";
          }
          if (elems.length === 1 && elem.nodeType === 1) {
            return jQuery6.find.matchesSelector(elem, expr) ? [elem] : [];
          }
          return jQuery6.find.matches(expr, jQuery6.grep(elems, function(elem2) {
            return elem2.nodeType === 1;
          }));
        };
        jQuery6.fn.extend({
          find: function(selector) {
            var i2, ret, len = this.length, self2 = this;
            if (typeof selector !== "string") {
              return this.pushStack(jQuery6(selector).filter(function() {
                for (i2 = 0; i2 < len; i2++) {
                  if (jQuery6.contains(self2[i2], this)) {
                    return true;
                  }
                }
              }));
            }
            ret = this.pushStack([]);
            for (i2 = 0; i2 < len; i2++) {
              jQuery6.find(selector, self2[i2], ret);
            }
            return len > 1 ? jQuery6.uniqueSort(ret) : ret;
          },
          filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
          },
          not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
          },
          is: function(selector) {
            return !!winnow(
              this,
              // If this is a positional/relative selector, check membership in the returned set
              // so $("p:first").is("p:last") won't return true for a doc with two "p".
              typeof selector === "string" && rneedsContext.test(selector) ? jQuery6(selector) : selector || [],
              false
            ).length;
          }
        });
        var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery6.fn.init = function(selector, context, root) {
          var match, elem;
          if (!selector) {
            return this;
          }
          root = root || rootjQuery;
          if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
              match = [null, selector, null];
            } else {
              match = rquickExpr.exec(selector);
            }
            if (match && (match[1] || !context)) {
              if (match[1]) {
                context = context instanceof jQuery6 ? context[0] : context;
                jQuery6.merge(this, jQuery6.parseHTML(
                  match[1],
                  context && context.nodeType ? context.ownerDocument || context : document2,
                  true
                ));
                if (rsingleTag.test(match[1]) && jQuery6.isPlainObject(context)) {
                  for (match in context) {
                    if (isFunction(this[match])) {
                      this[match](context[match]);
                    } else {
                      this.attr(match, context[match]);
                    }
                  }
                }
                return this;
              } else {
                elem = document2.getElementById(match[2]);
                if (elem) {
                  this[0] = elem;
                  this.length = 1;
                }
                return this;
              }
            } else if (!context || context.jquery) {
              return (context || root).find(selector);
            } else {
              return this.constructor(context).find(selector);
            }
          } else if (selector.nodeType) {
            this[0] = selector;
            this.length = 1;
            return this;
          } else if (isFunction(selector)) {
            return root.ready !== void 0 ? root.ready(selector) : (
              // Execute immediately if ready is not present
              selector(jQuery6)
            );
          }
          return jQuery6.makeArray(selector, this);
        };
        init.prototype = jQuery6.fn;
        rootjQuery = jQuery6(document2);
        var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
          children: true,
          contents: true,
          next: true,
          prev: true
        };
        jQuery6.fn.extend({
          has: function(target) {
            var targets = jQuery6(target, this), l2 = targets.length;
            return this.filter(function() {
              var i2 = 0;
              for (; i2 < l2; i2++) {
                if (jQuery6.contains(this, targets[i2])) {
                  return true;
                }
              }
            });
          },
          closest: function(selectors, context) {
            var cur, i2 = 0, l2 = this.length, matched = [], targets = typeof selectors !== "string" && jQuery6(selectors);
            if (!rneedsContext.test(selectors)) {
              for (; i2 < l2; i2++) {
                for (cur = this[i2]; cur && cur !== context; cur = cur.parentNode) {
                  if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                    // Don't pass non-elements to jQuery#find
                    cur.nodeType === 1 && jQuery6.find.matchesSelector(cur, selectors)
                  ))) {
                    matched.push(cur);
                    break;
                  }
                }
              }
            }
            return this.pushStack(matched.length > 1 ? jQuery6.uniqueSort(matched) : matched);
          },
          // Determine the position of an element within the set
          index: function(elem) {
            if (!elem) {
              return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
            }
            if (typeof elem === "string") {
              return indexOf2.call(jQuery6(elem), this[0]);
            }
            return indexOf2.call(
              this,
              // If it receives a jQuery object, the first element is used
              elem.jquery ? elem[0] : elem
            );
          },
          add: function(selector, context) {
            return this.pushStack(
              jQuery6.uniqueSort(
                jQuery6.merge(this.get(), jQuery6(selector, context))
              )
            );
          },
          addBack: function(selector) {
            return this.add(
              selector == null ? this.prevObject : this.prevObject.filter(selector)
            );
          }
        });
        function sibling(cur, dir2) {
          while ((cur = cur[dir2]) && cur.nodeType !== 1) {
          }
          return cur;
        }
        jQuery6.each({
          parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
          },
          parents: function(elem) {
            return dir(elem, "parentNode");
          },
          parentsUntil: function(elem, _i, until) {
            return dir(elem, "parentNode", until);
          },
          next: function(elem) {
            return sibling(elem, "nextSibling");
          },
          prev: function(elem) {
            return sibling(elem, "previousSibling");
          },
          nextAll: function(elem) {
            return dir(elem, "nextSibling");
          },
          prevAll: function(elem) {
            return dir(elem, "previousSibling");
          },
          nextUntil: function(elem, _i, until) {
            return dir(elem, "nextSibling", until);
          },
          prevUntil: function(elem, _i, until) {
            return dir(elem, "previousSibling", until);
          },
          siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
          },
          children: function(elem) {
            return siblings(elem.firstChild);
          },
          contents: function(elem) {
            if (elem.contentDocument != null && // Support: IE 11+
            // <object> elements with no `data` attribute has an object
            // `contentDocument` with a `null` prototype.
            getProto(elem.contentDocument)) {
              return elem.contentDocument;
            }
            if (nodeName(elem, "template")) {
              elem = elem.content || elem;
            }
            return jQuery6.merge([], elem.childNodes);
          }
        }, function(name, fn2) {
          jQuery6.fn[name] = function(until, selector) {
            var matched = jQuery6.map(this, fn2, until);
            if (name.slice(-5) !== "Until") {
              selector = until;
            }
            if (selector && typeof selector === "string") {
              matched = jQuery6.filter(selector, matched);
            }
            if (this.length > 1) {
              if (!guaranteedUnique[name]) {
                jQuery6.uniqueSort(matched);
              }
              if (rparentsprev.test(name)) {
                matched.reverse();
              }
            }
            return this.pushStack(matched);
          };
        });
        var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
        function createOptions(options) {
          var object = {};
          jQuery6.each(options.match(rnothtmlwhite) || [], function(_2, flag) {
            object[flag] = true;
          });
          return object;
        }
        jQuery6.Callbacks = function(options) {
          options = typeof options === "string" ? createOptions(options) : jQuery6.extend({}, options);
          var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
            locked = locked || options.once;
            fired = firing = true;
            for (; queue.length; firingIndex = -1) {
              memory = queue.shift();
              while (++firingIndex < list.length) {
                if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                  firingIndex = list.length;
                  memory = false;
                }
              }
            }
            if (!options.memory) {
              memory = false;
            }
            firing = false;
            if (locked) {
              if (memory) {
                list = [];
              } else {
                list = "";
              }
            }
          }, self2 = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
              if (list) {
                if (memory && !firing) {
                  firingIndex = list.length - 1;
                  queue.push(memory);
                }
                (function add2(args) {
                  jQuery6.each(args, function(_2, arg) {
                    if (isFunction(arg)) {
                      if (!options.unique || !self2.has(arg)) {
                        list.push(arg);
                      }
                    } else if (arg && arg.length && toType2(arg) !== "string") {
                      add2(arg);
                    }
                  });
                })(arguments);
                if (memory && !firing) {
                  fire();
                }
              }
              return this;
            },
            // Remove a callback from the list
            remove: function() {
              jQuery6.each(arguments, function(_2, arg) {
                var index;
                while ((index = jQuery6.inArray(arg, list, index)) > -1) {
                  list.splice(index, 1);
                  if (index <= firingIndex) {
                    firingIndex--;
                  }
                }
              });
              return this;
            },
            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            has: function(fn2) {
              return fn2 ? jQuery6.inArray(fn2, list) > -1 : list.length > 0;
            },
            // Remove all callbacks from the list
            empty: function() {
              if (list) {
                list = [];
              }
              return this;
            },
            // Disable .fire and .add
            // Abort any current/pending executions
            // Clear all callbacks and values
            disable: function() {
              locked = queue = [];
              list = memory = "";
              return this;
            },
            disabled: function() {
              return !list;
            },
            // Disable .fire
            // Also disable .add unless we have memory (since it would have no effect)
            // Abort any pending executions
            lock: function() {
              locked = queue = [];
              if (!memory && !firing) {
                list = memory = "";
              }
              return this;
            },
            locked: function() {
              return !!locked;
            },
            // Call all callbacks with the given context and arguments
            fireWith: function(context, args) {
              if (!locked) {
                args = args || [];
                args = [context, args.slice ? args.slice() : args];
                queue.push(args);
                if (!firing) {
                  fire();
                }
              }
              return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
              self2.fireWith(this, arguments);
              return this;
            },
            // To know if the callbacks have already been called at least once
            fired: function() {
              return !!fired;
            }
          };
          return self2;
        };
        function Identity(v2) {
          return v2;
        }
        function Thrower(ex) {
          throw ex;
        }
        function adoptValue(value, resolve, reject, noValue) {
          var method;
          try {
            if (value && isFunction(method = value.promise)) {
              method.call(value).done(resolve).fail(reject);
            } else if (value && isFunction(method = value.then)) {
              method.call(value, resolve, reject);
            } else {
              resolve.apply(void 0, [value].slice(noValue));
            }
          } catch (value2) {
            reject.apply(void 0, [value2]);
          }
        }
        jQuery6.extend({
          Deferred: function(func) {
            var tuples = [
              // action, add listener, callbacks,
              // ... .then handlers, argument index, [final state]
              [
                "notify",
                "progress",
                jQuery6.Callbacks("memory"),
                jQuery6.Callbacks("memory"),
                2
              ],
              [
                "resolve",
                "done",
                jQuery6.Callbacks("once memory"),
                jQuery6.Callbacks("once memory"),
                0,
                "resolved"
              ],
              [
                "reject",
                "fail",
                jQuery6.Callbacks("once memory"),
                jQuery6.Callbacks("once memory"),
                1,
                "rejected"
              ]
            ], state = "pending", promise = {
              state: function() {
                return state;
              },
              always: function() {
                deferred.done(arguments).fail(arguments);
                return this;
              },
              "catch": function(fn2) {
                return promise.then(null, fn2);
              },
              // Keep pipe for back-compat
              pipe: function() {
                var fns = arguments;
                return jQuery6.Deferred(function(newDefer) {
                  jQuery6.each(tuples, function(_i, tuple) {
                    var fn2 = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                    deferred[tuple[1]](function() {
                      var returned = fn2 && fn2.apply(this, arguments);
                      if (returned && isFunction(returned.promise)) {
                        returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                      } else {
                        newDefer[tuple[0] + "With"](
                          this,
                          fn2 ? [returned] : arguments
                        );
                      }
                    });
                  });
                  fns = null;
                }).promise();
              },
              then: function(onFulfilled, onRejected, onProgress) {
                var maxDepth = 0;
                function resolve(depth, deferred2, handler, special) {
                  return function() {
                    var that = this, args = arguments, mightThrow = function() {
                      var returned, then;
                      if (depth < maxDepth) {
                        return;
                      }
                      returned = handler.apply(that, args);
                      if (returned === deferred2.promise()) {
                        throw new TypeError("Thenable self-resolution");
                      }
                      then = returned && // Support: Promises/A+ section 2.3.4
                      // https://promisesaplus.com/#point-64
                      // Only check objects and functions for thenability
                      (typeof returned === "object" || typeof returned === "function") && returned.then;
                      if (isFunction(then)) {
                        if (special) {
                          then.call(
                            returned,
                            resolve(maxDepth, deferred2, Identity, special),
                            resolve(maxDepth, deferred2, Thrower, special)
                          );
                        } else {
                          maxDepth++;
                          then.call(
                            returned,
                            resolve(maxDepth, deferred2, Identity, special),
                            resolve(maxDepth, deferred2, Thrower, special),
                            resolve(
                              maxDepth,
                              deferred2,
                              Identity,
                              deferred2.notifyWith
                            )
                          );
                        }
                      } else {
                        if (handler !== Identity) {
                          that = void 0;
                          args = [returned];
                        }
                        (special || deferred2.resolveWith)(that, args);
                      }
                    }, process = special ? mightThrow : function() {
                      try {
                        mightThrow();
                      } catch (e2) {
                        if (jQuery6.Deferred.exceptionHook) {
                          jQuery6.Deferred.exceptionHook(
                            e2,
                            process.error
                          );
                        }
                        if (depth + 1 >= maxDepth) {
                          if (handler !== Thrower) {
                            that = void 0;
                            args = [e2];
                          }
                          deferred2.rejectWith(that, args);
                        }
                      }
                    };
                    if (depth) {
                      process();
                    } else {
                      if (jQuery6.Deferred.getErrorHook) {
                        process.error = jQuery6.Deferred.getErrorHook();
                      } else if (jQuery6.Deferred.getStackHook) {
                        process.error = jQuery6.Deferred.getStackHook();
                      }
                      window2.setTimeout(process);
                    }
                  };
                }
                return jQuery6.Deferred(function(newDefer) {
                  tuples[0][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction(onProgress) ? onProgress : Identity,
                      newDefer.notifyWith
                    )
                  );
                  tuples[1][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction(onFulfilled) ? onFulfilled : Identity
                    )
                  );
                  tuples[2][3].add(
                    resolve(
                      0,
                      newDefer,
                      isFunction(onRejected) ? onRejected : Thrower
                    )
                  );
                }).promise();
              },
              // Get a promise for this deferred
              // If obj is provided, the promise aspect is added to the object
              promise: function(obj) {
                return obj != null ? jQuery6.extend(obj, promise) : promise;
              }
            }, deferred = {};
            jQuery6.each(tuples, function(i2, tuple) {
              var list = tuple[2], stateString = tuple[5];
              promise[tuple[1]] = list.add;
              if (stateString) {
                list.add(
                  function() {
                    state = stateString;
                  },
                  // rejected_callbacks.disable
                  // fulfilled_callbacks.disable
                  tuples[3 - i2][2].disable,
                  // rejected_handlers.disable
                  // fulfilled_handlers.disable
                  tuples[3 - i2][3].disable,
                  // progress_callbacks.lock
                  tuples[0][2].lock,
                  // progress_handlers.lock
                  tuples[0][3].lock
                );
              }
              list.add(tuple[3].fire);
              deferred[tuple[0]] = function() {
                deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
                return this;
              };
              deferred[tuple[0] + "With"] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) {
              func.call(deferred, deferred);
            }
            return deferred;
          },
          // Deferred helper
          when: function(singleValue) {
            var remaining = arguments.length, i2 = remaining, resolveContexts = Array(i2), resolveValues = slice.call(arguments), primary = jQuery6.Deferred(), updateFunc = function(i3) {
              return function(value) {
                resolveContexts[i3] = this;
                resolveValues[i3] = arguments.length > 1 ? slice.call(arguments) : value;
                if (!--remaining) {
                  primary.resolveWith(resolveContexts, resolveValues);
                }
              };
            };
            if (remaining <= 1) {
              adoptValue(
                singleValue,
                primary.done(updateFunc(i2)).resolve,
                primary.reject,
                !remaining
              );
              if (primary.state() === "pending" || isFunction(resolveValues[i2] && resolveValues[i2].then)) {
                return primary.then();
              }
            }
            while (i2--) {
              adoptValue(resolveValues[i2], updateFunc(i2), primary.reject);
            }
            return primary.promise();
          }
        });
        var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        jQuery6.Deferred.exceptionHook = function(error2, asyncError) {
          if (window2.console && window2.console.warn && error2 && rerrorNames.test(error2.name)) {
            window2.console.warn(
              "jQuery.Deferred exception: " + error2.message,
              error2.stack,
              asyncError
            );
          }
        };
        jQuery6.readyException = function(error2) {
          window2.setTimeout(function() {
            throw error2;
          });
        };
        var readyList = jQuery6.Deferred();
        jQuery6.fn.ready = function(fn2) {
          readyList.then(fn2).catch(function(error2) {
            jQuery6.readyException(error2);
          });
          return this;
        };
        jQuery6.extend({
          // Is the DOM ready to be used? Set to true once it occurs.
          isReady: false,
          // A counter to track how many items to wait for before
          // the ready event fires. See trac-6781
          readyWait: 1,
          // Handle when the DOM is ready
          ready: function(wait) {
            if (wait === true ? --jQuery6.readyWait : jQuery6.isReady) {
              return;
            }
            jQuery6.isReady = true;
            if (wait !== true && --jQuery6.readyWait > 0) {
              return;
            }
            readyList.resolveWith(document2, [jQuery6]);
          }
        });
        jQuery6.ready.then = readyList.then;
        function completed() {
          document2.removeEventListener("DOMContentLoaded", completed);
          window2.removeEventListener("load", completed);
          jQuery6.ready();
        }
        if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
          window2.setTimeout(jQuery6.ready);
        } else {
          document2.addEventListener("DOMContentLoaded", completed);
          window2.addEventListener("load", completed);
        }
        var access = function(elems, fn2, key, value, chainable, emptyGet, raw) {
          var i2 = 0, len = elems.length, bulk = key == null;
          if (toType2(key) === "object") {
            chainable = true;
            for (i2 in key) {
              access(elems, fn2, i2, key[i2], true, emptyGet, raw);
            }
          } else if (value !== void 0) {
            chainable = true;
            if (!isFunction(value)) {
              raw = true;
            }
            if (bulk) {
              if (raw) {
                fn2.call(elems, value);
                fn2 = null;
              } else {
                bulk = fn2;
                fn2 = function(elem, _key, value2) {
                  return bulk.call(jQuery6(elem), value2);
                };
              }
            }
            if (fn2) {
              for (; i2 < len; i2++) {
                fn2(
                  elems[i2],
                  key,
                  raw ? value : value.call(elems[i2], i2, fn2(elems[i2], key))
                );
              }
            }
          }
          if (chainable) {
            return elems;
          }
          if (bulk) {
            return fn2.call(elems);
          }
          return len ? fn2(elems[0], key) : emptyGet;
        };
        var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
        function fcamelCase(_all, letter) {
          return letter.toUpperCase();
        }
        function camelCase(string) {
          return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        }
        var acceptData = function(owner) {
          return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
        };
        function Data2() {
          this.expando = jQuery6.expando + Data2.uid++;
        }
        Data2.uid = 1;
        Data2.prototype = {
          cache: function(owner) {
            var value = owner[this.expando];
            if (!value) {
              value = {};
              if (acceptData(owner)) {
                if (owner.nodeType) {
                  owner[this.expando] = value;
                } else {
                  Object.defineProperty(owner, this.expando, {
                    value,
                    configurable: true
                  });
                }
              }
            }
            return value;
          },
          set: function(owner, data, value) {
            var prop, cache2 = this.cache(owner);
            if (typeof data === "string") {
              cache2[camelCase(data)] = value;
            } else {
              for (prop in data) {
                cache2[camelCase(prop)] = data[prop];
              }
            }
            return cache2;
          },
          get: function(owner, key) {
            return key === void 0 ? this.cache(owner) : (
              // Always use camelCase key (gh-2257)
              owner[this.expando] && owner[this.expando][camelCase(key)]
            );
          },
          access: function(owner, key, value) {
            if (key === void 0 || key && typeof key === "string" && value === void 0) {
              return this.get(owner, key);
            }
            this.set(owner, key, value);
            return value !== void 0 ? value : key;
          },
          remove: function(owner, key) {
            var i2, cache2 = owner[this.expando];
            if (cache2 === void 0) {
              return;
            }
            if (key !== void 0) {
              if (Array.isArray(key)) {
                key = key.map(camelCase);
              } else {
                key = camelCase(key);
                key = key in cache2 ? [key] : key.match(rnothtmlwhite) || [];
              }
              i2 = key.length;
              while (i2--) {
                delete cache2[key[i2]];
              }
            }
            if (key === void 0 || jQuery6.isEmptyObject(cache2)) {
              if (owner.nodeType) {
                owner[this.expando] = void 0;
              } else {
                delete owner[this.expando];
              }
            }
          },
          hasData: function(owner) {
            var cache2 = owner[this.expando];
            return cache2 !== void 0 && !jQuery6.isEmptyObject(cache2);
          }
        };
        var dataPriv = new Data2();
        var dataUser = new Data2();
        var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
        function getData(data) {
          if (data === "true") {
            return true;
          }
          if (data === "false") {
            return false;
          }
          if (data === "null") {
            return null;
          }
          if (data === +data + "") {
            return +data;
          }
          if (rbrace.test(data)) {
            return JSON.parse(data);
          }
          return data;
        }
        function dataAttr(elem, key, data) {
          var name;
          if (data === void 0 && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
              try {
                data = getData(data);
              } catch (e2) {
              }
              dataUser.set(elem, key, data);
            } else {
              data = void 0;
            }
          }
          return data;
        }
        jQuery6.extend({
          hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
          },
          data: function(elem, name, data) {
            return dataUser.access(elem, name, data);
          },
          removeData: function(elem, name) {
            dataUser.remove(elem, name);
          },
          // TODO: Now that all calls to _data and _removeData have been replaced
          // with direct calls to dataPriv methods, these can be deprecated.
          _data: function(elem, name, data) {
            return dataPriv.access(elem, name, data);
          },
          _removeData: function(elem, name) {
            dataPriv.remove(elem, name);
          }
        });
        jQuery6.fn.extend({
          data: function(key, value) {
            var i2, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (key === void 0) {
              if (this.length) {
                data = dataUser.get(elem);
                if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                  i2 = attrs.length;
                  while (i2--) {
                    if (attrs[i2]) {
                      name = attrs[i2].name;
                      if (name.indexOf("data-") === 0) {
                        name = camelCase(name.slice(5));
                        dataAttr(elem, name, data[name]);
                      }
                    }
                  }
                  dataPriv.set(elem, "hasDataAttrs", true);
                }
              }
              return data;
            }
            if (typeof key === "object") {
              return this.each(function() {
                dataUser.set(this, key);
              });
            }
            return access(this, function(value2) {
              var data2;
              if (elem && value2 === void 0) {
                data2 = dataUser.get(elem, key);
                if (data2 !== void 0) {
                  return data2;
                }
                data2 = dataAttr(elem, key);
                if (data2 !== void 0) {
                  return data2;
                }
                return;
              }
              this.each(function() {
                dataUser.set(this, key, value2);
              });
            }, null, value, arguments.length > 1, null, true);
          },
          removeData: function(key) {
            return this.each(function() {
              dataUser.remove(this, key);
            });
          }
        });
        jQuery6.extend({
          queue: function(elem, type, data) {
            var queue;
            if (elem) {
              type = (type || "fx") + "queue";
              queue = dataPriv.get(elem, type);
              if (data) {
                if (!queue || Array.isArray(data)) {
                  queue = dataPriv.access(elem, type, jQuery6.makeArray(data));
                } else {
                  queue.push(data);
                }
              }
              return queue || [];
            }
          },
          dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery6.queue(elem, type), startLength = queue.length, fn2 = queue.shift(), hooks = jQuery6._queueHooks(elem, type), next = function() {
              jQuery6.dequeue(elem, type);
            };
            if (fn2 === "inprogress") {
              fn2 = queue.shift();
              startLength--;
            }
            if (fn2) {
              if (type === "fx") {
                queue.unshift("inprogress");
              }
              delete hooks.stop;
              fn2.call(elem, next, hooks);
            }
            if (!startLength && hooks) {
              hooks.empty.fire();
            }
          },
          // Not public - generate a queueHooks object, or return the current one
          _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
              empty: jQuery6.Callbacks("once memory").add(function() {
                dataPriv.remove(elem, [type + "queue", key]);
              })
            });
          }
        });
        jQuery6.fn.extend({
          queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") {
              data = type;
              type = "fx";
              setter--;
            }
            if (arguments.length < setter) {
              return jQuery6.queue(this[0], type);
            }
            return data === void 0 ? this : this.each(function() {
              var queue = jQuery6.queue(this, type, data);
              jQuery6._queueHooks(this, type);
              if (type === "fx" && queue[0] !== "inprogress") {
                jQuery6.dequeue(this, type);
              }
            });
          },
          dequeue: function(type) {
            return this.each(function() {
              jQuery6.dequeue(this, type);
            });
          },
          clearQueue: function(type) {
            return this.queue(type || "fx", []);
          },
          // Get a promise resolved when queues of a certain type
          // are emptied (fx is the type by default)
          promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery6.Deferred(), elements = this, i2 = this.length, resolve = function() {
              if (!--count) {
                defer.resolveWith(elements, [elements]);
              }
            };
            if (typeof type !== "string") {
              obj = type;
              type = void 0;
            }
            type = type || "fx";
            while (i2--) {
              tmp = dataPriv.get(elements[i2], type + "queueHooks");
              if (tmp && tmp.empty) {
                count++;
                tmp.empty.add(resolve);
              }
            }
            resolve();
            return defer.promise(obj);
          }
        });
        var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
        var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
        var cssExpand = ["Top", "Right", "Bottom", "Left"];
        var documentElement = document2.documentElement;
        var isAttached = function(elem) {
          return jQuery6.contains(elem.ownerDocument, elem);
        }, composed = { composed: true };
        if (documentElement.getRootNode) {
          isAttached = function(elem) {
            return jQuery6.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
          };
        }
        var isHiddenWithinTree = function(elem, el) {
          elem = el || elem;
          return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
          // Support: Firefox <=43 - 45
          // Disconnected elements can have computed display: none, so first confirm that elem is
          // in the document.
          isAttached(elem) && jQuery6.css(elem, "display") === "none";
        };
        function adjustCSS(elem, prop, valueParts, tween) {
          var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur();
          } : function() {
            return jQuery6.css(elem, prop, "");
          }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery6.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery6.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery6.css(elem, prop));
          if (initialInUnit && initialInUnit[3] !== unit) {
            initial = initial / 2;
            unit = unit || initialInUnit[3];
            initialInUnit = +initial || 1;
            while (maxIterations--) {
              jQuery6.style(elem, prop, initialInUnit + unit);
              if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
                maxIterations = 0;
              }
              initialInUnit = initialInUnit / scale;
            }
            initialInUnit = initialInUnit * 2;
            jQuery6.style(elem, prop, initialInUnit + unit);
            valueParts = valueParts || [];
          }
          if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
              tween.unit = unit;
              tween.start = initialInUnit;
              tween.end = adjusted;
            }
          }
          return adjusted;
        }
        var defaultDisplayMap = {};
        function getDefaultDisplay(elem) {
          var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
          if (display) {
            return display;
          }
          temp = doc.body.appendChild(doc.createElement(nodeName2));
          display = jQuery6.css(temp, "display");
          temp.parentNode.removeChild(temp);
          if (display === "none") {
            display = "block";
          }
          defaultDisplayMap[nodeName2] = display;
          return display;
        }
        function showHide(elements, show) {
          var display, elem, values = [], index = 0, length = elements.length;
          for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
              continue;
            }
            display = elem.style.display;
            if (show) {
              if (display === "none") {
                values[index] = dataPriv.get(elem, "display") || null;
                if (!values[index]) {
                  elem.style.display = "";
                }
              }
              if (elem.style.display === "" && isHiddenWithinTree(elem)) {
                values[index] = getDefaultDisplay(elem);
              }
            } else {
              if (display !== "none") {
                values[index] = "none";
                dataPriv.set(elem, "display", display);
              }
            }
          }
          for (index = 0; index < length; index++) {
            if (values[index] != null) {
              elements[index].style.display = values[index];
            }
          }
          return elements;
        }
        jQuery6.fn.extend({
          show: function() {
            return showHide(this, true);
          },
          hide: function() {
            return showHide(this);
          },
          toggle: function(state) {
            if (typeof state === "boolean") {
              return state ? this.show() : this.hide();
            }
            return this.each(function() {
              if (isHiddenWithinTree(this)) {
                jQuery6(this).show();
              } else {
                jQuery6(this).hide();
              }
            });
          }
        });
        var rcheckableType = /^(?:checkbox|radio)$/i;
        var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
        var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
        (function() {
          var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
          input.setAttribute("type", "radio");
          input.setAttribute("checked", "checked");
          input.setAttribute("name", "t");
          div.appendChild(input);
          support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
          div.innerHTML = "<textarea>x</textarea>";
          support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
          div.innerHTML = "<option></option>";
          support.option = !!div.lastChild;
        })();
        var wrapMap = {
          // XHTML parsers do not magically insert elements in the
          // same way that tag soup parsers do. So we cannot shorten
          // this by omitting <tbody> or other required elements.
          thead: [1, "<table>", "</table>"],
          col: [2, "<table><colgroup>", "</colgroup></table>"],
          tr: [2, "<table><tbody>", "</tbody></table>"],
          td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
          _default: [0, "", ""]
        };
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;
        if (!support.option) {
          wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
        }
        function getAll(context, tag) {
          var ret;
          if (typeof context.getElementsByTagName !== "undefined") {
            ret = context.getElementsByTagName(tag || "*");
          } else if (typeof context.querySelectorAll !== "undefined") {
            ret = context.querySelectorAll(tag || "*");
          } else {
            ret = [];
          }
          if (tag === void 0 || tag && nodeName(context, tag)) {
            return jQuery6.merge([context], ret);
          }
          return ret;
        }
        function setGlobalEval(elems, refElements) {
          var i2 = 0, l2 = elems.length;
          for (; i2 < l2; i2++) {
            dataPriv.set(
              elems[i2],
              "globalEval",
              !refElements || dataPriv.get(refElements[i2], "globalEval")
            );
          }
        }
        var rhtml = /<|&#?\w+;/;
        function buildFragment(elems, context, scripts, selection, ignored) {
          var elem, tmp, tag, wrap, attached, j2, fragment = context.createDocumentFragment(), nodes = [], i2 = 0, l2 = elems.length;
          for (; i2 < l2; i2++) {
            elem = elems[i2];
            if (elem || elem === 0) {
              if (toType2(elem) === "object") {
                jQuery6.merge(nodes, elem.nodeType ? [elem] : elem);
              } else if (!rhtml.test(elem)) {
                nodes.push(context.createTextNode(elem));
              } else {
                tmp = tmp || fragment.appendChild(context.createElement("div"));
                tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                wrap = wrapMap[tag] || wrapMap._default;
                tmp.innerHTML = wrap[1] + jQuery6.htmlPrefilter(elem) + wrap[2];
                j2 = wrap[0];
                while (j2--) {
                  tmp = tmp.lastChild;
                }
                jQuery6.merge(nodes, tmp.childNodes);
                tmp = fragment.firstChild;
                tmp.textContent = "";
              }
            }
          }
          fragment.textContent = "";
          i2 = 0;
          while (elem = nodes[i2++]) {
            if (selection && jQuery6.inArray(elem, selection) > -1) {
              if (ignored) {
                ignored.push(elem);
              }
              continue;
            }
            attached = isAttached(elem);
            tmp = getAll(fragment.appendChild(elem), "script");
            if (attached) {
              setGlobalEval(tmp);
            }
            if (scripts) {
              j2 = 0;
              while (elem = tmp[j2++]) {
                if (rscriptType.test(elem.type || "")) {
                  scripts.push(elem);
                }
              }
            }
          }
          return fragment;
        }
        var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
        function returnTrue() {
          return true;
        }
        function returnFalse() {
          return false;
        }
        function on(elem, types, selector, data, fn2, one) {
          var origFn, type;
          if (typeof types === "object") {
            if (typeof selector !== "string") {
              data = data || selector;
              selector = void 0;
            }
            for (type in types) {
              on(elem, type, selector, data, types[type], one);
            }
            return elem;
          }
          if (data == null && fn2 == null) {
            fn2 = selector;
            data = selector = void 0;
          } else if (fn2 == null) {
            if (typeof selector === "string") {
              fn2 = data;
              data = void 0;
            } else {
              fn2 = data;
              data = selector;
              selector = void 0;
            }
          }
          if (fn2 === false) {
            fn2 = returnFalse;
          } else if (!fn2) {
            return elem;
          }
          if (one === 1) {
            origFn = fn2;
            fn2 = function(event) {
              jQuery6().off(event);
              return origFn.apply(this, arguments);
            };
            fn2.guid = origFn.guid || (origFn.guid = jQuery6.guid++);
          }
          return elem.each(function() {
            jQuery6.event.add(this, types, fn2, data, selector);
          });
        }
        jQuery6.event = {
          global: {},
          add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t2, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (!acceptData(elem)) {
              return;
            }
            if (handler.handler) {
              handleObjIn = handler;
              handler = handleObjIn.handler;
              selector = handleObjIn.selector;
            }
            if (selector) {
              jQuery6.find.matchesSelector(documentElement, selector);
            }
            if (!handler.guid) {
              handler.guid = jQuery6.guid++;
            }
            if (!(events = elemData.events)) {
              events = elemData.events = /* @__PURE__ */ Object.create(null);
            }
            if (!(eventHandle = elemData.handle)) {
              eventHandle = elemData.handle = function(e2) {
                return typeof jQuery6 !== "undefined" && jQuery6.event.triggered !== e2.type ? jQuery6.event.dispatch.apply(elem, arguments) : void 0;
              };
            }
            types = (types || "").match(rnothtmlwhite) || [""];
            t2 = types.length;
            while (t2--) {
              tmp = rtypenamespace.exec(types[t2]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                continue;
              }
              special = jQuery6.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              special = jQuery6.event.special[type] || {};
              handleObj = jQuery6.extend({
                type,
                origType,
                data,
                handler,
                guid: handler.guid,
                selector,
                needsContext: selector && jQuery6.expr.match.needsContext.test(selector),
                namespace: namespaces.join(".")
              }, handleObjIn);
              if (!(handlers = events[type])) {
                handlers = events[type] = [];
                handlers.delegateCount = 0;
                if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                  if (elem.addEventListener) {
                    elem.addEventListener(type, eventHandle);
                  }
                }
              }
              if (special.add) {
                special.add.call(elem, handleObj);
                if (!handleObj.handler.guid) {
                  handleObj.handler.guid = handler.guid;
                }
              }
              if (selector) {
                handlers.splice(handlers.delegateCount++, 0, handleObj);
              } else {
                handlers.push(handleObj);
              }
              jQuery6.event.global[type] = true;
            }
          },
          // Detach an event or set of events from an element
          remove: function(elem, types, handler, selector, mappedTypes) {
            var j2, origCount, tmp, events, t2, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (!elemData || !(events = elemData.events)) {
              return;
            }
            types = (types || "").match(rnothtmlwhite) || [""];
            t2 = types.length;
            while (t2--) {
              tmp = rtypenamespace.exec(types[t2]) || [];
              type = origType = tmp[1];
              namespaces = (tmp[2] || "").split(".").sort();
              if (!type) {
                for (type in events) {
                  jQuery6.event.remove(elem, type + types[t2], handler, selector, true);
                }
                continue;
              }
              special = jQuery6.event.special[type] || {};
              type = (selector ? special.delegateType : special.bindType) || type;
              handlers = events[type] || [];
              tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
              origCount = j2 = handlers.length;
              while (j2--) {
                handleObj = handlers[j2];
                if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                  handlers.splice(j2, 1);
                  if (handleObj.selector) {
                    handlers.delegateCount--;
                  }
                  if (special.remove) {
                    special.remove.call(elem, handleObj);
                  }
                }
              }
              if (origCount && !handlers.length) {
                if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                  jQuery6.removeEvent(elem, type, elemData.handle);
                }
                delete events[type];
              }
            }
            if (jQuery6.isEmptyObject(events)) {
              dataPriv.remove(elem, "handle events");
            }
          },
          dispatch: function(nativeEvent) {
            var i2, j2, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery6.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery6.event.special[event.type] || {};
            args[0] = event;
            for (i2 = 1; i2 < arguments.length; i2++) {
              args[i2] = arguments[i2];
            }
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
              return;
            }
            handlerQueue = jQuery6.event.handlers.call(this, event, handlers);
            i2 = 0;
            while ((matched = handlerQueue[i2++]) && !event.isPropagationStopped()) {
              event.currentTarget = matched.elem;
              j2 = 0;
              while ((handleObj = matched.handlers[j2++]) && !event.isImmediatePropagationStopped()) {
                if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                  event.handleObj = handleObj;
                  event.data = handleObj.data;
                  ret = ((jQuery6.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                  if (ret !== void 0) {
                    if ((event.result = ret) === false) {
                      event.preventDefault();
                      event.stopPropagation();
                    }
                  }
                }
              }
            }
            if (special.postDispatch) {
              special.postDispatch.call(this, event);
            }
            return event.result;
          },
          handlers: function(event, handlers) {
            var i2, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && // Support: IE <=9
            // Black-hole SVG <use> instance trees (trac-13180)
            cur.nodeType && // Support: Firefox <=42
            // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
            // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
            // Support: IE 11 only
            // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
            !(event.type === "click" && event.button >= 1)) {
              for (; cur !== this; cur = cur.parentNode || this) {
                if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                  matchedHandlers = [];
                  matchedSelectors = {};
                  for (i2 = 0; i2 < delegateCount; i2++) {
                    handleObj = handlers[i2];
                    sel = handleObj.selector + " ";
                    if (matchedSelectors[sel] === void 0) {
                      matchedSelectors[sel] = handleObj.needsContext ? jQuery6(sel, this).index(cur) > -1 : jQuery6.find(sel, this, null, [cur]).length;
                    }
                    if (matchedSelectors[sel]) {
                      matchedHandlers.push(handleObj);
                    }
                  }
                  if (matchedHandlers.length) {
                    handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                  }
                }
              }
            }
            cur = this;
            if (delegateCount < handlers.length) {
              handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
            }
            return handlerQueue;
          },
          addProp: function(name, hook) {
            Object.defineProperty(jQuery6.Event.prototype, name, {
              enumerable: true,
              configurable: true,
              get: isFunction(hook) ? function() {
                if (this.originalEvent) {
                  return hook(this.originalEvent);
                }
              } : function() {
                if (this.originalEvent) {
                  return this.originalEvent[name];
                }
              },
              set: function(value) {
                Object.defineProperty(this, name, {
                  enumerable: true,
                  configurable: true,
                  writable: true,
                  value
                });
              }
            });
          },
          fix: function(originalEvent) {
            return originalEvent[jQuery6.expando] ? originalEvent : new jQuery6.Event(originalEvent);
          },
          special: {
            load: {
              // Prevent triggered image.load events from bubbling to window.load
              noBubble: true
            },
            click: {
              // Utilize native event to ensure correct state for checkable inputs
              setup: function(data) {
                var el = this || data;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click", true);
                }
                return false;
              },
              trigger: function(data) {
                var el = this || data;
                if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                  leverageNative(el, "click");
                }
                return true;
              },
              // For cross-browser consistency, suppress native .click() on links
              // Also prevent it if we're currently inside a leveraged native-event stack
              _default: function(event) {
                var target = event.target;
                return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
              }
            },
            beforeunload: {
              postDispatch: function(event) {
                if (event.result !== void 0 && event.originalEvent) {
                  event.originalEvent.returnValue = event.result;
                }
              }
            }
          }
        };
        function leverageNative(el, type, isSetup) {
          if (!isSetup) {
            if (dataPriv.get(el, type) === void 0) {
              jQuery6.event.add(el, type, returnTrue);
            }
            return;
          }
          dataPriv.set(el, type, false);
          jQuery6.event.add(el, type, {
            namespace: false,
            handler: function(event) {
              var result, saved = dataPriv.get(this, type);
              if (event.isTrigger & 1 && this[type]) {
                if (!saved) {
                  saved = slice.call(arguments);
                  dataPriv.set(this, type, saved);
                  this[type]();
                  result = dataPriv.get(this, type);
                  dataPriv.set(this, type, false);
                  if (saved !== result) {
                    event.stopImmediatePropagation();
                    event.preventDefault();
                    return result;
                  }
                } else if ((jQuery6.event.special[type] || {}).delegateType) {
                  event.stopPropagation();
                }
              } else if (saved) {
                dataPriv.set(this, type, jQuery6.event.trigger(
                  saved[0],
                  saved.slice(1),
                  this
                ));
                event.stopPropagation();
                event.isImmediatePropagationStopped = returnTrue;
              }
            }
          });
        }
        jQuery6.removeEvent = function(elem, type, handle) {
          if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
          }
        };
        jQuery6.Event = function(src, props) {
          if (!(this instanceof jQuery6.Event)) {
            return new jQuery6.Event(src, props);
          }
          if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
            src.returnValue === false ? returnTrue : returnFalse;
            this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
            this.currentTarget = src.currentTarget;
            this.relatedTarget = src.relatedTarget;
          } else {
            this.type = src;
          }
          if (props) {
            jQuery6.extend(this, props);
          }
          this.timeStamp = src && src.timeStamp || Date.now();
          this[jQuery6.expando] = true;
        };
        jQuery6.Event.prototype = {
          constructor: jQuery6.Event,
          isDefaultPrevented: returnFalse,
          isPropagationStopped: returnFalse,
          isImmediatePropagationStopped: returnFalse,
          isSimulated: false,
          preventDefault: function() {
            var e2 = this.originalEvent;
            this.isDefaultPrevented = returnTrue;
            if (e2 && !this.isSimulated) {
              e2.preventDefault();
            }
          },
          stopPropagation: function() {
            var e2 = this.originalEvent;
            this.isPropagationStopped = returnTrue;
            if (e2 && !this.isSimulated) {
              e2.stopPropagation();
            }
          },
          stopImmediatePropagation: function() {
            var e2 = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue;
            if (e2 && !this.isSimulated) {
              e2.stopImmediatePropagation();
            }
            this.stopPropagation();
          }
        };
        jQuery6.each({
          altKey: true,
          bubbles: true,
          cancelable: true,
          changedTouches: true,
          ctrlKey: true,
          detail: true,
          eventPhase: true,
          metaKey: true,
          pageX: true,
          pageY: true,
          shiftKey: true,
          view: true,
          "char": true,
          code: true,
          charCode: true,
          key: true,
          keyCode: true,
          button: true,
          buttons: true,
          clientX: true,
          clientY: true,
          offsetX: true,
          offsetY: true,
          pointerId: true,
          pointerType: true,
          screenX: true,
          screenY: true,
          targetTouches: true,
          toElement: true,
          touches: true,
          which: true
        }, jQuery6.event.addProp);
        jQuery6.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
          function focusMappedHandler(nativeEvent) {
            if (document2.documentMode) {
              var handle = dataPriv.get(this, "handle"), event = jQuery6.event.fix(nativeEvent);
              event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
              event.isSimulated = true;
              handle(nativeEvent);
              if (event.target === event.currentTarget) {
                handle(event);
              }
            } else {
              jQuery6.event.simulate(
                delegateType,
                nativeEvent.target,
                jQuery6.event.fix(nativeEvent)
              );
            }
          }
          jQuery6.event.special[type] = {
            // Utilize native event if possible so blur/focus sequence is correct
            setup: function() {
              var attaches;
              leverageNative(this, type, true);
              if (document2.documentMode) {
                attaches = dataPriv.get(this, delegateType);
                if (!attaches) {
                  this.addEventListener(delegateType, focusMappedHandler);
                }
                dataPriv.set(this, delegateType, (attaches || 0) + 1);
              } else {
                return false;
              }
            },
            trigger: function() {
              leverageNative(this, type);
              return true;
            },
            teardown: function() {
              var attaches;
              if (document2.documentMode) {
                attaches = dataPriv.get(this, delegateType) - 1;
                if (!attaches) {
                  this.removeEventListener(delegateType, focusMappedHandler);
                  dataPriv.remove(this, delegateType);
                } else {
                  dataPriv.set(this, delegateType, attaches);
                }
              } else {
                return false;
              }
            },
            // Suppress native focus or blur if we're currently inside
            // a leveraged native-event stack
            _default: function(event) {
              return dataPriv.get(event.target, type);
            },
            delegateType
          };
          jQuery6.event.special[delegateType] = {
            setup: function() {
              var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType);
              if (!attaches) {
                if (document2.documentMode) {
                  this.addEventListener(delegateType, focusMappedHandler);
                } else {
                  doc.addEventListener(type, focusMappedHandler, true);
                }
              }
              dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);
            },
            teardown: function() {
              var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType) - 1;
              if (!attaches) {
                if (document2.documentMode) {
                  this.removeEventListener(delegateType, focusMappedHandler);
                } else {
                  doc.removeEventListener(type, focusMappedHandler, true);
                }
                dataPriv.remove(dataHolder, delegateType);
              } else {
                dataPriv.set(dataHolder, delegateType, attaches);
              }
            }
          };
        });
        jQuery6.each({
          mouseenter: "mouseover",
          mouseleave: "mouseout",
          pointerenter: "pointerover",
          pointerleave: "pointerout"
        }, function(orig, fix) {
          jQuery6.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
              var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
              if (!related || related !== target && !jQuery6.contains(target, related)) {
                event.type = handleObj.origType;
                ret = handleObj.handler.apply(this, arguments);
                event.type = fix;
              }
              return ret;
            }
          };
        });
        jQuery6.fn.extend({
          on: function(types, selector, data, fn2) {
            return on(this, types, selector, data, fn2);
          },
          one: function(types, selector, data, fn2) {
            return on(this, types, selector, data, fn2, 1);
          },
          off: function(types, selector, fn2) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {
              handleObj = types.handleObj;
              jQuery6(types.delegateTarget).off(
                handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                handleObj.selector,
                handleObj.handler
              );
              return this;
            }
            if (typeof types === "object") {
              for (type in types) {
                this.off(type, selector, types[type]);
              }
              return this;
            }
            if (selector === false || typeof selector === "function") {
              fn2 = selector;
              selector = void 0;
            }
            if (fn2 === false) {
              fn2 = returnFalse;
            }
            return this.each(function() {
              jQuery6.event.remove(this, types, fn2, selector);
            });
          }
        });
        var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
        function manipulationTarget(elem, content) {
          if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
            return jQuery6(elem).children("tbody")[0] || elem;
          }
          return elem;
        }
        function disableScript(elem) {
          elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
          return elem;
        }
        function restoreScript(elem) {
          if ((elem.type || "").slice(0, 5) === "true/") {
            elem.type = elem.type.slice(5);
          } else {
            elem.removeAttribute("type");
          }
          return elem;
        }
        function cloneCopyEvent(src, dest) {
          var i2, l2, type, pdataOld, udataOld, udataCur, events;
          if (dest.nodeType !== 1) {
            return;
          }
          if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.get(src);
            events = pdataOld.events;
            if (events) {
              dataPriv.remove(dest, "handle events");
              for (type in events) {
                for (i2 = 0, l2 = events[type].length; i2 < l2; i2++) {
                  jQuery6.event.add(dest, type, events[type][i2]);
                }
              }
            }
          }
          if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery6.extend({}, udataOld);
            dataUser.set(dest, udataCur);
          }
        }
        function fixInput(src, dest) {
          var nodeName2 = dest.nodeName.toLowerCase();
          if (nodeName2 === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;
          } else if (nodeName2 === "input" || nodeName2 === "textarea") {
            dest.defaultValue = src.defaultValue;
          }
        }
        function domManip(collection, args, callback, ignored) {
          args = flat(args);
          var fragment, first, scripts, hasScripts, node, doc, i2 = 0, l2 = collection.length, iNoClone = l2 - 1, value = args[0], valueIsFunction = isFunction(value);
          if (valueIsFunction || l2 > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
            return collection.each(function(index) {
              var self2 = collection.eq(index);
              if (valueIsFunction) {
                args[0] = value.call(this, index, self2.html());
              }
              domManip(self2, args, callback, ignored);
            });
          }
          if (l2) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) {
              fragment = first;
            }
            if (first || ignored) {
              scripts = jQuery6.map(getAll(fragment, "script"), disableScript);
              hasScripts = scripts.length;
              for (; i2 < l2; i2++) {
                node = fragment;
                if (i2 !== iNoClone) {
                  node = jQuery6.clone(node, true, true);
                  if (hasScripts) {
                    jQuery6.merge(scripts, getAll(node, "script"));
                  }
                }
                callback.call(collection[i2], node, i2);
              }
              if (hasScripts) {
                doc = scripts[scripts.length - 1].ownerDocument;
                jQuery6.map(scripts, restoreScript);
                for (i2 = 0; i2 < hasScripts; i2++) {
                  node = scripts[i2];
                  if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery6.contains(doc, node)) {
                    if (node.src && (node.type || "").toLowerCase() !== "module") {
                      if (jQuery6._evalUrl && !node.noModule) {
                        jQuery6._evalUrl(node.src, {
                          nonce: node.nonce || node.getAttribute("nonce")
                        }, doc);
                      }
                    } else {
                      DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                    }
                  }
                }
              }
            }
          }
          return collection;
        }
        function remove(elem, selector, keepData) {
          var node, nodes = selector ? jQuery6.filter(selector, elem) : elem, i2 = 0;
          for (; (node = nodes[i2]) != null; i2++) {
            if (!keepData && node.nodeType === 1) {
              jQuery6.cleanData(getAll(node));
            }
            if (node.parentNode) {
              if (keepData && isAttached(node)) {
                setGlobalEval(getAll(node, "script"));
              }
              node.parentNode.removeChild(node);
            }
          }
          return elem;
        }
        jQuery6.extend({
          htmlPrefilter: function(html) {
            return html;
          },
          clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i2, l2, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery6.isXMLDoc(elem)) {
              destElements = getAll(clone);
              srcElements = getAll(elem);
              for (i2 = 0, l2 = srcElements.length; i2 < l2; i2++) {
                fixInput(srcElements[i2], destElements[i2]);
              }
            }
            if (dataAndEvents) {
              if (deepDataAndEvents) {
                srcElements = srcElements || getAll(elem);
                destElements = destElements || getAll(clone);
                for (i2 = 0, l2 = srcElements.length; i2 < l2; i2++) {
                  cloneCopyEvent(srcElements[i2], destElements[i2]);
                }
              } else {
                cloneCopyEvent(elem, clone);
              }
            }
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
              setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }
            return clone;
          },
          cleanData: function(elems) {
            var data, elem, type, special = jQuery6.event.special, i2 = 0;
            for (; (elem = elems[i2]) !== void 0; i2++) {
              if (acceptData(elem)) {
                if (data = elem[dataPriv.expando]) {
                  if (data.events) {
                    for (type in data.events) {
                      if (special[type]) {
                        jQuery6.event.remove(elem, type);
                      } else {
                        jQuery6.removeEvent(elem, type, data.handle);
                      }
                    }
                  }
                  elem[dataPriv.expando] = void 0;
                }
                if (elem[dataUser.expando]) {
                  elem[dataUser.expando] = void 0;
                }
              }
            }
          }
        });
        jQuery6.fn.extend({
          detach: function(selector) {
            return remove(this, selector, true);
          },
          remove: function(selector) {
            return remove(this, selector);
          },
          text: function(value) {
            return access(this, function(value2) {
              return value2 === void 0 ? jQuery6.text(this) : this.empty().each(function() {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                  this.textContent = value2;
                }
              });
            }, null, value, arguments.length);
          },
          append: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.appendChild(elem);
              }
            });
          },
          prepend: function() {
            return domManip(this, arguments, function(elem) {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                var target = manipulationTarget(this, elem);
                target.insertBefore(elem, target.firstChild);
              }
            });
          },
          before: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this);
              }
            });
          },
          after: function() {
            return domManip(this, arguments, function(elem) {
              if (this.parentNode) {
                this.parentNode.insertBefore(elem, this.nextSibling);
              }
            });
          },
          empty: function() {
            var elem, i2 = 0;
            for (; (elem = this[i2]) != null; i2++) {
              if (elem.nodeType === 1) {
                jQuery6.cleanData(getAll(elem, false));
                elem.textContent = "";
              }
            }
            return this;
          },
          clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
            return this.map(function() {
              return jQuery6.clone(this, dataAndEvents, deepDataAndEvents);
            });
          },
          html: function(value) {
            return access(this, function(value2) {
              var elem = this[0] || {}, i2 = 0, l2 = this.length;
              if (value2 === void 0 && elem.nodeType === 1) {
                return elem.innerHTML;
              }
              if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
                value2 = jQuery6.htmlPrefilter(value2);
                try {
                  for (; i2 < l2; i2++) {
                    elem = this[i2] || {};
                    if (elem.nodeType === 1) {
                      jQuery6.cleanData(getAll(elem, false));
                      elem.innerHTML = value2;
                    }
                  }
                  elem = 0;
                } catch (e2) {
                }
              }
              if (elem) {
                this.empty().append(value2);
              }
            }, null, value, arguments.length);
          },
          replaceWith: function() {
            var ignored = [];
            return domManip(this, arguments, function(elem) {
              var parent = this.parentNode;
              if (jQuery6.inArray(this, ignored) < 0) {
                jQuery6.cleanData(getAll(this));
                if (parent) {
                  parent.replaceChild(elem, this);
                }
              }
            }, ignored);
          }
        });
        jQuery6.each({
          appendTo: "append",
          prependTo: "prepend",
          insertBefore: "before",
          insertAfter: "after",
          replaceAll: "replaceWith"
        }, function(name, original) {
          jQuery6.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery6(selector), last = insert.length - 1, i2 = 0;
            for (; i2 <= last; i2++) {
              elems = i2 === last ? this : this.clone(true);
              jQuery6(insert[i2])[original](elems);
              push.apply(ret, elems.get());
            }
            return this.pushStack(ret);
          };
        });
        var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
        var rcustomProp = /^--/;
        var getStyles = function(elem) {
          var view = elem.ownerDocument.defaultView;
          if (!view || !view.opener) {
            view = window2;
          }
          return view.getComputedStyle(elem);
        };
        var swap = function(elem, options, callback) {
          var ret, name, old = {};
          for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
          }
          ret = callback.call(elem);
          for (name in options) {
            elem.style[name] = old[name];
          }
          return ret;
        };
        var rboxStyle = new RegExp(cssExpand.join("|"), "i");
        (function() {
          function computeStyleTests() {
            if (!div) {
              return;
            }
            container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
            div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
            documentElement.appendChild(container).appendChild(div);
            var divStyle = window2.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== "1%";
            reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
            div.style.right = "60%";
            pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
            boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
            div.style.position = "absolute";
            scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
            documentElement.removeChild(container);
            div = null;
          }
          function roundPixelMeasures(measure) {
            return Math.round(parseFloat(measure));
          }
          var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
          if (!div.style) {
            return;
          }
          div.style.backgroundClip = "content-box";
          div.cloneNode(true).style.backgroundClip = "";
          support.clearCloneStyle = div.style.backgroundClip === "content-box";
          jQuery6.extend(support, {
            boxSizingReliable: function() {
              computeStyleTests();
              return boxSizingReliableVal;
            },
            pixelBoxStyles: function() {
              computeStyleTests();
              return pixelBoxStylesVal;
            },
            pixelPosition: function() {
              computeStyleTests();
              return pixelPositionVal;
            },
            reliableMarginLeft: function() {
              computeStyleTests();
              return reliableMarginLeftVal;
            },
            scrollboxSize: function() {
              computeStyleTests();
              return scrollboxSizeVal;
            },
            // Support: IE 9 - 11+, Edge 15 - 18+
            // IE/Edge misreport `getComputedStyle` of table rows with width/height
            // set in CSS while `offset*` properties report correct values.
            // Behavior in IE 9 is more subtle than in newer versions & it passes
            // some versions of this test; make sure not to make it pass there!
            //
            // Support: Firefox 70+
            // Only Firefox includes border widths
            // in computed dimensions. (gh-4529)
            reliableTrDimensions: function() {
              var table, tr, trChild, trStyle;
              if (reliableTrDimensionsVal == null) {
                table = document2.createElement("table");
                tr = document2.createElement("tr");
                trChild = document2.createElement("div");
                table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
                tr.style.cssText = "box-sizing:content-box;border:1px solid";
                tr.style.height = "1px";
                trChild.style.height = "9px";
                trChild.style.display = "block";
                documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
                trStyle = window2.getComputedStyle(tr);
                reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
                documentElement.removeChild(table);
              }
              return reliableTrDimensionsVal;
            }
          });
        })();
        function curCSS(elem, name, computed) {
          var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), style = elem.style;
          computed = computed || getStyles(elem);
          if (computed) {
            ret = computed.getPropertyValue(name) || computed[name];
            if (isCustomProp && ret) {
              ret = ret.replace(rtrimCSS, "$1") || void 0;
            }
            if (ret === "" && !isAttached(elem)) {
              ret = jQuery6.style(elem, name);
            }
            if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
              width = style.width;
              minWidth = style.minWidth;
              maxWidth = style.maxWidth;
              style.minWidth = style.maxWidth = style.width = ret;
              ret = computed.width;
              style.width = width;
              style.minWidth = minWidth;
              style.maxWidth = maxWidth;
            }
          }
          return ret !== void 0 ? (
            // Support: IE <=9 - 11 only
            // IE returns zIndex value as an integer.
            ret + ""
          ) : ret;
        }
        function addGetHookIf(conditionFn, hookFn) {
          return {
            get: function() {
              if (conditionFn()) {
                delete this.get;
                return;
              }
              return (this.get = hookFn).apply(this, arguments);
            }
          };
        }
        var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
        function vendorPropName(name) {
          var capName = name[0].toUpperCase() + name.slice(1), i2 = cssPrefixes.length;
          while (i2--) {
            name = cssPrefixes[i2] + capName;
            if (name in emptyStyle) {
              return name;
            }
          }
        }
        function finalPropName(name) {
          var final = jQuery6.cssProps[name] || vendorProps[name];
          if (final) {
            return final;
          }
          if (name in emptyStyle) {
            return name;
          }
          return vendorProps[name] = vendorPropName(name) || name;
        }
        var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
          letterSpacing: "0",
          fontWeight: "400"
        };
        function setPositiveNumber(_elem, value, subtract) {
          var matches = rcssNum.exec(value);
          return matches ? (
            // Guard against undefined "subtract", e.g., when used as in cssHooks
            Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
          ) : value;
        }
        function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
          var i2 = dimension === "width" ? 1 : 0, extra = 0, delta = 0, marginDelta = 0;
          if (box === (isBorderBox ? "border" : "content")) {
            return 0;
          }
          for (; i2 < 4; i2 += 2) {
            if (box === "margin") {
              marginDelta += jQuery6.css(elem, box + cssExpand[i2], true, styles);
            }
            if (!isBorderBox) {
              delta += jQuery6.css(elem, "padding" + cssExpand[i2], true, styles);
              if (box !== "padding") {
                delta += jQuery6.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
              } else {
                extra += jQuery6.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
              }
            } else {
              if (box === "content") {
                delta -= jQuery6.css(elem, "padding" + cssExpand[i2], true, styles);
              }
              if (box !== "margin") {
                delta -= jQuery6.css(elem, "border" + cssExpand[i2] + "Width", true, styles);
              }
            }
          }
          if (!isBorderBox && computedVal >= 0) {
            delta += Math.max(0, Math.ceil(
              elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
              // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
              // Use an explicit zero to avoid NaN (gh-3964)
            )) || 0;
          }
          return delta + marginDelta;
        }
        function getWidthOrHeight(elem, dimension, extra) {
          var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery6.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
          if (rnumnonpx.test(val)) {
            if (!extra) {
              return val;
            }
            val = "auto";
          }
          if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
          // IE/Edge misreport `getComputedStyle` of table rows with width/height
          // set in CSS while `offset*` properties report correct values.
          // Interestingly, in some cases IE 9 doesn't suffer from this issue.
          !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
          // This happens for inline elements with no explicit setting (gh-3571)
          val === "auto" || // Support: Android <=4.1 - 4.3 only
          // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
          !parseFloat(val) && jQuery6.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
          elem.getClientRects().length) {
            isBorderBox = jQuery6.css(elem, "boxSizing", false, styles) === "border-box";
            valueIsBorderBox = offsetProp in elem;
            if (valueIsBorderBox) {
              val = elem[offsetProp];
            }
          }
          val = parseFloat(val) || 0;
          return val + boxModelAdjustment(
            elem,
            dimension,
            extra || (isBorderBox ? "border" : "content"),
            valueIsBorderBox,
            styles,
            // Provide the current computed size to request scroll gutter calculation (gh-3589)
            val
          ) + "px";
        }
        jQuery6.extend({
          // Add in style property hooks for overriding the default
          // behavior of getting and setting a style property
          cssHooks: {
            opacity: {
              get: function(elem, computed) {
                if (computed) {
                  var ret = curCSS(elem, "opacity");
                  return ret === "" ? "1" : ret;
                }
              }
            }
          },
          // Don't automatically add "px" to these possibly-unitless properties
          cssNumber: {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageSlice: true,
            columnCount: true,
            flexGrow: true,
            flexShrink: true,
            fontWeight: true,
            gridArea: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnStart: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowStart: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            scale: true,
            widows: true,
            zIndex: true,
            zoom: true,
            // SVG-related
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeMiterlimit: true,
            strokeOpacity: true
          },
          // Add in properties whose names you wish to fix before
          // setting or getting the value
          cssProps: {},
          // Get and set the style property on a DOM Node
          style: function(elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
              return;
            }
            var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
            if (!isCustomProp) {
              name = finalPropName(origName);
            }
            hooks = jQuery6.cssHooks[name] || jQuery6.cssHooks[origName];
            if (value !== void 0) {
              type = typeof value;
              if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                value = adjustCSS(elem, name, ret);
                type = "number";
              }
              if (value == null || value !== value) {
                return;
              }
              if (type === "number" && !isCustomProp) {
                value += ret && ret[3] || (jQuery6.cssNumber[origName] ? "" : "px");
              }
              if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                style[name] = "inherit";
              }
              if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
                if (isCustomProp) {
                  style.setProperty(name, value);
                } else {
                  style[name] = value;
                }
              }
            } else {
              if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
                return ret;
              }
              return style[name];
            }
          },
          css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
            if (!isCustomProp) {
              name = finalPropName(origName);
            }
            hooks = jQuery6.cssHooks[name] || jQuery6.cssHooks[origName];
            if (hooks && "get" in hooks) {
              val = hooks.get(elem, true, extra);
            }
            if (val === void 0) {
              val = curCSS(elem, name, styles);
            }
            if (val === "normal" && name in cssNormalTransform) {
              val = cssNormalTransform[name];
            }
            if (extra === "" || extra) {
              num = parseFloat(val);
              return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
          }
        });
        jQuery6.each(["height", "width"], function(_i, dimension) {
          jQuery6.cssHooks[dimension] = {
            get: function(elem, computed, extra) {
              if (computed) {
                return rdisplayswap.test(jQuery6.css(elem, "display")) && // Support: Safari 8+
                // Table columns in Safari have non-zero offsetWidth & zero
                // getBoundingClientRect().width unless display is changed.
                // Support: IE <=11 only
                // Running getBoundingClientRect on a disconnected node
                // in IE throws an error.
                (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                  return getWidthOrHeight(elem, dimension, extra);
                }) : getWidthOrHeight(elem, dimension, extra);
              }
            },
            set: function(elem, value, extra) {
              var matches, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery6.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
                elem,
                dimension,
                extra,
                isBorderBox,
                styles
              ) : 0;
              if (isBorderBox && scrollboxSizeBuggy) {
                subtract -= Math.ceil(
                  elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
                );
              }
              if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
                elem.style[dimension] = value;
                value = jQuery6.css(elem, dimension);
              }
              return setPositiveNumber(elem, value, subtract);
            }
          };
        });
        jQuery6.cssHooks.marginLeft = addGetHookIf(
          support.reliableMarginLeft,
          function(elem, computed) {
            if (computed) {
              return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
                return elem.getBoundingClientRect().left;
              })) + "px";
            }
          }
        );
        jQuery6.each({
          margin: "",
          padding: "",
          border: "Width"
        }, function(prefix, suffix) {
          jQuery6.cssHooks[prefix + suffix] = {
            expand: function(value) {
              var i2 = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
              for (; i2 < 4; i2++) {
                expanded[prefix + cssExpand[i2] + suffix] = parts[i2] || parts[i2 - 2] || parts[0];
              }
              return expanded;
            }
          };
          if (prefix !== "margin") {
            jQuery6.cssHooks[prefix + suffix].set = setPositiveNumber;
          }
        });
        jQuery6.fn.extend({
          css: function(name, value) {
            return access(this, function(elem, name2, value2) {
              var styles, len, map = {}, i2 = 0;
              if (Array.isArray(name2)) {
                styles = getStyles(elem);
                len = name2.length;
                for (; i2 < len; i2++) {
                  map[name2[i2]] = jQuery6.css(elem, name2[i2], false, styles);
                }
                return map;
              }
              return value2 !== void 0 ? jQuery6.style(elem, name2, value2) : jQuery6.css(elem, name2);
            }, name, value, arguments.length > 1);
          }
        });
        function Tween(elem, options, prop, end2, easing) {
          return new Tween.prototype.init(elem, options, prop, end2, easing);
        }
        jQuery6.Tween = Tween;
        Tween.prototype = {
          constructor: Tween,
          init: function(elem, options, prop, end2, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery6.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end2;
            this.unit = unit || (jQuery6.cssNumber[prop] ? "" : "px");
          },
          cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
          },
          run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) {
              this.pos = eased = jQuery6.easing[this.easing](
                percent,
                this.options.duration * percent,
                0,
                1,
                this.options.duration
              );
            } else {
              this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) {
              this.options.step.call(this.elem, this.now, this);
            }
            if (hooks && hooks.set) {
              hooks.set(this);
            } else {
              Tween.propHooks._default.set(this);
            }
            return this;
          }
        };
        Tween.prototype.init.prototype = Tween.prototype;
        Tween.propHooks = {
          _default: {
            get: function(tween) {
              var result;
              if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                return tween.elem[tween.prop];
              }
              result = jQuery6.css(tween.elem, tween.prop, "");
              return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {
              if (jQuery6.fx.step[tween.prop]) {
                jQuery6.fx.step[tween.prop](tween);
              } else if (tween.elem.nodeType === 1 && (jQuery6.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
                jQuery6.style(tween.elem, tween.prop, tween.now + tween.unit);
              } else {
                tween.elem[tween.prop] = tween.now;
              }
            }
          }
        };
        Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
          set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
              tween.elem[tween.prop] = tween.now;
            }
          }
        };
        jQuery6.easing = {
          linear: function(p2) {
            return p2;
          },
          swing: function(p2) {
            return 0.5 - Math.cos(p2 * Math.PI) / 2;
          },
          _default: "swing"
        };
        jQuery6.fx = Tween.prototype.init;
        jQuery6.fx.step = {};
        var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
        function schedule() {
          if (inProgress) {
            if (document2.hidden === false && window2.requestAnimationFrame) {
              window2.requestAnimationFrame(schedule);
            } else {
              window2.setTimeout(schedule, jQuery6.fx.interval);
            }
            jQuery6.fx.tick();
          }
        }
        function createFxNow() {
          window2.setTimeout(function() {
            fxNow = void 0;
          });
          return fxNow = Date.now();
        }
        function genFx(type, includeWidth) {
          var which, i2 = 0, attrs = { height: type };
          includeWidth = includeWidth ? 1 : 0;
          for (; i2 < 4; i2 += 2 - includeWidth) {
            which = cssExpand[i2];
            attrs["margin" + which] = attrs["padding" + which] = type;
          }
          if (includeWidth) {
            attrs.opacity = attrs.width = type;
          }
          return attrs;
        }
        function createTween(value, prop, animation) {
          var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
          for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
              return tween;
            }
          }
        }
        function defaultPrefilter(elem, props, opts) {
          var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
          if (!opts.queue) {
            hooks = jQuery6._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
              hooks.unqueued = 0;
              oldfire = hooks.empty.fire;
              hooks.empty.fire = function() {
                if (!hooks.unqueued) {
                  oldfire();
                }
              };
            }
            hooks.unqueued++;
            anim.always(function() {
              anim.always(function() {
                hooks.unqueued--;
                if (!jQuery6.queue(elem, "fx").length) {
                  hooks.empty.fire();
                }
              });
            });
          }
          for (prop in props) {
            value = props[prop];
            if (rfxtypes.test(value)) {
              delete props[prop];
              toggle = toggle || value === "toggle";
              if (value === (hidden ? "hide" : "show")) {
                if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                  hidden = true;
                } else {
                  continue;
                }
              }
              orig[prop] = dataShow && dataShow[prop] || jQuery6.style(elem, prop);
            }
          }
          propTween = !jQuery6.isEmptyObject(props);
          if (!propTween && jQuery6.isEmptyObject(orig)) {
            return;
          }
          if (isBox && elem.nodeType === 1) {
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];
            restoreDisplay = dataShow && dataShow.display;
            if (restoreDisplay == null) {
              restoreDisplay = dataPriv.get(elem, "display");
            }
            display = jQuery6.css(elem, "display");
            if (display === "none") {
              if (restoreDisplay) {
                display = restoreDisplay;
              } else {
                showHide([elem], true);
                restoreDisplay = elem.style.display || restoreDisplay;
                display = jQuery6.css(elem, "display");
                showHide([elem]);
              }
            }
            if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
              if (jQuery6.css(elem, "float") === "none") {
                if (!propTween) {
                  anim.done(function() {
                    style.display = restoreDisplay;
                  });
                  if (restoreDisplay == null) {
                    display = style.display;
                    restoreDisplay = display === "none" ? "" : display;
                  }
                }
                style.display = "inline-block";
              }
            }
          }
          if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
              style.overflow = opts.overflow[0];
              style.overflowX = opts.overflow[1];
              style.overflowY = opts.overflow[2];
            });
          }
          propTween = false;
          for (prop in orig) {
            if (!propTween) {
              if (dataShow) {
                if ("hidden" in dataShow) {
                  hidden = dataShow.hidden;
                }
              } else {
                dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
              }
              if (toggle) {
                dataShow.hidden = !hidden;
              }
              if (hidden) {
                showHide([elem], true);
              }
              anim.done(function() {
                if (!hidden) {
                  showHide([elem]);
                }
                dataPriv.remove(elem, "fxshow");
                for (prop in orig) {
                  jQuery6.style(elem, prop, orig[prop]);
                }
              });
            }
            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
              dataShow[prop] = propTween.start;
              if (hidden) {
                propTween.end = propTween.start;
                propTween.start = 0;
              }
            }
          }
        }
        function propFilter(props, specialEasing) {
          var index, name, easing, value, hooks;
          for (index in props) {
            name = camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (Array.isArray(value)) {
              easing = value[1];
              value = props[index] = value[0];
            }
            if (index !== name) {
              props[name] = value;
              delete props[index];
            }
            hooks = jQuery6.cssHooks[name];
            if (hooks && "expand" in hooks) {
              value = hooks.expand(value);
              delete props[name];
              for (index in value) {
                if (!(index in props)) {
                  props[index] = value[index];
                  specialEasing[index] = easing;
                }
              }
            } else {
              specialEasing[name] = easing;
            }
          }
        }
        function Animation(elem, properties, options) {
          var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery6.Deferred().always(function() {
            delete tick.elem;
          }), tick = function() {
            if (stopped) {
              return false;
            }
            var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length2 = animation.tweens.length;
            for (; index2 < length2; index2++) {
              animation.tweens[index2].run(percent);
            }
            deferred.notifyWith(elem, [animation, percent, remaining]);
            if (percent < 1 && length2) {
              return remaining;
            }
            if (!length2) {
              deferred.notifyWith(elem, [animation, 1, 0]);
            }
            deferred.resolveWith(elem, [animation]);
            return false;
          }, animation = deferred.promise({
            elem,
            props: jQuery6.extend({}, properties),
            opts: jQuery6.extend(true, {
              specialEasing: {},
              easing: jQuery6.easing._default
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end2) {
              var tween = jQuery6.Tween(
                elem,
                animation.opts,
                prop,
                end2,
                animation.opts.specialEasing[prop] || animation.opts.easing
              );
              animation.tweens.push(tween);
              return tween;
            },
            stop: function(gotoEnd) {
              var index2 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
              if (stopped) {
                return this;
              }
              stopped = true;
              for (; index2 < length2; index2++) {
                animation.tweens[index2].run(1);
              }
              if (gotoEnd) {
                deferred.notifyWith(elem, [animation, 1, 0]);
                deferred.resolveWith(elem, [animation, gotoEnd]);
              } else {
                deferred.rejectWith(elem, [animation, gotoEnd]);
              }
              return this;
            }
          }), props = animation.props;
          propFilter(props, animation.opts.specialEasing);
          for (; index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
              if (isFunction(result.stop)) {
                jQuery6._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
              }
              return result;
            }
          }
          jQuery6.map(props, createTween, animation);
          if (isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
          }
          animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
          jQuery6.fx.timer(
            jQuery6.extend(tick, {
              elem,
              anim: animation,
              queue: animation.opts.queue
            })
          );
          return animation;
        }
        jQuery6.Animation = jQuery6.extend(Animation, {
          tweeners: {
            "*": [function(prop, value) {
              var tween = this.createTween(prop, value);
              adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
              return tween;
            }]
          },
          tweener: function(props, callback) {
            if (isFunction(props)) {
              callback = props;
              props = ["*"];
            } else {
              props = props.match(rnothtmlwhite);
            }
            var prop, index = 0, length = props.length;
            for (; index < length; index++) {
              prop = props[index];
              Animation.tweeners[prop] = Animation.tweeners[prop] || [];
              Animation.tweeners[prop].unshift(callback);
            }
          },
          prefilters: [defaultPrefilter],
          prefilter: function(callback, prepend) {
            if (prepend) {
              Animation.prefilters.unshift(callback);
            } else {
              Animation.prefilters.push(callback);
            }
          }
        });
        jQuery6.speed = function(speed, easing, fn2) {
          var opt = speed && typeof speed === "object" ? jQuery6.extend({}, speed) : {
            complete: fn2 || !fn2 && easing || isFunction(speed) && speed,
            duration: speed,
            easing: fn2 && easing || easing && !isFunction(easing) && easing
          };
          if (jQuery6.fx.off) {
            opt.duration = 0;
          } else {
            if (typeof opt.duration !== "number") {
              if (opt.duration in jQuery6.fx.speeds) {
                opt.duration = jQuery6.fx.speeds[opt.duration];
              } else {
                opt.duration = jQuery6.fx.speeds._default;
              }
            }
          }
          if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
          }
          opt.old = opt.complete;
          opt.complete = function() {
            if (isFunction(opt.old)) {
              opt.old.call(this);
            }
            if (opt.queue) {
              jQuery6.dequeue(this, opt.queue);
            }
          };
          return opt;
        };
        jQuery6.fn.extend({
          fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
          },
          animate: function(prop, speed, easing, callback) {
            var empty = jQuery6.isEmptyObject(prop), optall = jQuery6.speed(speed, easing, callback), doAnimation = function() {
              var anim = Animation(this, jQuery6.extend({}, prop), optall);
              if (empty || dataPriv.get(this, "finish")) {
                anim.stop(true);
              }
            };
            doAnimation.finish = doAnimation;
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
          },
          stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
              var stop = hooks.stop;
              delete hooks.stop;
              stop(gotoEnd);
            };
            if (typeof type !== "string") {
              gotoEnd = clearQueue;
              clearQueue = type;
              type = void 0;
            }
            if (clearQueue) {
              this.queue(type || "fx", []);
            }
            return this.each(function() {
              var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery6.timers, data = dataPriv.get(this);
              if (index) {
                if (data[index] && data[index].stop) {
                  stopQueue(data[index]);
                }
              } else {
                for (index in data) {
                  if (data[index] && data[index].stop && rrun.test(index)) {
                    stopQueue(data[index]);
                  }
                }
              }
              for (index = timers.length; index--; ) {
                if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                  timers[index].anim.stop(gotoEnd);
                  dequeue = false;
                  timers.splice(index, 1);
                }
              }
              if (dequeue || !gotoEnd) {
                jQuery6.dequeue(this, type);
              }
            });
          },
          finish: function(type) {
            if (type !== false) {
              type = type || "fx";
            }
            return this.each(function() {
              var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery6.timers, length = queue ? queue.length : 0;
              data.finish = true;
              jQuery6.queue(this, type, []);
              if (hooks && hooks.stop) {
                hooks.stop.call(this, true);
              }
              for (index = timers.length; index--; ) {
                if (timers[index].elem === this && timers[index].queue === type) {
                  timers[index].anim.stop(true);
                  timers.splice(index, 1);
                }
              }
              for (index = 0; index < length; index++) {
                if (queue[index] && queue[index].finish) {
                  queue[index].finish.call(this);
                }
              }
              delete data.finish;
            });
          }
        });
        jQuery6.each(["toggle", "show", "hide"], function(_i, name) {
          var cssFn = jQuery6.fn[name];
          jQuery6.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
          };
        });
        jQuery6.each({
          slideDown: genFx("show"),
          slideUp: genFx("hide"),
          slideToggle: genFx("toggle"),
          fadeIn: { opacity: "show" },
          fadeOut: { opacity: "hide" },
          fadeToggle: { opacity: "toggle" }
        }, function(name, props) {
          jQuery6.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
          };
        });
        jQuery6.timers = [];
        jQuery6.fx.tick = function() {
          var timer, i2 = 0, timers = jQuery6.timers;
          fxNow = Date.now();
          for (; i2 < timers.length; i2++) {
            timer = timers[i2];
            if (!timer() && timers[i2] === timer) {
              timers.splice(i2--, 1);
            }
          }
          if (!timers.length) {
            jQuery6.fx.stop();
          }
          fxNow = void 0;
        };
        jQuery6.fx.timer = function(timer) {
          jQuery6.timers.push(timer);
          jQuery6.fx.start();
        };
        jQuery6.fx.interval = 13;
        jQuery6.fx.start = function() {
          if (inProgress) {
            return;
          }
          inProgress = true;
          schedule();
        };
        jQuery6.fx.stop = function() {
          inProgress = null;
        };
        jQuery6.fx.speeds = {
          slow: 600,
          fast: 200,
          // Default speed
          _default: 400
        };
        jQuery6.fn.delay = function(time, type) {
          time = jQuery6.fx ? jQuery6.fx.speeds[time] || time : time;
          type = type || "fx";
          return this.queue(type, function(next, hooks) {
            var timeout = window2.setTimeout(next, time);
            hooks.stop = function() {
              window2.clearTimeout(timeout);
            };
          });
        };
        (function() {
          var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
          input.type = "checkbox";
          support.checkOn = input.value !== "";
          support.optSelected = opt.selected;
          input = document2.createElement("input");
          input.value = "t";
          input.type = "radio";
          support.radioValue = input.value === "t";
        })();
        var boolHook, attrHandle = jQuery6.expr.attrHandle;
        jQuery6.fn.extend({
          attr: function(name, value) {
            return access(this, jQuery6.attr, name, value, arguments.length > 1);
          },
          removeAttr: function(name) {
            return this.each(function() {
              jQuery6.removeAttr(this, name);
            });
          }
        });
        jQuery6.extend({
          attr: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (typeof elem.getAttribute === "undefined") {
              return jQuery6.prop(elem, name, value);
            }
            if (nType !== 1 || !jQuery6.isXMLDoc(elem)) {
              hooks = jQuery6.attrHooks[name.toLowerCase()] || (jQuery6.expr.match.bool.test(name) ? boolHook : void 0);
            }
            if (value !== void 0) {
              if (value === null) {
                jQuery6.removeAttr(elem, name);
                return;
              }
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                return ret;
              }
              elem.setAttribute(name, value + "");
              return value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
              return ret;
            }
            ret = jQuery6.find.attr(elem, name);
            return ret == null ? void 0 : ret;
          },
          attrHooks: {
            type: {
              set: function(elem, value) {
                if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                  var val = elem.value;
                  elem.setAttribute("type", value);
                  if (val) {
                    elem.value = val;
                  }
                  return value;
                }
              }
            }
          },
          removeAttr: function(elem, value) {
            var name, i2 = 0, attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && elem.nodeType === 1) {
              while (name = attrNames[i2++]) {
                elem.removeAttribute(name);
              }
            }
          }
        });
        boolHook = {
          set: function(elem, value, name) {
            if (value === false) {
              jQuery6.removeAttr(elem, name);
            } else {
              elem.setAttribute(name, name);
            }
            return name;
          }
        };
        jQuery6.each(jQuery6.expr.match.bool.source.match(/\w+/g), function(_i, name) {
          var getter = attrHandle[name] || jQuery6.find.attr;
          attrHandle[name] = function(elem, name2, isXML) {
            var ret, handle, lowercaseName = name2.toLowerCase();
            if (!isXML) {
              handle = attrHandle[lowercaseName];
              attrHandle[lowercaseName] = ret;
              ret = getter(elem, name2, isXML) != null ? lowercaseName : null;
              attrHandle[lowercaseName] = handle;
            }
            return ret;
          };
        });
        var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
        jQuery6.fn.extend({
          prop: function(name, value) {
            return access(this, jQuery6.prop, name, value, arguments.length > 1);
          },
          removeProp: function(name) {
            return this.each(function() {
              delete this[jQuery6.propFix[name] || name];
            });
          }
        });
        jQuery6.extend({
          prop: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (nType === 3 || nType === 8 || nType === 2) {
              return;
            }
            if (nType !== 1 || !jQuery6.isXMLDoc(elem)) {
              name = jQuery6.propFix[name] || name;
              hooks = jQuery6.propHooks[name];
            }
            if (value !== void 0) {
              if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
                return ret;
              }
              return elem[name] = value;
            }
            if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
              return ret;
            }
            return elem[name];
          },
          propHooks: {
            tabIndex: {
              get: function(elem) {
                var tabindex = jQuery6.find.attr(elem, "tabindex");
                if (tabindex) {
                  return parseInt(tabindex, 10);
                }
                if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                  return 0;
                }
                return -1;
              }
            }
          },
          propFix: {
            "for": "htmlFor",
            "class": "className"
          }
        });
        if (!support.optSelected) {
          jQuery6.propHooks.selected = {
            get: function(elem) {
              var parent = elem.parentNode;
              if (parent && parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
              return null;
            },
            set: function(elem) {
              var parent = elem.parentNode;
              if (parent) {
                parent.selectedIndex;
                if (parent.parentNode) {
                  parent.parentNode.selectedIndex;
                }
              }
            }
          };
        }
        jQuery6.each([
          "tabIndex",
          "readOnly",
          "maxLength",
          "cellSpacing",
          "cellPadding",
          "rowSpan",
          "colSpan",
          "useMap",
          "frameBorder",
          "contentEditable"
        ], function() {
          jQuery6.propFix[this.toLowerCase()] = this;
        });
        function stripAndCollapse(value) {
          var tokens = value.match(rnothtmlwhite) || [];
          return tokens.join(" ");
        }
        function getClass(elem) {
          return elem.getAttribute && elem.getAttribute("class") || "";
        }
        function classesToArray(value) {
          if (Array.isArray(value)) {
            return value;
          }
          if (typeof value === "string") {
            return value.match(rnothtmlwhite) || [];
          }
          return [];
        }
        jQuery6.fn.extend({
          addClass: function(value) {
            var classNames, cur, curValue, className, i2, finalValue;
            if (isFunction(value)) {
              return this.each(function(j2) {
                jQuery6(this).addClass(value.call(this, j2, getClass(this)));
              });
            }
            classNames = classesToArray(value);
            if (classNames.length) {
              return this.each(function() {
                curValue = getClass(this);
                cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  for (i2 = 0; i2 < classNames.length; i2++) {
                    className = classNames[i2];
                    if (cur.indexOf(" " + className + " ") < 0) {
                      cur += className + " ";
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    this.setAttribute("class", finalValue);
                  }
                }
              });
            }
            return this;
          },
          removeClass: function(value) {
            var classNames, cur, curValue, className, i2, finalValue;
            if (isFunction(value)) {
              return this.each(function(j2) {
                jQuery6(this).removeClass(value.call(this, j2, getClass(this)));
              });
            }
            if (!arguments.length) {
              return this.attr("class", "");
            }
            classNames = classesToArray(value);
            if (classNames.length) {
              return this.each(function() {
                curValue = getClass(this);
                cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
                if (cur) {
                  for (i2 = 0; i2 < classNames.length; i2++) {
                    className = classNames[i2];
                    while (cur.indexOf(" " + className + " ") > -1) {
                      cur = cur.replace(" " + className + " ", " ");
                    }
                  }
                  finalValue = stripAndCollapse(cur);
                  if (curValue !== finalValue) {
                    this.setAttribute("class", finalValue);
                  }
                }
              });
            }
            return this;
          },
          toggleClass: function(value, stateVal) {
            var classNames, className, i2, self2, type = typeof value, isValidValue = type === "string" || Array.isArray(value);
            if (isFunction(value)) {
              return this.each(function(i3) {
                jQuery6(this).toggleClass(
                  value.call(this, i3, getClass(this), stateVal),
                  stateVal
                );
              });
            }
            if (typeof stateVal === "boolean" && isValidValue) {
              return stateVal ? this.addClass(value) : this.removeClass(value);
            }
            classNames = classesToArray(value);
            return this.each(function() {
              if (isValidValue) {
                self2 = jQuery6(this);
                for (i2 = 0; i2 < classNames.length; i2++) {
                  className = classNames[i2];
                  if (self2.hasClass(className)) {
                    self2.removeClass(className);
                  } else {
                    self2.addClass(className);
                  }
                }
              } else if (value === void 0 || type === "boolean") {
                className = getClass(this);
                if (className) {
                  dataPriv.set(this, "__className__", className);
                }
                if (this.setAttribute) {
                  this.setAttribute(
                    "class",
                    className || value === false ? "" : dataPriv.get(this, "__className__") || ""
                  );
                }
              }
            });
          },
          hasClass: function(selector) {
            var className, elem, i2 = 0;
            className = " " + selector + " ";
            while (elem = this[i2++]) {
              if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
                return true;
              }
            }
            return false;
          }
        });
        var rreturn = /\r/g;
        jQuery6.fn.extend({
          val: function(value) {
            var hooks, ret, valueIsFunction, elem = this[0];
            if (!arguments.length) {
              if (elem) {
                hooks = jQuery6.valHooks[elem.type] || jQuery6.valHooks[elem.nodeName.toLowerCase()];
                if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                  return ret;
                }
                ret = elem.value;
                if (typeof ret === "string") {
                  return ret.replace(rreturn, "");
                }
                return ret == null ? "" : ret;
              }
              return;
            }
            valueIsFunction = isFunction(value);
            return this.each(function(i2) {
              var val;
              if (this.nodeType !== 1) {
                return;
              }
              if (valueIsFunction) {
                val = value.call(this, i2, jQuery6(this).val());
              } else {
                val = value;
              }
              if (val == null) {
                val = "";
              } else if (typeof val === "number") {
                val += "";
              } else if (Array.isArray(val)) {
                val = jQuery6.map(val, function(value2) {
                  return value2 == null ? "" : value2 + "";
                });
              }
              hooks = jQuery6.valHooks[this.type] || jQuery6.valHooks[this.nodeName.toLowerCase()];
              if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
                this.value = val;
              }
            });
          }
        });
        jQuery6.extend({
          valHooks: {
            option: {
              get: function(elem) {
                var val = jQuery6.find.attr(elem, "value");
                return val != null ? val : (
                  // Support: IE <=10 - 11 only
                  // option.text throws exceptions (trac-14686, trac-14858)
                  // Strip and collapse whitespace
                  // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                  stripAndCollapse(jQuery6.text(elem))
                );
              }
            },
            select: {
              get: function(elem) {
                var value, option, i2, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max2 = one ? index + 1 : options.length;
                if (index < 0) {
                  i2 = max2;
                } else {
                  i2 = one ? index : 0;
                }
                for (; i2 < max2; i2++) {
                  option = options[i2];
                  if ((option.selected || i2 === index) && // Don't return options that are disabled or in a disabled optgroup
                  !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                    value = jQuery6(option).val();
                    if (one) {
                      return value;
                    }
                    values.push(value);
                  }
                }
                return values;
              },
              set: function(elem, value) {
                var optionSet, option, options = elem.options, values = jQuery6.makeArray(value), i2 = options.length;
                while (i2--) {
                  option = options[i2];
                  if (option.selected = jQuery6.inArray(jQuery6.valHooks.option.get(option), values) > -1) {
                    optionSet = true;
                  }
                }
                if (!optionSet) {
                  elem.selectedIndex = -1;
                }
                return values;
              }
            }
          }
        });
        jQuery6.each(["radio", "checkbox"], function() {
          jQuery6.valHooks[this] = {
            set: function(elem, value) {
              if (Array.isArray(value)) {
                return elem.checked = jQuery6.inArray(jQuery6(elem).val(), value) > -1;
              }
            }
          };
          if (!support.checkOn) {
            jQuery6.valHooks[this].get = function(elem) {
              return elem.getAttribute("value") === null ? "on" : elem.value;
            };
          }
        });
        var location2 = window2.location;
        var nonce = { guid: Date.now() };
        var rquery = /\?/;
        jQuery6.parseXML = function(data) {
          var xml, parserErrorElem;
          if (!data || typeof data !== "string") {
            return null;
          }
          try {
            xml = new window2.DOMParser().parseFromString(data, "text/xml");
          } catch (e2) {
          }
          parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
          if (!xml || parserErrorElem) {
            jQuery6.error("Invalid XML: " + (parserErrorElem ? jQuery6.map(parserErrorElem.childNodes, function(el) {
              return el.textContent;
            }).join("\n") : data));
          }
          return xml;
        };
        var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e2) {
          e2.stopPropagation();
        };
        jQuery6.extend(jQuery6.event, {
          trigger: function(event, data, elem, onlyHandlers) {
            var i2, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            cur = lastElement = tmp = elem = elem || document2;
            if (elem.nodeType === 3 || elem.nodeType === 8) {
              return;
            }
            if (rfocusMorph.test(type + jQuery6.event.triggered)) {
              return;
            }
            if (type.indexOf(".") > -1) {
              namespaces = type.split(".");
              type = namespaces.shift();
              namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;
            event = event[jQuery6.expando] ? event : new jQuery6.Event(type, typeof event === "object" && event);
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            event.result = void 0;
            if (!event.target) {
              event.target = elem;
            }
            data = data == null ? [event] : jQuery6.makeArray(data, [event]);
            special = jQuery6.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
              return;
            }
            if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
              bubbleType = special.delegateType || type;
              if (!rfocusMorph.test(bubbleType + type)) {
                cur = cur.parentNode;
              }
              for (; cur; cur = cur.parentNode) {
                eventPath.push(cur);
                tmp = cur;
              }
              if (tmp === (elem.ownerDocument || document2)) {
                eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
              }
            }
            i2 = 0;
            while ((cur = eventPath[i2++]) && !event.isPropagationStopped()) {
              lastElement = cur;
              event.type = i2 > 1 ? bubbleType : special.bindType || type;
              handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
              if (handle) {
                handle.apply(cur, data);
              }
              handle = ontype && cur[ontype];
              if (handle && handle.apply && acceptData(cur)) {
                event.result = handle.apply(cur, data);
                if (event.result === false) {
                  event.preventDefault();
                }
              }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
              if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
                  tmp = elem[ontype];
                  if (tmp) {
                    elem[ontype] = null;
                  }
                  jQuery6.event.triggered = type;
                  if (event.isPropagationStopped()) {
                    lastElement.addEventListener(type, stopPropagationCallback);
                  }
                  elem[type]();
                  if (event.isPropagationStopped()) {
                    lastElement.removeEventListener(type, stopPropagationCallback);
                  }
                  jQuery6.event.triggered = void 0;
                  if (tmp) {
                    elem[ontype] = tmp;
                  }
                }
              }
            }
            return event.result;
          },
          // Piggyback on a donor event to simulate a different one
          // Used only for `focus(in | out)` events
          simulate: function(type, elem, event) {
            var e2 = jQuery6.extend(
              new jQuery6.Event(),
              event,
              {
                type,
                isSimulated: true
              }
            );
            jQuery6.event.trigger(e2, null, elem);
          }
        });
        jQuery6.fn.extend({
          trigger: function(type, data) {
            return this.each(function() {
              jQuery6.event.trigger(type, data, this);
            });
          },
          triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
              return jQuery6.event.trigger(type, data, elem, true);
            }
          }
        });
        var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
        function buildParams(prefix, obj, traditional, add2) {
          var name;
          if (Array.isArray(obj)) {
            jQuery6.each(obj, function(i2, v2) {
              if (traditional || rbracket.test(prefix)) {
                add2(prefix, v2);
              } else {
                buildParams(
                  prefix + "[" + (typeof v2 === "object" && v2 != null ? i2 : "") + "]",
                  v2,
                  traditional,
                  add2
                );
              }
            });
          } else if (!traditional && toType2(obj) === "object") {
            for (name in obj) {
              buildParams(prefix + "[" + name + "]", obj[name], traditional, add2);
            }
          } else {
            add2(prefix, obj);
          }
        }
        jQuery6.param = function(a2, traditional) {
          var prefix, s2 = [], add2 = function(key, valueOrFunction) {
            var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
            s2[s2.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
          };
          if (a2 == null) {
            return "";
          }
          if (Array.isArray(a2) || a2.jquery && !jQuery6.isPlainObject(a2)) {
            jQuery6.each(a2, function() {
              add2(this.name, this.value);
            });
          } else {
            for (prefix in a2) {
              buildParams(prefix, a2[prefix], traditional, add2);
            }
          }
          return s2.join("&");
        };
        jQuery6.fn.extend({
          serialize: function() {
            return jQuery6.param(this.serializeArray());
          },
          serializeArray: function() {
            return this.map(function() {
              var elements = jQuery6.prop(this, "elements");
              return elements ? jQuery6.makeArray(elements) : this;
            }).filter(function() {
              var type = this.type;
              return this.name && !jQuery6(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(_i, elem) {
              var val = jQuery6(this).val();
              if (val == null) {
                return null;
              }
              if (Array.isArray(val)) {
                return jQuery6.map(val, function(val2) {
                  return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
                });
              }
              return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
            }).get();
          }
        });
        var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
        originAnchor.href = location2.href;
        function addToPrefiltersOrTransports(structure) {
          return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
              func = dataTypeExpression;
              dataTypeExpression = "*";
            }
            var dataType, i2 = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (isFunction(func)) {
              while (dataType = dataTypes[i2++]) {
                if (dataType[0] === "+") {
                  dataType = dataType.slice(1) || "*";
                  (structure[dataType] = structure[dataType] || []).unshift(func);
                } else {
                  (structure[dataType] = structure[dataType] || []).push(func);
                }
              }
            }
          };
        }
        function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
          var inspected = {}, seekingTransport = structure === transports;
          function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery6.each(structure[dataType] || [], function(_2, prefilterOrFactory) {
              var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
              if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                options.dataTypes.unshift(dataTypeOrTransport);
                inspect(dataTypeOrTransport);
                return false;
              } else if (seekingTransport) {
                return !(selected = dataTypeOrTransport);
              }
            });
            return selected;
          }
          return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
        }
        function ajaxExtend(target, src) {
          var key, deep, flatOptions = jQuery6.ajaxSettings.flatOptions || {};
          for (key in src) {
            if (src[key] !== void 0) {
              (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
            }
          }
          if (deep) {
            jQuery6.extend(true, target, deep);
          }
          return target;
        }
        function ajaxHandleResponses(s2, jqXHR, responses) {
          var ct, type, finalDataType, firstDataType, contents = s2.contents, dataTypes = s2.dataTypes;
          while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === void 0) {
              ct = s2.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
          }
          if (ct) {
            for (type in contents) {
              if (contents[type] && contents[type].test(ct)) {
                dataTypes.unshift(type);
                break;
              }
            }
          }
          if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0];
          } else {
            for (type in responses) {
              if (!dataTypes[0] || s2.converters[type + " " + dataTypes[0]]) {
                finalDataType = type;
                break;
              }
              if (!firstDataType) {
                firstDataType = type;
              }
            }
            finalDataType = finalDataType || firstDataType;
          }
          if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
              dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
          }
        }
        function ajaxConvert(s2, response, jqXHR, isSuccess) {
          var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s2.dataTypes.slice();
          if (dataTypes[1]) {
            for (conv in s2.converters) {
              converters[conv.toLowerCase()] = s2.converters[conv];
            }
          }
          current = dataTypes.shift();
          while (current) {
            if (s2.responseFields[current]) {
              jqXHR[s2.responseFields[current]] = response;
            }
            if (!prev && isSuccess && s2.dataFilter) {
              response = s2.dataFilter(response, s2.dataType);
            }
            prev = current;
            current = dataTypes.shift();
            if (current) {
              if (current === "*") {
                current = prev;
              } else if (prev !== "*" && prev !== current) {
                conv = converters[prev + " " + current] || converters["* " + current];
                if (!conv) {
                  for (conv2 in converters) {
                    tmp = conv2.split(" ");
                    if (tmp[1] === current) {
                      conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                      if (conv) {
                        if (conv === true) {
                          conv = converters[conv2];
                        } else if (converters[conv2] !== true) {
                          current = tmp[0];
                          dataTypes.unshift(tmp[1]);
                        }
                        break;
                      }
                    }
                  }
                }
                if (conv !== true) {
                  if (conv && s2.throws) {
                    response = conv(response);
                  } else {
                    try {
                      response = conv(response);
                    } catch (e2) {
                      return {
                        state: "parsererror",
                        error: conv ? e2 : "No conversion from " + prev + " to " + current
                      };
                    }
                  }
                }
              }
            }
          }
          return { state: "success", data: response };
        }
        jQuery6.extend({
          // Counter for holding the number of active queries
          active: 0,
          // Last-Modified header cache for next request
          lastModified: {},
          etag: {},
          ajaxSettings: {
            url: location2.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location2.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            /*
            timeout: 0,
            data: null,
            dataType: null,
            username: null,
            password: null,
            cache: null,
            throws: false,
            traditional: false,
            headers: {},
            */
            accepts: {
              "*": allTypes,
              text: "text/plain",
              html: "text/html",
              xml: "application/xml, text/xml",
              json: "application/json, text/javascript"
            },
            contents: {
              xml: /\bxml\b/,
              html: /\bhtml/,
              json: /\bjson\b/
            },
            responseFields: {
              xml: "responseXML",
              text: "responseText",
              json: "responseJSON"
            },
            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {
              // Convert anything to text
              "* text": String,
              // Text to html (true = no transformation)
              "text html": true,
              // Evaluate text as a json expression
              "text json": JSON.parse,
              // Parse text as xml
              "text xml": jQuery6.parseXML
            },
            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
              url: true,
              context: true
            }
          },
          // Creates a full fledged settings object into target
          // with both ajaxSettings and settings fields.
          // If target is omitted, writes into ajaxSettings.
          ajaxSetup: function(target, settings) {
            return settings ? (
              // Building a settings object
              ajaxExtend(ajaxExtend(target, jQuery6.ajaxSettings), settings)
            ) : (
              // Extending ajaxSettings
              ajaxExtend(jQuery6.ajaxSettings, target)
            );
          },
          ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
          ajaxTransport: addToPrefiltersOrTransports(transports),
          // Main method
          ajax: function(url, options) {
            if (typeof url === "object") {
              options = url;
              url = void 0;
            }
            options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i2, uncached, s2 = jQuery6.ajaxSetup({}, options), callbackContext = s2.context || s2, globalEventContext = s2.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery6(callbackContext) : jQuery6.event, deferred = jQuery6.Deferred(), completeDeferred = jQuery6.Callbacks("once memory"), statusCode = s2.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
              readyState: 0,
              // Builds headers hashtable if needed
              getResponseHeader: function(key) {
                var match;
                if (completed2) {
                  if (!responseHeaders) {
                    responseHeaders = {};
                    while (match = rheaders.exec(responseHeadersString)) {
                      responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                    }
                  }
                  match = responseHeaders[key.toLowerCase() + " "];
                }
                return match == null ? null : match.join(", ");
              },
              // Raw string
              getAllResponseHeaders: function() {
                return completed2 ? responseHeadersString : null;
              },
              // Caches the header
              setRequestHeader: function(name, value) {
                if (completed2 == null) {
                  name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                  requestHeaders[name] = value;
                }
                return this;
              },
              // Overrides response content-type header
              overrideMimeType: function(type) {
                if (completed2 == null) {
                  s2.mimeType = type;
                }
                return this;
              },
              // Status-dependent callbacks
              statusCode: function(map) {
                var code;
                if (map) {
                  if (completed2) {
                    jqXHR.always(map[jqXHR.status]);
                  } else {
                    for (code in map) {
                      statusCode[code] = [statusCode[code], map[code]];
                    }
                  }
                }
                return this;
              },
              // Cancel the request
              abort: function(statusText) {
                var finalText = statusText || strAbort;
                if (transport) {
                  transport.abort(finalText);
                }
                done(0, finalText);
                return this;
              }
            };
            deferred.promise(jqXHR);
            s2.url = ((url || s2.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
            s2.type = options.method || options.type || s2.method || s2.type;
            s2.dataTypes = (s2.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
            if (s2.crossDomain == null) {
              urlAnchor = document2.createElement("a");
              try {
                urlAnchor.href = s2.url;
                urlAnchor.href = urlAnchor.href;
                s2.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
              } catch (e2) {
                s2.crossDomain = true;
              }
            }
            if (s2.data && s2.processData && typeof s2.data !== "string") {
              s2.data = jQuery6.param(s2.data, s2.traditional);
            }
            inspectPrefiltersOrTransports(prefilters, s2, options, jqXHR);
            if (completed2) {
              return jqXHR;
            }
            fireGlobals = jQuery6.event && s2.global;
            if (fireGlobals && jQuery6.active++ === 0) {
              jQuery6.event.trigger("ajaxStart");
            }
            s2.type = s2.type.toUpperCase();
            s2.hasContent = !rnoContent.test(s2.type);
            cacheURL = s2.url.replace(rhash, "");
            if (!s2.hasContent) {
              uncached = s2.url.slice(cacheURL.length);
              if (s2.data && (s2.processData || typeof s2.data === "string")) {
                cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s2.data;
                delete s2.data;
              }
              if (s2.cache === false) {
                cacheURL = cacheURL.replace(rantiCache, "$1");
                uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
              }
              s2.url = cacheURL + uncached;
            } else if (s2.data && s2.processData && (s2.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
              s2.data = s2.data.replace(r20, "+");
            }
            if (s2.ifModified) {
              if (jQuery6.lastModified[cacheURL]) {
                jqXHR.setRequestHeader("If-Modified-Since", jQuery6.lastModified[cacheURL]);
              }
              if (jQuery6.etag[cacheURL]) {
                jqXHR.setRequestHeader("If-None-Match", jQuery6.etag[cacheURL]);
              }
            }
            if (s2.data && s2.hasContent && s2.contentType !== false || options.contentType) {
              jqXHR.setRequestHeader("Content-Type", s2.contentType);
            }
            jqXHR.setRequestHeader(
              "Accept",
              s2.dataTypes[0] && s2.accepts[s2.dataTypes[0]] ? s2.accepts[s2.dataTypes[0]] + (s2.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s2.accepts["*"]
            );
            for (i2 in s2.headers) {
              jqXHR.setRequestHeader(i2, s2.headers[i2]);
            }
            if (s2.beforeSend && (s2.beforeSend.call(callbackContext, jqXHR, s2) === false || completed2)) {
              return jqXHR.abort();
            }
            strAbort = "abort";
            completeDeferred.add(s2.complete);
            jqXHR.done(s2.success);
            jqXHR.fail(s2.error);
            transport = inspectPrefiltersOrTransports(transports, s2, options, jqXHR);
            if (!transport) {
              done(-1, "No Transport");
            } else {
              jqXHR.readyState = 1;
              if (fireGlobals) {
                globalEventContext.trigger("ajaxSend", [jqXHR, s2]);
              }
              if (completed2) {
                return jqXHR;
              }
              if (s2.async && s2.timeout > 0) {
                timeoutTimer = window2.setTimeout(function() {
                  jqXHR.abort("timeout");
                }, s2.timeout);
              }
              try {
                completed2 = false;
                transport.send(requestHeaders, done);
              } catch (e2) {
                if (completed2) {
                  throw e2;
                }
                done(-1, e2);
              }
            }
            function done(status, nativeStatusText, responses, headers) {
              var isSuccess, success, error2, response, modified, statusText = nativeStatusText;
              if (completed2) {
                return;
              }
              completed2 = true;
              if (timeoutTimer) {
                window2.clearTimeout(timeoutTimer);
              }
              transport = void 0;
              responseHeadersString = headers || "";
              jqXHR.readyState = status > 0 ? 4 : 0;
              isSuccess = status >= 200 && status < 300 || status === 304;
              if (responses) {
                response = ajaxHandleResponses(s2, jqXHR, responses);
              }
              if (!isSuccess && jQuery6.inArray("script", s2.dataTypes) > -1 && jQuery6.inArray("json", s2.dataTypes) < 0) {
                s2.converters["text script"] = function() {
                };
              }
              response = ajaxConvert(s2, response, jqXHR, isSuccess);
              if (isSuccess) {
                if (s2.ifModified) {
                  modified = jqXHR.getResponseHeader("Last-Modified");
                  if (modified) {
                    jQuery6.lastModified[cacheURL] = modified;
                  }
                  modified = jqXHR.getResponseHeader("etag");
                  if (modified) {
                    jQuery6.etag[cacheURL] = modified;
                  }
                }
                if (status === 204 || s2.type === "HEAD") {
                  statusText = "nocontent";
                } else if (status === 304) {
                  statusText = "notmodified";
                } else {
                  statusText = response.state;
                  success = response.data;
                  error2 = response.error;
                  isSuccess = !error2;
                }
              } else {
                error2 = statusText;
                if (status || !statusText) {
                  statusText = "error";
                  if (status < 0) {
                    status = 0;
                  }
                }
              }
              jqXHR.status = status;
              jqXHR.statusText = (nativeStatusText || statusText) + "";
              if (isSuccess) {
                deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
              } else {
                deferred.rejectWith(callbackContext, [jqXHR, statusText, error2]);
              }
              jqXHR.statusCode(statusCode);
              statusCode = void 0;
              if (fireGlobals) {
                globalEventContext.trigger(
                  isSuccess ? "ajaxSuccess" : "ajaxError",
                  [jqXHR, s2, isSuccess ? success : error2]
                );
              }
              completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
              if (fireGlobals) {
                globalEventContext.trigger("ajaxComplete", [jqXHR, s2]);
                if (!--jQuery6.active) {
                  jQuery6.event.trigger("ajaxStop");
                }
              }
            }
            return jqXHR;
          },
          getJSON: function(url, data, callback) {
            return jQuery6.get(url, data, callback, "json");
          },
          getScript: function(url, callback) {
            return jQuery6.get(url, void 0, callback, "script");
          }
        });
        jQuery6.each(["get", "post"], function(_i, method) {
          jQuery6[method] = function(url, data, callback, type) {
            if (isFunction(data)) {
              type = type || callback;
              callback = data;
              data = void 0;
            }
            return jQuery6.ajax(jQuery6.extend({
              url,
              type: method,
              dataType: type,
              data,
              success: callback
            }, jQuery6.isPlainObject(url) && url));
          };
        });
        jQuery6.ajaxPrefilter(function(s2) {
          var i2;
          for (i2 in s2.headers) {
            if (i2.toLowerCase() === "content-type") {
              s2.contentType = s2.headers[i2] || "";
            }
          }
        });
        jQuery6._evalUrl = function(url, options, doc) {
          return jQuery6.ajax({
            url,
            // Make this explicit, since user can override this through ajaxSetup (trac-11264)
            type: "GET",
            dataType: "script",
            cache: true,
            async: false,
            global: false,
            // Only evaluate the response if it is successful (gh-4126)
            // dataFilter is not invoked for failure responses, so using it instead
            // of the default converter is kludgy but it works.
            converters: {
              "text script": function() {
              }
            },
            dataFilter: function(response) {
              jQuery6.globalEval(response, options, doc);
            }
          });
        };
        jQuery6.fn.extend({
          wrapAll: function(html) {
            var wrap;
            if (this[0]) {
              if (isFunction(html)) {
                html = html.call(this[0]);
              }
              wrap = jQuery6(html, this[0].ownerDocument).eq(0).clone(true);
              if (this[0].parentNode) {
                wrap.insertBefore(this[0]);
              }
              wrap.map(function() {
                var elem = this;
                while (elem.firstElementChild) {
                  elem = elem.firstElementChild;
                }
                return elem;
              }).append(this);
            }
            return this;
          },
          wrapInner: function(html) {
            if (isFunction(html)) {
              return this.each(function(i2) {
                jQuery6(this).wrapInner(html.call(this, i2));
              });
            }
            return this.each(function() {
              var self2 = jQuery6(this), contents = self2.contents();
              if (contents.length) {
                contents.wrapAll(html);
              } else {
                self2.append(html);
              }
            });
          },
          wrap: function(html) {
            var htmlIsFunction = isFunction(html);
            return this.each(function(i2) {
              jQuery6(this).wrapAll(htmlIsFunction ? html.call(this, i2) : html);
            });
          },
          unwrap: function(selector) {
            this.parent(selector).not("body").each(function() {
              jQuery6(this).replaceWith(this.childNodes);
            });
            return this;
          }
        });
        jQuery6.expr.pseudos.hidden = function(elem) {
          return !jQuery6.expr.pseudos.visible(elem);
        };
        jQuery6.expr.pseudos.visible = function(elem) {
          return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
        };
        jQuery6.ajaxSettings.xhr = function() {
          try {
            return new window2.XMLHttpRequest();
          } catch (e2) {
          }
        };
        var xhrSuccessStatus = {
          // File protocol always yields status code 0, assume 200
          0: 200,
          // Support: IE <=9 only
          // trac-1450: sometimes IE returns 1223 when it should be 204
          1223: 204
        }, xhrSupported = jQuery6.ajaxSettings.xhr();
        support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
        support.ajax = xhrSupported = !!xhrSupported;
        jQuery6.ajaxTransport(function(options) {
          var callback, errorCallback;
          if (support.cors || xhrSupported && !options.crossDomain) {
            return {
              send: function(headers, complete) {
                var i2, xhr = options.xhr();
                xhr.open(
                  options.type,
                  options.url,
                  options.async,
                  options.username,
                  options.password
                );
                if (options.xhrFields) {
                  for (i2 in options.xhrFields) {
                    xhr[i2] = options.xhrFields[i2];
                  }
                }
                if (options.mimeType && xhr.overrideMimeType) {
                  xhr.overrideMimeType(options.mimeType);
                }
                if (!options.crossDomain && !headers["X-Requested-With"]) {
                  headers["X-Requested-With"] = "XMLHttpRequest";
                }
                for (i2 in headers) {
                  xhr.setRequestHeader(i2, headers[i2]);
                }
                callback = function(type) {
                  return function() {
                    if (callback) {
                      callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                      if (type === "abort") {
                        xhr.abort();
                      } else if (type === "error") {
                        if (typeof xhr.status !== "number") {
                          complete(0, "error");
                        } else {
                          complete(
                            // File: protocol always yields status 0; see trac-8605, trac-14207
                            xhr.status,
                            xhr.statusText
                          );
                        }
                      } else {
                        complete(
                          xhrSuccessStatus[xhr.status] || xhr.status,
                          xhr.statusText,
                          // Support: IE <=9 only
                          // IE9 has no XHR2 but throws on binary (trac-11426)
                          // For XHR2 non-text, let the caller handle it (gh-2498)
                          (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                          xhr.getAllResponseHeaders()
                        );
                      }
                    }
                  };
                };
                xhr.onload = callback();
                errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
                if (xhr.onabort !== void 0) {
                  xhr.onabort = errorCallback;
                } else {
                  xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                      window2.setTimeout(function() {
                        if (callback) {
                          errorCallback();
                        }
                      });
                    }
                  };
                }
                callback = callback("abort");
                try {
                  xhr.send(options.hasContent && options.data || null);
                } catch (e2) {
                  if (callback) {
                    throw e2;
                  }
                }
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        jQuery6.ajaxPrefilter(function(s2) {
          if (s2.crossDomain) {
            s2.contents.script = false;
          }
        });
        jQuery6.ajaxSetup({
          accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
          },
          contents: {
            script: /\b(?:java|ecma)script\b/
          },
          converters: {
            "text script": function(text) {
              jQuery6.globalEval(text);
              return text;
            }
          }
        });
        jQuery6.ajaxPrefilter("script", function(s2) {
          if (s2.cache === void 0) {
            s2.cache = false;
          }
          if (s2.crossDomain) {
            s2.type = "GET";
          }
        });
        jQuery6.ajaxTransport("script", function(s2) {
          if (s2.crossDomain || s2.scriptAttrs) {
            var script, callback;
            return {
              send: function(_2, complete) {
                script = jQuery6("<script>").attr(s2.scriptAttrs || {}).prop({ charset: s2.scriptCharset, src: s2.url }).on("load error", callback = function(evt) {
                  script.remove();
                  callback = null;
                  if (evt) {
                    complete(evt.type === "error" ? 404 : 200, evt.type);
                  }
                });
                document2.head.appendChild(script[0]);
              },
              abort: function() {
                if (callback) {
                  callback();
                }
              }
            };
          }
        });
        var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
        jQuery6.ajaxSetup({
          jsonp: "callback",
          jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery6.expando + "_" + nonce.guid++;
            this[callback] = true;
            return callback;
          }
        });
        jQuery6.ajaxPrefilter("json jsonp", function(s2, originalSettings, jqXHR) {
          var callbackName, overwritten, responseContainer, jsonProp = s2.jsonp !== false && (rjsonp.test(s2.url) ? "url" : typeof s2.data === "string" && (s2.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s2.data) && "data");
          if (jsonProp || s2.dataTypes[0] === "jsonp") {
            callbackName = s2.jsonpCallback = isFunction(s2.jsonpCallback) ? s2.jsonpCallback() : s2.jsonpCallback;
            if (jsonProp) {
              s2[jsonProp] = s2[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s2.jsonp !== false) {
              s2.url += (rquery.test(s2.url) ? "&" : "?") + s2.jsonp + "=" + callbackName;
            }
            s2.converters["script json"] = function() {
              if (!responseContainer) {
                jQuery6.error(callbackName + " was not called");
              }
              return responseContainer[0];
            };
            s2.dataTypes[0] = "json";
            overwritten = window2[callbackName];
            window2[callbackName] = function() {
              responseContainer = arguments;
            };
            jqXHR.always(function() {
              if (overwritten === void 0) {
                jQuery6(window2).removeProp(callbackName);
              } else {
                window2[callbackName] = overwritten;
              }
              if (s2[callbackName]) {
                s2.jsonpCallback = originalSettings.jsonpCallback;
                oldCallbacks.push(callbackName);
              }
              if (responseContainer && isFunction(overwritten)) {
                overwritten(responseContainer[0]);
              }
              responseContainer = overwritten = void 0;
            });
            return "script";
          }
        });
        support.createHTMLDocument = function() {
          var body = document2.implementation.createHTMLDocument("").body;
          body.innerHTML = "<form></form><form></form>";
          return body.childNodes.length === 2;
        }();
        jQuery6.parseHTML = function(data, context, keepScripts) {
          if (typeof data !== "string") {
            return [];
          }
          if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
          }
          var base, parsed, scripts;
          if (!context) {
            if (support.createHTMLDocument) {
              context = document2.implementation.createHTMLDocument("");
              base = context.createElement("base");
              base.href = document2.location.href;
              context.head.appendChild(base);
            } else {
              context = document2;
            }
          }
          parsed = rsingleTag.exec(data);
          scripts = !keepScripts && [];
          if (parsed) {
            return [context.createElement(parsed[1])];
          }
          parsed = buildFragment([data], context, scripts);
          if (scripts && scripts.length) {
            jQuery6(scripts).remove();
          }
          return jQuery6.merge([], parsed.childNodes);
        };
        jQuery6.fn.load = function(url, params, callback) {
          var selector, type, response, self2 = this, off = url.indexOf(" ");
          if (off > -1) {
            selector = stripAndCollapse(url.slice(off));
            url = url.slice(0, off);
          }
          if (isFunction(params)) {
            callback = params;
            params = void 0;
          } else if (params && typeof params === "object") {
            type = "POST";
          }
          if (self2.length > 0) {
            jQuery6.ajax({
              url,
              // If "type" variable is undefined, then "GET" method will be used.
              // Make value of this field explicit since
              // user can override it through ajaxSetup method
              type: type || "GET",
              dataType: "html",
              data: params
            }).done(function(responseText) {
              response = arguments;
              self2.html(selector ? (
                // If a selector was specified, locate the right elements in a dummy div
                // Exclude scripts to avoid IE 'Permission Denied' errors
                jQuery6("<div>").append(jQuery6.parseHTML(responseText)).find(selector)
              ) : (
                // Otherwise use the full result
                responseText
              ));
            }).always(callback && function(jqXHR, status) {
              self2.each(function() {
                callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
              });
            });
          }
          return this;
        };
        jQuery6.expr.pseudos.animated = function(elem) {
          return jQuery6.grep(jQuery6.timers, function(fn2) {
            return elem === fn2.elem;
          }).length;
        };
        jQuery6.offset = {
          setOffset: function(elem, options, i2) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery6.css(elem, "position"), curElem = jQuery6(elem), props = {};
            if (position === "static") {
              elem.style.position = "relative";
            }
            curOffset = curElem.offset();
            curCSSTop = jQuery6.css(elem, "top");
            curCSSLeft = jQuery6.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
            if (calculatePosition) {
              curPosition = curElem.position();
              curTop = curPosition.top;
              curLeft = curPosition.left;
            } else {
              curTop = parseFloat(curCSSTop) || 0;
              curLeft = parseFloat(curCSSLeft) || 0;
            }
            if (isFunction(options)) {
              options = options.call(elem, i2, jQuery6.extend({}, curOffset));
            }
            if (options.top != null) {
              props.top = options.top - curOffset.top + curTop;
            }
            if (options.left != null) {
              props.left = options.left - curOffset.left + curLeft;
            }
            if ("using" in options) {
              options.using.call(elem, props);
            } else {
              curElem.css(props);
            }
          }
        };
        jQuery6.fn.extend({
          // offset() relates an element's border box to the document origin
          offset: function(options) {
            if (arguments.length) {
              return options === void 0 ? this : this.each(function(i2) {
                jQuery6.offset.setOffset(this, options, i2);
              });
            }
            var rect, win, elem = this[0];
            if (!elem) {
              return;
            }
            if (!elem.getClientRects().length) {
              return { top: 0, left: 0 };
            }
            rect = elem.getBoundingClientRect();
            win = elem.ownerDocument.defaultView;
            return {
              top: rect.top + win.pageYOffset,
              left: rect.left + win.pageXOffset
            };
          },
          // position() relates an element's margin box to its offset parent's padding box
          // This corresponds to the behavior of CSS absolute positioning
          position: function() {
            if (!this[0]) {
              return;
            }
            var offsetParent, offset2, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
            if (jQuery6.css(elem, "position") === "fixed") {
              offset2 = elem.getBoundingClientRect();
            } else {
              offset2 = this.offset();
              doc = elem.ownerDocument;
              offsetParent = elem.offsetParent || doc.documentElement;
              while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery6.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.parentNode;
              }
              if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
                parentOffset = jQuery6(offsetParent).offset();
                parentOffset.top += jQuery6.css(offsetParent, "borderTopWidth", true);
                parentOffset.left += jQuery6.css(offsetParent, "borderLeftWidth", true);
              }
            }
            return {
              top: offset2.top - parentOffset.top - jQuery6.css(elem, "marginTop", true),
              left: offset2.left - parentOffset.left - jQuery6.css(elem, "marginLeft", true)
            };
          },
          // This method will return documentElement in the following cases:
          // 1) For the element inside the iframe without offsetParent, this method will return
          //    documentElement of the parent window
          // 2) For the hidden or detached element
          // 3) For body or html element, i.e. in case of the html node - it will return itself
          //
          // but those exceptions were never presented as a real life use-cases
          // and might be considered as more preferable results.
          //
          // This logic, however, is not guaranteed and can change at any point in the future
          offsetParent: function() {
            return this.map(function() {
              var offsetParent = this.offsetParent;
              while (offsetParent && jQuery6.css(offsetParent, "position") === "static") {
                offsetParent = offsetParent.offsetParent;
              }
              return offsetParent || documentElement;
            });
          }
        });
        jQuery6.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
          var top2 = "pageYOffset" === prop;
          jQuery6.fn[method] = function(val) {
            return access(this, function(elem, method2, val2) {
              var win;
              if (isWindow(elem)) {
                win = elem;
              } else if (elem.nodeType === 9) {
                win = elem.defaultView;
              }
              if (val2 === void 0) {
                return win ? win[prop] : elem[method2];
              }
              if (win) {
                win.scrollTo(
                  !top2 ? val2 : win.pageXOffset,
                  top2 ? val2 : win.pageYOffset
                );
              } else {
                elem[method2] = val2;
              }
            }, method, val, arguments.length);
          };
        });
        jQuery6.each(["top", "left"], function(_i, prop) {
          jQuery6.cssHooks[prop] = addGetHookIf(
            support.pixelPosition,
            function(elem, computed) {
              if (computed) {
                computed = curCSS(elem, prop);
                return rnumnonpx.test(computed) ? jQuery6(elem).position()[prop] + "px" : computed;
              }
            }
          );
        });
        jQuery6.each({ Height: "height", Width: "width" }, function(name, type) {
          jQuery6.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
          }, function(defaultExtra, funcName) {
            jQuery6.fn[funcName] = function(margin, value) {
              var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
              return access(this, function(elem, type2, value2) {
                var doc;
                if (isWindow(elem)) {
                  return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
                }
                if (elem.nodeType === 9) {
                  doc = elem.documentElement;
                  return Math.max(
                    elem.body["scroll" + name],
                    doc["scroll" + name],
                    elem.body["offset" + name],
                    doc["offset" + name],
                    doc["client" + name]
                  );
                }
                return value2 === void 0 ? (
                  // Get width or height on the element, requesting but not forcing parseFloat
                  jQuery6.css(elem, type2, extra)
                ) : (
                  // Set width or height on the element
                  jQuery6.style(elem, type2, value2, extra)
                );
              }, type, chainable ? margin : void 0, chainable);
            };
          });
        });
        jQuery6.each([
          "ajaxStart",
          "ajaxStop",
          "ajaxComplete",
          "ajaxError",
          "ajaxSuccess",
          "ajaxSend"
        ], function(_i, type) {
          jQuery6.fn[type] = function(fn2) {
            return this.on(type, fn2);
          };
        });
        jQuery6.fn.extend({
          bind: function(types, data, fn2) {
            return this.on(types, null, data, fn2);
          },
          unbind: function(types, fn2) {
            return this.off(types, null, fn2);
          },
          delegate: function(selector, types, data, fn2) {
            return this.on(types, selector, data, fn2);
          },
          undelegate: function(selector, types, fn2) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn2);
          },
          hover: function(fnOver, fnOut) {
            return this.on("mouseenter", fnOver).on("mouseleave", fnOut || fnOver);
          }
        });
        jQuery6.each(
          "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
          function(_i, name) {
            jQuery6.fn[name] = function(data, fn2) {
              return arguments.length > 0 ? this.on(name, null, data, fn2) : this.trigger(name);
            };
          }
        );
        var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
        jQuery6.proxy = function(fn2, context) {
          var tmp, args, proxy;
          if (typeof context === "string") {
            tmp = fn2[context];
            context = fn2;
            fn2 = tmp;
          }
          if (!isFunction(fn2)) {
            return void 0;
          }
          args = slice.call(arguments, 2);
          proxy = function() {
            return fn2.apply(context || this, args.concat(slice.call(arguments)));
          };
          proxy.guid = fn2.guid = fn2.guid || jQuery6.guid++;
          return proxy;
        };
        jQuery6.holdReady = function(hold) {
          if (hold) {
            jQuery6.readyWait++;
          } else {
            jQuery6.ready(true);
          }
        };
        jQuery6.isArray = Array.isArray;
        jQuery6.parseJSON = JSON.parse;
        jQuery6.nodeName = nodeName;
        jQuery6.isFunction = isFunction;
        jQuery6.isWindow = isWindow;
        jQuery6.camelCase = camelCase;
        jQuery6.type = toType2;
        jQuery6.now = Date.now;
        jQuery6.isNumeric = function(obj) {
          var type = jQuery6.type(obj);
          return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
          // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
          // subtraction forces infinities to NaN
          !isNaN(obj - parseFloat(obj));
        };
        jQuery6.trim = function(text) {
          return text == null ? "" : (text + "").replace(rtrim, "$1");
        };
        if (typeof define === "function" && define.amd) {
          define("jquery", [], function() {
            return jQuery6;
          });
        }
        var _jQuery = window2.jQuery, _$ = window2.$;
        jQuery6.noConflict = function(deep) {
          if (window2.$ === jQuery6) {
            window2.$ = _$;
          }
          if (deep && window2.jQuery === jQuery6) {
            window2.jQuery = _jQuery;
          }
          return jQuery6;
        };
        if (typeof noGlobal === "undefined") {
          window2.jQuery = window2.$ = jQuery6;
        }
        return jQuery6;
      });
    }
  });

  // node_modules/select2/dist/js/select2.js
  var require_select2 = __commonJS({
    "node_modules/select2/dist/js/select2.js"(exports, module) {
      (function(factory) {
        if (typeof define === "function" && define.amd) {
          define(["jquery"], factory);
        } else if (typeof module === "object" && module.exports) {
          module.exports = function(root, jQuery6) {
            if (jQuery6 === void 0) {
              if (typeof window !== "undefined") {
                jQuery6 = require_jquery();
              } else {
                jQuery6 = require_jquery()(root);
              }
            }
            factory(jQuery6);
            return jQuery6;
          };
        } else {
          factory(jQuery);
        }
      })(function(jQuery6) {
        var S2 = function() {
          if (jQuery6 && jQuery6.fn && jQuery6.fn.select2 && jQuery6.fn.select2.amd) {
            var S22 = jQuery6.fn.select2.amd;
          }
          var S22;
          (function() {
            if (!S22 || !S22.requirejs) {
              if (!S22) {
                S22 = {};
              } else {
                require2 = S22;
              }
              var requirejs, require2, define2;
              (function(undef) {
                var main2, req, makeMap, handlers, defined = {}, waiting = {}, config = {}, defining = {}, hasOwn = Object.prototype.hasOwnProperty, aps = [].slice, jsSuffixRegExp = /\.js$/;
                function hasProp(obj, prop) {
                  return hasOwn.call(obj, prop);
                }
                function normalize(name, baseName) {
                  var nameParts, nameSegment, mapValue, foundMap, lastIndex, foundI, foundStarMap, starI, i2, j2, part, normalizedBaseParts, baseParts = baseName && baseName.split("/"), map = config.map, starMap = map && map["*"] || {};
                  if (name) {
                    name = name.split("/");
                    lastIndex = name.length - 1;
                    if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                      name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, "");
                    }
                    if (name[0].charAt(0) === "." && baseParts) {
                      normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                      name = normalizedBaseParts.concat(name);
                    }
                    for (i2 = 0; i2 < name.length; i2++) {
                      part = name[i2];
                      if (part === ".") {
                        name.splice(i2, 1);
                        i2 -= 1;
                      } else if (part === "..") {
                        if (i2 === 0 || i2 === 1 && name[2] === ".." || name[i2 - 1] === "..") {
                          continue;
                        } else if (i2 > 0) {
                          name.splice(i2 - 1, 2);
                          i2 -= 2;
                        }
                      }
                    }
                    name = name.join("/");
                  }
                  if ((baseParts || starMap) && map) {
                    nameParts = name.split("/");
                    for (i2 = nameParts.length; i2 > 0; i2 -= 1) {
                      nameSegment = nameParts.slice(0, i2).join("/");
                      if (baseParts) {
                        for (j2 = baseParts.length; j2 > 0; j2 -= 1) {
                          mapValue = map[baseParts.slice(0, j2).join("/")];
                          if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                              foundMap = mapValue;
                              foundI = i2;
                              break;
                            }
                          }
                        }
                      }
                      if (foundMap) {
                        break;
                      }
                      if (!foundStarMap && starMap && starMap[nameSegment]) {
                        foundStarMap = starMap[nameSegment];
                        starI = i2;
                      }
                    }
                    if (!foundMap && foundStarMap) {
                      foundMap = foundStarMap;
                      foundI = starI;
                    }
                    if (foundMap) {
                      nameParts.splice(0, foundI, foundMap);
                      name = nameParts.join("/");
                    }
                  }
                  return name;
                }
                function makeRequire(relName, forceSync) {
                  return function() {
                    var args = aps.call(arguments, 0);
                    if (typeof args[0] !== "string" && args.length === 1) {
                      args.push(null);
                    }
                    return req.apply(undef, args.concat([relName, forceSync]));
                  };
                }
                function makeNormalize(relName) {
                  return function(name) {
                    return normalize(name, relName);
                  };
                }
                function makeLoad(depName) {
                  return function(value) {
                    defined[depName] = value;
                  };
                }
                function callDep(name) {
                  if (hasProp(waiting, name)) {
                    var args = waiting[name];
                    delete waiting[name];
                    defining[name] = true;
                    main2.apply(undef, args);
                  }
                  if (!hasProp(defined, name) && !hasProp(defining, name)) {
                    throw new Error("No " + name);
                  }
                  return defined[name];
                }
                function splitPrefix(name) {
                  var prefix, index = name ? name.indexOf("!") : -1;
                  if (index > -1) {
                    prefix = name.substring(0, index);
                    name = name.substring(index + 1, name.length);
                  }
                  return [prefix, name];
                }
                function makeRelParts(relName) {
                  return relName ? splitPrefix(relName) : [];
                }
                makeMap = function(name, relParts) {
                  var plugin, parts = splitPrefix(name), prefix = parts[0], relResourceName = relParts[1];
                  name = parts[1];
                  if (prefix) {
                    prefix = normalize(prefix, relResourceName);
                    plugin = callDep(prefix);
                  }
                  if (prefix) {
                    if (plugin && plugin.normalize) {
                      name = plugin.normalize(name, makeNormalize(relResourceName));
                    } else {
                      name = normalize(name, relResourceName);
                    }
                  } else {
                    name = normalize(name, relResourceName);
                    parts = splitPrefix(name);
                    prefix = parts[0];
                    name = parts[1];
                    if (prefix) {
                      plugin = callDep(prefix);
                    }
                  }
                  return {
                    f: prefix ? prefix + "!" + name : name,
                    //fullName
                    n: name,
                    pr: prefix,
                    p: plugin
                  };
                };
                function makeConfig(name) {
                  return function() {
                    return config && config.config && config.config[name] || {};
                  };
                }
                handlers = {
                  require: function(name) {
                    return makeRequire(name);
                  },
                  exports: function(name) {
                    var e2 = defined[name];
                    if (typeof e2 !== "undefined") {
                      return e2;
                    } else {
                      return defined[name] = {};
                    }
                  },
                  module: function(name) {
                    return {
                      id: name,
                      uri: "",
                      exports: defined[name],
                      config: makeConfig(name)
                    };
                  }
                };
                main2 = function(name, deps, callback, relName) {
                  var cjsModule, depName, ret, map, i2, relParts, args = [], callbackType = typeof callback, usingExports;
                  relName = relName || name;
                  relParts = makeRelParts(relName);
                  if (callbackType === "undefined" || callbackType === "function") {
                    deps = !deps.length && callback.length ? ["require", "exports", "module"] : deps;
                    for (i2 = 0; i2 < deps.length; i2 += 1) {
                      map = makeMap(deps[i2], relParts);
                      depName = map.f;
                      if (depName === "require") {
                        args[i2] = handlers.require(name);
                      } else if (depName === "exports") {
                        args[i2] = handlers.exports(name);
                        usingExports = true;
                      } else if (depName === "module") {
                        cjsModule = args[i2] = handlers.module(name);
                      } else if (hasProp(defined, depName) || hasProp(waiting, depName) || hasProp(defining, depName)) {
                        args[i2] = callDep(depName);
                      } else if (map.p) {
                        map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                        args[i2] = defined[depName];
                      } else {
                        throw new Error(name + " missing " + depName);
                      }
                    }
                    ret = callback ? callback.apply(defined[name], args) : void 0;
                    if (name) {
                      if (cjsModule && cjsModule.exports !== undef && cjsModule.exports !== defined[name]) {
                        defined[name] = cjsModule.exports;
                      } else if (ret !== undef || !usingExports) {
                        defined[name] = ret;
                      }
                    }
                  } else if (name) {
                    defined[name] = callback;
                  }
                };
                requirejs = require2 = req = function(deps, callback, relName, forceSync, alt) {
                  if (typeof deps === "string") {
                    if (handlers[deps]) {
                      return handlers[deps](callback);
                    }
                    return callDep(makeMap(deps, makeRelParts(callback)).f);
                  } else if (!deps.splice) {
                    config = deps;
                    if (config.deps) {
                      req(config.deps, config.callback);
                    }
                    if (!callback) {
                      return;
                    }
                    if (callback.splice) {
                      deps = callback;
                      callback = relName;
                      relName = null;
                    } else {
                      deps = undef;
                    }
                  }
                  callback = callback || function() {
                  };
                  if (typeof relName === "function") {
                    relName = forceSync;
                    forceSync = alt;
                  }
                  if (forceSync) {
                    main2(undef, deps, callback, relName);
                  } else {
                    setTimeout(function() {
                      main2(undef, deps, callback, relName);
                    }, 4);
                  }
                  return req;
                };
                req.config = function(cfg) {
                  return req(cfg);
                };
                requirejs._defined = defined;
                define2 = function(name, deps, callback) {
                  if (typeof name !== "string") {
                    throw new Error("See almond README: incorrect module build, no module name");
                  }
                  if (!deps.splice) {
                    callback = deps;
                    deps = [];
                  }
                  if (!hasProp(defined, name) && !hasProp(waiting, name)) {
                    waiting[name] = [name, deps, callback];
                  }
                };
                define2.amd = {
                  jQuery: true
                };
              })();
              S22.requirejs = requirejs;
              S22.require = require2;
              S22.define = define2;
            }
          })();
          S22.define("almond", function() {
          });
          S22.define("jquery", [], function() {
            var _$ = jQuery6 || $;
            if (_$ == null && console && console.error) {
              console.error(
                "Select2: An instance of jQuery or a jQuery-compatible library was not found. Make sure that you are including jQuery before Select2 on your web page."
              );
            }
            return _$;
          });
          S22.define("select2/utils", [
            "jquery"
          ], function($8) {
            var Utils = {};
            Utils.Extend = function(ChildClass, SuperClass) {
              var __hasProp = {}.hasOwnProperty;
              function BaseConstructor() {
                this.constructor = ChildClass;
              }
              for (var key in SuperClass) {
                if (__hasProp.call(SuperClass, key)) {
                  ChildClass[key] = SuperClass[key];
                }
              }
              BaseConstructor.prototype = SuperClass.prototype;
              ChildClass.prototype = new BaseConstructor();
              ChildClass.__super__ = SuperClass.prototype;
              return ChildClass;
            };
            function getMethods(theClass) {
              var proto = theClass.prototype;
              var methods = [];
              for (var methodName in proto) {
                var m2 = proto[methodName];
                if (typeof m2 !== "function") {
                  continue;
                }
                if (methodName === "constructor") {
                  continue;
                }
                methods.push(methodName);
              }
              return methods;
            }
            Utils.Decorate = function(SuperClass, DecoratorClass) {
              var decoratedMethods = getMethods(DecoratorClass);
              var superMethods = getMethods(SuperClass);
              function DecoratedClass() {
                var unshift = Array.prototype.unshift;
                var argCount = DecoratorClass.prototype.constructor.length;
                var calledConstructor = SuperClass.prototype.constructor;
                if (argCount > 0) {
                  unshift.call(arguments, SuperClass.prototype.constructor);
                  calledConstructor = DecoratorClass.prototype.constructor;
                }
                calledConstructor.apply(this, arguments);
              }
              DecoratorClass.displayName = SuperClass.displayName;
              function ctr() {
                this.constructor = DecoratedClass;
              }
              DecoratedClass.prototype = new ctr();
              for (var m2 = 0; m2 < superMethods.length; m2++) {
                var superMethod = superMethods[m2];
                DecoratedClass.prototype[superMethod] = SuperClass.prototype[superMethod];
              }
              var calledMethod = function(methodName) {
                var originalMethod = function() {
                };
                if (methodName in DecoratedClass.prototype) {
                  originalMethod = DecoratedClass.prototype[methodName];
                }
                var decoratedMethod2 = DecoratorClass.prototype[methodName];
                return function() {
                  var unshift = Array.prototype.unshift;
                  unshift.call(arguments, originalMethod);
                  return decoratedMethod2.apply(this, arguments);
                };
              };
              for (var d2 = 0; d2 < decoratedMethods.length; d2++) {
                var decoratedMethod = decoratedMethods[d2];
                DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
              }
              return DecoratedClass;
            };
            var Observable = function() {
              this.listeners = {};
            };
            Observable.prototype.on = function(event, callback) {
              this.listeners = this.listeners || {};
              if (event in this.listeners) {
                this.listeners[event].push(callback);
              } else {
                this.listeners[event] = [callback];
              }
            };
            Observable.prototype.trigger = function(event) {
              var slice = Array.prototype.slice;
              var params = slice.call(arguments, 1);
              this.listeners = this.listeners || {};
              if (params == null) {
                params = [];
              }
              if (params.length === 0) {
                params.push({});
              }
              params[0]._type = event;
              if (event in this.listeners) {
                this.invoke(this.listeners[event], slice.call(arguments, 1));
              }
              if ("*" in this.listeners) {
                this.invoke(this.listeners["*"], arguments);
              }
            };
            Observable.prototype.invoke = function(listeners, params) {
              for (var i2 = 0, len = listeners.length; i2 < len; i2++) {
                listeners[i2].apply(this, params);
              }
            };
            Utils.Observable = Observable;
            Utils.generateChars = function(length) {
              var chars = "";
              for (var i2 = 0; i2 < length; i2++) {
                var randomChar = Math.floor(Math.random() * 36);
                chars += randomChar.toString(36);
              }
              return chars;
            };
            Utils.bind = function(func, context) {
              return function() {
                func.apply(context, arguments);
              };
            };
            Utils._convertData = function(data) {
              for (var originalKey in data) {
                var keys = originalKey.split("-");
                var dataLevel = data;
                if (keys.length === 1) {
                  continue;
                }
                for (var k2 = 0; k2 < keys.length; k2++) {
                  var key = keys[k2];
                  key = key.substring(0, 1).toLowerCase() + key.substring(1);
                  if (!(key in dataLevel)) {
                    dataLevel[key] = {};
                  }
                  if (k2 == keys.length - 1) {
                    dataLevel[key] = data[originalKey];
                  }
                  dataLevel = dataLevel[key];
                }
                delete data[originalKey];
              }
              return data;
            };
            Utils.hasScroll = function(index, el) {
              var $el = $8(el);
              var overflowX = el.style.overflowX;
              var overflowY = el.style.overflowY;
              if (overflowX === overflowY && (overflowY === "hidden" || overflowY === "visible")) {
                return false;
              }
              if (overflowX === "scroll" || overflowY === "scroll") {
                return true;
              }
              return $el.innerHeight() < el.scrollHeight || $el.innerWidth() < el.scrollWidth;
            };
            Utils.escapeMarkup = function(markup) {
              var replaceMap = {
                "\\": "&#92;",
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;",
                "/": "&#47;"
              };
              if (typeof markup !== "string") {
                return markup;
              }
              return String(markup).replace(/[&<>"'\/\\]/g, function(match) {
                return replaceMap[match];
              });
            };
            Utils.__cache = {};
            var id = 0;
            Utils.GetUniqueElementId = function(element) {
              var select2Id = element.getAttribute("data-select2-id");
              if (select2Id != null) {
                return select2Id;
              }
              if (element.id) {
                select2Id = "select2-data-" + element.id;
              } else {
                select2Id = "select2-data-" + (++id).toString() + "-" + Utils.generateChars(4);
              }
              element.setAttribute("data-select2-id", select2Id);
              return select2Id;
            };
            Utils.StoreData = function(element, name, value) {
              var id2 = Utils.GetUniqueElementId(element);
              if (!Utils.__cache[id2]) {
                Utils.__cache[id2] = {};
              }
              Utils.__cache[id2][name] = value;
            };
            Utils.GetData = function(element, name) {
              var id2 = Utils.GetUniqueElementId(element);
              if (name) {
                if (Utils.__cache[id2]) {
                  if (Utils.__cache[id2][name] != null) {
                    return Utils.__cache[id2][name];
                  }
                  return $8(element).data(name);
                }
                return $8(element).data(name);
              } else {
                return Utils.__cache[id2];
              }
            };
            Utils.RemoveData = function(element) {
              var id2 = Utils.GetUniqueElementId(element);
              if (Utils.__cache[id2] != null) {
                delete Utils.__cache[id2];
              }
              element.removeAttribute("data-select2-id");
            };
            Utils.copyNonInternalCssClasses = function(dest, src) {
              var classes;
              var destinationClasses = dest.getAttribute("class").trim().split(/\s+/);
              destinationClasses = destinationClasses.filter(function(clazz) {
                return clazz.indexOf("select2-") === 0;
              });
              var sourceClasses = src.getAttribute("class").trim().split(/\s+/);
              sourceClasses = sourceClasses.filter(function(clazz) {
                return clazz.indexOf("select2-") !== 0;
              });
              var replacements = destinationClasses.concat(sourceClasses);
              dest.setAttribute("class", replacements.join(" "));
            };
            return Utils;
          });
          S22.define("select2/results", [
            "jquery",
            "./utils"
          ], function($8, Utils) {
            function Results($element, options, dataAdapter) {
              this.$element = $element;
              this.data = dataAdapter;
              this.options = options;
              Results.__super__.constructor.call(this);
            }
            Utils.Extend(Results, Utils.Observable);
            Results.prototype.render = function() {
              var $results = $8(
                '<ul class="select2-results__options" role="listbox"></ul>'
              );
              if (this.options.get("multiple")) {
                $results.attr("aria-multiselectable", "true");
              }
              this.$results = $results;
              return $results;
            };
            Results.prototype.clear = function() {
              this.$results.empty();
            };
            Results.prototype.displayMessage = function(params) {
              var escapeMarkup = this.options.get("escapeMarkup");
              this.clear();
              this.hideLoading();
              var $message = $8(
                '<li role="alert" aria-live="assertive" class="select2-results__option"></li>'
              );
              var message = this.options.get("translations").get(params.message);
              $message.append(
                escapeMarkup(
                  message(params.args)
                )
              );
              $message[0].className += " select2-results__message";
              this.$results.append($message);
            };
            Results.prototype.hideMessages = function() {
              this.$results.find(".select2-results__message").remove();
            };
            Results.prototype.append = function(data) {
              this.hideLoading();
              var $options = [];
              if (data.results == null || data.results.length === 0) {
                if (this.$results.children().length === 0) {
                  this.trigger("results:message", {
                    message: "noResults"
                  });
                }
                return;
              }
              data.results = this.sort(data.results);
              for (var d2 = 0; d2 < data.results.length; d2++) {
                var item = data.results[d2];
                var $option = this.option(item);
                $options.push($option);
              }
              this.$results.append($options);
            };
            Results.prototype.position = function($results, $dropdown) {
              var $resultsContainer = $dropdown.find(".select2-results");
              $resultsContainer.append($results);
            };
            Results.prototype.sort = function(data) {
              var sorter = this.options.get("sorter");
              return sorter(data);
            };
            Results.prototype.highlightFirstItem = function() {
              var $options = this.$results.find(".select2-results__option--selectable");
              var $selected = $options.filter(".select2-results__option--selected");
              if ($selected.length > 0) {
                $selected.first().trigger("mouseenter");
              } else {
                $options.first().trigger("mouseenter");
              }
              this.ensureHighlightVisible();
            };
            Results.prototype.setClasses = function() {
              var self2 = this;
              this.data.current(function(selected) {
                var selectedIds = selected.map(function(s2) {
                  return s2.id.toString();
                });
                var $options = self2.$results.find(".select2-results__option--selectable");
                $options.each(function() {
                  var $option = $8(this);
                  var item = Utils.GetData(this, "data");
                  var id = "" + item.id;
                  if (item.element != null && item.element.selected || item.element == null && selectedIds.indexOf(id) > -1) {
                    this.classList.add("select2-results__option--selected");
                    $option.attr("aria-selected", "true");
                  } else {
                    this.classList.remove("select2-results__option--selected");
                    $option.attr("aria-selected", "false");
                  }
                });
              });
            };
            Results.prototype.showLoading = function(params) {
              this.hideLoading();
              var loadingMore = this.options.get("translations").get("searching");
              var loading = {
                disabled: true,
                loading: true,
                text: loadingMore(params)
              };
              var $loading = this.option(loading);
              $loading.className += " loading-results";
              this.$results.prepend($loading);
            };
            Results.prototype.hideLoading = function() {
              this.$results.find(".loading-results").remove();
            };
            Results.prototype.option = function(data) {
              var option = document.createElement("li");
              option.classList.add("select2-results__option");
              option.classList.add("select2-results__option--selectable");
              var attrs = {
                "role": "option"
              };
              var matches = window.Element.prototype.matches || window.Element.prototype.msMatchesSelector || window.Element.prototype.webkitMatchesSelector;
              if (data.element != null && matches.call(data.element, ":disabled") || data.element == null && data.disabled) {
                attrs["aria-disabled"] = "true";
                option.classList.remove("select2-results__option--selectable");
                option.classList.add("select2-results__option--disabled");
              }
              if (data.id == null) {
                option.classList.remove("select2-results__option--selectable");
              }
              if (data._resultId != null) {
                option.id = data._resultId;
              }
              if (data.title) {
                option.title = data.title;
              }
              if (data.children) {
                attrs.role = "group";
                attrs["aria-label"] = data.text;
                option.classList.remove("select2-results__option--selectable");
                option.classList.add("select2-results__option--group");
              }
              for (var attr in attrs) {
                var val = attrs[attr];
                option.setAttribute(attr, val);
              }
              if (data.children) {
                var $option = $8(option);
                var label = document.createElement("strong");
                label.className = "select2-results__group";
                this.template(data, label);
                var $children = [];
                for (var c2 = 0; c2 < data.children.length; c2++) {
                  var child = data.children[c2];
                  var $child = this.option(child);
                  $children.push($child);
                }
                var $childrenContainer = $8("<ul></ul>", {
                  "class": "select2-results__options select2-results__options--nested",
                  "role": "none"
                });
                $childrenContainer.append($children);
                $option.append(label);
                $option.append($childrenContainer);
              } else {
                this.template(data, option);
              }
              Utils.StoreData(option, "data", data);
              return option;
            };
            Results.prototype.bind = function(container, $container) {
              var self2 = this;
              var id = container.id + "-results";
              this.$results.attr("id", id);
              container.on("results:all", function(params) {
                self2.clear();
                self2.append(params.data);
                if (container.isOpen()) {
                  self2.setClasses();
                  self2.highlightFirstItem();
                }
              });
              container.on("results:append", function(params) {
                self2.append(params.data);
                if (container.isOpen()) {
                  self2.setClasses();
                }
              });
              container.on("query", function(params) {
                self2.hideMessages();
                self2.showLoading(params);
              });
              container.on("select", function() {
                if (!container.isOpen()) {
                  return;
                }
                self2.setClasses();
                if (self2.options.get("scrollAfterSelect")) {
                  self2.highlightFirstItem();
                }
              });
              container.on("unselect", function() {
                if (!container.isOpen()) {
                  return;
                }
                self2.setClasses();
                if (self2.options.get("scrollAfterSelect")) {
                  self2.highlightFirstItem();
                }
              });
              container.on("open", function() {
                self2.$results.attr("aria-expanded", "true");
                self2.$results.attr("aria-hidden", "false");
                self2.setClasses();
                self2.ensureHighlightVisible();
              });
              container.on("close", function() {
                self2.$results.attr("aria-expanded", "false");
                self2.$results.attr("aria-hidden", "true");
                self2.$results.removeAttr("aria-activedescendant");
              });
              container.on("results:toggle", function() {
                var $highlighted = self2.getHighlightedResults();
                if ($highlighted.length === 0) {
                  return;
                }
                $highlighted.trigger("mouseup");
              });
              container.on("results:select", function() {
                var $highlighted = self2.getHighlightedResults();
                if ($highlighted.length === 0) {
                  return;
                }
                var data = Utils.GetData($highlighted[0], "data");
                if ($highlighted.hasClass("select2-results__option--selected")) {
                  self2.trigger("close", {});
                } else {
                  self2.trigger("select", {
                    data
                  });
                }
              });
              container.on("results:previous", function() {
                var $highlighted = self2.getHighlightedResults();
                var $options = self2.$results.find(".select2-results__option--selectable");
                var currentIndex = $options.index($highlighted);
                if (currentIndex <= 0) {
                  return;
                }
                var nextIndex = currentIndex - 1;
                if ($highlighted.length === 0) {
                  nextIndex = 0;
                }
                var $next = $options.eq(nextIndex);
                $next.trigger("mouseenter");
                var currentOffset = self2.$results.offset().top;
                var nextTop = $next.offset().top;
                var nextOffset = self2.$results.scrollTop() + (nextTop - currentOffset);
                if (nextIndex === 0) {
                  self2.$results.scrollTop(0);
                } else if (nextTop - currentOffset < 0) {
                  self2.$results.scrollTop(nextOffset);
                }
              });
              container.on("results:next", function() {
                var $highlighted = self2.getHighlightedResults();
                var $options = self2.$results.find(".select2-results__option--selectable");
                var currentIndex = $options.index($highlighted);
                var nextIndex = currentIndex + 1;
                if (nextIndex >= $options.length) {
                  return;
                }
                var $next = $options.eq(nextIndex);
                $next.trigger("mouseenter");
                var currentOffset = self2.$results.offset().top + self2.$results.outerHeight(false);
                var nextBottom = $next.offset().top + $next.outerHeight(false);
                var nextOffset = self2.$results.scrollTop() + nextBottom - currentOffset;
                if (nextIndex === 0) {
                  self2.$results.scrollTop(0);
                } else if (nextBottom > currentOffset) {
                  self2.$results.scrollTop(nextOffset);
                }
              });
              container.on("results:focus", function(params) {
                params.element[0].classList.add("select2-results__option--highlighted");
                params.element[0].setAttribute("aria-selected", "true");
              });
              container.on("results:message", function(params) {
                self2.displayMessage(params);
              });
              if ($8.fn.mousewheel) {
                this.$results.on("mousewheel", function(e2) {
                  var top2 = self2.$results.scrollTop();
                  var bottom2 = self2.$results.get(0).scrollHeight - top2 + e2.deltaY;
                  var isAtTop = e2.deltaY > 0 && top2 - e2.deltaY <= 0;
                  var isAtBottom = e2.deltaY < 0 && bottom2 <= self2.$results.height();
                  if (isAtTop) {
                    self2.$results.scrollTop(0);
                    e2.preventDefault();
                    e2.stopPropagation();
                  } else if (isAtBottom) {
                    self2.$results.scrollTop(
                      self2.$results.get(0).scrollHeight - self2.$results.height()
                    );
                    e2.preventDefault();
                    e2.stopPropagation();
                  }
                });
              }
              this.$results.on(
                "mouseup",
                ".select2-results__option--selectable",
                function(evt) {
                  var $this = $8(this);
                  var data = Utils.GetData(this, "data");
                  if ($this.hasClass("select2-results__option--selected")) {
                    if (self2.options.get("multiple")) {
                      self2.trigger("unselect", {
                        originalEvent: evt,
                        data
                      });
                    } else {
                      self2.trigger("close", {});
                    }
                    return;
                  }
                  self2.trigger("select", {
                    originalEvent: evt,
                    data
                  });
                }
              );
              this.$results.on(
                "mouseenter",
                ".select2-results__option--selectable",
                function(evt) {
                  var data = Utils.GetData(this, "data");
                  self2.getHighlightedResults().removeClass("select2-results__option--highlighted").attr("aria-selected", "false");
                  self2.trigger("results:focus", {
                    data,
                    element: $8(this)
                  });
                }
              );
            };
            Results.prototype.getHighlightedResults = function() {
              var $highlighted = this.$results.find(".select2-results__option--highlighted");
              return $highlighted;
            };
            Results.prototype.destroy = function() {
              this.$results.remove();
            };
            Results.prototype.ensureHighlightVisible = function() {
              var $highlighted = this.getHighlightedResults();
              if ($highlighted.length === 0) {
                return;
              }
              var $options = this.$results.find(".select2-results__option--selectable");
              var currentIndex = $options.index($highlighted);
              var currentOffset = this.$results.offset().top;
              var nextTop = $highlighted.offset().top;
              var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);
              var offsetDelta = nextTop - currentOffset;
              nextOffset -= $highlighted.outerHeight(false) * 2;
              if (currentIndex <= 2) {
                this.$results.scrollTop(0);
              } else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
                this.$results.scrollTop(nextOffset);
              }
            };
            Results.prototype.template = function(result, container) {
              var template = this.options.get("templateResult");
              var escapeMarkup = this.options.get("escapeMarkup");
              var content = template(result, container);
              if (content == null) {
                container.style.display = "none";
              } else if (typeof content === "string") {
                container.innerHTML = escapeMarkup(content);
              } else {
                $8(container).append(content);
              }
            };
            return Results;
          });
          S22.define("select2/keys", [], function() {
            var KEYS = {
              BACKSPACE: 8,
              TAB: 9,
              ENTER: 13,
              SHIFT: 16,
              CTRL: 17,
              ALT: 18,
              ESC: 27,
              SPACE: 32,
              PAGE_UP: 33,
              PAGE_DOWN: 34,
              END: 35,
              HOME: 36,
              LEFT: 37,
              UP: 38,
              RIGHT: 39,
              DOWN: 40,
              DELETE: 46
            };
            return KEYS;
          });
          S22.define("select2/selection/base", [
            "jquery",
            "../utils",
            "../keys"
          ], function($8, Utils, KEYS) {
            function BaseSelection($element, options) {
              this.$element = $element;
              this.options = options;
              BaseSelection.__super__.constructor.call(this);
            }
            Utils.Extend(BaseSelection, Utils.Observable);
            BaseSelection.prototype.render = function() {
              var $selection = $8(
                '<span class="select2-selection" role="combobox"  aria-haspopup="true" aria-expanded="false"></span>'
              );
              this._tabindex = 0;
              if (Utils.GetData(this.$element[0], "old-tabindex") != null) {
                this._tabindex = Utils.GetData(this.$element[0], "old-tabindex");
              } else if (this.$element.attr("tabindex") != null) {
                this._tabindex = this.$element.attr("tabindex");
              }
              $selection.attr("title", this.$element.attr("title"));
              $selection.attr("tabindex", this._tabindex);
              $selection.attr("aria-disabled", "false");
              this.$selection = $selection;
              return $selection;
            };
            BaseSelection.prototype.bind = function(container, $container) {
              var self2 = this;
              var resultsId = container.id + "-results";
              this.container = container;
              this.$selection.on("focus", function(evt) {
                self2.trigger("focus", evt);
              });
              this.$selection.on("blur", function(evt) {
                self2._handleBlur(evt);
              });
              this.$selection.on("keydown", function(evt) {
                self2.trigger("keypress", evt);
                if (evt.which === KEYS.SPACE) {
                  evt.preventDefault();
                }
              });
              container.on("results:focus", function(params) {
                self2.$selection.attr("aria-activedescendant", params.data._resultId);
              });
              container.on("selection:update", function(params) {
                self2.update(params.data);
              });
              container.on("open", function() {
                self2.$selection.attr("aria-expanded", "true");
                self2.$selection.attr("aria-owns", resultsId);
                self2._attachCloseHandler(container);
              });
              container.on("close", function() {
                self2.$selection.attr("aria-expanded", "false");
                self2.$selection.removeAttr("aria-activedescendant");
                self2.$selection.removeAttr("aria-owns");
                self2.$selection.trigger("focus");
                self2._detachCloseHandler(container);
              });
              container.on("enable", function() {
                self2.$selection.attr("tabindex", self2._tabindex);
                self2.$selection.attr("aria-disabled", "false");
              });
              container.on("disable", function() {
                self2.$selection.attr("tabindex", "-1");
                self2.$selection.attr("aria-disabled", "true");
              });
            };
            BaseSelection.prototype._handleBlur = function(evt) {
              var self2 = this;
              window.setTimeout(function() {
                if (document.activeElement == self2.$selection[0] || $8.contains(self2.$selection[0], document.activeElement)) {
                  return;
                }
                self2.trigger("blur", evt);
              }, 1);
            };
            BaseSelection.prototype._attachCloseHandler = function(container) {
              $8(document.body).on("mousedown.select2." + container.id, function(e2) {
                var $target = $8(e2.target);
                var $select = $target.closest(".select2");
                var $all = $8(".select2.select2-container--open");
                $all.each(function() {
                  if (this == $select[0]) {
                    return;
                  }
                  var $element = Utils.GetData(this, "element");
                  $element.select2("close");
                });
              });
            };
            BaseSelection.prototype._detachCloseHandler = function(container) {
              $8(document.body).off("mousedown.select2." + container.id);
            };
            BaseSelection.prototype.position = function($selection, $container) {
              var $selectionContainer = $container.find(".selection");
              $selectionContainer.append($selection);
            };
            BaseSelection.prototype.destroy = function() {
              this._detachCloseHandler(this.container);
            };
            BaseSelection.prototype.update = function(data) {
              throw new Error("The `update` method must be defined in child classes.");
            };
            BaseSelection.prototype.isEnabled = function() {
              return !this.isDisabled();
            };
            BaseSelection.prototype.isDisabled = function() {
              return this.options.get("disabled");
            };
            return BaseSelection;
          });
          S22.define("select2/selection/single", [
            "jquery",
            "./base",
            "../utils",
            "../keys"
          ], function($8, BaseSelection, Utils, KEYS) {
            function SingleSelection() {
              SingleSelection.__super__.constructor.apply(this, arguments);
            }
            Utils.Extend(SingleSelection, BaseSelection);
            SingleSelection.prototype.render = function() {
              var $selection = SingleSelection.__super__.render.call(this);
              $selection[0].classList.add("select2-selection--single");
              $selection.html(
                '<span class="select2-selection__rendered"></span><span class="select2-selection__arrow" role="presentation"><b role="presentation"></b></span>'
              );
              return $selection;
            };
            SingleSelection.prototype.bind = function(container, $container) {
              var self2 = this;
              SingleSelection.__super__.bind.apply(this, arguments);
              var id = container.id + "-container";
              this.$selection.find(".select2-selection__rendered").attr("id", id).attr("role", "textbox").attr("aria-readonly", "true");
              this.$selection.attr("aria-labelledby", id);
              this.$selection.attr("aria-controls", id);
              this.$selection.on("mousedown", function(evt) {
                if (evt.which !== 1) {
                  return;
                }
                self2.trigger("toggle", {
                  originalEvent: evt
                });
              });
              this.$selection.on("focus", function(evt) {
              });
              this.$selection.on("blur", function(evt) {
              });
              container.on("focus", function(evt) {
                if (!container.isOpen()) {
                  self2.$selection.trigger("focus");
                }
              });
            };
            SingleSelection.prototype.clear = function() {
              var $rendered = this.$selection.find(".select2-selection__rendered");
              $rendered.empty();
              $rendered.removeAttr("title");
            };
            SingleSelection.prototype.display = function(data, container) {
              var template = this.options.get("templateSelection");
              var escapeMarkup = this.options.get("escapeMarkup");
              return escapeMarkup(template(data, container));
            };
            SingleSelection.prototype.selectionContainer = function() {
              return $8("<span></span>");
            };
            SingleSelection.prototype.update = function(data) {
              if (data.length === 0) {
                this.clear();
                return;
              }
              var selection = data[0];
              var $rendered = this.$selection.find(".select2-selection__rendered");
              var formatted = this.display(selection, $rendered);
              $rendered.empty().append(formatted);
              var title = selection.title || selection.text;
              if (title) {
                $rendered.attr("title", title);
              } else {
                $rendered.removeAttr("title");
              }
            };
            return SingleSelection;
          });
          S22.define("select2/selection/multiple", [
            "jquery",
            "./base",
            "../utils"
          ], function($8, BaseSelection, Utils) {
            function MultipleSelection($element, options) {
              MultipleSelection.__super__.constructor.apply(this, arguments);
            }
            Utils.Extend(MultipleSelection, BaseSelection);
            MultipleSelection.prototype.render = function() {
              var $selection = MultipleSelection.__super__.render.call(this);
              $selection[0].classList.add("select2-selection--multiple");
              $selection.html(
                '<ul class="select2-selection__rendered"></ul>'
              );
              return $selection;
            };
            MultipleSelection.prototype.bind = function(container, $container) {
              var self2 = this;
              MultipleSelection.__super__.bind.apply(this, arguments);
              var id = container.id + "-container";
              this.$selection.find(".select2-selection__rendered").attr("id", id);
              this.$selection.on("click", function(evt) {
                self2.trigger("toggle", {
                  originalEvent: evt
                });
              });
              this.$selection.on(
                "click",
                ".select2-selection__choice__remove",
                function(evt) {
                  if (self2.isDisabled()) {
                    return;
                  }
                  var $remove = $8(this);
                  var $selection = $remove.parent();
                  var data = Utils.GetData($selection[0], "data");
                  self2.trigger("unselect", {
                    originalEvent: evt,
                    data
                  });
                }
              );
              this.$selection.on(
                "keydown",
                ".select2-selection__choice__remove",
                function(evt) {
                  if (self2.isDisabled()) {
                    return;
                  }
                  evt.stopPropagation();
                }
              );
            };
            MultipleSelection.prototype.clear = function() {
              var $rendered = this.$selection.find(".select2-selection__rendered");
              $rendered.empty();
              $rendered.removeAttr("title");
            };
            MultipleSelection.prototype.display = function(data, container) {
              var template = this.options.get("templateSelection");
              var escapeMarkup = this.options.get("escapeMarkup");
              return escapeMarkup(template(data, container));
            };
            MultipleSelection.prototype.selectionContainer = function() {
              var $container = $8(
                '<li class="select2-selection__choice"><button type="button" class="select2-selection__choice__remove" tabindex="-1"><span aria-hidden="true">&times;</span></button><span class="select2-selection__choice__display"></span></li>'
              );
              return $container;
            };
            MultipleSelection.prototype.update = function(data) {
              this.clear();
              if (data.length === 0) {
                return;
              }
              var $selections = [];
              var selectionIdPrefix = this.$selection.find(".select2-selection__rendered").attr("id") + "-choice-";
              for (var d2 = 0; d2 < data.length; d2++) {
                var selection = data[d2];
                var $selection = this.selectionContainer();
                var formatted = this.display(selection, $selection);
                var selectionId = selectionIdPrefix + Utils.generateChars(4) + "-";
                if (selection.id) {
                  selectionId += selection.id;
                } else {
                  selectionId += Utils.generateChars(4);
                }
                $selection.find(".select2-selection__choice__display").append(formatted).attr("id", selectionId);
                var title = selection.title || selection.text;
                if (title) {
                  $selection.attr("title", title);
                }
                var removeItem = this.options.get("translations").get("removeItem");
                var $remove = $selection.find(".select2-selection__choice__remove");
                $remove.attr("title", removeItem());
                $remove.attr("aria-label", removeItem());
                $remove.attr("aria-describedby", selectionId);
                Utils.StoreData($selection[0], "data", selection);
                $selections.push($selection);
              }
              var $rendered = this.$selection.find(".select2-selection__rendered");
              $rendered.append($selections);
            };
            return MultipleSelection;
          });
          S22.define("select2/selection/placeholder", [], function() {
            function Placeholder(decorated, $element, options) {
              this.placeholder = this.normalizePlaceholder(options.get("placeholder"));
              decorated.call(this, $element, options);
            }
            Placeholder.prototype.normalizePlaceholder = function(_2, placeholder) {
              if (typeof placeholder === "string") {
                placeholder = {
                  id: "",
                  text: placeholder
                };
              }
              return placeholder;
            };
            Placeholder.prototype.createPlaceholder = function(decorated, placeholder) {
              var $placeholder = this.selectionContainer();
              $placeholder.html(this.display(placeholder));
              $placeholder[0].classList.add("select2-selection__placeholder");
              $placeholder[0].classList.remove("select2-selection__choice");
              var placeholderTitle = placeholder.title || placeholder.text || $placeholder.text();
              this.$selection.find(".select2-selection__rendered").attr(
                "title",
                placeholderTitle
              );
              return $placeholder;
            };
            Placeholder.prototype.update = function(decorated, data) {
              var singlePlaceholder = data.length == 1 && data[0].id != this.placeholder.id;
              var multipleSelections = data.length > 1;
              if (multipleSelections || singlePlaceholder) {
                return decorated.call(this, data);
              }
              this.clear();
              var $placeholder = this.createPlaceholder(this.placeholder);
              this.$selection.find(".select2-selection__rendered").append($placeholder);
            };
            return Placeholder;
          });
          S22.define("select2/selection/allowClear", [
            "jquery",
            "../keys",
            "../utils"
          ], function($8, KEYS, Utils) {
            function AllowClear() {
            }
            AllowClear.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              if (this.placeholder == null) {
                if (this.options.get("debug") && window.console && console.error) {
                  console.error(
                    "Select2: The `allowClear` option should be used in combination with the `placeholder` option."
                  );
                }
              }
              this.$selection.on(
                "mousedown",
                ".select2-selection__clear",
                function(evt) {
                  self2._handleClear(evt);
                }
              );
              container.on("keypress", function(evt) {
                self2._handleKeyboardClear(evt, container);
              });
            };
            AllowClear.prototype._handleClear = function(_2, evt) {
              if (this.isDisabled()) {
                return;
              }
              var $clear = this.$selection.find(".select2-selection__clear");
              if ($clear.length === 0) {
                return;
              }
              evt.stopPropagation();
              var data = Utils.GetData($clear[0], "data");
              var previousVal = this.$element.val();
              this.$element.val(this.placeholder.id);
              var unselectData = {
                data
              };
              this.trigger("clear", unselectData);
              if (unselectData.prevented) {
                this.$element.val(previousVal);
                return;
              }
              for (var d2 = 0; d2 < data.length; d2++) {
                unselectData = {
                  data: data[d2]
                };
                this.trigger("unselect", unselectData);
                if (unselectData.prevented) {
                  this.$element.val(previousVal);
                  return;
                }
              }
              this.$element.trigger("input").trigger("change");
              this.trigger("toggle", {});
            };
            AllowClear.prototype._handleKeyboardClear = function(_2, evt, container) {
              if (container.isOpen()) {
                return;
              }
              if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
                this._handleClear(evt);
              }
            };
            AllowClear.prototype.update = function(decorated, data) {
              decorated.call(this, data);
              this.$selection.find(".select2-selection__clear").remove();
              this.$selection[0].classList.remove("select2-selection--clearable");
              if (this.$selection.find(".select2-selection__placeholder").length > 0 || data.length === 0) {
                return;
              }
              var selectionId = this.$selection.find(".select2-selection__rendered").attr("id");
              var removeAll = this.options.get("translations").get("removeAllItems");
              var $remove = $8(
                '<button type="button" class="select2-selection__clear" tabindex="-1"><span aria-hidden="true">&times;</span></button>'
              );
              $remove.attr("title", removeAll());
              $remove.attr("aria-label", removeAll());
              $remove.attr("aria-describedby", selectionId);
              Utils.StoreData($remove[0], "data", data);
              this.$selection.prepend($remove);
              this.$selection[0].classList.add("select2-selection--clearable");
            };
            return AllowClear;
          });
          S22.define("select2/selection/search", [
            "jquery",
            "../utils",
            "../keys"
          ], function($8, Utils, KEYS) {
            function Search(decorated, $element, options) {
              decorated.call(this, $element, options);
            }
            Search.prototype.render = function(decorated) {
              var searchLabel = this.options.get("translations").get("search");
              var $search = $8(
                '<span class="select2-search select2-search--inline"><textarea class="select2-search__field" type="search" tabindex="-1" autocorrect="off" autocapitalize="none" spellcheck="false" role="searchbox" aria-autocomplete="list" ></textarea></span>'
              );
              this.$searchContainer = $search;
              this.$search = $search.find("textarea");
              this.$search.prop("autocomplete", this.options.get("autocomplete"));
              this.$search.attr("aria-label", searchLabel());
              var $rendered = decorated.call(this);
              this._transferTabIndex();
              $rendered.append(this.$searchContainer);
              return $rendered;
            };
            Search.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              var resultsId = container.id + "-results";
              var selectionId = container.id + "-container";
              decorated.call(this, container, $container);
              self2.$search.attr("aria-describedby", selectionId);
              container.on("open", function() {
                self2.$search.attr("aria-controls", resultsId);
                self2.$search.trigger("focus");
              });
              container.on("close", function() {
                self2.$search.val("");
                self2.resizeSearch();
                self2.$search.removeAttr("aria-controls");
                self2.$search.removeAttr("aria-activedescendant");
                self2.$search.trigger("focus");
              });
              container.on("enable", function() {
                self2.$search.prop("disabled", false);
                self2._transferTabIndex();
              });
              container.on("disable", function() {
                self2.$search.prop("disabled", true);
              });
              container.on("focus", function(evt) {
                self2.$search.trigger("focus");
              });
              container.on("results:focus", function(params) {
                if (params.data._resultId) {
                  self2.$search.attr("aria-activedescendant", params.data._resultId);
                } else {
                  self2.$search.removeAttr("aria-activedescendant");
                }
              });
              this.$selection.on("focusin", ".select2-search--inline", function(evt) {
                self2.trigger("focus", evt);
              });
              this.$selection.on("focusout", ".select2-search--inline", function(evt) {
                self2._handleBlur(evt);
              });
              this.$selection.on("keydown", ".select2-search--inline", function(evt) {
                evt.stopPropagation();
                self2.trigger("keypress", evt);
                self2._keyUpPrevented = evt.isDefaultPrevented();
                var key = evt.which;
                if (key === KEYS.BACKSPACE && self2.$search.val() === "") {
                  var $previousChoice = self2.$selection.find(".select2-selection__choice").last();
                  if ($previousChoice.length > 0) {
                    var item = Utils.GetData($previousChoice[0], "data");
                    self2.searchRemoveChoice(item);
                    evt.preventDefault();
                  }
                }
              });
              this.$selection.on("click", ".select2-search--inline", function(evt) {
                if (self2.$search.val()) {
                  evt.stopPropagation();
                }
              });
              var msie = document.documentMode;
              var disableInputEvents = msie && msie <= 11;
              this.$selection.on(
                "input.searchcheck",
                ".select2-search--inline",
                function(evt) {
                  if (disableInputEvents) {
                    self2.$selection.off("input.search input.searchcheck");
                    return;
                  }
                  self2.$selection.off("keyup.search");
                }
              );
              this.$selection.on(
                "keyup.search input.search",
                ".select2-search--inline",
                function(evt) {
                  if (disableInputEvents && evt.type === "input") {
                    self2.$selection.off("input.search input.searchcheck");
                    return;
                  }
                  var key = evt.which;
                  if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
                    return;
                  }
                  if (key == KEYS.TAB) {
                    return;
                  }
                  self2.handleSearch(evt);
                }
              );
            };
            Search.prototype._transferTabIndex = function(decorated) {
              this.$search.attr("tabindex", this.$selection.attr("tabindex"));
              this.$selection.attr("tabindex", "-1");
            };
            Search.prototype.createPlaceholder = function(decorated, placeholder) {
              this.$search.attr("placeholder", placeholder.text);
            };
            Search.prototype.update = function(decorated, data) {
              var searchHadFocus = this.$search[0] == document.activeElement;
              this.$search.attr("placeholder", "");
              decorated.call(this, data);
              this.resizeSearch();
              if (searchHadFocus) {
                this.$search.trigger("focus");
              }
            };
            Search.prototype.handleSearch = function() {
              this.resizeSearch();
              if (!this._keyUpPrevented) {
                var input = this.$search.val();
                this.trigger("query", {
                  term: input
                });
              }
              this._keyUpPrevented = false;
            };
            Search.prototype.searchRemoveChoice = function(decorated, item) {
              this.trigger("unselect", {
                data: item
              });
              this.$search.val(item.text);
              this.handleSearch();
            };
            Search.prototype.resizeSearch = function() {
              this.$search.css("width", "25px");
              var width = "100%";
              if (this.$search.attr("placeholder") === "") {
                var minimumWidth = this.$search.val().length + 1;
                width = minimumWidth * 0.75 + "em";
              }
              this.$search.css("width", width);
            };
            return Search;
          });
          S22.define("select2/selection/selectionCss", [
            "../utils"
          ], function(Utils) {
            function SelectionCSS() {
            }
            SelectionCSS.prototype.render = function(decorated) {
              var $selection = decorated.call(this);
              var selectionCssClass = this.options.get("selectionCssClass") || "";
              if (selectionCssClass.indexOf(":all:") !== -1) {
                selectionCssClass = selectionCssClass.replace(":all:", "");
                Utils.copyNonInternalCssClasses($selection[0], this.$element[0]);
              }
              $selection.addClass(selectionCssClass);
              return $selection;
            };
            return SelectionCSS;
          });
          S22.define("select2/selection/eventRelay", [
            "jquery"
          ], function($8) {
            function EventRelay() {
            }
            EventRelay.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              var relayEvents = [
                "open",
                "opening",
                "close",
                "closing",
                "select",
                "selecting",
                "unselect",
                "unselecting",
                "clear",
                "clearing"
              ];
              var preventableEvents = [
                "opening",
                "closing",
                "selecting",
                "unselecting",
                "clearing"
              ];
              decorated.call(this, container, $container);
              container.on("*", function(name, params) {
                if (relayEvents.indexOf(name) === -1) {
                  return;
                }
                params = params || {};
                var evt = $8.Event("select2:" + name, {
                  params
                });
                self2.$element.trigger(evt);
                if (preventableEvents.indexOf(name) === -1) {
                  return;
                }
                params.prevented = evt.isDefaultPrevented();
              });
            };
            return EventRelay;
          });
          S22.define("select2/translation", [
            "jquery",
            "require"
          ], function($8, require2) {
            function Translation(dict) {
              this.dict = dict || {};
            }
            Translation.prototype.all = function() {
              return this.dict;
            };
            Translation.prototype.get = function(key) {
              return this.dict[key];
            };
            Translation.prototype.extend = function(translation) {
              this.dict = $8.extend({}, translation.all(), this.dict);
            };
            Translation._cache = {};
            Translation.loadPath = function(path) {
              if (!(path in Translation._cache)) {
                var translations = require2(path);
                Translation._cache[path] = translations;
              }
              return new Translation(Translation._cache[path]);
            };
            return Translation;
          });
          S22.define("select2/diacritics", [], function() {
            var diacritics = {
              "\u24B6": "A",
              "\uFF21": "A",
              "\xC0": "A",
              "\xC1": "A",
              "\xC2": "A",
              "\u1EA6": "A",
              "\u1EA4": "A",
              "\u1EAA": "A",
              "\u1EA8": "A",
              "\xC3": "A",
              "\u0100": "A",
              "\u0102": "A",
              "\u1EB0": "A",
              "\u1EAE": "A",
              "\u1EB4": "A",
              "\u1EB2": "A",
              "\u0226": "A",
              "\u01E0": "A",
              "\xC4": "A",
              "\u01DE": "A",
              "\u1EA2": "A",
              "\xC5": "A",
              "\u01FA": "A",
              "\u01CD": "A",
              "\u0200": "A",
              "\u0202": "A",
              "\u1EA0": "A",
              "\u1EAC": "A",
              "\u1EB6": "A",
              "\u1E00": "A",
              "\u0104": "A",
              "\u023A": "A",
              "\u2C6F": "A",
              "\uA732": "AA",
              "\xC6": "AE",
              "\u01FC": "AE",
              "\u01E2": "AE",
              "\uA734": "AO",
              "\uA736": "AU",
              "\uA738": "AV",
              "\uA73A": "AV",
              "\uA73C": "AY",
              "\u24B7": "B",
              "\uFF22": "B",
              "\u1E02": "B",
              "\u1E04": "B",
              "\u1E06": "B",
              "\u0243": "B",
              "\u0182": "B",
              "\u0181": "B",
              "\u24B8": "C",
              "\uFF23": "C",
              "\u0106": "C",
              "\u0108": "C",
              "\u010A": "C",
              "\u010C": "C",
              "\xC7": "C",
              "\u1E08": "C",
              "\u0187": "C",
              "\u023B": "C",
              "\uA73E": "C",
              "\u24B9": "D",
              "\uFF24": "D",
              "\u1E0A": "D",
              "\u010E": "D",
              "\u1E0C": "D",
              "\u1E10": "D",
              "\u1E12": "D",
              "\u1E0E": "D",
              "\u0110": "D",
              "\u018B": "D",
              "\u018A": "D",
              "\u0189": "D",
              "\uA779": "D",
              "\u01F1": "DZ",
              "\u01C4": "DZ",
              "\u01F2": "Dz",
              "\u01C5": "Dz",
              "\u24BA": "E",
              "\uFF25": "E",
              "\xC8": "E",
              "\xC9": "E",
              "\xCA": "E",
              "\u1EC0": "E",
              "\u1EBE": "E",
              "\u1EC4": "E",
              "\u1EC2": "E",
              "\u1EBC": "E",
              "\u0112": "E",
              "\u1E14": "E",
              "\u1E16": "E",
              "\u0114": "E",
              "\u0116": "E",
              "\xCB": "E",
              "\u1EBA": "E",
              "\u011A": "E",
              "\u0204": "E",
              "\u0206": "E",
              "\u1EB8": "E",
              "\u1EC6": "E",
              "\u0228": "E",
              "\u1E1C": "E",
              "\u0118": "E",
              "\u1E18": "E",
              "\u1E1A": "E",
              "\u0190": "E",
              "\u018E": "E",
              "\u24BB": "F",
              "\uFF26": "F",
              "\u1E1E": "F",
              "\u0191": "F",
              "\uA77B": "F",
              "\u24BC": "G",
              "\uFF27": "G",
              "\u01F4": "G",
              "\u011C": "G",
              "\u1E20": "G",
              "\u011E": "G",
              "\u0120": "G",
              "\u01E6": "G",
              "\u0122": "G",
              "\u01E4": "G",
              "\u0193": "G",
              "\uA7A0": "G",
              "\uA77D": "G",
              "\uA77E": "G",
              "\u24BD": "H",
              "\uFF28": "H",
              "\u0124": "H",
              "\u1E22": "H",
              "\u1E26": "H",
              "\u021E": "H",
              "\u1E24": "H",
              "\u1E28": "H",
              "\u1E2A": "H",
              "\u0126": "H",
              "\u2C67": "H",
              "\u2C75": "H",
              "\uA78D": "H",
              "\u24BE": "I",
              "\uFF29": "I",
              "\xCC": "I",
              "\xCD": "I",
              "\xCE": "I",
              "\u0128": "I",
              "\u012A": "I",
              "\u012C": "I",
              "\u0130": "I",
              "\xCF": "I",
              "\u1E2E": "I",
              "\u1EC8": "I",
              "\u01CF": "I",
              "\u0208": "I",
              "\u020A": "I",
              "\u1ECA": "I",
              "\u012E": "I",
              "\u1E2C": "I",
              "\u0197": "I",
              "\u24BF": "J",
              "\uFF2A": "J",
              "\u0134": "J",
              "\u0248": "J",
              "\u24C0": "K",
              "\uFF2B": "K",
              "\u1E30": "K",
              "\u01E8": "K",
              "\u1E32": "K",
              "\u0136": "K",
              "\u1E34": "K",
              "\u0198": "K",
              "\u2C69": "K",
              "\uA740": "K",
              "\uA742": "K",
              "\uA744": "K",
              "\uA7A2": "K",
              "\u24C1": "L",
              "\uFF2C": "L",
              "\u013F": "L",
              "\u0139": "L",
              "\u013D": "L",
              "\u1E36": "L",
              "\u1E38": "L",
              "\u013B": "L",
              "\u1E3C": "L",
              "\u1E3A": "L",
              "\u0141": "L",
              "\u023D": "L",
              "\u2C62": "L",
              "\u2C60": "L",
              "\uA748": "L",
              "\uA746": "L",
              "\uA780": "L",
              "\u01C7": "LJ",
              "\u01C8": "Lj",
              "\u24C2": "M",
              "\uFF2D": "M",
              "\u1E3E": "M",
              "\u1E40": "M",
              "\u1E42": "M",
              "\u2C6E": "M",
              "\u019C": "M",
              "\u24C3": "N",
              "\uFF2E": "N",
              "\u01F8": "N",
              "\u0143": "N",
              "\xD1": "N",
              "\u1E44": "N",
              "\u0147": "N",
              "\u1E46": "N",
              "\u0145": "N",
              "\u1E4A": "N",
              "\u1E48": "N",
              "\u0220": "N",
              "\u019D": "N",
              "\uA790": "N",
              "\uA7A4": "N",
              "\u01CA": "NJ",
              "\u01CB": "Nj",
              "\u24C4": "O",
              "\uFF2F": "O",
              "\xD2": "O",
              "\xD3": "O",
              "\xD4": "O",
              "\u1ED2": "O",
              "\u1ED0": "O",
              "\u1ED6": "O",
              "\u1ED4": "O",
              "\xD5": "O",
              "\u1E4C": "O",
              "\u022C": "O",
              "\u1E4E": "O",
              "\u014C": "O",
              "\u1E50": "O",
              "\u1E52": "O",
              "\u014E": "O",
              "\u022E": "O",
              "\u0230": "O",
              "\xD6": "O",
              "\u022A": "O",
              "\u1ECE": "O",
              "\u0150": "O",
              "\u01D1": "O",
              "\u020C": "O",
              "\u020E": "O",
              "\u01A0": "O",
              "\u1EDC": "O",
              "\u1EDA": "O",
              "\u1EE0": "O",
              "\u1EDE": "O",
              "\u1EE2": "O",
              "\u1ECC": "O",
              "\u1ED8": "O",
              "\u01EA": "O",
              "\u01EC": "O",
              "\xD8": "O",
              "\u01FE": "O",
              "\u0186": "O",
              "\u019F": "O",
              "\uA74A": "O",
              "\uA74C": "O",
              "\u0152": "OE",
              "\u01A2": "OI",
              "\uA74E": "OO",
              "\u0222": "OU",
              "\u24C5": "P",
              "\uFF30": "P",
              "\u1E54": "P",
              "\u1E56": "P",
              "\u01A4": "P",
              "\u2C63": "P",
              "\uA750": "P",
              "\uA752": "P",
              "\uA754": "P",
              "\u24C6": "Q",
              "\uFF31": "Q",
              "\uA756": "Q",
              "\uA758": "Q",
              "\u024A": "Q",
              "\u24C7": "R",
              "\uFF32": "R",
              "\u0154": "R",
              "\u1E58": "R",
              "\u0158": "R",
              "\u0210": "R",
              "\u0212": "R",
              "\u1E5A": "R",
              "\u1E5C": "R",
              "\u0156": "R",
              "\u1E5E": "R",
              "\u024C": "R",
              "\u2C64": "R",
              "\uA75A": "R",
              "\uA7A6": "R",
              "\uA782": "R",
              "\u24C8": "S",
              "\uFF33": "S",
              "\u1E9E": "S",
              "\u015A": "S",
              "\u1E64": "S",
              "\u015C": "S",
              "\u1E60": "S",
              "\u0160": "S",
              "\u1E66": "S",
              "\u1E62": "S",
              "\u1E68": "S",
              "\u0218": "S",
              "\u015E": "S",
              "\u2C7E": "S",
              "\uA7A8": "S",
              "\uA784": "S",
              "\u24C9": "T",
              "\uFF34": "T",
              "\u1E6A": "T",
              "\u0164": "T",
              "\u1E6C": "T",
              "\u021A": "T",
              "\u0162": "T",
              "\u1E70": "T",
              "\u1E6E": "T",
              "\u0166": "T",
              "\u01AC": "T",
              "\u01AE": "T",
              "\u023E": "T",
              "\uA786": "T",
              "\uA728": "TZ",
              "\u24CA": "U",
              "\uFF35": "U",
              "\xD9": "U",
              "\xDA": "U",
              "\xDB": "U",
              "\u0168": "U",
              "\u1E78": "U",
              "\u016A": "U",
              "\u1E7A": "U",
              "\u016C": "U",
              "\xDC": "U",
              "\u01DB": "U",
              "\u01D7": "U",
              "\u01D5": "U",
              "\u01D9": "U",
              "\u1EE6": "U",
              "\u016E": "U",
              "\u0170": "U",
              "\u01D3": "U",
              "\u0214": "U",
              "\u0216": "U",
              "\u01AF": "U",
              "\u1EEA": "U",
              "\u1EE8": "U",
              "\u1EEE": "U",
              "\u1EEC": "U",
              "\u1EF0": "U",
              "\u1EE4": "U",
              "\u1E72": "U",
              "\u0172": "U",
              "\u1E76": "U",
              "\u1E74": "U",
              "\u0244": "U",
              "\u24CB": "V",
              "\uFF36": "V",
              "\u1E7C": "V",
              "\u1E7E": "V",
              "\u01B2": "V",
              "\uA75E": "V",
              "\u0245": "V",
              "\uA760": "VY",
              "\u24CC": "W",
              "\uFF37": "W",
              "\u1E80": "W",
              "\u1E82": "W",
              "\u0174": "W",
              "\u1E86": "W",
              "\u1E84": "W",
              "\u1E88": "W",
              "\u2C72": "W",
              "\u24CD": "X",
              "\uFF38": "X",
              "\u1E8A": "X",
              "\u1E8C": "X",
              "\u24CE": "Y",
              "\uFF39": "Y",
              "\u1EF2": "Y",
              "\xDD": "Y",
              "\u0176": "Y",
              "\u1EF8": "Y",
              "\u0232": "Y",
              "\u1E8E": "Y",
              "\u0178": "Y",
              "\u1EF6": "Y",
              "\u1EF4": "Y",
              "\u01B3": "Y",
              "\u024E": "Y",
              "\u1EFE": "Y",
              "\u24CF": "Z",
              "\uFF3A": "Z",
              "\u0179": "Z",
              "\u1E90": "Z",
              "\u017B": "Z",
              "\u017D": "Z",
              "\u1E92": "Z",
              "\u1E94": "Z",
              "\u01B5": "Z",
              "\u0224": "Z",
              "\u2C7F": "Z",
              "\u2C6B": "Z",
              "\uA762": "Z",
              "\u24D0": "a",
              "\uFF41": "a",
              "\u1E9A": "a",
              "\xE0": "a",
              "\xE1": "a",
              "\xE2": "a",
              "\u1EA7": "a",
              "\u1EA5": "a",
              "\u1EAB": "a",
              "\u1EA9": "a",
              "\xE3": "a",
              "\u0101": "a",
              "\u0103": "a",
              "\u1EB1": "a",
              "\u1EAF": "a",
              "\u1EB5": "a",
              "\u1EB3": "a",
              "\u0227": "a",
              "\u01E1": "a",
              "\xE4": "a",
              "\u01DF": "a",
              "\u1EA3": "a",
              "\xE5": "a",
              "\u01FB": "a",
              "\u01CE": "a",
              "\u0201": "a",
              "\u0203": "a",
              "\u1EA1": "a",
              "\u1EAD": "a",
              "\u1EB7": "a",
              "\u1E01": "a",
              "\u0105": "a",
              "\u2C65": "a",
              "\u0250": "a",
              "\uA733": "aa",
              "\xE6": "ae",
              "\u01FD": "ae",
              "\u01E3": "ae",
              "\uA735": "ao",
              "\uA737": "au",
              "\uA739": "av",
              "\uA73B": "av",
              "\uA73D": "ay",
              "\u24D1": "b",
              "\uFF42": "b",
              "\u1E03": "b",
              "\u1E05": "b",
              "\u1E07": "b",
              "\u0180": "b",
              "\u0183": "b",
              "\u0253": "b",
              "\u24D2": "c",
              "\uFF43": "c",
              "\u0107": "c",
              "\u0109": "c",
              "\u010B": "c",
              "\u010D": "c",
              "\xE7": "c",
              "\u1E09": "c",
              "\u0188": "c",
              "\u023C": "c",
              "\uA73F": "c",
              "\u2184": "c",
              "\u24D3": "d",
              "\uFF44": "d",
              "\u1E0B": "d",
              "\u010F": "d",
              "\u1E0D": "d",
              "\u1E11": "d",
              "\u1E13": "d",
              "\u1E0F": "d",
              "\u0111": "d",
              "\u018C": "d",
              "\u0256": "d",
              "\u0257": "d",
              "\uA77A": "d",
              "\u01F3": "dz",
              "\u01C6": "dz",
              "\u24D4": "e",
              "\uFF45": "e",
              "\xE8": "e",
              "\xE9": "e",
              "\xEA": "e",
              "\u1EC1": "e",
              "\u1EBF": "e",
              "\u1EC5": "e",
              "\u1EC3": "e",
              "\u1EBD": "e",
              "\u0113": "e",
              "\u1E15": "e",
              "\u1E17": "e",
              "\u0115": "e",
              "\u0117": "e",
              "\xEB": "e",
              "\u1EBB": "e",
              "\u011B": "e",
              "\u0205": "e",
              "\u0207": "e",
              "\u1EB9": "e",
              "\u1EC7": "e",
              "\u0229": "e",
              "\u1E1D": "e",
              "\u0119": "e",
              "\u1E19": "e",
              "\u1E1B": "e",
              "\u0247": "e",
              "\u025B": "e",
              "\u01DD": "e",
              "\u24D5": "f",
              "\uFF46": "f",
              "\u1E1F": "f",
              "\u0192": "f",
              "\uA77C": "f",
              "\u24D6": "g",
              "\uFF47": "g",
              "\u01F5": "g",
              "\u011D": "g",
              "\u1E21": "g",
              "\u011F": "g",
              "\u0121": "g",
              "\u01E7": "g",
              "\u0123": "g",
              "\u01E5": "g",
              "\u0260": "g",
              "\uA7A1": "g",
              "\u1D79": "g",
              "\uA77F": "g",
              "\u24D7": "h",
              "\uFF48": "h",
              "\u0125": "h",
              "\u1E23": "h",
              "\u1E27": "h",
              "\u021F": "h",
              "\u1E25": "h",
              "\u1E29": "h",
              "\u1E2B": "h",
              "\u1E96": "h",
              "\u0127": "h",
              "\u2C68": "h",
              "\u2C76": "h",
              "\u0265": "h",
              "\u0195": "hv",
              "\u24D8": "i",
              "\uFF49": "i",
              "\xEC": "i",
              "\xED": "i",
              "\xEE": "i",
              "\u0129": "i",
              "\u012B": "i",
              "\u012D": "i",
              "\xEF": "i",
              "\u1E2F": "i",
              "\u1EC9": "i",
              "\u01D0": "i",
              "\u0209": "i",
              "\u020B": "i",
              "\u1ECB": "i",
              "\u012F": "i",
              "\u1E2D": "i",
              "\u0268": "i",
              "\u0131": "i",
              "\u24D9": "j",
              "\uFF4A": "j",
              "\u0135": "j",
              "\u01F0": "j",
              "\u0249": "j",
              "\u24DA": "k",
              "\uFF4B": "k",
              "\u1E31": "k",
              "\u01E9": "k",
              "\u1E33": "k",
              "\u0137": "k",
              "\u1E35": "k",
              "\u0199": "k",
              "\u2C6A": "k",
              "\uA741": "k",
              "\uA743": "k",
              "\uA745": "k",
              "\uA7A3": "k",
              "\u24DB": "l",
              "\uFF4C": "l",
              "\u0140": "l",
              "\u013A": "l",
              "\u013E": "l",
              "\u1E37": "l",
              "\u1E39": "l",
              "\u013C": "l",
              "\u1E3D": "l",
              "\u1E3B": "l",
              "\u017F": "l",
              "\u0142": "l",
              "\u019A": "l",
              "\u026B": "l",
              "\u2C61": "l",
              "\uA749": "l",
              "\uA781": "l",
              "\uA747": "l",
              "\u01C9": "lj",
              "\u24DC": "m",
              "\uFF4D": "m",
              "\u1E3F": "m",
              "\u1E41": "m",
              "\u1E43": "m",
              "\u0271": "m",
              "\u026F": "m",
              "\u24DD": "n",
              "\uFF4E": "n",
              "\u01F9": "n",
              "\u0144": "n",
              "\xF1": "n",
              "\u1E45": "n",
              "\u0148": "n",
              "\u1E47": "n",
              "\u0146": "n",
              "\u1E4B": "n",
              "\u1E49": "n",
              "\u019E": "n",
              "\u0272": "n",
              "\u0149": "n",
              "\uA791": "n",
              "\uA7A5": "n",
              "\u01CC": "nj",
              "\u24DE": "o",
              "\uFF4F": "o",
              "\xF2": "o",
              "\xF3": "o",
              "\xF4": "o",
              "\u1ED3": "o",
              "\u1ED1": "o",
              "\u1ED7": "o",
              "\u1ED5": "o",
              "\xF5": "o",
              "\u1E4D": "o",
              "\u022D": "o",
              "\u1E4F": "o",
              "\u014D": "o",
              "\u1E51": "o",
              "\u1E53": "o",
              "\u014F": "o",
              "\u022F": "o",
              "\u0231": "o",
              "\xF6": "o",
              "\u022B": "o",
              "\u1ECF": "o",
              "\u0151": "o",
              "\u01D2": "o",
              "\u020D": "o",
              "\u020F": "o",
              "\u01A1": "o",
              "\u1EDD": "o",
              "\u1EDB": "o",
              "\u1EE1": "o",
              "\u1EDF": "o",
              "\u1EE3": "o",
              "\u1ECD": "o",
              "\u1ED9": "o",
              "\u01EB": "o",
              "\u01ED": "o",
              "\xF8": "o",
              "\u01FF": "o",
              "\u0254": "o",
              "\uA74B": "o",
              "\uA74D": "o",
              "\u0275": "o",
              "\u0153": "oe",
              "\u01A3": "oi",
              "\u0223": "ou",
              "\uA74F": "oo",
              "\u24DF": "p",
              "\uFF50": "p",
              "\u1E55": "p",
              "\u1E57": "p",
              "\u01A5": "p",
              "\u1D7D": "p",
              "\uA751": "p",
              "\uA753": "p",
              "\uA755": "p",
              "\u24E0": "q",
              "\uFF51": "q",
              "\u024B": "q",
              "\uA757": "q",
              "\uA759": "q",
              "\u24E1": "r",
              "\uFF52": "r",
              "\u0155": "r",
              "\u1E59": "r",
              "\u0159": "r",
              "\u0211": "r",
              "\u0213": "r",
              "\u1E5B": "r",
              "\u1E5D": "r",
              "\u0157": "r",
              "\u1E5F": "r",
              "\u024D": "r",
              "\u027D": "r",
              "\uA75B": "r",
              "\uA7A7": "r",
              "\uA783": "r",
              "\u24E2": "s",
              "\uFF53": "s",
              "\xDF": "s",
              "\u015B": "s",
              "\u1E65": "s",
              "\u015D": "s",
              "\u1E61": "s",
              "\u0161": "s",
              "\u1E67": "s",
              "\u1E63": "s",
              "\u1E69": "s",
              "\u0219": "s",
              "\u015F": "s",
              "\u023F": "s",
              "\uA7A9": "s",
              "\uA785": "s",
              "\u1E9B": "s",
              "\u24E3": "t",
              "\uFF54": "t",
              "\u1E6B": "t",
              "\u1E97": "t",
              "\u0165": "t",
              "\u1E6D": "t",
              "\u021B": "t",
              "\u0163": "t",
              "\u1E71": "t",
              "\u1E6F": "t",
              "\u0167": "t",
              "\u01AD": "t",
              "\u0288": "t",
              "\u2C66": "t",
              "\uA787": "t",
              "\uA729": "tz",
              "\u24E4": "u",
              "\uFF55": "u",
              "\xF9": "u",
              "\xFA": "u",
              "\xFB": "u",
              "\u0169": "u",
              "\u1E79": "u",
              "\u016B": "u",
              "\u1E7B": "u",
              "\u016D": "u",
              "\xFC": "u",
              "\u01DC": "u",
              "\u01D8": "u",
              "\u01D6": "u",
              "\u01DA": "u",
              "\u1EE7": "u",
              "\u016F": "u",
              "\u0171": "u",
              "\u01D4": "u",
              "\u0215": "u",
              "\u0217": "u",
              "\u01B0": "u",
              "\u1EEB": "u",
              "\u1EE9": "u",
              "\u1EEF": "u",
              "\u1EED": "u",
              "\u1EF1": "u",
              "\u1EE5": "u",
              "\u1E73": "u",
              "\u0173": "u",
              "\u1E77": "u",
              "\u1E75": "u",
              "\u0289": "u",
              "\u24E5": "v",
              "\uFF56": "v",
              "\u1E7D": "v",
              "\u1E7F": "v",
              "\u028B": "v",
              "\uA75F": "v",
              "\u028C": "v",
              "\uA761": "vy",
              "\u24E6": "w",
              "\uFF57": "w",
              "\u1E81": "w",
              "\u1E83": "w",
              "\u0175": "w",
              "\u1E87": "w",
              "\u1E85": "w",
              "\u1E98": "w",
              "\u1E89": "w",
              "\u2C73": "w",
              "\u24E7": "x",
              "\uFF58": "x",
              "\u1E8B": "x",
              "\u1E8D": "x",
              "\u24E8": "y",
              "\uFF59": "y",
              "\u1EF3": "y",
              "\xFD": "y",
              "\u0177": "y",
              "\u1EF9": "y",
              "\u0233": "y",
              "\u1E8F": "y",
              "\xFF": "y",
              "\u1EF7": "y",
              "\u1E99": "y",
              "\u1EF5": "y",
              "\u01B4": "y",
              "\u024F": "y",
              "\u1EFF": "y",
              "\u24E9": "z",
              "\uFF5A": "z",
              "\u017A": "z",
              "\u1E91": "z",
              "\u017C": "z",
              "\u017E": "z",
              "\u1E93": "z",
              "\u1E95": "z",
              "\u01B6": "z",
              "\u0225": "z",
              "\u0240": "z",
              "\u2C6C": "z",
              "\uA763": "z",
              "\u0386": "\u0391",
              "\u0388": "\u0395",
              "\u0389": "\u0397",
              "\u038A": "\u0399",
              "\u03AA": "\u0399",
              "\u038C": "\u039F",
              "\u038E": "\u03A5",
              "\u03AB": "\u03A5",
              "\u038F": "\u03A9",
              "\u03AC": "\u03B1",
              "\u03AD": "\u03B5",
              "\u03AE": "\u03B7",
              "\u03AF": "\u03B9",
              "\u03CA": "\u03B9",
              "\u0390": "\u03B9",
              "\u03CC": "\u03BF",
              "\u03CD": "\u03C5",
              "\u03CB": "\u03C5",
              "\u03B0": "\u03C5",
              "\u03CE": "\u03C9",
              "\u03C2": "\u03C3",
              "\u2019": "'"
            };
            return diacritics;
          });
          S22.define("select2/data/base", [
            "../utils"
          ], function(Utils) {
            function BaseAdapter($element, options) {
              BaseAdapter.__super__.constructor.call(this);
            }
            Utils.Extend(BaseAdapter, Utils.Observable);
            BaseAdapter.prototype.current = function(callback) {
              throw new Error("The `current` method must be defined in child classes.");
            };
            BaseAdapter.prototype.query = function(params, callback) {
              throw new Error("The `query` method must be defined in child classes.");
            };
            BaseAdapter.prototype.bind = function(container, $container) {
            };
            BaseAdapter.prototype.destroy = function() {
            };
            BaseAdapter.prototype.generateResultId = function(container, data) {
              var id = container.id + "-result-";
              id += Utils.generateChars(4);
              if (data.id != null) {
                id += "-" + data.id.toString();
              } else {
                id += "-" + Utils.generateChars(4);
              }
              return id;
            };
            return BaseAdapter;
          });
          S22.define("select2/data/select", [
            "./base",
            "../utils",
            "jquery"
          ], function(BaseAdapter, Utils, $8) {
            function SelectAdapter($element, options) {
              this.$element = $element;
              this.options = options;
              SelectAdapter.__super__.constructor.call(this);
            }
            Utils.Extend(SelectAdapter, BaseAdapter);
            SelectAdapter.prototype.current = function(callback) {
              var self2 = this;
              var data = Array.prototype.map.call(
                this.$element[0].querySelectorAll(":checked"),
                function(selectedElement) {
                  return self2.item($8(selectedElement));
                }
              );
              callback(data);
            };
            SelectAdapter.prototype.select = function(data) {
              var self2 = this;
              data.selected = true;
              if (data.element != null && data.element.tagName.toLowerCase() === "option") {
                data.element.selected = true;
                this.$element.trigger("input").trigger("change");
                return;
              }
              if (this.$element.prop("multiple")) {
                this.current(function(currentData) {
                  var val2 = [];
                  data = [data];
                  data.push.apply(data, currentData);
                  for (var d2 = 0; d2 < data.length; d2++) {
                    var id = data[d2].id;
                    if (val2.indexOf(id) === -1) {
                      val2.push(id);
                    }
                  }
                  self2.$element.val(val2);
                  self2.$element.trigger("input").trigger("change");
                });
              } else {
                var val = data.id;
                this.$element.val(val);
                this.$element.trigger("input").trigger("change");
              }
            };
            SelectAdapter.prototype.unselect = function(data) {
              var self2 = this;
              if (!this.$element.prop("multiple")) {
                return;
              }
              data.selected = false;
              if (data.element != null && data.element.tagName.toLowerCase() === "option") {
                data.element.selected = false;
                this.$element.trigger("input").trigger("change");
                return;
              }
              this.current(function(currentData) {
                var val = [];
                for (var d2 = 0; d2 < currentData.length; d2++) {
                  var id = currentData[d2].id;
                  if (id !== data.id && val.indexOf(id) === -1) {
                    val.push(id);
                  }
                }
                self2.$element.val(val);
                self2.$element.trigger("input").trigger("change");
              });
            };
            SelectAdapter.prototype.bind = function(container, $container) {
              var self2 = this;
              this.container = container;
              container.on("select", function(params) {
                self2.select(params.data);
              });
              container.on("unselect", function(params) {
                self2.unselect(params.data);
              });
            };
            SelectAdapter.prototype.destroy = function() {
              this.$element.find("*").each(function() {
                Utils.RemoveData(this);
              });
            };
            SelectAdapter.prototype.query = function(params, callback) {
              var data = [];
              var self2 = this;
              var $options = this.$element.children();
              $options.each(function() {
                if (this.tagName.toLowerCase() !== "option" && this.tagName.toLowerCase() !== "optgroup") {
                  return;
                }
                var $option = $8(this);
                var option = self2.item($option);
                var matches = self2.matches(params, option);
                if (matches !== null) {
                  data.push(matches);
                }
              });
              callback({
                results: data
              });
            };
            SelectAdapter.prototype.addOptions = function($options) {
              this.$element.append($options);
            };
            SelectAdapter.prototype.option = function(data) {
              var option;
              if (data.children) {
                option = document.createElement("optgroup");
                option.label = data.text;
              } else {
                option = document.createElement("option");
                if (option.textContent !== void 0) {
                  option.textContent = data.text;
                } else {
                  option.innerText = data.text;
                }
              }
              if (data.id !== void 0) {
                option.value = data.id;
              }
              if (data.disabled) {
                option.disabled = true;
              }
              if (data.selected) {
                option.selected = true;
              }
              if (data.title) {
                option.title = data.title;
              }
              var normalizedData = this._normalizeItem(data);
              normalizedData.element = option;
              Utils.StoreData(option, "data", normalizedData);
              return $8(option);
            };
            SelectAdapter.prototype.item = function($option) {
              var data = {};
              data = Utils.GetData($option[0], "data");
              if (data != null) {
                return data;
              }
              var option = $option[0];
              if (option.tagName.toLowerCase() === "option") {
                data = {
                  id: $option.val(),
                  text: $option.text(),
                  disabled: $option.prop("disabled"),
                  selected: $option.prop("selected"),
                  title: $option.prop("title")
                };
              } else if (option.tagName.toLowerCase() === "optgroup") {
                data = {
                  text: $option.prop("label"),
                  children: [],
                  title: $option.prop("title")
                };
                var $children = $option.children("option");
                var children = [];
                for (var c2 = 0; c2 < $children.length; c2++) {
                  var $child = $8($children[c2]);
                  var child = this.item($child);
                  children.push(child);
                }
                data.children = children;
              }
              data = this._normalizeItem(data);
              data.element = $option[0];
              Utils.StoreData($option[0], "data", data);
              return data;
            };
            SelectAdapter.prototype._normalizeItem = function(item) {
              if (item !== Object(item)) {
                item = {
                  id: item,
                  text: item
                };
              }
              item = $8.extend({}, {
                text: ""
              }, item);
              var defaults = {
                selected: false,
                disabled: false
              };
              if (item.id != null) {
                item.id = item.id.toString();
              }
              if (item.text != null) {
                item.text = item.text.toString();
              }
              if (item._resultId == null && item.id && this.container != null) {
                item._resultId = this.generateResultId(this.container, item);
              }
              return $8.extend({}, defaults, item);
            };
            SelectAdapter.prototype.matches = function(params, data) {
              var matcher = this.options.get("matcher");
              return matcher(params, data);
            };
            return SelectAdapter;
          });
          S22.define("select2/data/array", [
            "./select",
            "../utils",
            "jquery"
          ], function(SelectAdapter, Utils, $8) {
            function ArrayAdapter($element, options) {
              this._dataToConvert = options.get("data") || [];
              ArrayAdapter.__super__.constructor.call(this, $element, options);
            }
            Utils.Extend(ArrayAdapter, SelectAdapter);
            ArrayAdapter.prototype.bind = function(container, $container) {
              ArrayAdapter.__super__.bind.call(this, container, $container);
              this.addOptions(this.convertToOptions(this._dataToConvert));
            };
            ArrayAdapter.prototype.select = function(data) {
              var $option = this.$element.find("option").filter(function(i2, elm) {
                return elm.value == data.id.toString();
              });
              if ($option.length === 0) {
                $option = this.option(data);
                this.addOptions($option);
              }
              ArrayAdapter.__super__.select.call(this, data);
            };
            ArrayAdapter.prototype.convertToOptions = function(data) {
              var self2 = this;
              var $existing = this.$element.find("option");
              var existingIds = $existing.map(function() {
                return self2.item($8(this)).id;
              }).get();
              var $options = [];
              function onlyItem(item2) {
                return function() {
                  return $8(this).val() == item2.id;
                };
              }
              for (var d2 = 0; d2 < data.length; d2++) {
                var item = this._normalizeItem(data[d2]);
                if (existingIds.indexOf(item.id) >= 0) {
                  var $existingOption = $existing.filter(onlyItem(item));
                  var existingData = this.item($existingOption);
                  var newData = $8.extend(true, {}, item, existingData);
                  var $newOption = this.option(newData);
                  $existingOption.replaceWith($newOption);
                  continue;
                }
                var $option = this.option(item);
                if (item.children) {
                  var $children = this.convertToOptions(item.children);
                  $option.append($children);
                }
                $options.push($option);
              }
              return $options;
            };
            return ArrayAdapter;
          });
          S22.define("select2/data/ajax", [
            "./array",
            "../utils",
            "jquery"
          ], function(ArrayAdapter, Utils, $8) {
            function AjaxAdapter($element, options) {
              this.ajaxOptions = this._applyDefaults(options.get("ajax"));
              if (this.ajaxOptions.processResults != null) {
                this.processResults = this.ajaxOptions.processResults;
              }
              AjaxAdapter.__super__.constructor.call(this, $element, options);
            }
            Utils.Extend(AjaxAdapter, ArrayAdapter);
            AjaxAdapter.prototype._applyDefaults = function(options) {
              var defaults = {
                data: function(params) {
                  return $8.extend({}, params, {
                    q: params.term
                  });
                },
                transport: function(params, success, failure) {
                  var $request = $8.ajax(params);
                  $request.then(success);
                  $request.fail(failure);
                  return $request;
                }
              };
              return $8.extend({}, defaults, options, true);
            };
            AjaxAdapter.prototype.processResults = function(results) {
              return results;
            };
            AjaxAdapter.prototype.query = function(params, callback) {
              var matches = [];
              var self2 = this;
              if (this._request != null) {
                if (typeof this._request.abort === "function") {
                  this._request.abort();
                }
                this._request = null;
              }
              var options = $8.extend({
                type: "GET"
              }, this.ajaxOptions);
              if (typeof options.url === "function") {
                options.url = options.url.call(this.$element, params);
              }
              if (typeof options.data === "function") {
                options.data = options.data.call(this.$element, params);
              }
              function request() {
                var $request = options.transport(options, function(data) {
                  var results = self2.processResults(data, params);
                  if (self2.options.get("debug") && window.console && console.error) {
                    if (!results || !results.results || !Array.isArray(results.results)) {
                      console.error(
                        "Select2: The AJAX results did not return an array in the `results` key of the response."
                      );
                    }
                  }
                  callback(results);
                }, function() {
                  if ("status" in $request && ($request.status === 0 || $request.status === "0")) {
                    return;
                  }
                  self2.trigger("results:message", {
                    message: "errorLoading"
                  });
                });
                self2._request = $request;
              }
              if (this.ajaxOptions.delay && params.term != null) {
                if (this._queryTimeout) {
                  window.clearTimeout(this._queryTimeout);
                }
                this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);
              } else {
                request();
              }
            };
            return AjaxAdapter;
          });
          S22.define("select2/data/tags", [
            "jquery"
          ], function($8) {
            function Tags(decorated, $element, options) {
              var tags = options.get("tags");
              var createTag = options.get("createTag");
              if (createTag !== void 0) {
                this.createTag = createTag;
              }
              var insertTag = options.get("insertTag");
              if (insertTag !== void 0) {
                this.insertTag = insertTag;
              }
              decorated.call(this, $element, options);
              if (Array.isArray(tags)) {
                for (var t2 = 0; t2 < tags.length; t2++) {
                  var tag = tags[t2];
                  var item = this._normalizeItem(tag);
                  var $option = this.option(item);
                  this.$element.append($option);
                }
              }
            }
            Tags.prototype.query = function(decorated, params, callback) {
              var self2 = this;
              this._removeOldTags();
              if (params.term == null || params.page != null) {
                decorated.call(this, params, callback);
                return;
              }
              function wrapper(obj, child) {
                var data = obj.results;
                for (var i2 = 0; i2 < data.length; i2++) {
                  var option = data[i2];
                  var checkChildren = option.children != null && !wrapper({
                    results: option.children
                  }, true);
                  var optionText = (option.text || "").toUpperCase();
                  var paramsTerm = (params.term || "").toUpperCase();
                  var checkText = optionText === paramsTerm;
                  if (checkText || checkChildren) {
                    if (child) {
                      return false;
                    }
                    obj.data = data;
                    callback(obj);
                    return;
                  }
                }
                if (child) {
                  return true;
                }
                var tag = self2.createTag(params);
                if (tag != null) {
                  var $option = self2.option(tag);
                  $option.attr("data-select2-tag", "true");
                  self2.addOptions([$option]);
                  self2.insertTag(data, tag);
                }
                obj.results = data;
                callback(obj);
              }
              decorated.call(this, params, wrapper);
            };
            Tags.prototype.createTag = function(decorated, params) {
              if (params.term == null) {
                return null;
              }
              var term = params.term.trim();
              if (term === "") {
                return null;
              }
              return {
                id: term,
                text: term
              };
            };
            Tags.prototype.insertTag = function(_2, data, tag) {
              data.unshift(tag);
            };
            Tags.prototype._removeOldTags = function(_2) {
              var $options = this.$element.find("option[data-select2-tag]");
              $options.each(function() {
                if (this.selected) {
                  return;
                }
                $8(this).remove();
              });
            };
            return Tags;
          });
          S22.define("select2/data/tokenizer", [
            "jquery"
          ], function($8) {
            function Tokenizer(decorated, $element, options) {
              var tokenizer = options.get("tokenizer");
              if (tokenizer !== void 0) {
                this.tokenizer = tokenizer;
              }
              decorated.call(this, $element, options);
            }
            Tokenizer.prototype.bind = function(decorated, container, $container) {
              decorated.call(this, container, $container);
              this.$search = container.dropdown.$search || container.selection.$search || $container.find(".select2-search__field");
            };
            Tokenizer.prototype.query = function(decorated, params, callback) {
              var self2 = this;
              function createAndSelect(data) {
                var item = self2._normalizeItem(data);
                var $existingOptions = self2.$element.find("option").filter(function() {
                  return $8(this).val() === item.id;
                });
                if (!$existingOptions.length) {
                  var $option = self2.option(item);
                  $option.attr("data-select2-tag", true);
                  self2._removeOldTags();
                  self2.addOptions([$option]);
                }
                select(item);
              }
              function select(data) {
                self2.trigger("select", {
                  data
                });
              }
              params.term = params.term || "";
              var tokenData = this.tokenizer(params, this.options, createAndSelect);
              if (tokenData.term !== params.term) {
                if (this.$search.length) {
                  this.$search.val(tokenData.term);
                  this.$search.trigger("focus");
                }
                params.term = tokenData.term;
              }
              decorated.call(this, params, callback);
            };
            Tokenizer.prototype.tokenizer = function(_2, params, options, callback) {
              var separators = options.get("tokenSeparators") || [];
              var term = params.term;
              var i2 = 0;
              var createTag = this.createTag || function(params2) {
                return {
                  id: params2.term,
                  text: params2.term
                };
              };
              while (i2 < term.length) {
                var termChar = term[i2];
                if (separators.indexOf(termChar) === -1) {
                  i2++;
                  continue;
                }
                var part = term.substr(0, i2);
                var partParams = $8.extend({}, params, {
                  term: part
                });
                var data = createTag(partParams);
                if (data == null) {
                  i2++;
                  continue;
                }
                callback(data);
                term = term.substr(i2 + 1) || "";
                i2 = 0;
              }
              return {
                term
              };
            };
            return Tokenizer;
          });
          S22.define("select2/data/minimumInputLength", [], function() {
            function MinimumInputLength(decorated, $e, options) {
              this.minimumInputLength = options.get("minimumInputLength");
              decorated.call(this, $e, options);
            }
            MinimumInputLength.prototype.query = function(decorated, params, callback) {
              params.term = params.term || "";
              if (params.term.length < this.minimumInputLength) {
                this.trigger("results:message", {
                  message: "inputTooShort",
                  args: {
                    minimum: this.minimumInputLength,
                    input: params.term,
                    params
                  }
                });
                return;
              }
              decorated.call(this, params, callback);
            };
            return MinimumInputLength;
          });
          S22.define("select2/data/maximumInputLength", [], function() {
            function MaximumInputLength(decorated, $e, options) {
              this.maximumInputLength = options.get("maximumInputLength");
              decorated.call(this, $e, options);
            }
            MaximumInputLength.prototype.query = function(decorated, params, callback) {
              params.term = params.term || "";
              if (this.maximumInputLength > 0 && params.term.length > this.maximumInputLength) {
                this.trigger("results:message", {
                  message: "inputTooLong",
                  args: {
                    maximum: this.maximumInputLength,
                    input: params.term,
                    params
                  }
                });
                return;
              }
              decorated.call(this, params, callback);
            };
            return MaximumInputLength;
          });
          S22.define("select2/data/maximumSelectionLength", [], function() {
            function MaximumSelectionLength(decorated, $e, options) {
              this.maximumSelectionLength = options.get("maximumSelectionLength");
              decorated.call(this, $e, options);
            }
            MaximumSelectionLength.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              container.on("select", function() {
                self2._checkIfMaximumSelected();
              });
            };
            MaximumSelectionLength.prototype.query = function(decorated, params, callback) {
              var self2 = this;
              this._checkIfMaximumSelected(function() {
                decorated.call(self2, params, callback);
              });
            };
            MaximumSelectionLength.prototype._checkIfMaximumSelected = function(_2, successCallback) {
              var self2 = this;
              this.current(function(currentData) {
                var count = currentData != null ? currentData.length : 0;
                if (self2.maximumSelectionLength > 0 && count >= self2.maximumSelectionLength) {
                  self2.trigger("results:message", {
                    message: "maximumSelected",
                    args: {
                      maximum: self2.maximumSelectionLength
                    }
                  });
                  return;
                }
                if (successCallback) {
                  successCallback();
                }
              });
            };
            return MaximumSelectionLength;
          });
          S22.define("select2/dropdown", [
            "jquery",
            "./utils"
          ], function($8, Utils) {
            function Dropdown2($element, options) {
              this.$element = $element;
              this.options = options;
              Dropdown2.__super__.constructor.call(this);
            }
            Utils.Extend(Dropdown2, Utils.Observable);
            Dropdown2.prototype.render = function() {
              var $dropdown = $8(
                '<span class="select2-dropdown"><span class="select2-results"></span></span>'
              );
              $dropdown.attr("dir", this.options.get("dir"));
              this.$dropdown = $dropdown;
              return $dropdown;
            };
            Dropdown2.prototype.bind = function() {
            };
            Dropdown2.prototype.position = function($dropdown, $container) {
            };
            Dropdown2.prototype.destroy = function() {
              this.$dropdown.remove();
            };
            return Dropdown2;
          });
          S22.define("select2/dropdown/search", [
            "jquery"
          ], function($8) {
            function Search() {
            }
            Search.prototype.render = function(decorated) {
              var $rendered = decorated.call(this);
              var searchLabel = this.options.get("translations").get("search");
              var $search = $8(
                '<span class="select2-search select2-search--dropdown"><input class="select2-search__field" type="search" tabindex="-1" autocorrect="off" autocapitalize="none" spellcheck="false" role="searchbox" aria-autocomplete="list" /></span>'
              );
              this.$searchContainer = $search;
              this.$search = $search.find("input");
              this.$search.prop("autocomplete", this.options.get("autocomplete"));
              this.$search.attr("aria-label", searchLabel());
              $rendered.prepend($search);
              return $rendered;
            };
            Search.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              var resultsId = container.id + "-results";
              decorated.call(this, container, $container);
              this.$search.on("keydown", function(evt) {
                self2.trigger("keypress", evt);
                self2._keyUpPrevented = evt.isDefaultPrevented();
              });
              this.$search.on("input", function(evt) {
                $8(this).off("keyup");
              });
              this.$search.on("keyup input", function(evt) {
                self2.handleSearch(evt);
              });
              container.on("open", function() {
                self2.$search.attr("tabindex", 0);
                self2.$search.attr("aria-controls", resultsId);
                self2.$search.trigger("focus");
                window.setTimeout(function() {
                  self2.$search.trigger("focus");
                }, 0);
              });
              container.on("close", function() {
                self2.$search.attr("tabindex", -1);
                self2.$search.removeAttr("aria-controls");
                self2.$search.removeAttr("aria-activedescendant");
                self2.$search.val("");
                self2.$search.trigger("blur");
              });
              container.on("focus", function() {
                if (!container.isOpen()) {
                  self2.$search.trigger("focus");
                }
              });
              container.on("results:all", function(params) {
                if (params.query.term == null || params.query.term === "") {
                  var showSearch = self2.showSearch(params);
                  if (showSearch) {
                    self2.$searchContainer[0].classList.remove("select2-search--hide");
                  } else {
                    self2.$searchContainer[0].classList.add("select2-search--hide");
                  }
                }
              });
              container.on("results:focus", function(params) {
                if (params.data._resultId) {
                  self2.$search.attr("aria-activedescendant", params.data._resultId);
                } else {
                  self2.$search.removeAttr("aria-activedescendant");
                }
              });
            };
            Search.prototype.handleSearch = function(evt) {
              if (!this._keyUpPrevented) {
                var input = this.$search.val();
                this.trigger("query", {
                  term: input
                });
              }
              this._keyUpPrevented = false;
            };
            Search.prototype.showSearch = function(_2, params) {
              return true;
            };
            return Search;
          });
          S22.define("select2/dropdown/hidePlaceholder", [], function() {
            function HidePlaceholder(decorated, $element, options, dataAdapter) {
              this.placeholder = this.normalizePlaceholder(options.get("placeholder"));
              decorated.call(this, $element, options, dataAdapter);
            }
            HidePlaceholder.prototype.append = function(decorated, data) {
              data.results = this.removePlaceholder(data.results);
              decorated.call(this, data);
            };
            HidePlaceholder.prototype.normalizePlaceholder = function(_2, placeholder) {
              if (typeof placeholder === "string") {
                placeholder = {
                  id: "",
                  text: placeholder
                };
              }
              return placeholder;
            };
            HidePlaceholder.prototype.removePlaceholder = function(_2, data) {
              var modifiedData = data.slice(0);
              for (var d2 = data.length - 1; d2 >= 0; d2--) {
                var item = data[d2];
                if (this.placeholder.id === item.id) {
                  modifiedData.splice(d2, 1);
                }
              }
              return modifiedData;
            };
            return HidePlaceholder;
          });
          S22.define("select2/dropdown/infiniteScroll", [
            "jquery"
          ], function($8) {
            function InfiniteScroll(decorated, $element, options, dataAdapter) {
              this.lastParams = {};
              decorated.call(this, $element, options, dataAdapter);
              this.$loadingMore = this.createLoadingMore();
              this.loading = false;
            }
            InfiniteScroll.prototype.append = function(decorated, data) {
              this.$loadingMore.remove();
              this.loading = false;
              decorated.call(this, data);
              if (this.showLoadingMore(data)) {
                this.$results.append(this.$loadingMore);
                this.loadMoreIfNeeded();
              }
            };
            InfiniteScroll.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              container.on("query", function(params) {
                self2.lastParams = params;
                self2.loading = true;
              });
              container.on("query:append", function(params) {
                self2.lastParams = params;
                self2.loading = true;
              });
              this.$results.on("scroll", this.loadMoreIfNeeded.bind(this));
            };
            InfiniteScroll.prototype.loadMoreIfNeeded = function() {
              var isLoadMoreVisible = $8.contains(
                document.documentElement,
                this.$loadingMore[0]
              );
              if (this.loading || !isLoadMoreVisible) {
                return;
              }
              var currentOffset = this.$results.offset().top + this.$results.outerHeight(false);
              var loadingMoreOffset = this.$loadingMore.offset().top + this.$loadingMore.outerHeight(false);
              if (currentOffset + 50 >= loadingMoreOffset) {
                this.loadMore();
              }
            };
            InfiniteScroll.prototype.loadMore = function() {
              this.loading = true;
              var params = $8.extend({}, { page: 1 }, this.lastParams);
              params.page++;
              this.trigger("query:append", params);
            };
            InfiniteScroll.prototype.showLoadingMore = function(_2, data) {
              return data.pagination && data.pagination.more;
            };
            InfiniteScroll.prototype.createLoadingMore = function() {
              var $option = $8(
                '<li class="select2-results__option select2-results__option--load-more"role="option" aria-disabled="true"></li>'
              );
              var message = this.options.get("translations").get("loadingMore");
              $option.html(message(this.lastParams));
              return $option;
            };
            return InfiniteScroll;
          });
          S22.define("select2/dropdown/attachBody", [
            "jquery",
            "../utils"
          ], function($8, Utils) {
            function AttachBody(decorated, $element, options) {
              this.$dropdownParent = $8(options.get("dropdownParent") || document.body);
              decorated.call(this, $element, options);
            }
            AttachBody.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              container.on("open", function() {
                self2._showDropdown();
                self2._attachPositioningHandler(container);
                self2._bindContainerResultHandlers(container);
              });
              container.on("close", function() {
                self2._hideDropdown();
                self2._detachPositioningHandler(container);
              });
              this.$dropdownContainer.on("mousedown", function(evt) {
                evt.stopPropagation();
              });
            };
            AttachBody.prototype.destroy = function(decorated) {
              decorated.call(this);
              this.$dropdownContainer.remove();
            };
            AttachBody.prototype.position = function(decorated, $dropdown, $container) {
              $dropdown.attr("class", $container.attr("class"));
              $dropdown[0].classList.remove("select2");
              $dropdown[0].classList.add("select2-container--open");
              $dropdown.css({
                position: "absolute",
                top: -999999
              });
              this.$container = $container;
            };
            AttachBody.prototype.render = function(decorated) {
              var $container = $8("<span></span>");
              var $dropdown = decorated.call(this);
              $container.append($dropdown);
              this.$dropdownContainer = $container;
              return $container;
            };
            AttachBody.prototype._hideDropdown = function(decorated) {
              this.$dropdownContainer.detach();
            };
            AttachBody.prototype._bindContainerResultHandlers = function(decorated, container) {
              if (this._containerResultsHandlersBound) {
                return;
              }
              var self2 = this;
              container.on("results:all", function() {
                self2._positionDropdown();
                self2._resizeDropdown();
              });
              container.on("results:append", function() {
                self2._positionDropdown();
                self2._resizeDropdown();
              });
              container.on("results:message", function() {
                self2._positionDropdown();
                self2._resizeDropdown();
              });
              container.on("select", function() {
                self2._positionDropdown();
                self2._resizeDropdown();
              });
              container.on("unselect", function() {
                self2._positionDropdown();
                self2._resizeDropdown();
              });
              this._containerResultsHandlersBound = true;
            };
            AttachBody.prototype._attachPositioningHandler = function(decorated, container) {
              var self2 = this;
              var scrollEvent = "scroll.select2." + container.id;
              var resizeEvent = "resize.select2." + container.id;
              var orientationEvent = "orientationchange.select2." + container.id;
              var $watchers = this.$container.parents().filter(Utils.hasScroll);
              $watchers.each(function() {
                Utils.StoreData(this, "select2-scroll-position", {
                  x: $8(this).scrollLeft(),
                  y: $8(this).scrollTop()
                });
              });
              $watchers.on(scrollEvent, function(ev) {
                var position = Utils.GetData(this, "select2-scroll-position");
                $8(this).scrollTop(position.y);
              });
              $8(window).on(
                scrollEvent + " " + resizeEvent + " " + orientationEvent,
                function(e2) {
                  self2._positionDropdown();
                  self2._resizeDropdown();
                }
              );
            };
            AttachBody.prototype._detachPositioningHandler = function(decorated, container) {
              var scrollEvent = "scroll.select2." + container.id;
              var resizeEvent = "resize.select2." + container.id;
              var orientationEvent = "orientationchange.select2." + container.id;
              var $watchers = this.$container.parents().filter(Utils.hasScroll);
              $watchers.off(scrollEvent);
              $8(window).off(scrollEvent + " " + resizeEvent + " " + orientationEvent);
            };
            AttachBody.prototype._positionDropdown = function() {
              var $window = $8(window);
              var isCurrentlyAbove = this.$dropdown[0].classList.contains("select2-dropdown--above");
              var isCurrentlyBelow = this.$dropdown[0].classList.contains("select2-dropdown--below");
              var newDirection = null;
              var offset2 = this.$container.offset();
              offset2.bottom = offset2.top + this.$container.outerHeight(false);
              var container = {
                height: this.$container.outerHeight(false)
              };
              container.top = offset2.top;
              container.bottom = offset2.top + container.height;
              var dropdown = {
                height: this.$dropdown.outerHeight(false)
              };
              var viewport2 = {
                top: $window.scrollTop(),
                bottom: $window.scrollTop() + $window.height()
              };
              var enoughRoomAbove = viewport2.top < offset2.top - dropdown.height;
              var enoughRoomBelow = viewport2.bottom > offset2.bottom + dropdown.height;
              var css = {
                left: offset2.left,
                top: container.bottom
              };
              var $offsetParent = this.$dropdownParent;
              if ($offsetParent.css("position") === "static") {
                $offsetParent = $offsetParent.offsetParent();
              }
              var parentOffset = {
                top: 0,
                left: 0
              };
              if ($8.contains(document.body, $offsetParent[0]) || $offsetParent[0].isConnected) {
                parentOffset = $offsetParent.offset();
              }
              css.top -= parentOffset.top;
              css.left -= parentOffset.left;
              if (!isCurrentlyAbove && !isCurrentlyBelow) {
                newDirection = "below";
              }
              if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
                newDirection = "above";
              } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
                newDirection = "below";
              }
              if (newDirection == "above" || isCurrentlyAbove && newDirection !== "below") {
                css.top = container.top - parentOffset.top - dropdown.height;
              }
              if (newDirection != null) {
                this.$dropdown[0].classList.remove("select2-dropdown--below");
                this.$dropdown[0].classList.remove("select2-dropdown--above");
                this.$dropdown[0].classList.add("select2-dropdown--" + newDirection);
                this.$container[0].classList.remove("select2-container--below");
                this.$container[0].classList.remove("select2-container--above");
                this.$container[0].classList.add("select2-container--" + newDirection);
              }
              this.$dropdownContainer.css(css);
            };
            AttachBody.prototype._resizeDropdown = function() {
              var css = {
                width: this.$container.outerWidth(false) + "px"
              };
              if (this.options.get("dropdownAutoWidth")) {
                css.minWidth = css.width;
                css.position = "relative";
                css.width = "auto";
              }
              this.$dropdown.css(css);
            };
            AttachBody.prototype._showDropdown = function(decorated) {
              this.$dropdownContainer.appendTo(this.$dropdownParent);
              this._positionDropdown();
              this._resizeDropdown();
            };
            return AttachBody;
          });
          S22.define("select2/dropdown/minimumResultsForSearch", [], function() {
            function countResults(data) {
              var count = 0;
              for (var d2 = 0; d2 < data.length; d2++) {
                var item = data[d2];
                if (item.children) {
                  count += countResults(item.children);
                } else {
                  count++;
                }
              }
              return count;
            }
            function MinimumResultsForSearch(decorated, $element, options, dataAdapter) {
              this.minimumResultsForSearch = options.get("minimumResultsForSearch");
              if (this.minimumResultsForSearch < 0) {
                this.minimumResultsForSearch = Infinity;
              }
              decorated.call(this, $element, options, dataAdapter);
            }
            MinimumResultsForSearch.prototype.showSearch = function(decorated, params) {
              if (countResults(params.data.results) < this.minimumResultsForSearch) {
                return false;
              }
              return decorated.call(this, params);
            };
            return MinimumResultsForSearch;
          });
          S22.define("select2/dropdown/selectOnClose", [
            "../utils"
          ], function(Utils) {
            function SelectOnClose() {
            }
            SelectOnClose.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              container.on("close", function(params) {
                self2._handleSelectOnClose(params);
              });
            };
            SelectOnClose.prototype._handleSelectOnClose = function(_2, params) {
              if (params && params.originalSelect2Event != null) {
                var event = params.originalSelect2Event;
                if (event._type === "select" || event._type === "unselect") {
                  return;
                }
              }
              var $highlightedResults = this.getHighlightedResults();
              if ($highlightedResults.length < 1) {
                return;
              }
              var data = Utils.GetData($highlightedResults[0], "data");
              if (data.element != null && data.element.selected || data.element == null && data.selected) {
                return;
              }
              this.trigger("select", {
                data
              });
            };
            return SelectOnClose;
          });
          S22.define("select2/dropdown/closeOnSelect", [], function() {
            function CloseOnSelect() {
            }
            CloseOnSelect.prototype.bind = function(decorated, container, $container) {
              var self2 = this;
              decorated.call(this, container, $container);
              container.on("select", function(evt) {
                self2._selectTriggered(evt);
              });
              container.on("unselect", function(evt) {
                self2._selectTriggered(evt);
              });
            };
            CloseOnSelect.prototype._selectTriggered = function(_2, evt) {
              var originalEvent = evt.originalEvent;
              if (originalEvent && (originalEvent.ctrlKey || originalEvent.metaKey)) {
                return;
              }
              this.trigger("close", {
                originalEvent,
                originalSelect2Event: evt
              });
            };
            return CloseOnSelect;
          });
          S22.define("select2/dropdown/dropdownCss", [
            "../utils"
          ], function(Utils) {
            function DropdownCSS() {
            }
            DropdownCSS.prototype.render = function(decorated) {
              var $dropdown = decorated.call(this);
              var dropdownCssClass = this.options.get("dropdownCssClass") || "";
              if (dropdownCssClass.indexOf(":all:") !== -1) {
                dropdownCssClass = dropdownCssClass.replace(":all:", "");
                Utils.copyNonInternalCssClasses($dropdown[0], this.$element[0]);
              }
              $dropdown.addClass(dropdownCssClass);
              return $dropdown;
            };
            return DropdownCSS;
          });
          S22.define("select2/dropdown/tagsSearchHighlight", [
            "../utils"
          ], function(Utils) {
            function TagsSearchHighlight() {
            }
            TagsSearchHighlight.prototype.highlightFirstItem = function(decorated) {
              var $options = this.$results.find(
                ".select2-results__option--selectable:not(.select2-results__option--selected)"
              );
              if ($options.length > 0) {
                var $firstOption = $options.first();
                var data = Utils.GetData($firstOption[0], "data");
                var firstElement = data.element;
                if (firstElement && firstElement.getAttribute) {
                  if (firstElement.getAttribute("data-select2-tag") === "true") {
                    $firstOption.trigger("mouseenter");
                    return;
                  }
                }
              }
              decorated.call(this);
            };
            return TagsSearchHighlight;
          });
          S22.define("select2/i18n/en", [], function() {
            return {
              errorLoading: function() {
                return "The results could not be loaded.";
              },
              inputTooLong: function(args) {
                var overChars = args.input.length - args.maximum;
                var message = "Please delete " + overChars + " character";
                if (overChars != 1) {
                  message += "s";
                }
                return message;
              },
              inputTooShort: function(args) {
                var remainingChars = args.minimum - args.input.length;
                var message = "Please enter " + remainingChars + " or more characters";
                return message;
              },
              loadingMore: function() {
                return "Loading more results\u2026";
              },
              maximumSelected: function(args) {
                var message = "You can only select " + args.maximum + " item";
                if (args.maximum != 1) {
                  message += "s";
                }
                return message;
              },
              noResults: function() {
                return "No results found";
              },
              searching: function() {
                return "Searching\u2026";
              },
              removeAllItems: function() {
                return "Remove all items";
              },
              removeItem: function() {
                return "Remove item";
              },
              search: function() {
                return "Search";
              }
            };
          });
          S22.define("select2/defaults", [
            "jquery",
            "./results",
            "./selection/single",
            "./selection/multiple",
            "./selection/placeholder",
            "./selection/allowClear",
            "./selection/search",
            "./selection/selectionCss",
            "./selection/eventRelay",
            "./utils",
            "./translation",
            "./diacritics",
            "./data/select",
            "./data/array",
            "./data/ajax",
            "./data/tags",
            "./data/tokenizer",
            "./data/minimumInputLength",
            "./data/maximumInputLength",
            "./data/maximumSelectionLength",
            "./dropdown",
            "./dropdown/search",
            "./dropdown/hidePlaceholder",
            "./dropdown/infiniteScroll",
            "./dropdown/attachBody",
            "./dropdown/minimumResultsForSearch",
            "./dropdown/selectOnClose",
            "./dropdown/closeOnSelect",
            "./dropdown/dropdownCss",
            "./dropdown/tagsSearchHighlight",
            "./i18n/en"
          ], function($8, ResultsList, SingleSelection, MultipleSelection, Placeholder, AllowClear, SelectionSearch, SelectionCSS, EventRelay, Utils, Translation, DIACRITICS, SelectData, ArrayData, AjaxData, Tags, Tokenizer, MinimumInputLength, MaximumInputLength, MaximumSelectionLength, Dropdown2, DropdownSearch, HidePlaceholder, InfiniteScroll, AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect, DropdownCSS, TagsSearchHighlight, EnglishTranslation) {
            function Defaults() {
              this.reset();
            }
            Defaults.prototype.apply = function(options) {
              options = $8.extend(true, {}, this.defaults, options);
              if (options.dataAdapter == null) {
                if (options.ajax != null) {
                  options.dataAdapter = AjaxData;
                } else if (options.data != null) {
                  options.dataAdapter = ArrayData;
                } else {
                  options.dataAdapter = SelectData;
                }
                if (options.minimumInputLength > 0) {
                  options.dataAdapter = Utils.Decorate(
                    options.dataAdapter,
                    MinimumInputLength
                  );
                }
                if (options.maximumInputLength > 0) {
                  options.dataAdapter = Utils.Decorate(
                    options.dataAdapter,
                    MaximumInputLength
                  );
                }
                if (options.maximumSelectionLength > 0) {
                  options.dataAdapter = Utils.Decorate(
                    options.dataAdapter,
                    MaximumSelectionLength
                  );
                }
                if (options.tags) {
                  options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
                }
                if (options.tokenSeparators != null || options.tokenizer != null) {
                  options.dataAdapter = Utils.Decorate(
                    options.dataAdapter,
                    Tokenizer
                  );
                }
              }
              if (options.resultsAdapter == null) {
                options.resultsAdapter = ResultsList;
                if (options.ajax != null) {
                  options.resultsAdapter = Utils.Decorate(
                    options.resultsAdapter,
                    InfiniteScroll
                  );
                }
                if (options.placeholder != null) {
                  options.resultsAdapter = Utils.Decorate(
                    options.resultsAdapter,
                    HidePlaceholder
                  );
                }
                if (options.selectOnClose) {
                  options.resultsAdapter = Utils.Decorate(
                    options.resultsAdapter,
                    SelectOnClose
                  );
                }
                if (options.tags) {
                  options.resultsAdapter = Utils.Decorate(
                    options.resultsAdapter,
                    TagsSearchHighlight
                  );
                }
              }
              if (options.dropdownAdapter == null) {
                if (options.multiple) {
                  options.dropdownAdapter = Dropdown2;
                } else {
                  var SearchableDropdown = Utils.Decorate(Dropdown2, DropdownSearch);
                  options.dropdownAdapter = SearchableDropdown;
                }
                if (options.minimumResultsForSearch !== 0) {
                  options.dropdownAdapter = Utils.Decorate(
                    options.dropdownAdapter,
                    MinimumResultsForSearch
                  );
                }
                if (options.closeOnSelect) {
                  options.dropdownAdapter = Utils.Decorate(
                    options.dropdownAdapter,
                    CloseOnSelect
                  );
                }
                if (options.dropdownCssClass != null) {
                  options.dropdownAdapter = Utils.Decorate(
                    options.dropdownAdapter,
                    DropdownCSS
                  );
                }
                options.dropdownAdapter = Utils.Decorate(
                  options.dropdownAdapter,
                  AttachBody
                );
              }
              if (options.selectionAdapter == null) {
                if (options.multiple) {
                  options.selectionAdapter = MultipleSelection;
                } else {
                  options.selectionAdapter = SingleSelection;
                }
                if (options.placeholder != null) {
                  options.selectionAdapter = Utils.Decorate(
                    options.selectionAdapter,
                    Placeholder
                  );
                }
                if (options.allowClear) {
                  options.selectionAdapter = Utils.Decorate(
                    options.selectionAdapter,
                    AllowClear
                  );
                }
                if (options.multiple) {
                  options.selectionAdapter = Utils.Decorate(
                    options.selectionAdapter,
                    SelectionSearch
                  );
                }
                if (options.selectionCssClass != null) {
                  options.selectionAdapter = Utils.Decorate(
                    options.selectionAdapter,
                    SelectionCSS
                  );
                }
                options.selectionAdapter = Utils.Decorate(
                  options.selectionAdapter,
                  EventRelay
                );
              }
              options.language = this._resolveLanguage(options.language);
              options.language.push("en");
              var uniqueLanguages = [];
              for (var l2 = 0; l2 < options.language.length; l2++) {
                var language = options.language[l2];
                if (uniqueLanguages.indexOf(language) === -1) {
                  uniqueLanguages.push(language);
                }
              }
              options.language = uniqueLanguages;
              options.translations = this._processTranslations(
                options.language,
                options.debug
              );
              return options;
            };
            Defaults.prototype.reset = function() {
              function stripDiacritics(text) {
                function match(a2) {
                  return DIACRITICS[a2] || a2;
                }
                return text.replace(/[^\u0000-\u007E]/g, match);
              }
              function matcher(params, data) {
                if (params.term == null || params.term.trim() === "") {
                  return data;
                }
                if (data.children && data.children.length > 0) {
                  var match = $8.extend(true, {}, data);
                  for (var c2 = data.children.length - 1; c2 >= 0; c2--) {
                    var child = data.children[c2];
                    var matches = matcher(params, child);
                    if (matches == null) {
                      match.children.splice(c2, 1);
                    }
                  }
                  if (match.children.length > 0) {
                    return match;
                  }
                  return matcher(params, match);
                }
                var original = stripDiacritics(data.text).toUpperCase();
                var term = stripDiacritics(params.term).toUpperCase();
                if (original.indexOf(term) > -1) {
                  return data;
                }
                return null;
              }
              this.defaults = {
                amdLanguageBase: "./i18n/",
                autocomplete: "off",
                closeOnSelect: true,
                debug: false,
                dropdownAutoWidth: false,
                escapeMarkup: Utils.escapeMarkup,
                language: {},
                matcher,
                minimumInputLength: 0,
                maximumInputLength: 0,
                maximumSelectionLength: 0,
                minimumResultsForSearch: 0,
                selectOnClose: false,
                scrollAfterSelect: false,
                sorter: function(data) {
                  return data;
                },
                templateResult: function(result) {
                  return result.text;
                },
                templateSelection: function(selection) {
                  return selection.text;
                },
                theme: "default",
                width: "resolve"
              };
            };
            Defaults.prototype.applyFromElement = function(options, $element) {
              var optionLanguage = options.language;
              var defaultLanguage = this.defaults.language;
              var elementLanguage = $element.prop("lang");
              var parentLanguage = $element.closest("[lang]").prop("lang");
              var languages = Array.prototype.concat.call(
                this._resolveLanguage(elementLanguage),
                this._resolveLanguage(optionLanguage),
                this._resolveLanguage(defaultLanguage),
                this._resolveLanguage(parentLanguage)
              );
              options.language = languages;
              return options;
            };
            Defaults.prototype._resolveLanguage = function(language) {
              if (!language) {
                return [];
              }
              if ($8.isEmptyObject(language)) {
                return [];
              }
              if ($8.isPlainObject(language)) {
                return [language];
              }
              var languages;
              if (!Array.isArray(language)) {
                languages = [language];
              } else {
                languages = language;
              }
              var resolvedLanguages = [];
              for (var l2 = 0; l2 < languages.length; l2++) {
                resolvedLanguages.push(languages[l2]);
                if (typeof languages[l2] === "string" && languages[l2].indexOf("-") > 0) {
                  var languageParts = languages[l2].split("-");
                  var baseLanguage = languageParts[0];
                  resolvedLanguages.push(baseLanguage);
                }
              }
              return resolvedLanguages;
            };
            Defaults.prototype._processTranslations = function(languages, debug) {
              var translations = new Translation();
              for (var l2 = 0; l2 < languages.length; l2++) {
                var languageData = new Translation();
                var language = languages[l2];
                if (typeof language === "string") {
                  try {
                    languageData = Translation.loadPath(language);
                  } catch (e2) {
                    try {
                      language = this.defaults.amdLanguageBase + language;
                      languageData = Translation.loadPath(language);
                    } catch (ex) {
                      if (debug && window.console && console.warn) {
                        console.warn(
                          'Select2: The language file for "' + language + '" could not be automatically loaded. A fallback will be used instead.'
                        );
                      }
                    }
                  }
                } else if ($8.isPlainObject(language)) {
                  languageData = new Translation(language);
                } else {
                  languageData = language;
                }
                translations.extend(languageData);
              }
              return translations;
            };
            Defaults.prototype.set = function(key, value) {
              var camelKey = $8.camelCase(key);
              var data = {};
              data[camelKey] = value;
              var convertedData = Utils._convertData(data);
              $8.extend(true, this.defaults, convertedData);
            };
            var defaults = new Defaults();
            return defaults;
          });
          S22.define("select2/options", [
            "jquery",
            "./defaults",
            "./utils"
          ], function($8, Defaults, Utils) {
            function Options(options, $element) {
              this.options = options;
              if ($element != null) {
                this.fromElement($element);
              }
              if ($element != null) {
                this.options = Defaults.applyFromElement(this.options, $element);
              }
              this.options = Defaults.apply(this.options);
            }
            Options.prototype.fromElement = function($e) {
              var excludedData = ["select2"];
              if (this.options.multiple == null) {
                this.options.multiple = $e.prop("multiple");
              }
              if (this.options.disabled == null) {
                this.options.disabled = $e.prop("disabled");
              }
              if (this.options.autocomplete == null && $e.prop("autocomplete")) {
                this.options.autocomplete = $e.prop("autocomplete");
              }
              if (this.options.dir == null) {
                if ($e.prop("dir")) {
                  this.options.dir = $e.prop("dir");
                } else if ($e.closest("[dir]").prop("dir")) {
                  this.options.dir = $e.closest("[dir]").prop("dir");
                } else {
                  this.options.dir = "ltr";
                }
              }
              $e.prop("disabled", this.options.disabled);
              $e.prop("multiple", this.options.multiple);
              if (Utils.GetData($e[0], "select2Tags")) {
                if (this.options.debug && window.console && console.warn) {
                  console.warn(
                    'Select2: The `data-select2-tags` attribute has been changed to use the `data-data` and `data-tags="true"` attributes and will be removed in future versions of Select2.'
                  );
                }
                Utils.StoreData($e[0], "data", Utils.GetData($e[0], "select2Tags"));
                Utils.StoreData($e[0], "tags", true);
              }
              if (Utils.GetData($e[0], "ajaxUrl")) {
                if (this.options.debug && window.console && console.warn) {
                  console.warn(
                    "Select2: The `data-ajax-url` attribute has been changed to `data-ajax--url` and support for the old attribute will be removed in future versions of Select2."
                  );
                }
                $e.attr("ajax--url", Utils.GetData($e[0], "ajaxUrl"));
                Utils.StoreData($e[0], "ajax-Url", Utils.GetData($e[0], "ajaxUrl"));
              }
              var dataset = {};
              function upperCaseLetter(_2, letter) {
                return letter.toUpperCase();
              }
              for (var attr = 0; attr < $e[0].attributes.length; attr++) {
                var attributeName = $e[0].attributes[attr].name;
                var prefix = "data-";
                if (attributeName.substr(0, prefix.length) == prefix) {
                  var dataName = attributeName.substring(prefix.length);
                  var dataValue = Utils.GetData($e[0], dataName);
                  var camelDataName = dataName.replace(/-([a-z])/g, upperCaseLetter);
                  dataset[camelDataName] = dataValue;
                }
              }
              if ($8.fn.jquery && $8.fn.jquery.substr(0, 2) == "1." && $e[0].dataset) {
                dataset = $8.extend(true, {}, $e[0].dataset, dataset);
              }
              var data = $8.extend(true, {}, Utils.GetData($e[0]), dataset);
              data = Utils._convertData(data);
              for (var key in data) {
                if (excludedData.indexOf(key) > -1) {
                  continue;
                }
                if ($8.isPlainObject(this.options[key])) {
                  $8.extend(this.options[key], data[key]);
                } else {
                  this.options[key] = data[key];
                }
              }
              return this;
            };
            Options.prototype.get = function(key) {
              return this.options[key];
            };
            Options.prototype.set = function(key, val) {
              this.options[key] = val;
            };
            return Options;
          });
          S22.define("select2/core", [
            "jquery",
            "./options",
            "./utils",
            "./keys"
          ], function($8, Options, Utils, KEYS) {
            var Select22 = function($element, options) {
              if (Utils.GetData($element[0], "select2") != null) {
                Utils.GetData($element[0], "select2").destroy();
              }
              this.$element = $element;
              this.id = this._generateId($element);
              options = options || {};
              this.options = new Options(options, $element);
              Select22.__super__.constructor.call(this);
              var tabindex = $element.attr("tabindex") || 0;
              Utils.StoreData($element[0], "old-tabindex", tabindex);
              $element.attr("tabindex", "-1");
              var DataAdapter = this.options.get("dataAdapter");
              this.dataAdapter = new DataAdapter($element, this.options);
              var $container = this.render();
              this._placeContainer($container);
              var SelectionAdapter = this.options.get("selectionAdapter");
              this.selection = new SelectionAdapter($element, this.options);
              this.$selection = this.selection.render();
              this.selection.position(this.$selection, $container);
              var DropdownAdapter = this.options.get("dropdownAdapter");
              this.dropdown = new DropdownAdapter($element, this.options);
              this.$dropdown = this.dropdown.render();
              this.dropdown.position(this.$dropdown, $container);
              var ResultsAdapter = this.options.get("resultsAdapter");
              this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
              this.$results = this.results.render();
              this.results.position(this.$results, this.$dropdown);
              var self2 = this;
              this._bindAdapters();
              this._registerDomEvents();
              this._registerDataEvents();
              this._registerSelectionEvents();
              this._registerDropdownEvents();
              this._registerResultsEvents();
              this._registerEvents();
              this.dataAdapter.current(function(initialData) {
                self2.trigger("selection:update", {
                  data: initialData
                });
              });
              $element[0].classList.add("select2-hidden-accessible");
              $element.attr("aria-hidden", "true");
              this._syncAttributes();
              Utils.StoreData($element[0], "select2", this);
              $element.data("select2", this);
            };
            Utils.Extend(Select22, Utils.Observable);
            Select22.prototype._generateId = function($element) {
              var id = "";
              if ($element.attr("id") != null) {
                id = $element.attr("id");
              } else if ($element.attr("name") != null) {
                id = $element.attr("name") + "-" + Utils.generateChars(2);
              } else {
                id = Utils.generateChars(4);
              }
              id = id.replace(/(:|\.|\[|\]|,)/g, "");
              id = "select2-" + id;
              return id;
            };
            Select22.prototype._placeContainer = function($container) {
              $container.insertAfter(this.$element);
              var width = this._resolveWidth(this.$element, this.options.get("width"));
              if (width != null) {
                $container.css("width", width);
              }
            };
            Select22.prototype._resolveWidth = function($element, method) {
              var WIDTH2 = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;
              if (method == "resolve") {
                var styleWidth = this._resolveWidth($element, "style");
                if (styleWidth != null) {
                  return styleWidth;
                }
                return this._resolveWidth($element, "element");
              }
              if (method == "element") {
                var elementWidth = $element.outerWidth(false);
                if (elementWidth <= 0) {
                  return "auto";
                }
                return elementWidth + "px";
              }
              if (method == "style") {
                var style = $element.attr("style");
                if (typeof style !== "string") {
                  return null;
                }
                var attrs = style.split(";");
                for (var i2 = 0, l2 = attrs.length; i2 < l2; i2 = i2 + 1) {
                  var attr = attrs[i2].replace(/\s/g, "");
                  var matches = attr.match(WIDTH2);
                  if (matches !== null && matches.length >= 1) {
                    return matches[1];
                  }
                }
                return null;
              }
              if (method == "computedstyle") {
                var computedStyle = window.getComputedStyle($element[0]);
                return computedStyle.width;
              }
              return method;
            };
            Select22.prototype._bindAdapters = function() {
              this.dataAdapter.bind(this, this.$container);
              this.selection.bind(this, this.$container);
              this.dropdown.bind(this, this.$container);
              this.results.bind(this, this.$container);
            };
            Select22.prototype._registerDomEvents = function() {
              var self2 = this;
              this.$element.on("change.select2", function() {
                self2.dataAdapter.current(function(data) {
                  self2.trigger("selection:update", {
                    data
                  });
                });
              });
              this.$element.on("focus.select2", function(evt) {
                self2.trigger("focus", evt);
              });
              this._syncA = Utils.bind(this._syncAttributes, this);
              this._syncS = Utils.bind(this._syncSubtree, this);
              this._observer = new window.MutationObserver(function(mutations) {
                self2._syncA();
                self2._syncS(mutations);
              });
              this._observer.observe(this.$element[0], {
                attributes: true,
                childList: true,
                subtree: false
              });
            };
            Select22.prototype._registerDataEvents = function() {
              var self2 = this;
              this.dataAdapter.on("*", function(name, params) {
                self2.trigger(name, params);
              });
            };
            Select22.prototype._registerSelectionEvents = function() {
              var self2 = this;
              var nonRelayEvents = ["toggle", "focus"];
              this.selection.on("toggle", function() {
                self2.toggleDropdown();
              });
              this.selection.on("focus", function(params) {
                self2.focus(params);
              });
              this.selection.on("*", function(name, params) {
                if (nonRelayEvents.indexOf(name) !== -1) {
                  return;
                }
                self2.trigger(name, params);
              });
            };
            Select22.prototype._registerDropdownEvents = function() {
              var self2 = this;
              this.dropdown.on("*", function(name, params) {
                self2.trigger(name, params);
              });
            };
            Select22.prototype._registerResultsEvents = function() {
              var self2 = this;
              this.results.on("*", function(name, params) {
                self2.trigger(name, params);
              });
            };
            Select22.prototype._registerEvents = function() {
              var self2 = this;
              this.on("open", function() {
                self2.$container[0].classList.add("select2-container--open");
              });
              this.on("close", function() {
                self2.$container[0].classList.remove("select2-container--open");
              });
              this.on("enable", function() {
                self2.$container[0].classList.remove("select2-container--disabled");
              });
              this.on("disable", function() {
                self2.$container[0].classList.add("select2-container--disabled");
              });
              this.on("blur", function() {
                self2.$container[0].classList.remove("select2-container--focus");
              });
              this.on("query", function(params) {
                if (!self2.isOpen()) {
                  self2.trigger("open", {});
                }
                this.dataAdapter.query(params, function(data) {
                  self2.trigger("results:all", {
                    data,
                    query: params
                  });
                });
              });
              this.on("query:append", function(params) {
                this.dataAdapter.query(params, function(data) {
                  self2.trigger("results:append", {
                    data,
                    query: params
                  });
                });
              });
              this.on("keypress", function(evt) {
                var key = evt.which;
                if (self2.isOpen()) {
                  if (key === KEYS.ESC || key === KEYS.UP && evt.altKey) {
                    self2.close(evt);
                    evt.preventDefault();
                  } else if (key === KEYS.ENTER || key === KEYS.TAB) {
                    self2.trigger("results:select", {});
                    evt.preventDefault();
                  } else if (key === KEYS.SPACE && evt.ctrlKey) {
                    self2.trigger("results:toggle", {});
                    evt.preventDefault();
                  } else if (key === KEYS.UP) {
                    self2.trigger("results:previous", {});
                    evt.preventDefault();
                  } else if (key === KEYS.DOWN) {
                    self2.trigger("results:next", {});
                    evt.preventDefault();
                  }
                } else {
                  if (key === KEYS.ENTER || key === KEYS.SPACE || key === KEYS.DOWN && evt.altKey) {
                    self2.open();
                    evt.preventDefault();
                  }
                }
              });
            };
            Select22.prototype._syncAttributes = function() {
              this.options.set("disabled", this.$element.prop("disabled"));
              if (this.isDisabled()) {
                if (this.isOpen()) {
                  this.close();
                }
                this.trigger("disable", {});
              } else {
                this.trigger("enable", {});
              }
            };
            Select22.prototype._isChangeMutation = function(mutations) {
              var self2 = this;
              if (mutations.addedNodes && mutations.addedNodes.length > 0) {
                for (var n2 = 0; n2 < mutations.addedNodes.length; n2++) {
                  var node = mutations.addedNodes[n2];
                  if (node.selected) {
                    return true;
                  }
                }
              } else if (mutations.removedNodes && mutations.removedNodes.length > 0) {
                return true;
              } else if (Array.isArray(mutations)) {
                return mutations.some(function(mutation) {
                  return self2._isChangeMutation(mutation);
                });
              }
              return false;
            };
            Select22.prototype._syncSubtree = function(mutations) {
              var changed = this._isChangeMutation(mutations);
              var self2 = this;
              if (changed) {
                this.dataAdapter.current(function(currentData) {
                  self2.trigger("selection:update", {
                    data: currentData
                  });
                });
              }
            };
            Select22.prototype.trigger = function(name, args) {
              var actualTrigger = Select22.__super__.trigger;
              var preTriggerMap = {
                "open": "opening",
                "close": "closing",
                "select": "selecting",
                "unselect": "unselecting",
                "clear": "clearing"
              };
              if (args === void 0) {
                args = {};
              }
              if (name in preTriggerMap) {
                var preTriggerName = preTriggerMap[name];
                var preTriggerArgs = {
                  prevented: false,
                  name,
                  args
                };
                actualTrigger.call(this, preTriggerName, preTriggerArgs);
                if (preTriggerArgs.prevented) {
                  args.prevented = true;
                  return;
                }
              }
              actualTrigger.call(this, name, args);
            };
            Select22.prototype.toggleDropdown = function() {
              if (this.isDisabled()) {
                return;
              }
              if (this.isOpen()) {
                this.close();
              } else {
                this.open();
              }
            };
            Select22.prototype.open = function() {
              if (this.isOpen()) {
                return;
              }
              if (this.isDisabled()) {
                return;
              }
              this.trigger("query", {});
            };
            Select22.prototype.close = function(evt) {
              if (!this.isOpen()) {
                return;
              }
              this.trigger("close", { originalEvent: evt });
            };
            Select22.prototype.isEnabled = function() {
              return !this.isDisabled();
            };
            Select22.prototype.isDisabled = function() {
              return this.options.get("disabled");
            };
            Select22.prototype.isOpen = function() {
              return this.$container[0].classList.contains("select2-container--open");
            };
            Select22.prototype.hasFocus = function() {
              return this.$container[0].classList.contains("select2-container--focus");
            };
            Select22.prototype.focus = function(data) {
              if (this.hasFocus()) {
                return;
              }
              this.$container[0].classList.add("select2-container--focus");
              this.trigger("focus", {});
            };
            Select22.prototype.enable = function(args) {
              if (this.options.get("debug") && window.console && console.warn) {
                console.warn(
                  'Select2: The `select2("enable")` method has been deprecated and will be removed in later Select2 versions. Use $element.prop("disabled") instead.'
                );
              }
              if (args == null || args.length === 0) {
                args = [true];
              }
              var disabled = !args[0];
              this.$element.prop("disabled", disabled);
            };
            Select22.prototype.data = function() {
              if (this.options.get("debug") && arguments.length > 0 && window.console && console.warn) {
                console.warn(
                  'Select2: Data can no longer be set using `select2("data")`. You should consider setting the value instead using `$element.val()`.'
                );
              }
              var data = [];
              this.dataAdapter.current(function(currentData) {
                data = currentData;
              });
              return data;
            };
            Select22.prototype.val = function(args) {
              if (this.options.get("debug") && window.console && console.warn) {
                console.warn(
                  'Select2: The `select2("val")` method has been deprecated and will be removed in later Select2 versions. Use $element.val() instead.'
                );
              }
              if (args == null || args.length === 0) {
                return this.$element.val();
              }
              var newVal = args[0];
              if (Array.isArray(newVal)) {
                newVal = newVal.map(function(obj) {
                  return obj.toString();
                });
              }
              this.$element.val(newVal).trigger("input").trigger("change");
            };
            Select22.prototype.destroy = function() {
              Utils.RemoveData(this.$container[0]);
              this.$container.remove();
              this._observer.disconnect();
              this._observer = null;
              this._syncA = null;
              this._syncS = null;
              this.$element.off(".select2");
              this.$element.attr(
                "tabindex",
                Utils.GetData(this.$element[0], "old-tabindex")
              );
              this.$element[0].classList.remove("select2-hidden-accessible");
              this.$element.attr("aria-hidden", "false");
              Utils.RemoveData(this.$element[0]);
              this.$element.removeData("select2");
              this.dataAdapter.destroy();
              this.selection.destroy();
              this.dropdown.destroy();
              this.results.destroy();
              this.dataAdapter = null;
              this.selection = null;
              this.dropdown = null;
              this.results = null;
            };
            Select22.prototype.render = function() {
              var $container = $8(
                '<span class="select2 select2-container"><span class="selection"></span><span class="dropdown-wrapper" aria-hidden="true"></span></span>'
              );
              $container.attr("dir", this.options.get("dir"));
              this.$container = $container;
              this.$container[0].classList.add("select2-container--" + this.options.get("theme"));
              Utils.StoreData($container[0], "element", this.$element);
              return $container;
            };
            return Select22;
          });
          S22.define("jquery-mousewheel", [
            "jquery"
          ], function($8) {
            return $8;
          });
          S22.define("jquery.select2", [
            "jquery",
            "jquery-mousewheel",
            "./select2/core",
            "./select2/defaults",
            "./select2/utils"
          ], function($8, _2, Select22, Defaults, Utils) {
            if ($8.fn.select2 == null) {
              var thisMethods = ["open", "close", "destroy"];
              $8.fn.select2 = function(options) {
                options = options || {};
                if (typeof options === "object") {
                  this.each(function() {
                    var instanceOptions = $8.extend(true, {}, options);
                    var instance = new Select22($8(this), instanceOptions);
                  });
                  return this;
                } else if (typeof options === "string") {
                  var ret;
                  var args = Array.prototype.slice.call(arguments, 1);
                  this.each(function() {
                    var instance = Utils.GetData(this, "select2");
                    if (instance == null && window.console && console.error) {
                      console.error(
                        "The select2('" + options + "') method was called on an element that is not using Select2."
                      );
                    }
                    ret = instance[options].apply(instance, args);
                  });
                  if (thisMethods.indexOf(options) > -1) {
                    return this;
                  }
                  return ret;
                } else {
                  throw new Error("Invalid arguments for Select2: " + options);
                }
              };
            }
            if ($8.fn.select2.defaults == null) {
              $8.fn.select2.defaults = Defaults;
            }
            return Select22;
          });
          return {
            define: S22.define,
            require: S22.require
          };
        }();
        var select2 = S2.require("jquery.select2");
        jQuery6.fn.select2.amd = S2;
        return select2;
      });
    }
  });

  // node_modules/sweetalert2/dist/sweetalert2.all.js
  var require_sweetalert2_all = __commonJS({
    "node_modules/sweetalert2/dist/sweetalert2.all.js"(exports, module) {
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.Sweetalert2 = factory());
      })(exports, function() {
        "use strict";
        function _arrayLikeToArray(r2, a2) {
          (null == a2 || a2 > r2.length) && (a2 = r2.length);
          for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++)
            n2[e2] = r2[e2];
          return n2;
        }
        function _arrayWithHoles(r2) {
          if (Array.isArray(r2))
            return r2;
        }
        function _arrayWithoutHoles(r2) {
          if (Array.isArray(r2))
            return _arrayLikeToArray(r2);
        }
        function _assertClassBrand(e2, t2, n2) {
          if ("function" == typeof e2 ? e2 === t2 : e2.has(t2))
            return arguments.length < 3 ? t2 : n2;
          throw new TypeError("Private element is not present on this object");
        }
        function _assertThisInitialized(e2) {
          if (void 0 === e2)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e2;
        }
        function _callSuper(t2, o2, e2) {
          return o2 = _getPrototypeOf(o2), _possibleConstructorReturn(t2, _isNativeReflectConstruct() ? Reflect.construct(o2, e2 || [], _getPrototypeOf(t2).constructor) : o2.apply(t2, e2));
        }
        function _checkPrivateRedeclaration(e2, t2) {
          if (t2.has(e2))
            throw new TypeError("Cannot initialize the same private elements twice on an object");
        }
        function _classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function _classPrivateFieldGet2(s2, a2) {
          return s2.get(_assertClassBrand(s2, a2));
        }
        function _classPrivateFieldInitSpec(e2, t2, a2) {
          _checkPrivateRedeclaration(e2, t2), t2.set(e2, a2);
        }
        function _classPrivateFieldSet2(s2, a2, r2) {
          return s2.set(_assertClassBrand(s2, a2), r2), r2;
        }
        function _construct(t2, e2, r2) {
          if (_isNativeReflectConstruct())
            return Reflect.construct.apply(null, arguments);
          var o2 = [null];
          o2.push.apply(o2, e2);
          var p2 = new (t2.bind.apply(t2, o2))();
          return p2;
        }
        function _defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, _toPropertyKey(o2.key), o2);
          }
        }
        function _createClass(e2, r2, t2) {
          return r2 && _defineProperties(e2.prototype, r2), Object.defineProperty(e2, "prototype", {
            writable: false
          }), e2;
        }
        function _createForOfIteratorHelper(r2, e2) {
          var t2 = "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
          if (!t2) {
            if (Array.isArray(r2) || (t2 = _unsupportedIterableToArray(r2)) || e2) {
              t2 && (r2 = t2);
              var n2 = 0, F2 = function() {
              };
              return {
                s: F2,
                n: function() {
                  return n2 >= r2.length ? {
                    done: true
                  } : {
                    done: false,
                    value: r2[n2++]
                  };
                },
                e: function(r3) {
                  throw r3;
                },
                f: F2
              };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var o2, a2 = true, u2 = false;
          return {
            s: function() {
              t2 = t2.call(r2);
            },
            n: function() {
              var r3 = t2.next();
              return a2 = r3.done, r3;
            },
            e: function(r3) {
              u2 = true, o2 = r3;
            },
            f: function() {
              try {
                a2 || null == t2.return || t2.return();
              } finally {
                if (u2)
                  throw o2;
              }
            }
          };
        }
        function _get() {
          return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e2, t2, r2) {
            var p2 = _superPropBase(e2, t2);
            if (p2) {
              var n2 = Object.getOwnPropertyDescriptor(p2, t2);
              return n2.get ? n2.get.call(arguments.length < 3 ? e2 : r2) : n2.value;
            }
          }, _get.apply(null, arguments);
        }
        function _getPrototypeOf(t2) {
          return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
            return t3.__proto__ || Object.getPrototypeOf(t3);
          }, _getPrototypeOf(t2);
        }
        function _inherits(t2, e2) {
          if ("function" != typeof e2 && null !== e2)
            throw new TypeError("Super expression must either be null or a function");
          t2.prototype = Object.create(e2 && e2.prototype, {
            constructor: {
              value: t2,
              writable: true,
              configurable: true
            }
          }), Object.defineProperty(t2, "prototype", {
            writable: false
          }), e2 && _setPrototypeOf(t2, e2);
        }
        function _isNativeReflectConstruct() {
          try {
            var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch (t3) {
          }
          return (_isNativeReflectConstruct = function() {
            return !!t2;
          })();
        }
        function _iterableToArray(r2) {
          if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"])
            return Array.from(r2);
        }
        function _iterableToArrayLimit(r2, l2) {
          var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
          if (null != t2) {
            var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
            try {
              if (i2 = (t2 = t2.call(r2)).next, 0 === l2)
                ;
              else
                for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true)
                  ;
            } catch (r3) {
              o2 = true, n2 = r3;
            } finally {
              try {
                if (!f2 && null != t2.return && (u2 = t2.return(), Object(u2) !== u2))
                  return;
              } finally {
                if (o2)
                  throw n2;
              }
            }
            return a2;
          }
        }
        function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _possibleConstructorReturn(t2, e2) {
          if (e2 && ("object" == typeof e2 || "function" == typeof e2))
            return e2;
          if (void 0 !== e2)
            throw new TypeError("Derived constructors may only return object or undefined");
          return _assertThisInitialized(t2);
        }
        function _setPrototypeOf(t2, e2) {
          return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
            return t3.__proto__ = e3, t3;
          }, _setPrototypeOf(t2, e2);
        }
        function _slicedToArray(r2, e2) {
          return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
        }
        function _superPropBase(t2, o2) {
          for (; !{}.hasOwnProperty.call(t2, o2) && null !== (t2 = _getPrototypeOf(t2)); )
            ;
          return t2;
        }
        function _superPropGet(t2, e2, r2, o2) {
          var p2 = _get(_getPrototypeOf(t2.prototype), e2, r2);
          return function(t3) {
            return p2.apply(r2, t3);
          };
        }
        function _toConsumableArray(r2) {
          return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableSpread();
        }
        function _toPrimitive(t2, r2) {
          if ("object" != typeof t2 || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i2 = e2.call(t2, r2);
            if ("object" != typeof i2)
              return i2;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t2);
        }
        function _toPropertyKey(t2) {
          var i2 = _toPrimitive(t2, "string");
          return "symbol" == typeof i2 ? i2 : i2 + "";
        }
        function _typeof(o2) {
          "@babel/helpers - typeof";
          return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, _typeof(o2);
        }
        function _unsupportedIterableToArray(r2, a2) {
          if (r2) {
            if ("string" == typeof r2)
              return _arrayLikeToArray(r2, a2);
            var t2 = {}.toString.call(r2).slice(8, -1);
            return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
          }
        }
        var RESTORE_FOCUS_TIMEOUT = 100;
        var globalState = {};
        var focusPreviousActiveElement = function focusPreviousActiveElement2() {
          if (globalState.previousActiveElement instanceof HTMLElement) {
            globalState.previousActiveElement.focus();
            globalState.previousActiveElement = null;
          } else if (document.body) {
            document.body.focus();
          }
        };
        var restoreActiveElement = function restoreActiveElement2(returnFocus) {
          return new Promise(function(resolve) {
            if (!returnFocus) {
              return resolve();
            }
            var x2 = window.scrollX;
            var y2 = window.scrollY;
            globalState.restoreFocusTimeout = setTimeout(function() {
              focusPreviousActiveElement();
              resolve();
            }, RESTORE_FOCUS_TIMEOUT);
            window.scrollTo(x2, y2);
          });
        };
        var swalPrefix = "swal2-";
        var classNames = ["container", "shown", "height-auto", "iosfix", "popup", "modal", "no-backdrop", "no-transition", "toast", "toast-shown", "show", "hide", "close", "title", "html-container", "actions", "confirm", "deny", "cancel", "default-outline", "footer", "icon", "icon-content", "image", "input", "file", "range", "select", "radio", "checkbox", "label", "textarea", "inputerror", "input-label", "validation-message", "progress-steps", "active-progress-step", "progress-step", "progress-step-line", "loader", "loading", "styled", "top", "top-start", "top-end", "top-left", "top-right", "center", "center-start", "center-end", "center-left", "center-right", "bottom", "bottom-start", "bottom-end", "bottom-left", "bottom-right", "grow-row", "grow-column", "grow-fullscreen", "rtl", "timer-progress-bar", "timer-progress-bar-container", "scrollbar-measure", "icon-success", "icon-warning", "icon-info", "icon-question", "icon-error"];
        var swalClasses = classNames.reduce(
          function(acc, className) {
            acc[className] = swalPrefix + className;
            return acc;
          },
          /** @type {SwalClasses} */
          {}
        );
        var icons = ["success", "warning", "info", "question", "error"];
        var iconTypes = icons.reduce(
          function(acc, icon) {
            acc[icon] = swalPrefix + icon;
            return acc;
          },
          /** @type {SwalIcons} */
          {}
        );
        var consolePrefix = "SweetAlert2:";
        var capitalizeFirstLetter = function capitalizeFirstLetter2(str) {
          return str.charAt(0).toUpperCase() + str.slice(1);
        };
        var warn = function warn2(message) {
          console.warn("".concat(consolePrefix, " ").concat(_typeof(message) === "object" ? message.join(" ") : message));
        };
        var error2 = function error3(message) {
          console.error("".concat(consolePrefix, " ").concat(message));
        };
        var previousWarnOnceMessages = [];
        var warnOnce = function warnOnce2(message) {
          if (!previousWarnOnceMessages.includes(message)) {
            previousWarnOnceMessages.push(message);
            warn(message);
          }
        };
        var warnAboutDeprecation = function warnAboutDeprecation2(deprecatedParam) {
          var useInstead = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          warnOnce('"'.concat(deprecatedParam, '" is deprecated and will be removed in the next major release.').concat(useInstead ? ' Use "'.concat(useInstead, '" instead.') : ""));
        };
        var callIfFunction = function callIfFunction2(arg) {
          return typeof arg === "function" ? arg() : arg;
        };
        var hasToPromiseFn = function hasToPromiseFn2(arg) {
          return arg && typeof arg.toPromise === "function";
        };
        var asPromise = function asPromise2(arg) {
          return hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);
        };
        var isPromise = function isPromise2(arg) {
          return arg && Promise.resolve(arg) === arg;
        };
        var getContainer = function getContainer2() {
          return document.body.querySelector(".".concat(swalClasses.container));
        };
        var elementBySelector = function elementBySelector2(selectorString) {
          var container = getContainer();
          return container ? container.querySelector(selectorString) : null;
        };
        var elementByClass = function elementByClass2(className) {
          return elementBySelector(".".concat(className));
        };
        var getPopup = function getPopup2() {
          return elementByClass(swalClasses.popup);
        };
        var getIcon = function getIcon2() {
          return elementByClass(swalClasses.icon);
        };
        var getIconContent = function getIconContent2() {
          return elementByClass(swalClasses["icon-content"]);
        };
        var getTitle = function getTitle2() {
          return elementByClass(swalClasses.title);
        };
        var getHtmlContainer = function getHtmlContainer2() {
          return elementByClass(swalClasses["html-container"]);
        };
        var getImage = function getImage2() {
          return elementByClass(swalClasses.image);
        };
        var getProgressSteps = function getProgressSteps2() {
          return elementByClass(swalClasses["progress-steps"]);
        };
        var getValidationMessage = function getValidationMessage2() {
          return elementByClass(swalClasses["validation-message"]);
        };
        var getConfirmButton = function getConfirmButton2() {
          return (
            /** @type {HTMLButtonElement} */
            elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.confirm))
          );
        };
        var getCancelButton = function getCancelButton2() {
          return (
            /** @type {HTMLButtonElement} */
            elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.cancel))
          );
        };
        var getDenyButton = function getDenyButton2() {
          return (
            /** @type {HTMLButtonElement} */
            elementBySelector(".".concat(swalClasses.actions, " .").concat(swalClasses.deny))
          );
        };
        var getInputLabel = function getInputLabel2() {
          return elementByClass(swalClasses["input-label"]);
        };
        var getLoader = function getLoader2() {
          return elementBySelector(".".concat(swalClasses.loader));
        };
        var getActions = function getActions2() {
          return elementByClass(swalClasses.actions);
        };
        var getFooter = function getFooter2() {
          return elementByClass(swalClasses.footer);
        };
        var getTimerProgressBar = function getTimerProgressBar2() {
          return elementByClass(swalClasses["timer-progress-bar"]);
        };
        var getCloseButton = function getCloseButton2() {
          return elementByClass(swalClasses.close);
        };
        var focusable = '\n  a[href],\n  area[href],\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled]),\n  button:not([disabled]),\n  iframe,\n  object,\n  embed,\n  [tabindex="0"],\n  [contenteditable],\n  audio[controls],\n  video[controls],\n  summary\n';
        var getFocusableElements = function getFocusableElements2() {
          var popup = getPopup();
          if (!popup) {
            return [];
          }
          var focusableElementsWithTabindex = popup.querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])');
          var focusableElementsWithTabindexSorted = Array.from(focusableElementsWithTabindex).sort(function(a2, b2) {
            var tabindexA = parseInt(a2.getAttribute("tabindex") || "0");
            var tabindexB = parseInt(b2.getAttribute("tabindex") || "0");
            if (tabindexA > tabindexB) {
              return 1;
            } else if (tabindexA < tabindexB) {
              return -1;
            }
            return 0;
          });
          var otherFocusableElements = popup.querySelectorAll(focusable);
          var otherFocusableElementsFiltered = Array.from(otherFocusableElements).filter(function(el) {
            return el.getAttribute("tabindex") !== "-1";
          });
          return _toConsumableArray(new Set(focusableElementsWithTabindexSorted.concat(otherFocusableElementsFiltered))).filter(function(el) {
            return isVisible$1(el);
          });
        };
        var isModal = function isModal2() {
          return hasClass(document.body, swalClasses.shown) && !hasClass(document.body, swalClasses["toast-shown"]) && !hasClass(document.body, swalClasses["no-backdrop"]);
        };
        var isToast = function isToast2() {
          var popup = getPopup();
          if (!popup) {
            return false;
          }
          return hasClass(popup, swalClasses.toast);
        };
        var isLoading = function isLoading2() {
          var popup = getPopup();
          if (!popup) {
            return false;
          }
          return popup.hasAttribute("data-loading");
        };
        var setInnerHtml = function setInnerHtml2(elem, html) {
          elem.textContent = "";
          if (html) {
            var parser = new DOMParser();
            var parsed = parser.parseFromString(html, "text/html");
            var head = parsed.querySelector("head");
            if (head) {
              Array.from(head.childNodes).forEach(function(child) {
                elem.appendChild(child);
              });
            }
            var body = parsed.querySelector("body");
            if (body) {
              Array.from(body.childNodes).forEach(function(child) {
                if (child instanceof HTMLVideoElement || child instanceof HTMLAudioElement) {
                  elem.appendChild(child.cloneNode(true));
                } else {
                  elem.appendChild(child);
                }
              });
            }
          }
        };
        var hasClass = function hasClass2(elem, className) {
          if (!className) {
            return false;
          }
          var classList = className.split(/\s+/);
          for (var i2 = 0; i2 < classList.length; i2++) {
            if (!elem.classList.contains(classList[i2])) {
              return false;
            }
          }
          return true;
        };
        var removeCustomClasses = function removeCustomClasses2(elem, params) {
          Array.from(elem.classList).forEach(function(className) {
            if (!Object.values(swalClasses).includes(className) && !Object.values(iconTypes).includes(className) && !Object.values(params.showClass || {}).includes(className)) {
              elem.classList.remove(className);
            }
          });
        };
        var applyCustomClass = function applyCustomClass2(elem, params, className) {
          removeCustomClasses(elem, params);
          if (!params.customClass) {
            return;
          }
          var customClass = params.customClass[
            /** @type {keyof SweetAlertCustomClass} */
            className
          ];
          if (!customClass) {
            return;
          }
          if (typeof customClass !== "string" && !customClass.forEach) {
            warn("Invalid type of customClass.".concat(className, '! Expected string or iterable object, got "').concat(_typeof(customClass), '"'));
            return;
          }
          addClass(elem, customClass);
        };
        var getInput$1 = function getInput2(popup, inputClass) {
          if (!inputClass) {
            return null;
          }
          switch (inputClass) {
            case "select":
            case "textarea":
            case "file":
              return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses[inputClass]));
            case "checkbox":
              return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.checkbox, " input"));
            case "radio":
              return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.radio, " input:checked")) || popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.radio, " input:first-child"));
            case "range":
              return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.range, " input"));
            default:
              return popup.querySelector(".".concat(swalClasses.popup, " > .").concat(swalClasses.input));
          }
        };
        var focusInput = function focusInput2(input) {
          input.focus();
          if (input.type !== "file") {
            var val = input.value;
            input.value = "";
            input.value = val;
          }
        };
        var toggleClass = function toggleClass2(target, classList, condition) {
          if (!target || !classList) {
            return;
          }
          if (typeof classList === "string") {
            classList = classList.split(/\s+/).filter(Boolean);
          }
          classList.forEach(function(className) {
            if (Array.isArray(target)) {
              target.forEach(function(elem) {
                if (condition) {
                  elem.classList.add(className);
                } else {
                  elem.classList.remove(className);
                }
              });
            } else {
              if (condition) {
                target.classList.add(className);
              } else {
                target.classList.remove(className);
              }
            }
          });
        };
        var addClass = function addClass2(target, classList) {
          toggleClass(target, classList, true);
        };
        var removeClass = function removeClass2(target, classList) {
          toggleClass(target, classList, false);
        };
        var getDirectChildByClass = function getDirectChildByClass2(elem, className) {
          var children = Array.from(elem.children);
          for (var i2 = 0; i2 < children.length; i2++) {
            var child = children[i2];
            if (child instanceof HTMLElement && hasClass(child, className)) {
              return child;
            }
          }
        };
        var applyNumericalStyle = function applyNumericalStyle2(elem, property, value) {
          if (value === "".concat(parseInt(value))) {
            value = parseInt(value);
          }
          if (value || parseInt(value) === 0) {
            elem.style.setProperty(property, typeof value === "number" ? "".concat(value, "px") : value);
          } else {
            elem.style.removeProperty(property);
          }
        };
        var show = function show2(elem) {
          var display = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "flex";
          if (!elem) {
            return;
          }
          elem.style.display = display;
        };
        var hide2 = function hide3(elem) {
          if (!elem) {
            return;
          }
          elem.style.display = "none";
        };
        var showWhenInnerHtmlPresent = function showWhenInnerHtmlPresent2(elem) {
          var display = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "block";
          if (!elem) {
            return;
          }
          new MutationObserver(function() {
            toggle(elem, elem.innerHTML, display);
          }).observe(elem, {
            childList: true,
            subtree: true
          });
        };
        var setStyle = function setStyle2(parent, selector, property, value) {
          var el = parent.querySelector(selector);
          if (el) {
            el.style.setProperty(property, value);
          }
        };
        var toggle = function toggle2(elem, condition) {
          var display = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "flex";
          if (condition) {
            show(elem, display);
          } else {
            hide2(elem);
          }
        };
        var isVisible$1 = function isVisible3(elem) {
          return !!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));
        };
        var allButtonsAreHidden = function allButtonsAreHidden2() {
          return !isVisible$1(getConfirmButton()) && !isVisible$1(getDenyButton()) && !isVisible$1(getCancelButton());
        };
        var isScrollable = function isScrollable2(elem) {
          return !!(elem.scrollHeight > elem.clientHeight);
        };
        var hasCssAnimation = function hasCssAnimation2(elem) {
          var style = window.getComputedStyle(elem);
          var animDuration = parseFloat(style.getPropertyValue("animation-duration") || "0");
          var transDuration = parseFloat(style.getPropertyValue("transition-duration") || "0");
          return animDuration > 0 || transDuration > 0;
        };
        var animateTimerProgressBar = function animateTimerProgressBar2(timer) {
          var reset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var timerProgressBar = getTimerProgressBar();
          if (!timerProgressBar) {
            return;
          }
          if (isVisible$1(timerProgressBar)) {
            if (reset) {
              timerProgressBar.style.transition = "none";
              timerProgressBar.style.width = "100%";
            }
            setTimeout(function() {
              timerProgressBar.style.transition = "width ".concat(timer / 1e3, "s linear");
              timerProgressBar.style.width = "0%";
            }, 10);
          }
        };
        var stopTimerProgressBar = function stopTimerProgressBar2() {
          var timerProgressBar = getTimerProgressBar();
          if (!timerProgressBar) {
            return;
          }
          var timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
          timerProgressBar.style.removeProperty("transition");
          timerProgressBar.style.width = "100%";
          var timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
          var timerProgressBarPercent = timerProgressBarWidth / timerProgressBarFullWidth * 100;
          timerProgressBar.style.width = "".concat(timerProgressBarPercent, "%");
        };
        var isNodeEnv = function isNodeEnv2() {
          return typeof window === "undefined" || typeof document === "undefined";
        };
        var sweetHTML = '\n <div aria-labelledby="'.concat(swalClasses.title, '" aria-describedby="').concat(swalClasses["html-container"], '" class="').concat(swalClasses.popup, '" tabindex="-1">\n   <button type="button" class="').concat(swalClasses.close, '"></button>\n   <ul class="').concat(swalClasses["progress-steps"], '"></ul>\n   <div class="').concat(swalClasses.icon, '"></div>\n   <img class="').concat(swalClasses.image, '" />\n   <h2 class="').concat(swalClasses.title, '" id="').concat(swalClasses.title, '"></h2>\n   <div class="').concat(swalClasses["html-container"], '" id="').concat(swalClasses["html-container"], '"></div>\n   <input class="').concat(swalClasses.input, '" id="').concat(swalClasses.input, '" />\n   <input type="file" class="').concat(swalClasses.file, '" />\n   <div class="').concat(swalClasses.range, '">\n     <input type="range" />\n     <output></output>\n   </div>\n   <select class="').concat(swalClasses.select, '" id="').concat(swalClasses.select, '"></select>\n   <div class="').concat(swalClasses.radio, '"></div>\n   <label class="').concat(swalClasses.checkbox, '">\n     <input type="checkbox" id="').concat(swalClasses.checkbox, '" />\n     <span class="').concat(swalClasses.label, '"></span>\n   </label>\n   <textarea class="').concat(swalClasses.textarea, '" id="').concat(swalClasses.textarea, '"></textarea>\n   <div class="').concat(swalClasses["validation-message"], '" id="').concat(swalClasses["validation-message"], '"></div>\n   <div class="').concat(swalClasses.actions, '">\n     <div class="').concat(swalClasses.loader, '"></div>\n     <button type="button" class="').concat(swalClasses.confirm, '"></button>\n     <button type="button" class="').concat(swalClasses.deny, '"></button>\n     <button type="button" class="').concat(swalClasses.cancel, '"></button>\n   </div>\n   <div class="').concat(swalClasses.footer, '"></div>\n   <div class="').concat(swalClasses["timer-progress-bar-container"], '">\n     <div class="').concat(swalClasses["timer-progress-bar"], '"></div>\n   </div>\n </div>\n').replace(/(^|\n)\s*/g, "");
        var resetOldContainer = function resetOldContainer2() {
          var oldContainer = getContainer();
          if (!oldContainer) {
            return false;
          }
          oldContainer.remove();
          removeClass([document.documentElement, document.body], [swalClasses["no-backdrop"], swalClasses["toast-shown"], swalClasses["has-column"]]);
          return true;
        };
        var resetValidationMessage$1 = function resetValidationMessage2() {
          globalState.currentInstance.resetValidationMessage();
        };
        var addInputChangeListeners = function addInputChangeListeners2() {
          var popup = getPopup();
          var input = getDirectChildByClass(popup, swalClasses.input);
          var file = getDirectChildByClass(popup, swalClasses.file);
          var range = popup.querySelector(".".concat(swalClasses.range, " input"));
          var rangeOutput = popup.querySelector(".".concat(swalClasses.range, " output"));
          var select = getDirectChildByClass(popup, swalClasses.select);
          var checkbox = popup.querySelector(".".concat(swalClasses.checkbox, " input"));
          var textarea = getDirectChildByClass(popup, swalClasses.textarea);
          input.oninput = resetValidationMessage$1;
          file.onchange = resetValidationMessage$1;
          select.onchange = resetValidationMessage$1;
          checkbox.onchange = resetValidationMessage$1;
          textarea.oninput = resetValidationMessage$1;
          range.oninput = function() {
            resetValidationMessage$1();
            rangeOutput.value = range.value;
          };
          range.onchange = function() {
            resetValidationMessage$1();
            rangeOutput.value = range.value;
          };
        };
        var getTarget = function getTarget2(target) {
          return typeof target === "string" ? document.querySelector(target) : target;
        };
        var setupAccessibility = function setupAccessibility2(params) {
          var popup = getPopup();
          popup.setAttribute("role", params.toast ? "alert" : "dialog");
          popup.setAttribute("aria-live", params.toast ? "polite" : "assertive");
          if (!params.toast) {
            popup.setAttribute("aria-modal", "true");
          }
        };
        var setupRTL = function setupRTL2(targetElement) {
          if (window.getComputedStyle(targetElement).direction === "rtl") {
            addClass(getContainer(), swalClasses.rtl);
          }
        };
        var init = function init2(params) {
          var oldContainerExisted = resetOldContainer();
          if (isNodeEnv()) {
            error2("SweetAlert2 requires document to initialize");
            return;
          }
          var container = document.createElement("div");
          container.className = swalClasses.container;
          if (oldContainerExisted) {
            addClass(container, swalClasses["no-transition"]);
          }
          setInnerHtml(container, sweetHTML);
          var targetElement = getTarget(params.target);
          targetElement.appendChild(container);
          setupAccessibility(params);
          setupRTL(targetElement);
          addInputChangeListeners();
        };
        var parseHtmlToContainer = function parseHtmlToContainer2(param, target) {
          if (param instanceof HTMLElement) {
            target.appendChild(param);
          } else if (_typeof(param) === "object") {
            handleObject(param, target);
          } else if (param) {
            setInnerHtml(target, param);
          }
        };
        var handleObject = function handleObject2(param, target) {
          if (param.jquery) {
            handleJqueryElem(target, param);
          } else {
            setInnerHtml(target, param.toString());
          }
        };
        var handleJqueryElem = function handleJqueryElem2(target, elem) {
          target.textContent = "";
          if (0 in elem) {
            for (var i2 = 0; i2 in elem; i2++) {
              target.appendChild(elem[i2].cloneNode(true));
            }
          } else {
            target.appendChild(elem.cloneNode(true));
          }
        };
        var animationEndEvent = function() {
          if (isNodeEnv()) {
            return false;
          }
          var testEl = document.createElement("div");
          if (typeof testEl.style.webkitAnimation !== "undefined") {
            return "webkitAnimationEnd";
          }
          if (typeof testEl.style.animation !== "undefined") {
            return "animationend";
          }
          return false;
        }();
        var renderActions = function renderActions2(instance, params) {
          var actions = getActions();
          var loader = getLoader();
          if (!actions || !loader) {
            return;
          }
          if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) {
            hide2(actions);
          } else {
            show(actions);
          }
          applyCustomClass(actions, params, "actions");
          renderButtons(actions, loader, params);
          setInnerHtml(loader, params.loaderHtml || "");
          applyCustomClass(loader, params, "loader");
        };
        function renderButtons(actions, loader, params) {
          var confirmButton = getConfirmButton();
          var denyButton = getDenyButton();
          var cancelButton = getCancelButton();
          if (!confirmButton || !denyButton || !cancelButton) {
            return;
          }
          renderButton(confirmButton, "confirm", params);
          renderButton(denyButton, "deny", params);
          renderButton(cancelButton, "cancel", params);
          handleButtonsStyling(confirmButton, denyButton, cancelButton, params);
          if (params.reverseButtons) {
            if (params.toast) {
              actions.insertBefore(cancelButton, confirmButton);
              actions.insertBefore(denyButton, confirmButton);
            } else {
              actions.insertBefore(cancelButton, loader);
              actions.insertBefore(denyButton, loader);
              actions.insertBefore(confirmButton, loader);
            }
          }
        }
        function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {
          if (!params.buttonsStyling) {
            removeClass([confirmButton, denyButton, cancelButton], swalClasses.styled);
            return;
          }
          addClass([confirmButton, denyButton, cancelButton], swalClasses.styled);
          if (params.confirmButtonColor) {
            confirmButton.style.backgroundColor = params.confirmButtonColor;
            addClass(confirmButton, swalClasses["default-outline"]);
          }
          if (params.denyButtonColor) {
            denyButton.style.backgroundColor = params.denyButtonColor;
            addClass(denyButton, swalClasses["default-outline"]);
          }
          if (params.cancelButtonColor) {
            cancelButton.style.backgroundColor = params.cancelButtonColor;
            addClass(cancelButton, swalClasses["default-outline"]);
          }
        }
        function renderButton(button, buttonType, params) {
          var buttonName = (
            /** @type {'Confirm' | 'Deny' | 'Cancel'} */
            capitalizeFirstLetter(buttonType)
          );
          toggle(button, params["show".concat(buttonName, "Button")], "inline-block");
          setInnerHtml(button, params["".concat(buttonType, "ButtonText")] || "");
          button.setAttribute("aria-label", params["".concat(buttonType, "ButtonAriaLabel")] || "");
          button.className = swalClasses[buttonType];
          applyCustomClass(button, params, "".concat(buttonType, "Button"));
        }
        var renderCloseButton = function renderCloseButton2(instance, params) {
          var closeButton = getCloseButton();
          if (!closeButton) {
            return;
          }
          setInnerHtml(closeButton, params.closeButtonHtml || "");
          applyCustomClass(closeButton, params, "closeButton");
          toggle(closeButton, params.showCloseButton);
          closeButton.setAttribute("aria-label", params.closeButtonAriaLabel || "");
        };
        var renderContainer = function renderContainer2(instance, params) {
          var container = getContainer();
          if (!container) {
            return;
          }
          handleBackdropParam(container, params.backdrop);
          handlePositionParam(container, params.position);
          handleGrowParam(container, params.grow);
          applyCustomClass(container, params, "container");
        };
        function handleBackdropParam(container, backdrop) {
          if (typeof backdrop === "string") {
            container.style.background = backdrop;
          } else if (!backdrop) {
            addClass([document.documentElement, document.body], swalClasses["no-backdrop"]);
          }
        }
        function handlePositionParam(container, position) {
          if (!position) {
            return;
          }
          if (position in swalClasses) {
            addClass(container, swalClasses[position]);
          } else {
            warn('The "position" parameter is not valid, defaulting to "center"');
            addClass(container, swalClasses.center);
          }
        }
        function handleGrowParam(container, grow) {
          if (!grow) {
            return;
          }
          addClass(container, swalClasses["grow-".concat(grow)]);
        }
        var privateProps = {
          innerParams: /* @__PURE__ */ new WeakMap(),
          domCache: /* @__PURE__ */ new WeakMap()
        };
        var inputClasses = ["input", "file", "range", "select", "radio", "checkbox", "textarea"];
        var renderInput = function renderInput2(instance, params) {
          var popup = getPopup();
          if (!popup) {
            return;
          }
          var innerParams = privateProps.innerParams.get(instance);
          var rerender = !innerParams || params.input !== innerParams.input;
          inputClasses.forEach(function(inputClass) {
            var inputContainer = getDirectChildByClass(popup, swalClasses[inputClass]);
            if (!inputContainer) {
              return;
            }
            setAttributes(inputClass, params.inputAttributes);
            inputContainer.className = swalClasses[inputClass];
            if (rerender) {
              hide2(inputContainer);
            }
          });
          if (params.input) {
            if (rerender) {
              showInput(params);
            }
            setCustomClass(params);
          }
        };
        var showInput = function showInput2(params) {
          if (!params.input) {
            return;
          }
          if (!renderInputType[params.input]) {
            error2("Unexpected type of input! Expected ".concat(Object.keys(renderInputType).join(" | "), ', got "').concat(params.input, '"'));
            return;
          }
          var inputContainer = getInputContainer(params.input);
          if (!inputContainer) {
            return;
          }
          var input = renderInputType[params.input](inputContainer, params);
          show(inputContainer);
          if (params.inputAutoFocus) {
            setTimeout(function() {
              focusInput(input);
            });
          }
        };
        var removeAttributes = function removeAttributes2(input) {
          for (var i2 = 0; i2 < input.attributes.length; i2++) {
            var attrName = input.attributes[i2].name;
            if (!["id", "type", "value", "style"].includes(attrName)) {
              input.removeAttribute(attrName);
            }
          }
        };
        var setAttributes = function setAttributes2(inputClass, inputAttributes) {
          var popup = getPopup();
          if (!popup) {
            return;
          }
          var input = getInput$1(popup, inputClass);
          if (!input) {
            return;
          }
          removeAttributes(input);
          for (var attr in inputAttributes) {
            input.setAttribute(attr, inputAttributes[attr]);
          }
        };
        var setCustomClass = function setCustomClass2(params) {
          if (!params.input) {
            return;
          }
          var inputContainer = getInputContainer(params.input);
          if (inputContainer) {
            applyCustomClass(inputContainer, params, "input");
          }
        };
        var setInputPlaceholder = function setInputPlaceholder2(input, params) {
          if (!input.placeholder && params.inputPlaceholder) {
            input.placeholder = params.inputPlaceholder;
          }
        };
        var setInputLabel = function setInputLabel2(input, prependTo, params) {
          if (params.inputLabel) {
            var label = document.createElement("label");
            var labelClass = swalClasses["input-label"];
            label.setAttribute("for", input.id);
            label.className = labelClass;
            if (_typeof(params.customClass) === "object") {
              addClass(label, params.customClass.inputLabel);
            }
            label.innerText = params.inputLabel;
            prependTo.insertAdjacentElement("beforebegin", label);
          }
        };
        var getInputContainer = function getInputContainer2(inputType) {
          var popup = getPopup();
          if (!popup) {
            return;
          }
          return getDirectChildByClass(popup, swalClasses[
            /** @type {SwalClass} */
            inputType
          ] || swalClasses.input);
        };
        var checkAndSetInputValue = function checkAndSetInputValue2(input, inputValue) {
          if (["string", "number"].includes(_typeof(inputValue))) {
            input.value = "".concat(inputValue);
          } else if (!isPromise(inputValue)) {
            warn('Unexpected type of inputValue! Expected "string", "number" or "Promise", got "'.concat(_typeof(inputValue), '"'));
          }
        };
        var renderInputType = {};
        renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = renderInputType.search = renderInputType.date = renderInputType["datetime-local"] = renderInputType.time = renderInputType.week = renderInputType.month = /** @type {(input: Input | HTMLElement, params: SweetAlertOptions) => Input} */
        function(input, params) {
          checkAndSetInputValue(input, params.inputValue);
          setInputLabel(input, input, params);
          setInputPlaceholder(input, params);
          input.type = params.input;
          return input;
        };
        renderInputType.file = function(input, params) {
          setInputLabel(input, input, params);
          setInputPlaceholder(input, params);
          return input;
        };
        renderInputType.range = function(range, params) {
          var rangeInput = range.querySelector("input");
          var rangeOutput = range.querySelector("output");
          checkAndSetInputValue(rangeInput, params.inputValue);
          rangeInput.type = params.input;
          checkAndSetInputValue(rangeOutput, params.inputValue);
          setInputLabel(rangeInput, range, params);
          return range;
        };
        renderInputType.select = function(select, params) {
          select.textContent = "";
          if (params.inputPlaceholder) {
            var placeholder = document.createElement("option");
            setInnerHtml(placeholder, params.inputPlaceholder);
            placeholder.value = "";
            placeholder.disabled = true;
            placeholder.selected = true;
            select.appendChild(placeholder);
          }
          setInputLabel(select, select, params);
          return select;
        };
        renderInputType.radio = function(radio) {
          radio.textContent = "";
          return radio;
        };
        renderInputType.checkbox = function(checkboxContainer, params) {
          var checkbox = getInput$1(getPopup(), "checkbox");
          checkbox.value = "1";
          checkbox.checked = Boolean(params.inputValue);
          var label = checkboxContainer.querySelector("span");
          setInnerHtml(label, params.inputPlaceholder);
          return checkbox;
        };
        renderInputType.textarea = function(textarea, params) {
          checkAndSetInputValue(textarea, params.inputValue);
          setInputPlaceholder(textarea, params);
          setInputLabel(textarea, textarea, params);
          var getMargin = function getMargin2(el) {
            return parseInt(window.getComputedStyle(el).marginLeft) + parseInt(window.getComputedStyle(el).marginRight);
          };
          setTimeout(function() {
            if ("MutationObserver" in window) {
              var initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);
              var textareaResizeHandler = function textareaResizeHandler2() {
                if (!document.body.contains(textarea)) {
                  return;
                }
                var textareaWidth = textarea.offsetWidth + getMargin(textarea);
                if (textareaWidth > initialPopupWidth) {
                  getPopup().style.width = "".concat(textareaWidth, "px");
                } else {
                  applyNumericalStyle(getPopup(), "width", params.width);
                }
              };
              new MutationObserver(textareaResizeHandler).observe(textarea, {
                attributes: true,
                attributeFilter: ["style"]
              });
            }
          });
          return textarea;
        };
        var renderContent = function renderContent2(instance, params) {
          var htmlContainer = getHtmlContainer();
          if (!htmlContainer) {
            return;
          }
          showWhenInnerHtmlPresent(htmlContainer);
          applyCustomClass(htmlContainer, params, "htmlContainer");
          if (params.html) {
            parseHtmlToContainer(params.html, htmlContainer);
            show(htmlContainer, "block");
          } else if (params.text) {
            htmlContainer.textContent = params.text;
            show(htmlContainer, "block");
          } else {
            hide2(htmlContainer);
          }
          renderInput(instance, params);
        };
        var renderFooter = function renderFooter2(instance, params) {
          var footer = getFooter();
          if (!footer) {
            return;
          }
          showWhenInnerHtmlPresent(footer);
          toggle(footer, params.footer, "block");
          if (params.footer) {
            parseHtmlToContainer(params.footer, footer);
          }
          applyCustomClass(footer, params, "footer");
        };
        var renderIcon = function renderIcon2(instance, params) {
          var innerParams = privateProps.innerParams.get(instance);
          var icon = getIcon();
          if (!icon) {
            return;
          }
          if (innerParams && params.icon === innerParams.icon) {
            setContent(icon, params);
            applyStyles2(icon, params);
            return;
          }
          if (!params.icon && !params.iconHtml) {
            hide2(icon);
            return;
          }
          if (params.icon && Object.keys(iconTypes).indexOf(params.icon) === -1) {
            error2('Unknown icon! Expected "success", "error", "warning", "info" or "question", got "'.concat(params.icon, '"'));
            hide2(icon);
            return;
          }
          show(icon);
          setContent(icon, params);
          applyStyles2(icon, params);
          addClass(icon, params.showClass && params.showClass.icon);
        };
        var applyStyles2 = function applyStyles3(icon, params) {
          for (var _i = 0, _Object$entries = Object.entries(iconTypes); _i < _Object$entries.length; _i++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), iconType = _Object$entries$_i[0], iconClassName = _Object$entries$_i[1];
            if (params.icon !== iconType) {
              removeClass(icon, iconClassName);
            }
          }
          addClass(icon, params.icon && iconTypes[params.icon]);
          setColor(icon, params);
          adjustSuccessIconBackgroundColor();
          applyCustomClass(icon, params, "icon");
        };
        var adjustSuccessIconBackgroundColor = function adjustSuccessIconBackgroundColor2() {
          var popup = getPopup();
          if (!popup) {
            return;
          }
          var popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue("background-color");
          var successIconParts = popup.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix");
          for (var i2 = 0; i2 < successIconParts.length; i2++) {
            successIconParts[i2].style.backgroundColor = popupBackgroundColor;
          }
        };
        var successIconHtml = '\n  <div class="swal2-success-circular-line-left"></div>\n  <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>\n  <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>\n  <div class="swal2-success-circular-line-right"></div>\n';
        var errorIconHtml = '\n  <span class="swal2-x-mark">\n    <span class="swal2-x-mark-line-left"></span>\n    <span class="swal2-x-mark-line-right"></span>\n  </span>\n';
        var setContent = function setContent2(icon, params) {
          if (!params.icon && !params.iconHtml) {
            return;
          }
          var oldContent = icon.innerHTML;
          var newContent = "";
          if (params.iconHtml) {
            newContent = iconContent(params.iconHtml);
          } else if (params.icon === "success") {
            newContent = successIconHtml;
            oldContent = oldContent.replace(/ style=".*?"/g, "");
          } else if (params.icon === "error") {
            newContent = errorIconHtml;
          } else if (params.icon) {
            var defaultIconHtml = {
              question: "?",
              warning: "!",
              info: "i"
            };
            newContent = iconContent(defaultIconHtml[params.icon]);
          }
          if (oldContent.trim() !== newContent.trim()) {
            setInnerHtml(icon, newContent);
          }
        };
        var setColor = function setColor2(icon, params) {
          if (!params.iconColor) {
            return;
          }
          icon.style.color = params.iconColor;
          icon.style.borderColor = params.iconColor;
          for (var _i2 = 0, _arr = [".swal2-success-line-tip", ".swal2-success-line-long", ".swal2-x-mark-line-left", ".swal2-x-mark-line-right"]; _i2 < _arr.length; _i2++) {
            var sel = _arr[_i2];
            setStyle(icon, sel, "background-color", params.iconColor);
          }
          setStyle(icon, ".swal2-success-ring", "border-color", params.iconColor);
        };
        var iconContent = function iconContent2(content) {
          return '<div class="'.concat(swalClasses["icon-content"], '">').concat(content, "</div>");
        };
        var renderImage = function renderImage2(instance, params) {
          var image = getImage();
          if (!image) {
            return;
          }
          if (!params.imageUrl) {
            hide2(image);
            return;
          }
          show(image, "");
          image.setAttribute("src", params.imageUrl);
          image.setAttribute("alt", params.imageAlt || "");
          applyNumericalStyle(image, "width", params.imageWidth);
          applyNumericalStyle(image, "height", params.imageHeight);
          image.className = swalClasses.image;
          applyCustomClass(image, params, "image");
        };
        var renderPopup = function renderPopup2(instance, params) {
          var container = getContainer();
          var popup = getPopup();
          if (!container || !popup) {
            return;
          }
          if (params.toast) {
            applyNumericalStyle(container, "width", params.width);
            popup.style.width = "100%";
            var loader = getLoader();
            if (loader) {
              popup.insertBefore(loader, getIcon());
            }
          } else {
            applyNumericalStyle(popup, "width", params.width);
          }
          applyNumericalStyle(popup, "padding", params.padding);
          if (params.color) {
            popup.style.color = params.color;
          }
          if (params.background) {
            popup.style.background = params.background;
          }
          hide2(getValidationMessage());
          addClasses$1(popup, params);
        };
        var addClasses$1 = function addClasses2(popup, params) {
          var showClass = params.showClass || {};
          popup.className = "".concat(swalClasses.popup, " ").concat(isVisible$1(popup) ? showClass.popup : "");
          if (params.toast) {
            addClass([document.documentElement, document.body], swalClasses["toast-shown"]);
            addClass(popup, swalClasses.toast);
          } else {
            addClass(popup, swalClasses.modal);
          }
          applyCustomClass(popup, params, "popup");
          if (typeof params.customClass === "string") {
            addClass(popup, params.customClass);
          }
          if (params.icon) {
            addClass(popup, swalClasses["icon-".concat(params.icon)]);
          }
        };
        var renderProgressSteps = function renderProgressSteps2(instance, params) {
          var progressStepsContainer = getProgressSteps();
          if (!progressStepsContainer) {
            return;
          }
          var progressSteps = params.progressSteps, currentProgressStep = params.currentProgressStep;
          if (!progressSteps || progressSteps.length === 0 || currentProgressStep === void 0) {
            hide2(progressStepsContainer);
            return;
          }
          show(progressStepsContainer);
          progressStepsContainer.textContent = "";
          if (currentProgressStep >= progressSteps.length) {
            warn("Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)");
          }
          progressSteps.forEach(function(step, index) {
            var stepEl = createStepElement(step);
            progressStepsContainer.appendChild(stepEl);
            if (index === currentProgressStep) {
              addClass(stepEl, swalClasses["active-progress-step"]);
            }
            if (index !== progressSteps.length - 1) {
              var lineEl = createLineElement(params);
              progressStepsContainer.appendChild(lineEl);
            }
          });
        };
        var createStepElement = function createStepElement2(step) {
          var stepEl = document.createElement("li");
          addClass(stepEl, swalClasses["progress-step"]);
          setInnerHtml(stepEl, step);
          return stepEl;
        };
        var createLineElement = function createLineElement2(params) {
          var lineEl = document.createElement("li");
          addClass(lineEl, swalClasses["progress-step-line"]);
          if (params.progressStepsDistance) {
            applyNumericalStyle(lineEl, "width", params.progressStepsDistance);
          }
          return lineEl;
        };
        var renderTitle = function renderTitle2(instance, params) {
          var title = getTitle();
          if (!title) {
            return;
          }
          showWhenInnerHtmlPresent(title);
          toggle(title, params.title || params.titleText, "block");
          if (params.title) {
            parseHtmlToContainer(params.title, title);
          }
          if (params.titleText) {
            title.innerText = params.titleText;
          }
          applyCustomClass(title, params, "title");
        };
        var render = function render2(instance, params) {
          renderPopup(instance, params);
          renderContainer(instance, params);
          renderProgressSteps(instance, params);
          renderIcon(instance, params);
          renderImage(instance, params);
          renderTitle(instance, params);
          renderCloseButton(instance, params);
          renderContent(instance, params);
          renderActions(instance, params);
          renderFooter(instance, params);
          var popup = getPopup();
          if (typeof params.didRender === "function" && popup) {
            params.didRender(popup);
          }
        };
        var isVisible2 = function isVisible3() {
          return isVisible$1(getPopup());
        };
        var clickConfirm = function clickConfirm2() {
          var _dom$getConfirmButton;
          return (_dom$getConfirmButton = getConfirmButton()) === null || _dom$getConfirmButton === void 0 ? void 0 : _dom$getConfirmButton.click();
        };
        var clickDeny = function clickDeny2() {
          var _dom$getDenyButton;
          return (_dom$getDenyButton = getDenyButton()) === null || _dom$getDenyButton === void 0 ? void 0 : _dom$getDenyButton.click();
        };
        var clickCancel = function clickCancel2() {
          var _dom$getCancelButton;
          return (_dom$getCancelButton = getCancelButton()) === null || _dom$getCancelButton === void 0 ? void 0 : _dom$getCancelButton.click();
        };
        var DismissReason = Object.freeze({
          cancel: "cancel",
          backdrop: "backdrop",
          close: "close",
          esc: "esc",
          timer: "timer"
        });
        var removeKeydownHandler = function removeKeydownHandler2(globalState2) {
          if (globalState2.keydownTarget && globalState2.keydownHandlerAdded) {
            globalState2.keydownTarget.removeEventListener("keydown", globalState2.keydownHandler, {
              capture: globalState2.keydownListenerCapture
            });
            globalState2.keydownHandlerAdded = false;
          }
        };
        var addKeydownHandler = function addKeydownHandler2(globalState2, innerParams, dismissWith) {
          removeKeydownHandler(globalState2);
          if (!innerParams.toast) {
            globalState2.keydownHandler = function(e2) {
              return keydownHandler(innerParams, e2, dismissWith);
            };
            globalState2.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();
            globalState2.keydownListenerCapture = innerParams.keydownListenerCapture;
            globalState2.keydownTarget.addEventListener("keydown", globalState2.keydownHandler, {
              capture: globalState2.keydownListenerCapture
            });
            globalState2.keydownHandlerAdded = true;
          }
        };
        var setFocus = function setFocus2(index, increment) {
          var _dom$getPopup;
          var focusableElements = getFocusableElements();
          if (focusableElements.length) {
            index = index + increment;
            if (index === focusableElements.length) {
              index = 0;
            } else if (index === -1) {
              index = focusableElements.length - 1;
            }
            focusableElements[index].focus();
            return;
          }
          (_dom$getPopup = getPopup()) === null || _dom$getPopup === void 0 || _dom$getPopup.focus();
        };
        var arrowKeysNextButton = ["ArrowRight", "ArrowDown"];
        var arrowKeysPreviousButton = ["ArrowLeft", "ArrowUp"];
        var keydownHandler = function keydownHandler2(innerParams, event, dismissWith) {
          if (!innerParams) {
            return;
          }
          if (event.isComposing || event.keyCode === 229) {
            return;
          }
          if (innerParams.stopKeydownPropagation) {
            event.stopPropagation();
          }
          if (event.key === "Enter") {
            handleEnter(event, innerParams);
          } else if (event.key === "Tab") {
            handleTab(event);
          } else if ([].concat(arrowKeysNextButton, arrowKeysPreviousButton).includes(event.key)) {
            handleArrows(event.key);
          } else if (event.key === "Escape") {
            handleEsc(event, innerParams, dismissWith);
          }
        };
        var handleEnter = function handleEnter2(event, innerParams) {
          if (!callIfFunction(innerParams.allowEnterKey)) {
            return;
          }
          var input = getInput$1(getPopup(), innerParams.input);
          if (event.target && input && event.target instanceof HTMLElement && event.target.outerHTML === input.outerHTML) {
            if (["textarea", "file"].includes(innerParams.input)) {
              return;
            }
            clickConfirm();
            event.preventDefault();
          }
        };
        var handleTab = function handleTab2(event) {
          var targetElement = event.target;
          var focusableElements = getFocusableElements();
          var btnIndex = -1;
          for (var i2 = 0; i2 < focusableElements.length; i2++) {
            if (targetElement === focusableElements[i2]) {
              btnIndex = i2;
              break;
            }
          }
          if (!event.shiftKey) {
            setFocus(btnIndex, 1);
          } else {
            setFocus(btnIndex, -1);
          }
          event.stopPropagation();
          event.preventDefault();
        };
        var handleArrows = function handleArrows2(key) {
          var actions = getActions();
          var confirmButton = getConfirmButton();
          var denyButton = getDenyButton();
          var cancelButton = getCancelButton();
          if (!actions || !confirmButton || !denyButton || !cancelButton) {
            return;
          }
          var buttons = [confirmButton, denyButton, cancelButton];
          if (document.activeElement instanceof HTMLElement && !buttons.includes(document.activeElement)) {
            return;
          }
          var sibling = arrowKeysNextButton.includes(key) ? "nextElementSibling" : "previousElementSibling";
          var buttonToFocus = document.activeElement;
          if (!buttonToFocus) {
            return;
          }
          for (var i2 = 0; i2 < actions.children.length; i2++) {
            buttonToFocus = buttonToFocus[sibling];
            if (!buttonToFocus) {
              return;
            }
            if (buttonToFocus instanceof HTMLButtonElement && isVisible$1(buttonToFocus)) {
              break;
            }
          }
          if (buttonToFocus instanceof HTMLButtonElement) {
            buttonToFocus.focus();
          }
        };
        var handleEsc = function handleEsc2(event, innerParams, dismissWith) {
          if (callIfFunction(innerParams.allowEscapeKey)) {
            event.preventDefault();
            dismissWith(DismissReason.esc);
          }
        };
        var privateMethods = {
          swalPromiseResolve: /* @__PURE__ */ new WeakMap(),
          swalPromiseReject: /* @__PURE__ */ new WeakMap()
        };
        var setAriaHidden = function setAriaHidden2() {
          var container = getContainer();
          var bodyChildren = Array.from(document.body.children);
          bodyChildren.forEach(function(el) {
            if (el.contains(container)) {
              return;
            }
            if (el.hasAttribute("aria-hidden")) {
              el.setAttribute("data-previous-aria-hidden", el.getAttribute("aria-hidden") || "");
            }
            el.setAttribute("aria-hidden", "true");
          });
        };
        var unsetAriaHidden = function unsetAriaHidden2() {
          var bodyChildren = Array.from(document.body.children);
          bodyChildren.forEach(function(el) {
            if (el.hasAttribute("data-previous-aria-hidden")) {
              el.setAttribute("aria-hidden", el.getAttribute("data-previous-aria-hidden") || "");
              el.removeAttribute("data-previous-aria-hidden");
            } else {
              el.removeAttribute("aria-hidden");
            }
          });
        };
        var isSafariOrIOS = typeof window !== "undefined" && !!window.GestureEvent;
        var iOSfix = function iOSfix2() {
          if (isSafariOrIOS && !hasClass(document.body, swalClasses.iosfix)) {
            var offset2 = document.body.scrollTop;
            document.body.style.top = "".concat(offset2 * -1, "px");
            addClass(document.body, swalClasses.iosfix);
            lockBodyScroll();
          }
        };
        var lockBodyScroll = function lockBodyScroll2() {
          var container = getContainer();
          if (!container) {
            return;
          }
          var preventTouchMove;
          container.ontouchstart = function(event) {
            preventTouchMove = shouldPreventTouchMove(event);
          };
          container.ontouchmove = function(event) {
            if (preventTouchMove) {
              event.preventDefault();
              event.stopPropagation();
            }
          };
        };
        var shouldPreventTouchMove = function shouldPreventTouchMove2(event) {
          var target = event.target;
          var container = getContainer();
          var htmlContainer = getHtmlContainer();
          if (!container || !htmlContainer) {
            return false;
          }
          if (isStylus(event) || isZoom(event)) {
            return false;
          }
          if (target === container) {
            return true;
          }
          if (!isScrollable(container) && target instanceof HTMLElement && target.tagName !== "INPUT" && // #1603
          target.tagName !== "TEXTAREA" && // #2266
          !(isScrollable(htmlContainer) && // #1944
          htmlContainer.contains(target))) {
            return true;
          }
          return false;
        };
        var isStylus = function isStylus2(event) {
          return event.touches && event.touches.length && event.touches[0].touchType === "stylus";
        };
        var isZoom = function isZoom2(event) {
          return event.touches && event.touches.length > 1;
        };
        var undoIOSfix = function undoIOSfix2() {
          if (hasClass(document.body, swalClasses.iosfix)) {
            var offset2 = parseInt(document.body.style.top, 10);
            removeClass(document.body, swalClasses.iosfix);
            document.body.style.top = "";
            document.body.scrollTop = offset2 * -1;
          }
        };
        var measureScrollbar = function measureScrollbar2() {
          var scrollDiv = document.createElement("div");
          scrollDiv.className = swalClasses["scrollbar-measure"];
          document.body.appendChild(scrollDiv);
          var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
          document.body.removeChild(scrollDiv);
          return scrollbarWidth;
        };
        var previousBodyPadding = null;
        var replaceScrollbarWithPadding = function replaceScrollbarWithPadding2(initialBodyOverflow) {
          if (previousBodyPadding !== null) {
            return;
          }
          if (document.body.scrollHeight > window.innerHeight || initialBodyOverflow === "scroll") {
            previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right"));
            document.body.style.paddingRight = "".concat(previousBodyPadding + measureScrollbar(), "px");
          }
        };
        var undoReplaceScrollbarWithPadding = function undoReplaceScrollbarWithPadding2() {
          if (previousBodyPadding !== null) {
            document.body.style.paddingRight = "".concat(previousBodyPadding, "px");
            previousBodyPadding = null;
          }
        };
        function removePopupAndResetState(instance, container, returnFocus, didClose) {
          if (isToast()) {
            triggerDidCloseAndDispose(instance, didClose);
          } else {
            restoreActiveElement(returnFocus).then(function() {
              return triggerDidCloseAndDispose(instance, didClose);
            });
            removeKeydownHandler(globalState);
          }
          if (isSafariOrIOS) {
            container.setAttribute("style", "display:none !important");
            container.removeAttribute("class");
            container.innerHTML = "";
          } else {
            container.remove();
          }
          if (isModal()) {
            undoReplaceScrollbarWithPadding();
            undoIOSfix();
            unsetAriaHidden();
          }
          removeBodyClasses();
        }
        function removeBodyClasses() {
          removeClass([document.documentElement, document.body], [swalClasses.shown, swalClasses["height-auto"], swalClasses["no-backdrop"], swalClasses["toast-shown"]]);
        }
        function close(resolveValue) {
          resolveValue = prepareResolveValue(resolveValue);
          var swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);
          var didClose = triggerClosePopup(this);
          if (this.isAwaitingPromise) {
            if (!resolveValue.isDismissed) {
              handleAwaitingPromise(this);
              swalPromiseResolve(resolveValue);
            }
          } else if (didClose) {
            swalPromiseResolve(resolveValue);
          }
        }
        var triggerClosePopup = function triggerClosePopup2(instance) {
          var popup = getPopup();
          if (!popup) {
            return false;
          }
          var innerParams = privateProps.innerParams.get(instance);
          if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {
            return false;
          }
          removeClass(popup, innerParams.showClass.popup);
          addClass(popup, innerParams.hideClass.popup);
          var backdrop = getContainer();
          removeClass(backdrop, innerParams.showClass.backdrop);
          addClass(backdrop, innerParams.hideClass.backdrop);
          handlePopupAnimation(instance, popup, innerParams);
          return true;
        };
        function rejectPromise(error3) {
          var rejectPromise2 = privateMethods.swalPromiseReject.get(this);
          handleAwaitingPromise(this);
          if (rejectPromise2) {
            rejectPromise2(error3);
          }
        }
        var handleAwaitingPromise = function handleAwaitingPromise2(instance) {
          if (instance.isAwaitingPromise) {
            delete instance.isAwaitingPromise;
            if (!privateProps.innerParams.get(instance)) {
              instance._destroy();
            }
          }
        };
        var prepareResolveValue = function prepareResolveValue2(resolveValue) {
          if (typeof resolveValue === "undefined") {
            return {
              isConfirmed: false,
              isDenied: false,
              isDismissed: true
            };
          }
          return Object.assign({
            isConfirmed: false,
            isDenied: false,
            isDismissed: false
          }, resolveValue);
        };
        var handlePopupAnimation = function handlePopupAnimation2(instance, popup, innerParams) {
          var container = getContainer();
          var animationIsSupported = animationEndEvent && hasCssAnimation(popup);
          if (typeof innerParams.willClose === "function") {
            innerParams.willClose(popup);
          }
          if (animationIsSupported) {
            animatePopup(instance, popup, container, innerParams.returnFocus, innerParams.didClose);
          } else {
            removePopupAndResetState(instance, container, innerParams.returnFocus, innerParams.didClose);
          }
        };
        var animatePopup = function animatePopup2(instance, popup, container, returnFocus, didClose) {
          if (!animationEndEvent) {
            return;
          }
          globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, returnFocus, didClose);
          popup.addEventListener(animationEndEvent, function(e2) {
            if (e2.target === popup) {
              globalState.swalCloseEventFinishedCallback();
              delete globalState.swalCloseEventFinishedCallback;
            }
          });
        };
        var triggerDidCloseAndDispose = function triggerDidCloseAndDispose2(instance, didClose) {
          setTimeout(function() {
            if (typeof didClose === "function") {
              didClose.bind(instance.params)();
            }
            if (instance._destroy) {
              instance._destroy();
            }
          });
        };
        var showLoading = function showLoading2(buttonToReplace) {
          var popup = getPopup();
          if (!popup) {
            new Swal2();
          }
          popup = getPopup();
          if (!popup) {
            return;
          }
          var loader = getLoader();
          if (isToast()) {
            hide2(getIcon());
          } else {
            replaceButton(popup, buttonToReplace);
          }
          show(loader);
          popup.setAttribute("data-loading", "true");
          popup.setAttribute("aria-busy", "true");
          popup.focus();
        };
        var replaceButton = function replaceButton2(popup, buttonToReplace) {
          var actions = getActions();
          var loader = getLoader();
          if (!actions || !loader) {
            return;
          }
          if (!buttonToReplace && isVisible$1(getConfirmButton())) {
            buttonToReplace = getConfirmButton();
          }
          show(actions);
          if (buttonToReplace) {
            hide2(buttonToReplace);
            loader.setAttribute("data-button-to-replace", buttonToReplace.className);
            actions.insertBefore(loader, buttonToReplace);
          }
          addClass([popup, actions], swalClasses.loading);
        };
        var handleInputOptionsAndValue = function handleInputOptionsAndValue2(instance, params) {
          if (params.input === "select" || params.input === "radio") {
            handleInputOptions(instance, params);
          } else if (["text", "email", "number", "tel", "textarea"].some(function(i2) {
            return i2 === params.input;
          }) && (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {
            showLoading(getConfirmButton());
            handleInputValue(instance, params);
          }
        };
        var getInputValue = function getInputValue2(instance, innerParams) {
          var input = instance.getInput();
          if (!input) {
            return null;
          }
          switch (innerParams.input) {
            case "checkbox":
              return getCheckboxValue(input);
            case "radio":
              return getRadioValue(input);
            case "file":
              return getFileValue(input);
            default:
              return innerParams.inputAutoTrim ? input.value.trim() : input.value;
          }
        };
        var getCheckboxValue = function getCheckboxValue2(input) {
          return input.checked ? 1 : 0;
        };
        var getRadioValue = function getRadioValue2(input) {
          return input.checked ? input.value : null;
        };
        var getFileValue = function getFileValue2(input) {
          return input.files && input.files.length ? input.getAttribute("multiple") !== null ? input.files : input.files[0] : null;
        };
        var handleInputOptions = function handleInputOptions2(instance, params) {
          var popup = getPopup();
          if (!popup) {
            return;
          }
          var processInputOptions = function processInputOptions2(inputOptions) {
            if (params.input === "select") {
              populateSelectOptions(popup, _formatInputOptions(inputOptions), params);
            } else if (params.input === "radio") {
              populateRadioOptions(popup, _formatInputOptions(inputOptions), params);
            }
          };
          if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {
            showLoading(getConfirmButton());
            asPromise(params.inputOptions).then(function(inputOptions) {
              instance.hideLoading();
              processInputOptions(inputOptions);
            });
          } else if (_typeof(params.inputOptions) === "object") {
            processInputOptions(params.inputOptions);
          } else {
            error2("Unexpected type of inputOptions! Expected object, Map or Promise, got ".concat(_typeof(params.inputOptions)));
          }
        };
        var handleInputValue = function handleInputValue2(instance, params) {
          var input = instance.getInput();
          if (!input) {
            return;
          }
          hide2(input);
          asPromise(params.inputValue).then(function(inputValue) {
            input.value = params.input === "number" ? "".concat(parseFloat(inputValue) || 0) : "".concat(inputValue);
            show(input);
            input.focus();
            instance.hideLoading();
          })["catch"](function(err) {
            error2("Error in inputValue promise: ".concat(err));
            input.value = "";
            show(input);
            input.focus();
            instance.hideLoading();
          });
        };
        function populateSelectOptions(popup, inputOptions, params) {
          var select = getDirectChildByClass(popup, swalClasses.select);
          if (!select) {
            return;
          }
          var renderOption = function renderOption2(parent, optionLabel, optionValue) {
            var option = document.createElement("option");
            option.value = optionValue;
            setInnerHtml(option, optionLabel);
            option.selected = isSelected(optionValue, params.inputValue);
            parent.appendChild(option);
          };
          inputOptions.forEach(function(inputOption) {
            var optionValue = inputOption[0];
            var optionLabel = inputOption[1];
            if (Array.isArray(optionLabel)) {
              var optgroup = document.createElement("optgroup");
              optgroup.label = optionValue;
              optgroup.disabled = false;
              select.appendChild(optgroup);
              optionLabel.forEach(function(o2) {
                return renderOption(optgroup, o2[1], o2[0]);
              });
            } else {
              renderOption(select, optionLabel, optionValue);
            }
          });
          select.focus();
        }
        function populateRadioOptions(popup, inputOptions, params) {
          var radio = getDirectChildByClass(popup, swalClasses.radio);
          if (!radio) {
            return;
          }
          inputOptions.forEach(function(inputOption) {
            var radioValue = inputOption[0];
            var radioLabel = inputOption[1];
            var radioInput = document.createElement("input");
            var radioLabelElement = document.createElement("label");
            radioInput.type = "radio";
            radioInput.name = swalClasses.radio;
            radioInput.value = radioValue;
            if (isSelected(radioValue, params.inputValue)) {
              radioInput.checked = true;
            }
            var label = document.createElement("span");
            setInnerHtml(label, radioLabel);
            label.className = swalClasses.label;
            radioLabelElement.appendChild(radioInput);
            radioLabelElement.appendChild(label);
            radio.appendChild(radioLabelElement);
          });
          var radios = radio.querySelectorAll("input");
          if (radios.length) {
            radios[0].focus();
          }
        }
        var _formatInputOptions = function formatInputOptions(inputOptions) {
          var result = [];
          if (inputOptions instanceof Map) {
            inputOptions.forEach(function(value, key) {
              var valueFormatted = value;
              if (_typeof(valueFormatted) === "object") {
                valueFormatted = _formatInputOptions(valueFormatted);
              }
              result.push([key, valueFormatted]);
            });
          } else {
            Object.keys(inputOptions).forEach(function(key) {
              var valueFormatted = inputOptions[key];
              if (_typeof(valueFormatted) === "object") {
                valueFormatted = _formatInputOptions(valueFormatted);
              }
              result.push([key, valueFormatted]);
            });
          }
          return result;
        };
        var isSelected = function isSelected2(optionValue, inputValue) {
          return !!inputValue && inputValue.toString() === optionValue.toString();
        };
        var _this = void 0;
        var handleConfirmButtonClick = function handleConfirmButtonClick2(instance) {
          var innerParams = privateProps.innerParams.get(instance);
          instance.disableButtons();
          if (innerParams.input) {
            handleConfirmOrDenyWithInput(instance, "confirm");
          } else {
            confirm2(instance, true);
          }
        };
        var handleDenyButtonClick = function handleDenyButtonClick2(instance) {
          var innerParams = privateProps.innerParams.get(instance);
          instance.disableButtons();
          if (innerParams.returnInputValueOnDeny) {
            handleConfirmOrDenyWithInput(instance, "deny");
          } else {
            deny(instance, false);
          }
        };
        var handleCancelButtonClick = function handleCancelButtonClick2(instance, dismissWith) {
          instance.disableButtons();
          dismissWith(DismissReason.cancel);
        };
        var handleConfirmOrDenyWithInput = function handleConfirmOrDenyWithInput2(instance, type) {
          var innerParams = privateProps.innerParams.get(instance);
          if (!innerParams.input) {
            error2('The "input" parameter is needed to be set when using returnInputValueOn'.concat(capitalizeFirstLetter(type)));
            return;
          }
          var input = instance.getInput();
          var inputValue = getInputValue(instance, innerParams);
          if (innerParams.inputValidator) {
            handleInputValidator(instance, inputValue, type);
          } else if (input && !input.checkValidity()) {
            instance.enableButtons();
            instance.showValidationMessage(innerParams.validationMessage || input.validationMessage);
          } else if (type === "deny") {
            deny(instance, inputValue);
          } else {
            confirm2(instance, inputValue);
          }
        };
        var handleInputValidator = function handleInputValidator2(instance, inputValue, type) {
          var innerParams = privateProps.innerParams.get(instance);
          instance.disableInput();
          var validationPromise = Promise.resolve().then(function() {
            return asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage));
          });
          validationPromise.then(function(validationMessage) {
            instance.enableButtons();
            instance.enableInput();
            if (validationMessage) {
              instance.showValidationMessage(validationMessage);
            } else if (type === "deny") {
              deny(instance, inputValue);
            } else {
              confirm2(instance, inputValue);
            }
          });
        };
        var deny = function deny2(instance, value) {
          var innerParams = privateProps.innerParams.get(instance || _this);
          if (innerParams.showLoaderOnDeny) {
            showLoading(getDenyButton());
          }
          if (innerParams.preDeny) {
            instance.isAwaitingPromise = true;
            var preDenyPromise = Promise.resolve().then(function() {
              return asPromise(innerParams.preDeny(value, innerParams.validationMessage));
            });
            preDenyPromise.then(function(preDenyValue) {
              if (preDenyValue === false) {
                instance.hideLoading();
                handleAwaitingPromise(instance);
              } else {
                instance.close({
                  isDenied: true,
                  value: typeof preDenyValue === "undefined" ? value : preDenyValue
                });
              }
            })["catch"](function(error3) {
              return rejectWith(instance || _this, error3);
            });
          } else {
            instance.close({
              isDenied: true,
              value
            });
          }
        };
        var succeedWith = function succeedWith2(instance, value) {
          instance.close({
            isConfirmed: true,
            value
          });
        };
        var rejectWith = function rejectWith2(instance, error3) {
          instance.rejectPromise(error3);
        };
        var confirm2 = function confirm3(instance, value) {
          var innerParams = privateProps.innerParams.get(instance || _this);
          if (innerParams.showLoaderOnConfirm) {
            showLoading();
          }
          if (innerParams.preConfirm) {
            instance.resetValidationMessage();
            instance.isAwaitingPromise = true;
            var preConfirmPromise = Promise.resolve().then(function() {
              return asPromise(innerParams.preConfirm(value, innerParams.validationMessage));
            });
            preConfirmPromise.then(function(preConfirmValue) {
              if (isVisible$1(getValidationMessage()) || preConfirmValue === false) {
                instance.hideLoading();
                handleAwaitingPromise(instance);
              } else {
                succeedWith(instance, typeof preConfirmValue === "undefined" ? value : preConfirmValue);
              }
            })["catch"](function(error3) {
              return rejectWith(instance || _this, error3);
            });
          } else {
            succeedWith(instance, value);
          }
        };
        function hideLoading() {
          var innerParams = privateProps.innerParams.get(this);
          if (!innerParams) {
            return;
          }
          var domCache = privateProps.domCache.get(this);
          hide2(domCache.loader);
          if (isToast()) {
            if (innerParams.icon) {
              show(getIcon());
            }
          } else {
            showRelatedButton(domCache);
          }
          removeClass([domCache.popup, domCache.actions], swalClasses.loading);
          domCache.popup.removeAttribute("aria-busy");
          domCache.popup.removeAttribute("data-loading");
          domCache.confirmButton.disabled = false;
          domCache.denyButton.disabled = false;
          domCache.cancelButton.disabled = false;
        }
        var showRelatedButton = function showRelatedButton2(domCache) {
          var buttonToReplace = domCache.popup.getElementsByClassName(domCache.loader.getAttribute("data-button-to-replace"));
          if (buttonToReplace.length) {
            show(buttonToReplace[0], "inline-block");
          } else if (allButtonsAreHidden()) {
            hide2(domCache.actions);
          }
        };
        function getInput() {
          var innerParams = privateProps.innerParams.get(this);
          var domCache = privateProps.domCache.get(this);
          if (!domCache) {
            return null;
          }
          return getInput$1(domCache.popup, innerParams.input);
        }
        function setButtonsDisabled(instance, buttons, disabled) {
          var domCache = privateProps.domCache.get(instance);
          buttons.forEach(function(button) {
            domCache[button].disabled = disabled;
          });
        }
        function setInputDisabled(input, disabled) {
          var popup = getPopup();
          if (!popup || !input) {
            return;
          }
          if (input.type === "radio") {
            var radios = popup.querySelectorAll('[name="'.concat(swalClasses.radio, '"]'));
            for (var i2 = 0; i2 < radios.length; i2++) {
              radios[i2].disabled = disabled;
            }
          } else {
            input.disabled = disabled;
          }
        }
        function enableButtons() {
          setButtonsDisabled(this, ["confirmButton", "denyButton", "cancelButton"], false);
        }
        function disableButtons() {
          setButtonsDisabled(this, ["confirmButton", "denyButton", "cancelButton"], true);
        }
        function enableInput() {
          setInputDisabled(this.getInput(), false);
        }
        function disableInput() {
          setInputDisabled(this.getInput(), true);
        }
        function showValidationMessage(error3) {
          var domCache = privateProps.domCache.get(this);
          var params = privateProps.innerParams.get(this);
          setInnerHtml(domCache.validationMessage, error3);
          domCache.validationMessage.className = swalClasses["validation-message"];
          if (params.customClass && params.customClass.validationMessage) {
            addClass(domCache.validationMessage, params.customClass.validationMessage);
          }
          show(domCache.validationMessage);
          var input = this.getInput();
          if (input) {
            input.setAttribute("aria-invalid", "true");
            input.setAttribute("aria-describedby", swalClasses["validation-message"]);
            focusInput(input);
            addClass(input, swalClasses.inputerror);
          }
        }
        function resetValidationMessage() {
          var domCache = privateProps.domCache.get(this);
          if (domCache.validationMessage) {
            hide2(domCache.validationMessage);
          }
          var input = this.getInput();
          if (input) {
            input.removeAttribute("aria-invalid");
            input.removeAttribute("aria-describedby");
            removeClass(input, swalClasses.inputerror);
          }
        }
        var defaultParams = {
          title: "",
          titleText: "",
          text: "",
          html: "",
          footer: "",
          icon: void 0,
          iconColor: void 0,
          iconHtml: void 0,
          template: void 0,
          toast: false,
          animation: true,
          showClass: {
            popup: "swal2-show",
            backdrop: "swal2-backdrop-show",
            icon: "swal2-icon-show"
          },
          hideClass: {
            popup: "swal2-hide",
            backdrop: "swal2-backdrop-hide",
            icon: "swal2-icon-hide"
          },
          customClass: {},
          target: "body",
          color: void 0,
          backdrop: true,
          heightAuto: true,
          allowOutsideClick: true,
          allowEscapeKey: true,
          allowEnterKey: true,
          stopKeydownPropagation: true,
          keydownListenerCapture: false,
          showConfirmButton: true,
          showDenyButton: false,
          showCancelButton: false,
          preConfirm: void 0,
          preDeny: void 0,
          confirmButtonText: "OK",
          confirmButtonAriaLabel: "",
          confirmButtonColor: void 0,
          denyButtonText: "No",
          denyButtonAriaLabel: "",
          denyButtonColor: void 0,
          cancelButtonText: "Cancel",
          cancelButtonAriaLabel: "",
          cancelButtonColor: void 0,
          buttonsStyling: true,
          reverseButtons: false,
          focusConfirm: true,
          focusDeny: false,
          focusCancel: false,
          returnFocus: true,
          showCloseButton: false,
          closeButtonHtml: "&times;",
          closeButtonAriaLabel: "Close this dialog",
          loaderHtml: "",
          showLoaderOnConfirm: false,
          showLoaderOnDeny: false,
          imageUrl: void 0,
          imageWidth: void 0,
          imageHeight: void 0,
          imageAlt: "",
          timer: void 0,
          timerProgressBar: false,
          width: void 0,
          padding: void 0,
          background: void 0,
          input: void 0,
          inputPlaceholder: "",
          inputLabel: "",
          inputValue: "",
          inputOptions: {},
          inputAutoFocus: true,
          inputAutoTrim: true,
          inputAttributes: {},
          inputValidator: void 0,
          returnInputValueOnDeny: false,
          validationMessage: void 0,
          grow: false,
          position: "center",
          progressSteps: [],
          currentProgressStep: void 0,
          progressStepsDistance: void 0,
          willOpen: void 0,
          didOpen: void 0,
          didRender: void 0,
          willClose: void 0,
          didClose: void 0,
          didDestroy: void 0,
          scrollbarPadding: true
        };
        var updatableParams = ["allowEscapeKey", "allowOutsideClick", "background", "buttonsStyling", "cancelButtonAriaLabel", "cancelButtonColor", "cancelButtonText", "closeButtonAriaLabel", "closeButtonHtml", "color", "confirmButtonAriaLabel", "confirmButtonColor", "confirmButtonText", "currentProgressStep", "customClass", "denyButtonAriaLabel", "denyButtonColor", "denyButtonText", "didClose", "didDestroy", "footer", "hideClass", "html", "icon", "iconColor", "iconHtml", "imageAlt", "imageHeight", "imageUrl", "imageWidth", "preConfirm", "preDeny", "progressSteps", "returnFocus", "reverseButtons", "showCancelButton", "showCloseButton", "showConfirmButton", "showDenyButton", "text", "title", "titleText", "willClose"];
        var deprecatedParams = {
          allowEnterKey: void 0
        };
        var toastIncompatibleParams = ["allowOutsideClick", "allowEnterKey", "backdrop", "focusConfirm", "focusDeny", "focusCancel", "returnFocus", "heightAuto", "keydownListenerCapture"];
        var isValidParameter = function isValidParameter2(paramName) {
          return Object.prototype.hasOwnProperty.call(defaultParams, paramName);
        };
        var isUpdatableParameter = function isUpdatableParameter2(paramName) {
          return updatableParams.indexOf(paramName) !== -1;
        };
        var isDeprecatedParameter = function isDeprecatedParameter2(paramName) {
          return deprecatedParams[paramName];
        };
        var checkIfParamIsValid = function checkIfParamIsValid2(param) {
          if (!isValidParameter(param)) {
            warn('Unknown parameter "'.concat(param, '"'));
          }
        };
        var checkIfToastParamIsValid = function checkIfToastParamIsValid2(param) {
          if (toastIncompatibleParams.includes(param)) {
            warn('The parameter "'.concat(param, '" is incompatible with toasts'));
          }
        };
        var checkIfParamIsDeprecated = function checkIfParamIsDeprecated2(param) {
          var isDeprecated = isDeprecatedParameter(param);
          if (isDeprecated) {
            warnAboutDeprecation(param, isDeprecated);
          }
        };
        var showWarningsForParams = function showWarningsForParams2(params) {
          if (params.backdrop === false && params.allowOutsideClick) {
            warn('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
          }
          for (var param in params) {
            checkIfParamIsValid(param);
            if (params.toast) {
              checkIfToastParamIsValid(param);
            }
            checkIfParamIsDeprecated(param);
          }
        };
        function update(params) {
          var popup = getPopup();
          var innerParams = privateProps.innerParams.get(this);
          if (!popup || hasClass(popup, innerParams.hideClass.popup)) {
            warn("You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.");
            return;
          }
          var validUpdatableParams = filterValidParams(params);
          var updatedParams = Object.assign({}, innerParams, validUpdatableParams);
          render(this, updatedParams);
          privateProps.innerParams.set(this, updatedParams);
          Object.defineProperties(this, {
            params: {
              value: Object.assign({}, this.params, params),
              writable: false,
              enumerable: true
            }
          });
        }
        var filterValidParams = function filterValidParams2(params) {
          var validUpdatableParams = {};
          Object.keys(params).forEach(function(param) {
            if (isUpdatableParameter(param)) {
              validUpdatableParams[param] = params[param];
            } else {
              warn("Invalid parameter to update: ".concat(param));
            }
          });
          return validUpdatableParams;
        };
        function _destroy() {
          var domCache = privateProps.domCache.get(this);
          var innerParams = privateProps.innerParams.get(this);
          if (!innerParams) {
            disposeWeakMaps(this);
            return;
          }
          if (domCache.popup && globalState.swalCloseEventFinishedCallback) {
            globalState.swalCloseEventFinishedCallback();
            delete globalState.swalCloseEventFinishedCallback;
          }
          if (typeof innerParams.didDestroy === "function") {
            innerParams.didDestroy();
          }
          disposeSwal(this);
        }
        var disposeSwal = function disposeSwal2(instance) {
          disposeWeakMaps(instance);
          delete instance.params;
          delete globalState.keydownHandler;
          delete globalState.keydownTarget;
          delete globalState.currentInstance;
        };
        var disposeWeakMaps = function disposeWeakMaps2(instance) {
          if (instance.isAwaitingPromise) {
            unsetWeakMaps(privateProps, instance);
            instance.isAwaitingPromise = true;
          } else {
            unsetWeakMaps(privateMethods, instance);
            unsetWeakMaps(privateProps, instance);
            delete instance.isAwaitingPromise;
            delete instance.disableButtons;
            delete instance.enableButtons;
            delete instance.getInput;
            delete instance.disableInput;
            delete instance.enableInput;
            delete instance.hideLoading;
            delete instance.disableLoading;
            delete instance.showValidationMessage;
            delete instance.resetValidationMessage;
            delete instance.close;
            delete instance.closePopup;
            delete instance.closeModal;
            delete instance.closeToast;
            delete instance.rejectPromise;
            delete instance.update;
            delete instance._destroy;
          }
        };
        var unsetWeakMaps = function unsetWeakMaps2(obj, instance) {
          for (var i2 in obj) {
            obj[i2]["delete"](instance);
          }
        };
        var instanceMethods = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          _destroy,
          close,
          closeModal: close,
          closePopup: close,
          closeToast: close,
          disableButtons,
          disableInput,
          disableLoading: hideLoading,
          enableButtons,
          enableInput,
          getInput,
          handleAwaitingPromise,
          hideLoading,
          rejectPromise,
          resetValidationMessage,
          showValidationMessage,
          update
        });
        var handlePopupClick = function handlePopupClick2(innerParams, domCache, dismissWith) {
          if (innerParams.toast) {
            handleToastClick(innerParams, domCache, dismissWith);
          } else {
            handleModalMousedown(domCache);
            handleContainerMousedown(domCache);
            handleModalClick(innerParams, domCache, dismissWith);
          }
        };
        var handleToastClick = function handleToastClick2(innerParams, domCache, dismissWith) {
          domCache.popup.onclick = function() {
            if (innerParams && (isAnyButtonShown(innerParams) || innerParams.timer || innerParams.input)) {
              return;
            }
            dismissWith(DismissReason.close);
          };
        };
        var isAnyButtonShown = function isAnyButtonShown2(innerParams) {
          return !!(innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || innerParams.showCloseButton);
        };
        var ignoreOutsideClick = false;
        var handleModalMousedown = function handleModalMousedown2(domCache) {
          domCache.popup.onmousedown = function() {
            domCache.container.onmouseup = function(e2) {
              domCache.container.onmouseup = function() {
              };
              if (e2.target === domCache.container) {
                ignoreOutsideClick = true;
              }
            };
          };
        };
        var handleContainerMousedown = function handleContainerMousedown2(domCache) {
          domCache.container.onmousedown = function(e2) {
            if (e2.target === domCache.container) {
              e2.preventDefault();
            }
            domCache.popup.onmouseup = function(e3) {
              domCache.popup.onmouseup = function() {
              };
              if (e3.target === domCache.popup || e3.target instanceof HTMLElement && domCache.popup.contains(e3.target)) {
                ignoreOutsideClick = true;
              }
            };
          };
        };
        var handleModalClick = function handleModalClick2(innerParams, domCache, dismissWith) {
          domCache.container.onclick = function(e2) {
            if (ignoreOutsideClick) {
              ignoreOutsideClick = false;
              return;
            }
            if (e2.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {
              dismissWith(DismissReason.backdrop);
            }
          };
        };
        var isJqueryElement = function isJqueryElement2(elem) {
          return _typeof(elem) === "object" && elem.jquery;
        };
        var isElement3 = function isElement4(elem) {
          return elem instanceof Element || isJqueryElement(elem);
        };
        var argsToParams = function argsToParams2(args) {
          var params = {};
          if (_typeof(args[0]) === "object" && !isElement3(args[0])) {
            Object.assign(params, args[0]);
          } else {
            ["title", "html", "icon"].forEach(function(name, index) {
              var arg = args[index];
              if (typeof arg === "string" || isElement3(arg)) {
                params[name] = arg;
              } else if (arg !== void 0) {
                error2("Unexpected type of ".concat(name, '! Expected "string" or "Element", got ').concat(_typeof(arg)));
              }
            });
          }
          return params;
        };
        function fire() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return _construct(this, args);
        }
        function mixin(mixinParams) {
          var MixinSwal = /* @__PURE__ */ function(_this2) {
            function MixinSwal2() {
              _classCallCheck(this, MixinSwal2);
              return _callSuper(this, MixinSwal2, arguments);
            }
            _inherits(MixinSwal2, _this2);
            return _createClass(MixinSwal2, [{
              key: "_main",
              value: function _main(params, priorityMixinParams) {
                return _superPropGet(MixinSwal2, "_main", this)([params, Object.assign({}, mixinParams, priorityMixinParams)]);
              }
            }]);
          }(this);
          return MixinSwal;
        }
        var getTimerLeft = function getTimerLeft2() {
          return globalState.timeout && globalState.timeout.getTimerLeft();
        };
        var stopTimer = function stopTimer2() {
          if (globalState.timeout) {
            stopTimerProgressBar();
            return globalState.timeout.stop();
          }
        };
        var resumeTimer = function resumeTimer2() {
          if (globalState.timeout) {
            var remaining = globalState.timeout.start();
            animateTimerProgressBar(remaining);
            return remaining;
          }
        };
        var toggleTimer = function toggleTimer2() {
          var timer = globalState.timeout;
          return timer && (timer.running ? stopTimer() : resumeTimer());
        };
        var increaseTimer = function increaseTimer2(ms) {
          if (globalState.timeout) {
            var remaining = globalState.timeout.increase(ms);
            animateTimerProgressBar(remaining, true);
            return remaining;
          }
        };
        var isTimerRunning = function isTimerRunning2() {
          return !!(globalState.timeout && globalState.timeout.isRunning());
        };
        var bodyClickListenerAdded = false;
        var clickHandlers = {};
        function bindClickHandler() {
          var attr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "data-swal-template";
          clickHandlers[attr] = this;
          if (!bodyClickListenerAdded) {
            document.body.addEventListener("click", bodyClickListener);
            bodyClickListenerAdded = true;
          }
        }
        var bodyClickListener = function bodyClickListener2(event) {
          for (var el = event.target; el && el !== document; el = el.parentNode) {
            for (var attr in clickHandlers) {
              var template = el.getAttribute(attr);
              if (template) {
                clickHandlers[attr].fire({
                  template
                });
                return;
              }
            }
          }
        };
        var staticMethods = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          argsToParams,
          bindClickHandler,
          clickCancel,
          clickConfirm,
          clickDeny,
          enableLoading: showLoading,
          fire,
          getActions,
          getCancelButton,
          getCloseButton,
          getConfirmButton,
          getContainer,
          getDenyButton,
          getFocusableElements,
          getFooter,
          getHtmlContainer,
          getIcon,
          getIconContent,
          getImage,
          getInputLabel,
          getLoader,
          getPopup,
          getProgressSteps,
          getTimerLeft,
          getTimerProgressBar,
          getTitle,
          getValidationMessage,
          increaseTimer,
          isDeprecatedParameter,
          isLoading,
          isTimerRunning,
          isUpdatableParameter,
          isValidParameter,
          isVisible: isVisible2,
          mixin,
          resumeTimer,
          showLoading,
          stopTimer,
          toggleTimer
        });
        var Timer = /* @__PURE__ */ function() {
          function Timer2(callback, delay) {
            _classCallCheck(this, Timer2);
            this.callback = callback;
            this.remaining = delay;
            this.running = false;
            this.start();
          }
          return _createClass(Timer2, [{
            key: "start",
            value: function start3() {
              if (!this.running) {
                this.running = true;
                this.started = /* @__PURE__ */ new Date();
                this.id = setTimeout(this.callback, this.remaining);
              }
              return this.remaining;
            }
            /**
             * @returns {number}
             */
          }, {
            key: "stop",
            value: function stop() {
              if (this.started && this.running) {
                this.running = false;
                clearTimeout(this.id);
                this.remaining -= (/* @__PURE__ */ new Date()).getTime() - this.started.getTime();
              }
              return this.remaining;
            }
            /**
             * @param {number} n
             * @returns {number}
             */
          }, {
            key: "increase",
            value: function increase(n2) {
              var running = this.running;
              if (running) {
                this.stop();
              }
              this.remaining += n2;
              if (running) {
                this.start();
              }
              return this.remaining;
            }
            /**
             * @returns {number}
             */
          }, {
            key: "getTimerLeft",
            value: function getTimerLeft2() {
              if (this.running) {
                this.stop();
                this.start();
              }
              return this.remaining;
            }
            /**
             * @returns {boolean}
             */
          }, {
            key: "isRunning",
            value: function isRunning() {
              return this.running;
            }
          }]);
        }();
        var swalStringParams = ["swal-title", "swal-html", "swal-footer"];
        var getTemplateParams = function getTemplateParams2(params) {
          var template = typeof params.template === "string" ? (
            /** @type {HTMLTemplateElement} */
            document.querySelector(params.template)
          ) : params.template;
          if (!template) {
            return {};
          }
          var templateContent = template.content;
          showWarningsForElements(templateContent);
          var result = Object.assign(getSwalParams(templateContent), getSwalFunctionParams(templateContent), getSwalButtons(templateContent), getSwalImage(templateContent), getSwalIcon(templateContent), getSwalInput(templateContent), getSwalStringParams(templateContent, swalStringParams));
          return result;
        };
        var getSwalParams = function getSwalParams2(templateContent) {
          var result = {};
          var swalParams = Array.from(templateContent.querySelectorAll("swal-param"));
          swalParams.forEach(function(param) {
            showWarningsForAttributes(param, ["name", "value"]);
            var paramName = (
              /** @type {keyof SweetAlertOptions} */
              param.getAttribute("name")
            );
            var value = param.getAttribute("value");
            if (!paramName || !value) {
              return;
            }
            if (typeof defaultParams[paramName] === "boolean") {
              result[paramName] = value !== "false";
            } else if (_typeof(defaultParams[paramName]) === "object") {
              result[paramName] = JSON.parse(value);
            } else {
              result[paramName] = value;
            }
          });
          return result;
        };
        var getSwalFunctionParams = function getSwalFunctionParams2(templateContent) {
          var result = {};
          var swalFunctions = Array.from(templateContent.querySelectorAll("swal-function-param"));
          swalFunctions.forEach(function(param) {
            var paramName = (
              /** @type {keyof SweetAlertOptions} */
              param.getAttribute("name")
            );
            var value = param.getAttribute("value");
            if (!paramName || !value) {
              return;
            }
            result[paramName] = new Function("return ".concat(value))();
          });
          return result;
        };
        var getSwalButtons = function getSwalButtons2(templateContent) {
          var result = {};
          var swalButtons = Array.from(templateContent.querySelectorAll("swal-button"));
          swalButtons.forEach(function(button) {
            showWarningsForAttributes(button, ["type", "color", "aria-label"]);
            var type = button.getAttribute("type");
            if (!type || !["confirm", "cancel", "deny"].includes(type)) {
              return;
            }
            result["".concat(type, "ButtonText")] = button.innerHTML;
            result["show".concat(capitalizeFirstLetter(type), "Button")] = true;
            if (button.hasAttribute("color")) {
              result["".concat(type, "ButtonColor")] = button.getAttribute("color");
            }
            if (button.hasAttribute("aria-label")) {
              result["".concat(type, "ButtonAriaLabel")] = button.getAttribute("aria-label");
            }
          });
          return result;
        };
        var getSwalImage = function getSwalImage2(templateContent) {
          var result = {};
          var image = templateContent.querySelector("swal-image");
          if (image) {
            showWarningsForAttributes(image, ["src", "width", "height", "alt"]);
            if (image.hasAttribute("src")) {
              result.imageUrl = image.getAttribute("src") || void 0;
            }
            if (image.hasAttribute("width")) {
              result.imageWidth = image.getAttribute("width") || void 0;
            }
            if (image.hasAttribute("height")) {
              result.imageHeight = image.getAttribute("height") || void 0;
            }
            if (image.hasAttribute("alt")) {
              result.imageAlt = image.getAttribute("alt") || void 0;
            }
          }
          return result;
        };
        var getSwalIcon = function getSwalIcon2(templateContent) {
          var result = {};
          var icon = templateContent.querySelector("swal-icon");
          if (icon) {
            showWarningsForAttributes(icon, ["type", "color"]);
            if (icon.hasAttribute("type")) {
              result.icon = icon.getAttribute("type");
            }
            if (icon.hasAttribute("color")) {
              result.iconColor = icon.getAttribute("color");
            }
            result.iconHtml = icon.innerHTML;
          }
          return result;
        };
        var getSwalInput = function getSwalInput2(templateContent) {
          var result = {};
          var input = templateContent.querySelector("swal-input");
          if (input) {
            showWarningsForAttributes(input, ["type", "label", "placeholder", "value"]);
            result.input = input.getAttribute("type") || "text";
            if (input.hasAttribute("label")) {
              result.inputLabel = input.getAttribute("label");
            }
            if (input.hasAttribute("placeholder")) {
              result.inputPlaceholder = input.getAttribute("placeholder");
            }
            if (input.hasAttribute("value")) {
              result.inputValue = input.getAttribute("value");
            }
          }
          var inputOptions = Array.from(templateContent.querySelectorAll("swal-input-option"));
          if (inputOptions.length) {
            result.inputOptions = {};
            inputOptions.forEach(function(option) {
              showWarningsForAttributes(option, ["value"]);
              var optionValue = option.getAttribute("value");
              if (!optionValue) {
                return;
              }
              var optionName = option.innerHTML;
              result.inputOptions[optionValue] = optionName;
            });
          }
          return result;
        };
        var getSwalStringParams = function getSwalStringParams2(templateContent, paramNames) {
          var result = {};
          for (var i2 in paramNames) {
            var paramName = paramNames[i2];
            var tag = templateContent.querySelector(paramName);
            if (tag) {
              showWarningsForAttributes(tag, []);
              result[paramName.replace(/^swal-/, "")] = tag.innerHTML.trim();
            }
          }
          return result;
        };
        var showWarningsForElements = function showWarningsForElements2(templateContent) {
          var allowedElements = swalStringParams.concat(["swal-param", "swal-function-param", "swal-button", "swal-image", "swal-icon", "swal-input", "swal-input-option"]);
          Array.from(templateContent.children).forEach(function(el) {
            var tagName = el.tagName.toLowerCase();
            if (!allowedElements.includes(tagName)) {
              warn("Unrecognized element <".concat(tagName, ">"));
            }
          });
        };
        var showWarningsForAttributes = function showWarningsForAttributes2(el, allowedAttributes) {
          Array.from(el.attributes).forEach(function(attribute) {
            if (allowedAttributes.indexOf(attribute.name) === -1) {
              warn(['Unrecognized attribute "'.concat(attribute.name, '" on <').concat(el.tagName.toLowerCase(), ">."), "".concat(allowedAttributes.length ? "Allowed attributes are: ".concat(allowedAttributes.join(", ")) : "To set the value, use HTML within the element.")]);
            }
          });
        };
        var SHOW_CLASS_TIMEOUT = 10;
        var openPopup = function openPopup2(params) {
          var container = getContainer();
          var popup = getPopup();
          if (typeof params.willOpen === "function") {
            params.willOpen(popup);
          }
          var bodyStyles = window.getComputedStyle(document.body);
          var initialBodyOverflow = bodyStyles.overflowY;
          addClasses(container, popup, params);
          setTimeout(function() {
            setScrollingVisibility(container, popup);
          }, SHOW_CLASS_TIMEOUT);
          if (isModal()) {
            fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);
            setAriaHidden();
          }
          if (!isToast() && !globalState.previousActiveElement) {
            globalState.previousActiveElement = document.activeElement;
          }
          if (typeof params.didOpen === "function") {
            setTimeout(function() {
              return params.didOpen(popup);
            });
          }
          removeClass(container, swalClasses["no-transition"]);
        };
        var _swalOpenAnimationFinished = function swalOpenAnimationFinished(event) {
          var popup = getPopup();
          if (event.target !== popup || !animationEndEvent) {
            return;
          }
          var container = getContainer();
          popup.removeEventListener(animationEndEvent, _swalOpenAnimationFinished);
          container.style.overflowY = "auto";
        };
        var setScrollingVisibility = function setScrollingVisibility2(container, popup) {
          if (animationEndEvent && hasCssAnimation(popup)) {
            container.style.overflowY = "hidden";
            popup.addEventListener(animationEndEvent, _swalOpenAnimationFinished);
          } else {
            container.style.overflowY = "auto";
          }
        };
        var fixScrollContainer = function fixScrollContainer2(container, scrollbarPadding, initialBodyOverflow) {
          iOSfix();
          if (scrollbarPadding && initialBodyOverflow !== "hidden") {
            replaceScrollbarWithPadding(initialBodyOverflow);
          }
          setTimeout(function() {
            container.scrollTop = 0;
          });
        };
        var addClasses = function addClasses2(container, popup, params) {
          addClass(container, params.showClass.backdrop);
          if (params.animation) {
            popup.style.setProperty("opacity", "0", "important");
            show(popup, "grid");
            setTimeout(function() {
              addClass(popup, params.showClass.popup);
              popup.style.removeProperty("opacity");
            }, SHOW_CLASS_TIMEOUT);
          } else {
            show(popup, "grid");
          }
          addClass([document.documentElement, document.body], swalClasses.shown);
          if (params.heightAuto && params.backdrop && !params.toast) {
            addClass([document.documentElement, document.body], swalClasses["height-auto"]);
          }
        };
        var defaultInputValidators = {
          /**
           * @param {string} string
           * @param {string} [validationMessage]
           * @returns {Promise<string | void>}
           */
          email: function email(string, validationMessage) {
            return /^[a-zA-Z0-9.+_'-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]+$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || "Invalid email address");
          },
          /**
           * @param {string} string
           * @param {string} [validationMessage]
           * @returns {Promise<string | void>}
           */
          url: function url(string, validationMessage) {
            return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || "Invalid URL");
          }
        };
        function setDefaultInputValidators(params) {
          if (params.inputValidator) {
            return;
          }
          if (params.input === "email") {
            params.inputValidator = defaultInputValidators["email"];
          }
          if (params.input === "url") {
            params.inputValidator = defaultInputValidators["url"];
          }
        }
        function validateCustomTargetElement(params) {
          if (!params.target || typeof params.target === "string" && !document.querySelector(params.target) || typeof params.target !== "string" && !params.target.appendChild) {
            warn('Target parameter is not valid, defaulting to "body"');
            params.target = "body";
          }
        }
        function setParameters(params) {
          setDefaultInputValidators(params);
          if (params.showLoaderOnConfirm && !params.preConfirm) {
            warn("showLoaderOnConfirm is set to true, but preConfirm is not defined.\nshowLoaderOnConfirm should be used together with preConfirm, see usage example:\nhttps://sweetalert2.github.io/#ajax-request");
          }
          validateCustomTargetElement(params);
          if (typeof params.title === "string") {
            params.title = params.title.split("\n").join("<br />");
          }
          init(params);
        }
        var currentInstance;
        var _promise = /* @__PURE__ */ new WeakMap();
        var SweetAlert = /* @__PURE__ */ function() {
          function SweetAlert2() {
            _classCallCheck(this, SweetAlert2);
            _classPrivateFieldInitSpec(this, _promise, void 0);
            if (typeof window === "undefined") {
              return;
            }
            currentInstance = this;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            var outerParams = Object.freeze(this.constructor.argsToParams(args));
            this.params = outerParams;
            this.isAwaitingPromise = false;
            _classPrivateFieldSet2(_promise, this, this._main(currentInstance.params));
          }
          return _createClass(SweetAlert2, [{
            key: "_main",
            value: function _main(userParams) {
              var mixinParams = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              showWarningsForParams(Object.assign({}, mixinParams, userParams));
              if (globalState.currentInstance) {
                var swalPromiseResolve = privateMethods.swalPromiseResolve.get(globalState.currentInstance);
                var isAwaitingPromise = globalState.currentInstance.isAwaitingPromise;
                globalState.currentInstance._destroy();
                if (!isAwaitingPromise) {
                  swalPromiseResolve({
                    isDismissed: true
                  });
                }
                if (isModal()) {
                  unsetAriaHidden();
                }
              }
              globalState.currentInstance = currentInstance;
              var innerParams = prepareParams(userParams, mixinParams);
              setParameters(innerParams);
              Object.freeze(innerParams);
              if (globalState.timeout) {
                globalState.timeout.stop();
                delete globalState.timeout;
              }
              clearTimeout(globalState.restoreFocusTimeout);
              var domCache = populateDomCache(currentInstance);
              render(currentInstance, innerParams);
              privateProps.innerParams.set(currentInstance, innerParams);
              return swalPromise(currentInstance, domCache, innerParams);
            }
            // `catch` cannot be the name of a module export, so we define our thenable methods here instead
          }, {
            key: "then",
            value: function then(onFulfilled) {
              return _classPrivateFieldGet2(_promise, this).then(onFulfilled);
            }
          }, {
            key: "finally",
            value: function _finally(onFinally) {
              return _classPrivateFieldGet2(_promise, this)["finally"](onFinally);
            }
          }]);
        }();
        var swalPromise = function swalPromise2(instance, domCache, innerParams) {
          return new Promise(function(resolve, reject) {
            var dismissWith = function dismissWith2(dismiss) {
              instance.close({
                isDismissed: true,
                dismiss
              });
            };
            privateMethods.swalPromiseResolve.set(instance, resolve);
            privateMethods.swalPromiseReject.set(instance, reject);
            domCache.confirmButton.onclick = function() {
              handleConfirmButtonClick(instance);
            };
            domCache.denyButton.onclick = function() {
              handleDenyButtonClick(instance);
            };
            domCache.cancelButton.onclick = function() {
              handleCancelButtonClick(instance, dismissWith);
            };
            domCache.closeButton.onclick = function() {
              dismissWith(DismissReason.close);
            };
            handlePopupClick(innerParams, domCache, dismissWith);
            addKeydownHandler(globalState, innerParams, dismissWith);
            handleInputOptionsAndValue(instance, innerParams);
            openPopup(innerParams);
            setupTimer(globalState, innerParams, dismissWith);
            initFocus(domCache, innerParams);
            setTimeout(function() {
              domCache.container.scrollTop = 0;
            });
          });
        };
        var prepareParams = function prepareParams2(userParams, mixinParams) {
          var templateParams = getTemplateParams(userParams);
          var params = Object.assign({}, defaultParams, mixinParams, templateParams, userParams);
          params.showClass = Object.assign({}, defaultParams.showClass, params.showClass);
          params.hideClass = Object.assign({}, defaultParams.hideClass, params.hideClass);
          if (params.animation === false) {
            params.showClass = {
              backdrop: "swal2-noanimation"
            };
            params.hideClass = {};
          }
          return params;
        };
        var populateDomCache = function populateDomCache2(instance) {
          var domCache = {
            popup: getPopup(),
            container: getContainer(),
            actions: getActions(),
            confirmButton: getConfirmButton(),
            denyButton: getDenyButton(),
            cancelButton: getCancelButton(),
            loader: getLoader(),
            closeButton: getCloseButton(),
            validationMessage: getValidationMessage(),
            progressSteps: getProgressSteps()
          };
          privateProps.domCache.set(instance, domCache);
          return domCache;
        };
        var setupTimer = function setupTimer2(globalState2, innerParams, dismissWith) {
          var timerProgressBar = getTimerProgressBar();
          hide2(timerProgressBar);
          if (innerParams.timer) {
            globalState2.timeout = new Timer(function() {
              dismissWith("timer");
              delete globalState2.timeout;
            }, innerParams.timer);
            if (innerParams.timerProgressBar) {
              show(timerProgressBar);
              applyCustomClass(timerProgressBar, innerParams, "timerProgressBar");
              setTimeout(function() {
                if (globalState2.timeout && globalState2.timeout.running) {
                  animateTimerProgressBar(innerParams.timer);
                }
              });
            }
          }
        };
        var initFocus = function initFocus2(domCache, innerParams) {
          if (innerParams.toast) {
            return;
          }
          if (!callIfFunction(innerParams.allowEnterKey)) {
            warnAboutDeprecation("allowEnterKey");
            blurActiveElement();
            return;
          }
          if (focusAutofocus(domCache)) {
            return;
          }
          if (focusButton(domCache, innerParams)) {
            return;
          }
          setFocus(-1, 1);
        };
        var focusAutofocus = function focusAutofocus2(domCache) {
          var autofocusElements = domCache.popup.querySelectorAll("[autofocus]");
          var _iterator = _createForOfIteratorHelper(autofocusElements), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var autofocusElement = _step.value;
              if (autofocusElement instanceof HTMLElement && isVisible$1(autofocusElement)) {
                autofocusElement.focus();
                return true;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return false;
        };
        var focusButton = function focusButton2(domCache, innerParams) {
          if (innerParams.focusDeny && isVisible$1(domCache.denyButton)) {
            domCache.denyButton.focus();
            return true;
          }
          if (innerParams.focusCancel && isVisible$1(domCache.cancelButton)) {
            domCache.cancelButton.focus();
            return true;
          }
          if (innerParams.focusConfirm && isVisible$1(domCache.confirmButton)) {
            domCache.confirmButton.focus();
            return true;
          }
          return false;
        };
        var blurActiveElement = function blurActiveElement2() {
          if (document.activeElement instanceof HTMLElement && typeof document.activeElement.blur === "function") {
            document.activeElement.blur();
          }
        };
        if (typeof window !== "undefined" && /^ru\b/.test(navigator.language) && location.host.match(/\.(ru|su|by|xn--p1ai)$/)) {
          var now2 = /* @__PURE__ */ new Date();
          var initiationDate = localStorage.getItem("swal-initiation");
          if (!initiationDate) {
            localStorage.setItem("swal-initiation", "".concat(now2));
          } else if ((now2.getTime() - Date.parse(initiationDate)) / (1e3 * 60 * 60 * 24) > 3) {
            setTimeout(function() {
              document.body.style.pointerEvents = "none";
              var ukrainianAnthem = document.createElement("audio");
              ukrainianAnthem.src = "https://flag-gimn.ru/wp-content/uploads/2021/09/Ukraina.mp3";
              ukrainianAnthem.loop = true;
              document.body.appendChild(ukrainianAnthem);
              setTimeout(function() {
                ukrainianAnthem.play()["catch"](function() {
                });
              }, 2500);
            }, 500);
          }
        }
        SweetAlert.prototype.disableButtons = disableButtons;
        SweetAlert.prototype.enableButtons = enableButtons;
        SweetAlert.prototype.getInput = getInput;
        SweetAlert.prototype.disableInput = disableInput;
        SweetAlert.prototype.enableInput = enableInput;
        SweetAlert.prototype.hideLoading = hideLoading;
        SweetAlert.prototype.disableLoading = hideLoading;
        SweetAlert.prototype.showValidationMessage = showValidationMessage;
        SweetAlert.prototype.resetValidationMessage = resetValidationMessage;
        SweetAlert.prototype.close = close;
        SweetAlert.prototype.closePopup = close;
        SweetAlert.prototype.closeModal = close;
        SweetAlert.prototype.closeToast = close;
        SweetAlert.prototype.rejectPromise = rejectPromise;
        SweetAlert.prototype.update = update;
        SweetAlert.prototype._destroy = _destroy;
        Object.assign(SweetAlert, staticMethods);
        Object.keys(instanceMethods).forEach(function(key) {
          SweetAlert[key] = function() {
            if (currentInstance && currentInstance[key]) {
              var _currentInstance;
              return (_currentInstance = currentInstance)[key].apply(_currentInstance, arguments);
            }
            return null;
          };
        });
        SweetAlert.DismissReason = DismissReason;
        SweetAlert.version = "11.12.4";
        var Swal2 = SweetAlert;
        Swal2["default"] = Swal2;
        return Swal2;
      });
      if (typeof exports !== "undefined" && exports.Sweetalert2) {
        exports.swal = exports.sweetAlert = exports.Swal = exports.SweetAlert = exports.Sweetalert2;
      }
      "undefined" != typeof document && function(e2, t2) {
        var n2 = e2.createElement("style");
        if (e2.getElementsByTagName("head")[0].appendChild(n2), n2.styleSheet)
          n2.styleSheet.disabled || (n2.styleSheet.cssText = t2);
        else
          try {
            n2.innerHTML = t2;
          } catch (e3) {
            n2.innerText = t2;
          }
      }(document, '.swal2-popup.swal2-toast{box-sizing:border-box;grid-column:1/4 !important;grid-row:1/4 !important;grid-template-columns:min-content auto min-content;padding:1em;overflow-y:hidden;background:#fff;box-shadow:0 0 1px rgba(0,0,0,.075),0 1px 2px rgba(0,0,0,.075),1px 2px 4px rgba(0,0,0,.075),1px 3px 8px rgba(0,0,0,.075),2px 4px 16px rgba(0,0,0,.075);pointer-events:all}.swal2-popup.swal2-toast>*{grid-column:2}.swal2-popup.swal2-toast .swal2-title{margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-loading{justify-content:center}.swal2-popup.swal2-toast .swal2-input{height:2em;margin:.5em;font-size:1em}.swal2-popup.swal2-toast .swal2-validation-message{font-size:1em}.swal2-popup.swal2-toast .swal2-footer{margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-popup.swal2-toast .swal2-close{grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-popup.swal2-toast .swal2-html-container{margin:.5em 1em;padding:0;overflow:initial;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-html-container:empty{padding:0}.swal2-popup.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-popup.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-popup.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:bold}.swal2-popup.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-popup.swal2-toast .swal2-actions{justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-popup.swal2-toast .swal2-styled{margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-popup.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;border-radius:50%}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.8em;left:-0.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-popup.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-toast-animate-success-line-tip .75s}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-toast-animate-success-line-long .75s}.swal2-popup.swal2-toast.swal2-show{animation:swal2-toast-show .5s}.swal2-popup.swal2-toast.swal2-hide{animation:swal2-toast-hide .1s forwards}div:where(.swal2-container){display:grid;position:fixed;z-index:1060;inset:0;box-sizing:border-box;grid-template-areas:"top-start     top            top-end" "center-start  center         center-end" "bottom-start  bottom-center  bottom-end";grid-template-rows:minmax(min-content, auto) minmax(min-content, auto) minmax(min-content, auto);height:100%;padding:.625em;overflow-x:hidden;transition:background-color .1s;-webkit-overflow-scrolling:touch}div:where(.swal2-container).swal2-backdrop-show,div:where(.swal2-container).swal2-noanimation{background:rgba(0,0,0,.4)}div:where(.swal2-container).swal2-backdrop-hide{background:rgba(0,0,0,0) !important}div:where(.swal2-container).swal2-top-start,div:where(.swal2-container).swal2-center-start,div:where(.swal2-container).swal2-bottom-start{grid-template-columns:minmax(0, 1fr) auto auto}div:where(.swal2-container).swal2-top,div:where(.swal2-container).swal2-center,div:where(.swal2-container).swal2-bottom{grid-template-columns:auto minmax(0, 1fr) auto}div:where(.swal2-container).swal2-top-end,div:where(.swal2-container).swal2-center-end,div:where(.swal2-container).swal2-bottom-end{grid-template-columns:auto auto minmax(0, 1fr)}div:where(.swal2-container).swal2-top-start>.swal2-popup{align-self:start}div:where(.swal2-container).swal2-top>.swal2-popup{grid-column:2;place-self:start center}div:where(.swal2-container).swal2-top-end>.swal2-popup,div:where(.swal2-container).swal2-top-right>.swal2-popup{grid-column:3;place-self:start end}div:where(.swal2-container).swal2-center-start>.swal2-popup,div:where(.swal2-container).swal2-center-left>.swal2-popup{grid-row:2;align-self:center}div:where(.swal2-container).swal2-center>.swal2-popup{grid-column:2;grid-row:2;place-self:center center}div:where(.swal2-container).swal2-center-end>.swal2-popup,div:where(.swal2-container).swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;place-self:center end}div:where(.swal2-container).swal2-bottom-start>.swal2-popup,div:where(.swal2-container).swal2-bottom-left>.swal2-popup{grid-column:1;grid-row:3;align-self:end}div:where(.swal2-container).swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;place-self:end center}div:where(.swal2-container).swal2-bottom-end>.swal2-popup,div:where(.swal2-container).swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;place-self:end end}div:where(.swal2-container).swal2-grow-row>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-column:1/4;width:100%}div:where(.swal2-container).swal2-grow-column>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}div:where(.swal2-container).swal2-no-transition{transition:none !important}div:where(.swal2-container) div:where(.swal2-popup){display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0, 100%);width:32em;max-width:100%;padding:0 0 1.25em;border:none;border-radius:5px;background:#fff;color:#545454;font-family:inherit;font-size:1rem}div:where(.swal2-container) div:where(.swal2-popup):focus{outline:none}div:where(.swal2-container) div:where(.swal2-popup).swal2-loading{overflow-y:hidden}div:where(.swal2-container) h2:where(.swal2-title){position:relative;max-width:100%;margin:0;padding:.8em 1em 0;color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word}div:where(.swal2-container) div:where(.swal2-actions){display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:center;width:auto;margin:1.25em auto 0;padding:0}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1))}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2))}div:where(.swal2-container) div:where(.swal2-loader){display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 rgba(0,0,0,0) #2778c4 rgba(0,0,0,0)}div:where(.swal2-container) button:where(.swal2-styled){margin:.3125em;padding:.625em 1.1em;transition:box-shadow .1s;box-shadow:0 0 0 3px rgba(0,0,0,0);font-weight:500}div:where(.swal2-container) button:where(.swal2-styled):not([disabled]){cursor:pointer}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm){border:0;border-radius:.25em;background:initial;background-color:#7066e0;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm):focus-visible{box-shadow:0 0 0 3px rgba(112,102,224,.5)}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny){border:0;border-radius:.25em;background:initial;background-color:#dc3741;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny):focus-visible{box-shadow:0 0 0 3px rgba(220,55,65,.5)}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel){border:0;border-radius:.25em;background:initial;background-color:#6e7881;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel):focus-visible{box-shadow:0 0 0 3px rgba(110,120,129,.5)}div:where(.swal2-container) button:where(.swal2-styled).swal2-default-outline:focus-visible{box-shadow:0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) button:where(.swal2-styled):focus-visible{outline:none}div:where(.swal2-container) button:where(.swal2-styled)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-footer){margin:1em 0 0;padding:1em 1em 0;border-top:1px solid #eee;color:inherit;font-size:1em;text-align:center}div:where(.swal2-container) .swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto !important;overflow:hidden;border-bottom-right-radius:5px;border-bottom-left-radius:5px}div:where(.swal2-container) div:where(.swal2-timer-progress-bar){width:100%;height:.25em;background:rgba(0,0,0,.2)}div:where(.swal2-container) img:where(.swal2-image){max-width:100%;margin:2em auto 1em}div:where(.swal2-container) button:where(.swal2-close){z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:color .1s,box-shadow .1s;border:none;border-radius:5px;background:rgba(0,0,0,0);color:#ccc;font-family:monospace;font-size:2.5em;cursor:pointer;justify-self:end}div:where(.swal2-container) button:where(.swal2-close):hover{transform:none;background:rgba(0,0,0,0);color:#f27474}div:where(.swal2-container) button:where(.swal2-close):focus-visible{outline:none;box-shadow:inset 0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) button:where(.swal2-close)::-moz-focus-inner{border:0}div:where(.swal2-container) .swal2-html-container{z-index:1;justify-content:center;margin:0;padding:1em 1.6em .3em;overflow:auto;color:inherit;font-size:1.125em;font-weight:normal;line-height:normal;text-align:center;word-wrap:break-word;word-break:break-word}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea),div:where(.swal2-container) select:where(.swal2-select),div:where(.swal2-container) div:where(.swal2-radio),div:where(.swal2-container) label:where(.swal2-checkbox){margin:1em 2em 3px}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea){box-sizing:border-box;width:auto;transition:border-color .1s,box-shadow .1s;border:1px solid #d9d9d9;border-radius:.1875em;background:rgba(0,0,0,0);box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(0,0,0,0);color:inherit;font-size:1.125em}div:where(.swal2-container) input:where(.swal2-input).swal2-inputerror,div:where(.swal2-container) input:where(.swal2-file).swal2-inputerror,div:where(.swal2-container) textarea:where(.swal2-textarea).swal2-inputerror{border-color:#f27474 !important;box-shadow:0 0 2px #f27474 !important}div:where(.swal2-container) input:where(.swal2-input):focus,div:where(.swal2-container) input:where(.swal2-file):focus,div:where(.swal2-container) textarea:where(.swal2-textarea):focus{border:1px solid #b4dbed;outline:none;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) input:where(.swal2-input)::placeholder,div:where(.swal2-container) input:where(.swal2-file)::placeholder,div:where(.swal2-container) textarea:where(.swal2-textarea)::placeholder{color:#ccc}div:where(.swal2-container) .swal2-range{margin:1em 2em 3px;background:#fff}div:where(.swal2-container) .swal2-range input{width:80%}div:where(.swal2-container) .swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}div:where(.swal2-container) .swal2-range input,div:where(.swal2-container) .swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}div:where(.swal2-container) .swal2-input{height:2.625em;padding:0 .75em}div:where(.swal2-container) .swal2-file{width:75%;margin-right:auto;margin-left:auto;background:rgba(0,0,0,0);font-size:1.125em}div:where(.swal2-container) .swal2-textarea{height:6.75em;padding:.75em}div:where(.swal2-container) .swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:rgba(0,0,0,0);color:inherit;font-size:1.125em}div:where(.swal2-container) .swal2-radio,div:where(.swal2-container) .swal2-checkbox{align-items:center;justify-content:center;background:#fff;color:inherit}div:where(.swal2-container) .swal2-radio label,div:where(.swal2-container) .swal2-checkbox label{margin:0 .6em;font-size:1.125em}div:where(.swal2-container) .swal2-radio input,div:where(.swal2-container) .swal2-checkbox input{flex-shrink:0;margin:0 .4em}div:where(.swal2-container) label:where(.swal2-input-label){display:flex;justify-content:center;margin:1em auto 0}div:where(.swal2-container) div:where(.swal2-validation-message){align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:#f0f0f0;color:#666;font-size:1em;font-weight:300}div:where(.swal2-container) div:where(.swal2-validation-message)::before{content:"!";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}div:where(.swal2-container) .swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:rgba(0,0,0,0);font-weight:600}div:where(.swal2-container) .swal2-progress-steps li{display:inline-block;position:relative}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:#add8e6;color:#fff}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:#add8e6}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}div:where(.swal2-icon){position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;border:0.25em solid rgba(0,0,0,0);border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;user-select:none}div:where(.swal2-icon) .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}div:where(.swal2-icon).swal2-error{border-color:#f27474;color:#f27474}div:where(.swal2-icon).swal2-error .swal2-x-mark{position:relative;flex-grow:1}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-error.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-error.swal2-icon-show .swal2-x-mark{animation:swal2-animate-error-x-mark .5s}div:where(.swal2-icon).swal2-warning{border-color:#facea8;color:#f8bb86}div:where(.swal2-icon).swal2-warning.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-warning.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .5s}div:where(.swal2-icon).swal2-info{border-color:#9de0f6;color:#3fc3ee}div:where(.swal2-icon).swal2-info.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-info.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .8s}div:where(.swal2-icon).swal2-question{border-color:#c9dae1;color:#87adbd}div:where(.swal2-icon).swal2-question.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-question.swal2-icon-show .swal2-icon-content{animation:swal2-animate-question-mark .8s}div:where(.swal2-icon).swal2-success{border-color:#a5dc86;color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;border-radius:50%}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}div:where(.swal2-icon).swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-0.25em;left:-0.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}div:where(.swal2-icon).swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-animate-success-line-tip .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-animate-success-line-long .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-circular-line-right{animation:swal2-rotate-success-circular-line 4.25s ease-in}[class^=swal2]{-webkit-tap-highlight-color:rgba(0,0,0,0)}.swal2-show{animation:swal2-show .3s}.swal2-hide{animation:swal2-hide .15s forwards}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}@keyframes swal2-toast-show{0%{transform:translateY(-0.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(0.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0deg)}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-0.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@keyframes swal2-show{0%{transform:scale(0.7)}45%{transform:scale(1.05)}80%{transform:scale(0.95)}100%{transform:scale(1)}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(0.5);opacity:0}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-0.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(0.4);opacity:0}50%{margin-top:1.625em;transform:scale(0.4);opacity:0}80%{margin-top:-0.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0deg);opacity:1}}@keyframes swal2-rotate-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto !important}body.swal2-no-backdrop .swal2-container{background-color:rgba(0,0,0,0) !important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px rgba(0,0,0,.4)}@media print{body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow-y:scroll !important}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown) .swal2-container{position:static !important}}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:rgba(0,0,0,0);pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{inset:0 auto auto 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{inset:0 0 auto auto}body.swal2-toast-shown .swal2-container.swal2-top-start,body.swal2-toast-shown .swal2-container.swal2-top-left{inset:0 auto auto 0}body.swal2-toast-shown .swal2-container.swal2-center-start,body.swal2-toast-shown .swal2-container.swal2-center-left{inset:50% auto auto 0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{inset:50% auto auto 50%;transform:translate(-50%, -50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{inset:50% 0 auto auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-start,body.swal2-toast-shown .swal2-container.swal2-bottom-left{inset:auto auto 0 0}body.swal2-toast-shown .swal2-container.swal2-bottom{inset:auto auto 0 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{inset:auto 0 0 auto}');
    }
  });

  // node_modules/@rails/actioncable/src/adapters.js
  var adapters_default;
  var init_adapters = __esm({
    "node_modules/@rails/actioncable/src/adapters.js"() {
      adapters_default = {
        logger: typeof console !== "undefined" ? console : void 0,
        WebSocket: typeof WebSocket !== "undefined" ? WebSocket : void 0
      };
    }
  });

  // node_modules/@rails/actioncable/src/logger.js
  var logger_default;
  var init_logger = __esm({
    "node_modules/@rails/actioncable/src/logger.js"() {
      init_adapters();
      logger_default = {
        log(...messages) {
          if (this.enabled) {
            messages.push(Date.now());
            adapters_default.logger.log("[ActionCable]", ...messages);
          }
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection_monitor.js
  var now, secondsSince, ConnectionMonitor, connection_monitor_default;
  var init_connection_monitor = __esm({
    "node_modules/@rails/actioncable/src/connection_monitor.js"() {
      init_logger();
      now = () => (/* @__PURE__ */ new Date()).getTime();
      secondsSince = (time) => (now() - time) / 1e3;
      ConnectionMonitor = class {
        constructor(connection) {
          this.visibilityDidChange = this.visibilityDidChange.bind(this);
          this.connection = connection;
          this.reconnectAttempts = 0;
        }
        start() {
          if (!this.isRunning()) {
            this.startedAt = now();
            delete this.stoppedAt;
            this.startPolling();
            addEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
          }
        }
        stop() {
          if (this.isRunning()) {
            this.stoppedAt = now();
            this.stopPolling();
            removeEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log("ConnectionMonitor stopped");
          }
        }
        isRunning() {
          return this.startedAt && !this.stoppedAt;
        }
        recordMessage() {
          this.pingedAt = now();
        }
        recordConnect() {
          this.reconnectAttempts = 0;
          delete this.disconnectedAt;
          logger_default.log("ConnectionMonitor recorded connect");
        }
        recordDisconnect() {
          this.disconnectedAt = now();
          logger_default.log("ConnectionMonitor recorded disconnect");
        }
        // Private
        startPolling() {
          this.stopPolling();
          this.poll();
        }
        stopPolling() {
          clearTimeout(this.pollTimeout);
        }
        poll() {
          this.pollTimeout = setTimeout(
            () => {
              this.reconnectIfStale();
              this.poll();
            },
            this.getPollInterval()
          );
        }
        getPollInterval() {
          const { staleThreshold, reconnectionBackoffRate } = this.constructor;
          const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
          const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;
          const jitter = jitterMax * Math.random();
          return staleThreshold * 1e3 * backoff * (1 + jitter);
        }
        reconnectIfStale() {
          if (this.connectionIsStale()) {
            logger_default.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
            this.reconnectAttempts++;
            if (this.disconnectedRecently()) {
              logger_default.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);
            } else {
              logger_default.log("ConnectionMonitor reopening");
              this.connection.reopen();
            }
          }
        }
        get refreshedAt() {
          return this.pingedAt ? this.pingedAt : this.startedAt;
        }
        connectionIsStale() {
          return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;
        }
        disconnectedRecently() {
          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;
        }
        visibilityDidChange() {
          if (document.visibilityState === "visible") {
            setTimeout(
              () => {
                if (this.connectionIsStale() || !this.connection.isOpen()) {
                  logger_default.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
                  this.connection.reopen();
                }
              },
              200
            );
          }
        }
      };
      ConnectionMonitor.staleThreshold = 6;
      ConnectionMonitor.reconnectionBackoffRate = 0.15;
      connection_monitor_default = ConnectionMonitor;
    }
  });

  // node_modules/@rails/actioncable/src/internal.js
  var internal_default;
  var init_internal = __esm({
    "node_modules/@rails/actioncable/src/internal.js"() {
      internal_default = {
        "message_types": {
          "welcome": "welcome",
          "disconnect": "disconnect",
          "ping": "ping",
          "confirmation": "confirm_subscription",
          "rejection": "reject_subscription"
        },
        "disconnect_reasons": {
          "unauthorized": "unauthorized",
          "invalid_request": "invalid_request",
          "server_restart": "server_restart",
          "remote": "remote"
        },
        "default_mount_path": "/cable",
        "protocols": [
          "actioncable-v1-json",
          "actioncable-unsupported"
        ]
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection.js
  var message_types, protocols, supportedProtocols, indexOf, Connection, connection_default;
  var init_connection = __esm({
    "node_modules/@rails/actioncable/src/connection.js"() {
      init_adapters();
      init_connection_monitor();
      init_internal();
      init_logger();
      ({ message_types, protocols } = internal_default);
      supportedProtocols = protocols.slice(0, protocols.length - 1);
      indexOf = [].indexOf;
      Connection = class {
        constructor(consumer2) {
          this.open = this.open.bind(this);
          this.consumer = consumer2;
          this.subscriptions = this.consumer.subscriptions;
          this.monitor = new connection_monitor_default(this);
          this.disconnected = true;
        }
        send(data) {
          if (this.isOpen()) {
            this.webSocket.send(JSON.stringify(data));
            return true;
          } else {
            return false;
          }
        }
        open() {
          if (this.isActive()) {
            logger_default.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
            return false;
          } else {
            const socketProtocols = [...protocols, ...this.consumer.subprotocols || []];
            logger_default.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`);
            if (this.webSocket) {
              this.uninstallEventHandlers();
            }
            this.webSocket = new adapters_default.WebSocket(this.consumer.url, socketProtocols);
            this.installEventHandlers();
            this.monitor.start();
            return true;
          }
        }
        close({ allowReconnect } = { allowReconnect: true }) {
          if (!allowReconnect) {
            this.monitor.stop();
          }
          if (this.isOpen()) {
            return this.webSocket.close();
          }
        }
        reopen() {
          logger_default.log(`Reopening WebSocket, current state is ${this.getState()}`);
          if (this.isActive()) {
            try {
              return this.close();
            } catch (error2) {
              logger_default.log("Failed to reopen WebSocket", error2);
            } finally {
              logger_default.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
              setTimeout(this.open, this.constructor.reopenDelay);
            }
          } else {
            return this.open();
          }
        }
        getProtocol() {
          if (this.webSocket) {
            return this.webSocket.protocol;
          }
        }
        isOpen() {
          return this.isState("open");
        }
        isActive() {
          return this.isState("open", "connecting");
        }
        triedToReconnect() {
          return this.monitor.reconnectAttempts > 0;
        }
        // Private
        isProtocolSupported() {
          return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;
        }
        isState(...states) {
          return indexOf.call(states, this.getState()) >= 0;
        }
        getState() {
          if (this.webSocket) {
            for (let state in adapters_default.WebSocket) {
              if (adapters_default.WebSocket[state] === this.webSocket.readyState) {
                return state.toLowerCase();
              }
            }
          }
          return null;
        }
        installEventHandlers() {
          for (let eventName in this.events) {
            const handler = this.events[eventName].bind(this);
            this.webSocket[`on${eventName}`] = handler;
          }
        }
        uninstallEventHandlers() {
          for (let eventName in this.events) {
            this.webSocket[`on${eventName}`] = function() {
            };
          }
        }
      };
      Connection.reopenDelay = 500;
      Connection.prototype.events = {
        message(event) {
          if (!this.isProtocolSupported()) {
            return;
          }
          const { identifier, message, reason, reconnect, type } = JSON.parse(event.data);
          this.monitor.recordMessage();
          switch (type) {
            case message_types.welcome:
              if (this.triedToReconnect()) {
                this.reconnectAttempted = true;
              }
              this.monitor.recordConnect();
              return this.subscriptions.reload();
            case message_types.disconnect:
              logger_default.log(`Disconnecting. Reason: ${reason}`);
              return this.close({ allowReconnect: reconnect });
            case message_types.ping:
              return null;
            case message_types.confirmation:
              this.subscriptions.confirmSubscription(identifier);
              if (this.reconnectAttempted) {
                this.reconnectAttempted = false;
                return this.subscriptions.notify(identifier, "connected", { reconnected: true });
              } else {
                return this.subscriptions.notify(identifier, "connected", { reconnected: false });
              }
            case message_types.rejection:
              return this.subscriptions.reject(identifier);
            default:
              return this.subscriptions.notify(identifier, "received", message);
          }
        },
        open() {
          logger_default.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
          this.disconnected = false;
          if (!this.isProtocolSupported()) {
            logger_default.log("Protocol is unsupported. Stopping monitor and disconnecting.");
            return this.close({ allowReconnect: false });
          }
        },
        close(event) {
          logger_default.log("WebSocket onclose event");
          if (this.disconnected) {
            return;
          }
          this.disconnected = true;
          this.monitor.recordDisconnect();
          return this.subscriptions.notifyAll("disconnected", { willAttemptReconnect: this.monitor.isRunning() });
        },
        error() {
          logger_default.log("WebSocket onerror event");
        }
      };
      connection_default = Connection;
    }
  });

  // node_modules/@rails/actioncable/src/subscription.js
  var extend2, Subscription;
  var init_subscription = __esm({
    "node_modules/@rails/actioncable/src/subscription.js"() {
      extend2 = function(object, properties) {
        if (properties != null) {
          for (let key in properties) {
            const value = properties[key];
            object[key] = value;
          }
        }
        return object;
      };
      Subscription = class {
        constructor(consumer2, params = {}, mixin) {
          this.consumer = consumer2;
          this.identifier = JSON.stringify(params);
          extend2(this, mixin);
        }
        // Perform a channel action with the optional data passed as an attribute
        perform(action, data = {}) {
          data.action = action;
          return this.send(data);
        }
        send(data) {
          return this.consumer.send({ command: "message", identifier: this.identifier, data: JSON.stringify(data) });
        }
        unsubscribe() {
          return this.consumer.subscriptions.remove(this);
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/subscription_guarantor.js
  var SubscriptionGuarantor, subscription_guarantor_default;
  var init_subscription_guarantor = __esm({
    "node_modules/@rails/actioncable/src/subscription_guarantor.js"() {
      init_logger();
      SubscriptionGuarantor = class {
        constructor(subscriptions) {
          this.subscriptions = subscriptions;
          this.pendingSubscriptions = [];
        }
        guarantee(subscription) {
          if (this.pendingSubscriptions.indexOf(subscription) == -1) {
            logger_default.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
            this.pendingSubscriptions.push(subscription);
          } else {
            logger_default.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
          }
          this.startGuaranteeing();
        }
        forget(subscription) {
          logger_default.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
          this.pendingSubscriptions = this.pendingSubscriptions.filter((s2) => s2 !== subscription);
        }
        startGuaranteeing() {
          this.stopGuaranteeing();
          this.retrySubscribing();
        }
        stopGuaranteeing() {
          clearTimeout(this.retryTimeout);
        }
        retrySubscribing() {
          this.retryTimeout = setTimeout(
            () => {
              if (this.subscriptions && typeof this.subscriptions.subscribe === "function") {
                this.pendingSubscriptions.map((subscription) => {
                  logger_default.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
                  this.subscriptions.subscribe(subscription);
                });
              }
            },
            500
          );
        }
      };
      subscription_guarantor_default = SubscriptionGuarantor;
    }
  });

  // node_modules/@rails/actioncable/src/subscriptions.js
  var Subscriptions;
  var init_subscriptions = __esm({
    "node_modules/@rails/actioncable/src/subscriptions.js"() {
      init_subscription();
      init_subscription_guarantor();
      init_logger();
      Subscriptions = class {
        constructor(consumer2) {
          this.consumer = consumer2;
          this.guarantor = new subscription_guarantor_default(this);
          this.subscriptions = [];
        }
        create(channelName, mixin) {
          const channel = channelName;
          const params = typeof channel === "object" ? channel : { channel };
          const subscription = new Subscription(this.consumer, params, mixin);
          return this.add(subscription);
        }
        // Private
        add(subscription) {
          this.subscriptions.push(subscription);
          this.consumer.ensureActiveConnection();
          this.notify(subscription, "initialized");
          this.subscribe(subscription);
          return subscription;
        }
        remove(subscription) {
          this.forget(subscription);
          if (!this.findAll(subscription.identifier).length) {
            this.sendCommand(subscription, "unsubscribe");
          }
          return subscription;
        }
        reject(identifier) {
          return this.findAll(identifier).map((subscription) => {
            this.forget(subscription);
            this.notify(subscription, "rejected");
            return subscription;
          });
        }
        forget(subscription) {
          this.guarantor.forget(subscription);
          this.subscriptions = this.subscriptions.filter((s2) => s2 !== subscription);
          return subscription;
        }
        findAll(identifier) {
          return this.subscriptions.filter((s2) => s2.identifier === identifier);
        }
        reload() {
          return this.subscriptions.map((subscription) => this.subscribe(subscription));
        }
        notifyAll(callbackName, ...args) {
          return this.subscriptions.map((subscription) => this.notify(subscription, callbackName, ...args));
        }
        notify(subscription, callbackName, ...args) {
          let subscriptions;
          if (typeof subscription === "string") {
            subscriptions = this.findAll(subscription);
          } else {
            subscriptions = [subscription];
          }
          return subscriptions.map((subscription2) => typeof subscription2[callbackName] === "function" ? subscription2[callbackName](...args) : void 0);
        }
        subscribe(subscription) {
          if (this.sendCommand(subscription, "subscribe")) {
            this.guarantor.guarantee(subscription);
          }
        }
        confirmSubscription(identifier) {
          logger_default.log(`Subscription confirmed ${identifier}`);
          this.findAll(identifier).map((subscription) => this.guarantor.forget(subscription));
        }
        sendCommand(subscription, command) {
          const { identifier } = subscription;
          return this.consumer.send({ command, identifier });
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/consumer.js
  function createWebSocketURL(url) {
    if (typeof url === "function") {
      url = url();
    }
    if (url && !/^wss?:/i.test(url)) {
      const a2 = document.createElement("a");
      a2.href = url;
      a2.href = a2.href;
      a2.protocol = a2.protocol.replace("http", "ws");
      return a2.href;
    } else {
      return url;
    }
  }
  var Consumer;
  var init_consumer = __esm({
    "node_modules/@rails/actioncable/src/consumer.js"() {
      init_connection();
      init_subscriptions();
      Consumer = class {
        constructor(url) {
          this._url = url;
          this.subscriptions = new Subscriptions(this);
          this.connection = new connection_default(this);
          this.subprotocols = [];
        }
        get url() {
          return createWebSocketURL(this._url);
        }
        send(data) {
          return this.connection.send(data);
        }
        connect() {
          return this.connection.open();
        }
        disconnect() {
          return this.connection.close({ allowReconnect: false });
        }
        ensureActiveConnection() {
          if (!this.connection.isActive()) {
            return this.connection.open();
          }
        }
        addSubProtocol(subprotocol) {
          this.subprotocols = [...this.subprotocols, subprotocol];
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/index.js
  var src_exports = {};
  __export(src_exports, {
    Connection: () => connection_default,
    ConnectionMonitor: () => connection_monitor_default,
    Consumer: () => Consumer,
    INTERNAL: () => internal_default,
    Subscription: () => Subscription,
    SubscriptionGuarantor: () => subscription_guarantor_default,
    Subscriptions: () => Subscriptions,
    adapters: () => adapters_default,
    createConsumer: () => createConsumer,
    createWebSocketURL: () => createWebSocketURL,
    getConfig: () => getConfig,
    logger: () => logger_default
  });
  function createConsumer(url = getConfig("url") || internal_default.default_mount_path) {
    return new Consumer(url);
  }
  function getConfig(name) {
    const element = document.head.querySelector(`meta[name='action-cable-${name}']`);
    if (element) {
      return element.getAttribute("content");
    }
  }
  var init_src = __esm({
    "node_modules/@rails/actioncable/src/index.js"() {
      init_connection();
      init_connection_monitor();
      init_consumer();
      init_internal();
      init_subscription();
      init_subscriptions();
      init_subscription_guarantor();
      init_adapters();
      init_logger();
    }
  });

  // app/javascript/controllers/tinymce.js
  var require_tinymce = __commonJS({
    "app/javascript/controllers/tinymce.js"(exports, module) {
      (function() {
        "use strict";
        var typeOf$1 = function(x2) {
          if (x2 === null) {
            return "null";
          }
          if (x2 === void 0) {
            return "undefined";
          }
          var t2 = typeof x2;
          if (t2 === "object" && (Array.prototype.isPrototypeOf(x2) || x2.constructor && x2.constructor.name === "Array")) {
            return "array";
          }
          if (t2 === "object" && (String.prototype.isPrototypeOf(x2) || x2.constructor && x2.constructor.name === "String")) {
            return "string";
          }
          return t2;
        };
        var isEquatableType = function(x2) {
          return [
            "undefined",
            "boolean",
            "number",
            "string",
            "function",
            "xml",
            "null"
          ].indexOf(x2) !== -1;
        };
        var sort$1 = function(xs, compareFn) {
          var clone2 = Array.prototype.slice.call(xs);
          return clone2.sort(compareFn);
        };
        var contramap = function(eqa, f2) {
          return eq$2(function(x2, y2) {
            return eqa.eq(f2(x2), f2(y2));
          });
        };
        var eq$2 = function(f2) {
          return { eq: f2 };
        };
        var tripleEq = eq$2(function(x2, y2) {
          return x2 === y2;
        });
        var eqString = tripleEq;
        var eqArray = function(eqa) {
          return eq$2(function(x2, y2) {
            if (x2.length !== y2.length) {
              return false;
            }
            var len = x2.length;
            for (var i2 = 0; i2 < len; i2++) {
              if (!eqa.eq(x2[i2], y2[i2])) {
                return false;
              }
            }
            return true;
          });
        };
        var eqSortedArray = function(eqa, compareFn) {
          return contramap(eqArray(eqa), function(xs) {
            return sort$1(xs, compareFn);
          });
        };
        var eqRecord = function(eqa) {
          return eq$2(function(x2, y2) {
            var kx = Object.keys(x2);
            var ky = Object.keys(y2);
            if (!eqSortedArray(eqString).eq(kx, ky)) {
              return false;
            }
            var len = kx.length;
            for (var i2 = 0; i2 < len; i2++) {
              var q2 = kx[i2];
              if (!eqa.eq(x2[q2], y2[q2])) {
                return false;
              }
            }
            return true;
          });
        };
        var eqAny = eq$2(function(x2, y2) {
          if (x2 === y2) {
            return true;
          }
          var tx = typeOf$1(x2);
          var ty = typeOf$1(y2);
          if (tx !== ty) {
            return false;
          }
          if (isEquatableType(tx)) {
            return x2 === y2;
          } else if (tx === "array") {
            return eqArray(eqAny).eq(x2, y2);
          } else if (tx === "object") {
            return eqRecord(eqAny).eq(x2, y2);
          }
          return false;
        });
        const getPrototypeOf$2 = Object.getPrototypeOf;
        const hasProto = (v2, constructor, predicate) => {
          var _a;
          if (predicate(v2, constructor.prototype)) {
            return true;
          } else {
            return ((_a = v2.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;
          }
        };
        const typeOf = (x2) => {
          const t2 = typeof x2;
          if (x2 === null) {
            return "null";
          } else if (t2 === "object" && Array.isArray(x2)) {
            return "array";
          } else if (t2 === "object" && hasProto(x2, String, (o2, proto) => proto.isPrototypeOf(o2))) {
            return "string";
          } else {
            return t2;
          }
        };
        const isType$1 = (type2) => (value2) => typeOf(value2) === type2;
        const isSimpleType = (type2) => (value2) => typeof value2 === type2;
        const eq$1 = (t2) => (a2) => t2 === a2;
        const is$4 = (value2, constructor) => isObject(value2) && hasProto(value2, constructor, (o2, proto) => getPrototypeOf$2(o2) === proto);
        const isString = isType$1("string");
        const isObject = isType$1("object");
        const isPlainObject = (value2) => is$4(value2, Object);
        const isArray$1 = isType$1("array");
        const isNull = eq$1(null);
        const isBoolean = isSimpleType("boolean");
        const isUndefined = eq$1(void 0);
        const isNullable = (a2) => a2 === null || a2 === void 0;
        const isNonNullable = (a2) => !isNullable(a2);
        const isFunction = isSimpleType("function");
        const isNumber = isSimpleType("number");
        const isArrayOf = (value2, pred) => {
          if (isArray$1(value2)) {
            for (let i2 = 0, len = value2.length; i2 < len; ++i2) {
              if (!pred(value2[i2])) {
                return false;
              }
            }
            return true;
          }
          return false;
        };
        const noop2 = () => {
        };
        const compose = (fa, fb) => {
          return (...args) => {
            return fa(fb.apply(null, args));
          };
        };
        const compose1 = (fbc, fab) => (a2) => fbc(fab(a2));
        const constant = (value2) => {
          return () => {
            return value2;
          };
        };
        const identity = (x2) => {
          return x2;
        };
        const tripleEquals = (a2, b2) => {
          return a2 === b2;
        };
        function curry(fn2, ...initialArgs) {
          return (...restArgs) => {
            const all2 = initialArgs.concat(restArgs);
            return fn2.apply(null, all2);
          };
        }
        const not = (f2) => (t2) => !f2(t2);
        const die = (msg) => {
          return () => {
            throw new Error(msg);
          };
        };
        const apply$1 = (f2) => {
          return f2();
        };
        const call = (f2) => {
          f2();
        };
        const never = constant(false);
        const always = constant(true);
        class Optional {
          constructor(tag, value2) {
            this.tag = tag;
            this.value = value2;
          }
          static some(value2) {
            return new Optional(true, value2);
          }
          static none() {
            return Optional.singletonNone;
          }
          fold(onNone, onSome) {
            if (this.tag) {
              return onSome(this.value);
            } else {
              return onNone();
            }
          }
          isSome() {
            return this.tag;
          }
          isNone() {
            return !this.tag;
          }
          map(mapper) {
            if (this.tag) {
              return Optional.some(mapper(this.value));
            } else {
              return Optional.none();
            }
          }
          bind(binder2) {
            if (this.tag) {
              return binder2(this.value);
            } else {
              return Optional.none();
            }
          }
          exists(predicate) {
            return this.tag && predicate(this.value);
          }
          forall(predicate) {
            return !this.tag || predicate(this.value);
          }
          filter(predicate) {
            if (!this.tag || predicate(this.value)) {
              return this;
            } else {
              return Optional.none();
            }
          }
          getOr(replacement) {
            return this.tag ? this.value : replacement;
          }
          or(replacement) {
            return this.tag ? this : replacement;
          }
          getOrThunk(thunk) {
            return this.tag ? this.value : thunk();
          }
          orThunk(thunk) {
            return this.tag ? this : thunk();
          }
          getOrDie(message) {
            if (!this.tag) {
              throw new Error(message !== null && message !== void 0 ? message : "Called getOrDie on None");
            } else {
              return this.value;
            }
          }
          static from(value2) {
            return isNonNullable(value2) ? Optional.some(value2) : Optional.none();
          }
          getOrNull() {
            return this.tag ? this.value : null;
          }
          getOrUndefined() {
            return this.value;
          }
          each(worker) {
            if (this.tag) {
              worker(this.value);
            }
          }
          toArray() {
            return this.tag ? [this.value] : [];
          }
          toString() {
            return this.tag ? `some(${this.value})` : "none()";
          }
        }
        Optional.singletonNone = new Optional(false);
        const nativeSlice = Array.prototype.slice;
        const nativeIndexOf = Array.prototype.indexOf;
        const nativePush = Array.prototype.push;
        const rawIndexOf = (ts, t2) => nativeIndexOf.call(ts, t2);
        const indexOf$1 = (xs, x2) => {
          const r3 = rawIndexOf(xs, x2);
          return r3 === -1 ? Optional.none() : Optional.some(r3);
        };
        const contains$2 = (xs, x2) => rawIndexOf(xs, x2) > -1;
        const exists = (xs, pred) => {
          for (let i2 = 0, len = xs.length; i2 < len; i2++) {
            const x2 = xs[i2];
            if (pred(x2, i2)) {
              return true;
            }
          }
          return false;
        };
        const map$3 = (xs, f2) => {
          const len = xs.length;
          const r3 = new Array(len);
          for (let i2 = 0; i2 < len; i2++) {
            const x2 = xs[i2];
            r3[i2] = f2(x2, i2);
          }
          return r3;
        };
        const each$e = (xs, f2) => {
          for (let i2 = 0, len = xs.length; i2 < len; i2++) {
            const x2 = xs[i2];
            f2(x2, i2);
          }
        };
        const eachr = (xs, f2) => {
          for (let i2 = xs.length - 1; i2 >= 0; i2--) {
            const x2 = xs[i2];
            f2(x2, i2);
          }
        };
        const partition$2 = (xs, pred) => {
          const pass = [];
          const fail = [];
          for (let i2 = 0, len = xs.length; i2 < len; i2++) {
            const x2 = xs[i2];
            const arr = pred(x2, i2) ? pass : fail;
            arr.push(x2);
          }
          return {
            pass,
            fail
          };
        };
        const filter$5 = (xs, pred) => {
          const r3 = [];
          for (let i2 = 0, len = xs.length; i2 < len; i2++) {
            const x2 = xs[i2];
            if (pred(x2, i2)) {
              r3.push(x2);
            }
          }
          return r3;
        };
        const foldr = (xs, f2, acc) => {
          eachr(xs, (x2, i2) => {
            acc = f2(acc, x2, i2);
          });
          return acc;
        };
        const foldl = (xs, f2, acc) => {
          each$e(xs, (x2, i2) => {
            acc = f2(acc, x2, i2);
          });
          return acc;
        };
        const findUntil$1 = (xs, pred, until) => {
          for (let i2 = 0, len = xs.length; i2 < len; i2++) {
            const x2 = xs[i2];
            if (pred(x2, i2)) {
              return Optional.some(x2);
            } else if (until(x2, i2)) {
              break;
            }
          }
          return Optional.none();
        };
        const find$2 = (xs, pred) => {
          return findUntil$1(xs, pred, never);
        };
        const findIndex$2 = (xs, pred) => {
          for (let i2 = 0, len = xs.length; i2 < len; i2++) {
            const x2 = xs[i2];
            if (pred(x2, i2)) {
              return Optional.some(i2);
            }
          }
          return Optional.none();
        };
        const flatten = (xs) => {
          const r3 = [];
          for (let i2 = 0, len = xs.length; i2 < len; ++i2) {
            if (!isArray$1(xs[i2])) {
              throw new Error("Arr.flatten item " + i2 + " was not an array, input: " + xs);
            }
            nativePush.apply(r3, xs[i2]);
          }
          return r3;
        };
        const bind$3 = (xs, f2) => flatten(map$3(xs, f2));
        const forall = (xs, pred) => {
          for (let i2 = 0, len = xs.length; i2 < len; ++i2) {
            const x2 = xs[i2];
            if (pred(x2, i2) !== true) {
              return false;
            }
          }
          return true;
        };
        const reverse = (xs) => {
          const r3 = nativeSlice.call(xs, 0);
          r3.reverse();
          return r3;
        };
        const difference = (a1, a2) => filter$5(a1, (x2) => !contains$2(a2, x2));
        const mapToObject = (xs, f2) => {
          const r3 = {};
          for (let i2 = 0, len = xs.length; i2 < len; i2++) {
            const x2 = xs[i2];
            r3[String(x2)] = f2(x2, i2);
          }
          return r3;
        };
        const sort = (xs, comparator) => {
          const copy2 = nativeSlice.call(xs, 0);
          copy2.sort(comparator);
          return copy2;
        };
        const get$b = (xs, i2) => i2 >= 0 && i2 < xs.length ? Optional.some(xs[i2]) : Optional.none();
        const head = (xs) => get$b(xs, 0);
        const last$3 = (xs) => get$b(xs, xs.length - 1);
        const from = isFunction(Array.from) ? Array.from : (x2) => nativeSlice.call(x2);
        const findMap = (arr, f2) => {
          for (let i2 = 0; i2 < arr.length; i2++) {
            const r3 = f2(arr[i2], i2);
            if (r3.isSome()) {
              return r3;
            }
          }
          return Optional.none();
        };
        const unique$1 = (xs, comparator) => {
          const r3 = [];
          const isDuplicated = isFunction(comparator) ? (x2) => exists(r3, (i2) => comparator(i2, x2)) : (x2) => contains$2(r3, x2);
          for (let i2 = 0, len = xs.length; i2 < len; i2++) {
            const x2 = xs[i2];
            if (!isDuplicated(x2)) {
              r3.push(x2);
            }
          }
          return r3;
        };
        const keys = Object.keys;
        const hasOwnProperty$2 = Object.hasOwnProperty;
        const each$d = (obj, f2) => {
          const props = keys(obj);
          for (let k2 = 0, len = props.length; k2 < len; k2++) {
            const i2 = props[k2];
            const x2 = obj[i2];
            f2(x2, i2);
          }
        };
        const map$2 = (obj, f2) => {
          return tupleMap(obj, (x2, i2) => ({
            k: i2,
            v: f2(x2, i2)
          }));
        };
        const tupleMap = (obj, f2) => {
          const r3 = {};
          each$d(obj, (x2, i2) => {
            const tuple = f2(x2, i2);
            r3[tuple.k] = tuple.v;
          });
          return r3;
        };
        const objAcc = (r3) => (x2, i2) => {
          r3[i2] = x2;
        };
        const internalFilter = (obj, pred, onTrue, onFalse) => {
          each$d(obj, (x2, i2) => {
            (pred(x2, i2) ? onTrue : onFalse)(x2, i2);
          });
        };
        const bifilter = (obj, pred) => {
          const t2 = {};
          const f2 = {};
          internalFilter(obj, pred, objAcc(t2), objAcc(f2));
          return {
            t: t2,
            f: f2
          };
        };
        const filter$4 = (obj, pred) => {
          const t2 = {};
          internalFilter(obj, pred, objAcc(t2), noop2);
          return t2;
        };
        const mapToArray = (obj, f2) => {
          const r3 = [];
          each$d(obj, (value2, name2) => {
            r3.push(f2(value2, name2));
          });
          return r3;
        };
        const values = (obj) => {
          return mapToArray(obj, identity);
        };
        const get$a = (obj, key) => {
          return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();
        };
        const has$2 = (obj, key) => hasOwnProperty$2.call(obj, key);
        const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== void 0 && obj[key] !== null;
        const equal$1 = (a1, a2, eq2 = eqAny) => eqRecord(eq2).eq(a1, a2);
        const stringArray = (a2) => {
          const all2 = {};
          each$e(a2, (key) => {
            all2[key] = {};
          });
          return keys(all2);
        };
        const isArrayLike = (o2) => o2.length !== void 0;
        const isArray = Array.isArray;
        const toArray$1 = (obj) => {
          if (!isArray(obj)) {
            const array = [];
            for (let i2 = 0, l2 = obj.length; i2 < l2; i2++) {
              array[i2] = obj[i2];
            }
            return array;
          } else {
            return obj;
          }
        };
        const each$c = (o2, cb, s2) => {
          if (!o2) {
            return false;
          }
          s2 = s2 || o2;
          if (isArrayLike(o2)) {
            for (let n2 = 0, l2 = o2.length; n2 < l2; n2++) {
              if (cb.call(s2, o2[n2], n2, o2) === false) {
                return false;
              }
            }
          } else {
            for (const n2 in o2) {
              if (has$2(o2, n2)) {
                if (cb.call(s2, o2[n2], n2, o2) === false) {
                  return false;
                }
              }
            }
          }
          return true;
        };
        const map$1 = (array, callback) => {
          const out = [];
          each$c(array, (item, index) => {
            out.push(callback(item, index, array));
          });
          return out;
        };
        const filter$3 = (a2, f2) => {
          const o2 = [];
          each$c(a2, (v2, index) => {
            if (!f2 || f2(v2, index, a2)) {
              o2.push(v2);
            }
          });
          return o2;
        };
        const indexOf2 = (a2, v2) => {
          if (a2) {
            for (let i2 = 0, l2 = a2.length; i2 < l2; i2++) {
              if (a2[i2] === v2) {
                return i2;
              }
            }
          }
          return -1;
        };
        const reduce = (collection, iteratee, accumulator, thisArg) => {
          let acc = isUndefined(accumulator) ? collection[0] : accumulator;
          for (let i2 = 0; i2 < collection.length; i2++) {
            acc = iteratee.call(thisArg, acc, collection[i2], i2);
          }
          return acc;
        };
        const findIndex$1 = (array, predicate, thisArg) => {
          for (let i2 = 0, l2 = array.length; i2 < l2; i2++) {
            if (predicate.call(thisArg, array[i2], i2, array)) {
              return i2;
            }
          }
          return -1;
        };
        const last$2 = (collection) => collection[collection.length - 1];
        const cached = (f2) => {
          let called = false;
          let r3;
          return (...args) => {
            if (!called) {
              called = true;
              r3 = f2.apply(null, args);
            }
            return r3;
          };
        };
        const DeviceType = (os2, browser2, userAgent2, mediaMatch2) => {
          const isiPad = os2.isiOS() && /ipad/i.test(userAgent2) === true;
          const isiPhone = os2.isiOS() && !isiPad;
          const isMobile = os2.isiOS() || os2.isAndroid();
          const isTouch2 = isMobile || mediaMatch2("(pointer:coarse)");
          const isTablet2 = isiPad || !isiPhone && isMobile && mediaMatch2("(min-device-width:768px)");
          const isPhone2 = isiPhone || isMobile && !isTablet2;
          const iOSwebview = browser2.isSafari() && os2.isiOS() && /safari/i.test(userAgent2) === false;
          const isDesktop = !isPhone2 && !isTablet2 && !iOSwebview;
          return {
            isiPad: constant(isiPad),
            isiPhone: constant(isiPhone),
            isTablet: constant(isTablet2),
            isPhone: constant(isPhone2),
            isTouch: constant(isTouch2),
            isAndroid: os2.isAndroid,
            isiOS: os2.isiOS,
            isWebView: constant(iOSwebview),
            isDesktop: constant(isDesktop)
          };
        };
        const firstMatch = (regexes, s2) => {
          for (let i2 = 0; i2 < regexes.length; i2++) {
            const x2 = regexes[i2];
            if (x2.test(s2)) {
              return x2;
            }
          }
          return void 0;
        };
        const find$1 = (regexes, agent) => {
          const r3 = firstMatch(regexes, agent);
          if (!r3) {
            return {
              major: 0,
              minor: 0
            };
          }
          const group = (i2) => {
            return Number(agent.replace(r3, "$" + i2));
          };
          return nu$3(group(1), group(2));
        };
        const detect$5 = (versionRegexes, agent) => {
          const cleanedAgent = String(agent).toLowerCase();
          if (versionRegexes.length === 0) {
            return unknown$2();
          }
          return find$1(versionRegexes, cleanedAgent);
        };
        const unknown$2 = () => {
          return nu$3(0, 0);
        };
        const nu$3 = (major, minor) => {
          return {
            major,
            minor
          };
        };
        const Version = {
          nu: nu$3,
          detect: detect$5,
          unknown: unknown$2
        };
        const detectBrowser$1 = (browsers2, userAgentData) => {
          return findMap(userAgentData.brands, (uaBrand) => {
            const lcBrand = uaBrand.brand.toLowerCase();
            return find$2(browsers2, (browser2) => {
              var _a;
              return lcBrand === ((_a = browser2.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());
            }).map((info) => ({
              current: info.name,
              version: Version.nu(parseInt(uaBrand.version, 10), 0)
            }));
          });
        };
        const detect$4 = (candidates, userAgent2) => {
          const agent = String(userAgent2).toLowerCase();
          return find$2(candidates, (candidate) => {
            return candidate.search(agent);
          });
        };
        const detectBrowser = (browsers2, userAgent2) => {
          return detect$4(browsers2, userAgent2).map((browser2) => {
            const version = Version.detect(browser2.versionRegexes, userAgent2);
            return {
              current: browser2.name,
              version
            };
          });
        };
        const detectOs = (oses2, userAgent2) => {
          return detect$4(oses2, userAgent2).map((os2) => {
            const version = Version.detect(os2.versionRegexes, userAgent2);
            return {
              current: os2.name,
              version
            };
          });
        };
        const removeFromStart = (str, numChars) => {
          return str.substring(numChars);
        };
        const checkRange = (str, substr, start4) => substr === "" || str.length >= substr.length && str.substr(start4, start4 + substr.length) === substr;
        const removeLeading = (str, prefix) => {
          return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;
        };
        const contains$1 = (str, substr, start4 = 0, end3) => {
          const idx = str.indexOf(substr, start4);
          if (idx !== -1) {
            return isUndefined(end3) ? true : idx + substr.length <= end3;
          } else {
            return false;
          }
        };
        const startsWith = (str, prefix) => {
          return checkRange(str, prefix, 0);
        };
        const endsWith = (str, suffix) => {
          return checkRange(str, suffix, str.length - suffix.length);
        };
        const blank = (r3) => (s2) => s2.replace(r3, "");
        const trim$3 = blank(/^\s+|\s+$/g);
        const lTrim = blank(/^\s+/g);
        const rTrim = blank(/\s+$/g);
        const isNotEmpty = (s2) => s2.length > 0;
        const isEmpty$3 = (s2) => !isNotEmpty(s2);
        const repeat = (s2, count2) => count2 <= 0 ? "" : new Array(count2 + 1).join(s2);
        const toInt = (value2, radix = 10) => {
          const num = parseInt(value2, radix);
          return isNaN(num) ? Optional.none() : Optional.some(num);
        };
        const normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
        const checkContains = (target) => {
          return (uastring) => {
            return contains$1(uastring, target);
          };
        };
        const browsers = [
          {
            name: "Edge",
            versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
            search: (uastring) => {
              return contains$1(uastring, "edge/") && contains$1(uastring, "chrome") && contains$1(uastring, "safari") && contains$1(uastring, "applewebkit");
            }
          },
          {
            name: "Chromium",
            brand: "Chromium",
            versionRegexes: [
              /.*?chrome\/([0-9]+)\.([0-9]+).*/,
              normalVersionRegex
            ],
            search: (uastring) => {
              return contains$1(uastring, "chrome") && !contains$1(uastring, "chromeframe");
            }
          },
          {
            name: "IE",
            versionRegexes: [
              /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
              /.*?rv:([0-9]+)\.([0-9]+).*/
            ],
            search: (uastring) => {
              return contains$1(uastring, "msie") || contains$1(uastring, "trident");
            }
          },
          {
            name: "Opera",
            versionRegexes: [
              normalVersionRegex,
              /.*?opera\/([0-9]+)\.([0-9]+).*/
            ],
            search: checkContains("opera")
          },
          {
            name: "Firefox",
            versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
            search: checkContains("firefox")
          },
          {
            name: "Safari",
            versionRegexes: [
              normalVersionRegex,
              /.*?cpu os ([0-9]+)_([0-9]+).*/
            ],
            search: (uastring) => {
              return (contains$1(uastring, "safari") || contains$1(uastring, "mobile/")) && contains$1(uastring, "applewebkit");
            }
          }
        ];
        const oses = [
          {
            name: "Windows",
            search: checkContains("win"),
            versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
          },
          {
            name: "iOS",
            search: (uastring) => {
              return contains$1(uastring, "iphone") || contains$1(uastring, "ipad");
            },
            versionRegexes: [
              /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
              /.*cpu os ([0-9]+)_([0-9]+).*/,
              /.*cpu iphone os ([0-9]+)_([0-9]+).*/
            ]
          },
          {
            name: "Android",
            search: checkContains("android"),
            versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
          },
          {
            name: "macOS",
            search: checkContains("mac os x"),
            versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
          },
          {
            name: "Linux",
            search: checkContains("linux"),
            versionRegexes: []
          },
          {
            name: "Solaris",
            search: checkContains("sunos"),
            versionRegexes: []
          },
          {
            name: "FreeBSD",
            search: checkContains("freebsd"),
            versionRegexes: []
          },
          {
            name: "ChromeOS",
            search: checkContains("cros"),
            versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
          }
        ];
        const PlatformInfo = {
          browsers: constant(browsers),
          oses: constant(oses)
        };
        const edge = "Edge";
        const chromium = "Chromium";
        const ie = "IE";
        const opera = "Opera";
        const firefox = "Firefox";
        const safari = "Safari";
        const unknown$1 = () => {
          return nu$2({
            current: void 0,
            version: Version.unknown()
          });
        };
        const nu$2 = (info) => {
          const current = info.current;
          const version = info.version;
          const isBrowser = (name2) => () => current === name2;
          return {
            current,
            version,
            isEdge: isBrowser(edge),
            isChromium: isBrowser(chromium),
            isIE: isBrowser(ie),
            isOpera: isBrowser(opera),
            isFirefox: isBrowser(firefox),
            isSafari: isBrowser(safari)
          };
        };
        const Browser = {
          unknown: unknown$1,
          nu: nu$2,
          edge: constant(edge),
          chromium: constant(chromium),
          ie: constant(ie),
          opera: constant(opera),
          firefox: constant(firefox),
          safari: constant(safari)
        };
        const windows = "Windows";
        const ios = "iOS";
        const android = "Android";
        const linux = "Linux";
        const macos = "macOS";
        const solaris = "Solaris";
        const freebsd = "FreeBSD";
        const chromeos = "ChromeOS";
        const unknown = () => {
          return nu$1({
            current: void 0,
            version: Version.unknown()
          });
        };
        const nu$1 = (info) => {
          const current = info.current;
          const version = info.version;
          const isOS = (name2) => () => current === name2;
          return {
            current,
            version,
            isWindows: isOS(windows),
            isiOS: isOS(ios),
            isAndroid: isOS(android),
            isMacOS: isOS(macos),
            isLinux: isOS(linux),
            isSolaris: isOS(solaris),
            isFreeBSD: isOS(freebsd),
            isChromeOS: isOS(chromeos)
          };
        };
        const OperatingSystem = {
          unknown,
          nu: nu$1,
          windows: constant(windows),
          ios: constant(ios),
          android: constant(android),
          linux: constant(linux),
          macos: constant(macos),
          solaris: constant(solaris),
          freebsd: constant(freebsd),
          chromeos: constant(chromeos)
        };
        const detect$3 = (userAgent2, userAgentDataOpt, mediaMatch2) => {
          const browsers2 = PlatformInfo.browsers();
          const oses2 = PlatformInfo.oses();
          const browser2 = userAgentDataOpt.bind((userAgentData) => detectBrowser$1(browsers2, userAgentData)).orThunk(() => detectBrowser(browsers2, userAgent2)).fold(Browser.unknown, Browser.nu);
          const os2 = detectOs(oses2, userAgent2).fold(OperatingSystem.unknown, OperatingSystem.nu);
          const deviceType2 = DeviceType(os2, browser2, userAgent2, mediaMatch2);
          return {
            browser: browser2,
            os: os2,
            deviceType: deviceType2
          };
        };
        const PlatformDetection = { detect: detect$3 };
        const mediaMatch = (query) => window.matchMedia(query).matches;
        let platform$4 = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));
        const detect$2 = () => platform$4();
        const userAgent = navigator.userAgent;
        const platform$3 = detect$2();
        const browser$2 = platform$3.browser;
        const os$1 = platform$3.os;
        const deviceType = platform$3.deviceType;
        const windowsPhone = userAgent.indexOf("Windows Phone") !== -1;
        const Env = {
          transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
          documentMode: browser$2.isIE() ? document.documentMode || 7 : 10,
          cacheSuffix: null,
          container: null,
          canHaveCSP: !browser$2.isIE(),
          windowsPhone,
          browser: {
            current: browser$2.current,
            version: browser$2.version,
            isChromium: browser$2.isChromium,
            isEdge: browser$2.isEdge,
            isFirefox: browser$2.isFirefox,
            isIE: browser$2.isIE,
            isOpera: browser$2.isOpera,
            isSafari: browser$2.isSafari
          },
          os: {
            current: os$1.current,
            version: os$1.version,
            isAndroid: os$1.isAndroid,
            isChromeOS: os$1.isChromeOS,
            isFreeBSD: os$1.isFreeBSD,
            isiOS: os$1.isiOS,
            isLinux: os$1.isLinux,
            isMacOS: os$1.isMacOS,
            isSolaris: os$1.isSolaris,
            isWindows: os$1.isWindows
          },
          deviceType: {
            isDesktop: deviceType.isDesktop,
            isiPad: deviceType.isiPad,
            isiPhone: deviceType.isiPhone,
            isPhone: deviceType.isPhone,
            isTablet: deviceType.isTablet,
            isTouch: deviceType.isTouch,
            isWebView: deviceType.isWebView
          }
        };
        const whiteSpaceRegExp$1 = /^\s*|\s*$/g;
        const trim$2 = (str) => {
          return isNullable(str) ? "" : ("" + str).replace(whiteSpaceRegExp$1, "");
        };
        const is$3 = (obj, type2) => {
          if (!type2) {
            return obj !== void 0;
          }
          if (type2 === "array" && isArray(obj)) {
            return true;
          }
          return typeof obj === type2;
        };
        const makeMap$4 = (items, delim, map2 = {}) => {
          const resolvedItems = isString(items) ? items.split(delim || ",") : items || [];
          let i2 = resolvedItems.length;
          while (i2--) {
            map2[resolvedItems[i2]] = {};
          }
          return map2;
        };
        const hasOwnProperty$1 = has$2;
        const extend$3 = (obj, ...exts) => {
          for (let i2 = 0; i2 < exts.length; i2++) {
            const ext = exts[i2];
            for (const name2 in ext) {
              if (has$2(ext, name2)) {
                const value2 = ext[name2];
                if (value2 !== void 0) {
                  obj[name2] = value2;
                }
              }
            }
          }
          return obj;
        };
        const walk$4 = function(o2, f2, n2, s2) {
          s2 = s2 || this;
          if (o2) {
            if (n2) {
              o2 = o2[n2];
            }
            each$c(o2, (o3, i2) => {
              if (f2.call(s2, o3, i2, n2) === false) {
                return false;
              } else {
                walk$4(o3, f2, n2, s2);
                return true;
              }
            });
          }
        };
        const resolve$3 = (n2, o2 = window) => {
          const path2 = n2.split(".");
          for (let i2 = 0, l2 = path2.length; i2 < l2; i2++) {
            o2 = o2[path2[i2]];
            if (!o2) {
              break;
            }
          }
          return o2;
        };
        const explode$3 = (s2, d2) => {
          if (isArray$1(s2)) {
            return s2;
          } else if (s2 === "") {
            return [];
          } else {
            return map$1(s2.split(d2 || ","), trim$2);
          }
        };
        const _addCacheSuffix = (url) => {
          const cacheSuffix = Env.cacheSuffix;
          if (cacheSuffix) {
            url += (url.indexOf("?") === -1 ? "?" : "&") + cacheSuffix;
          }
          return url;
        };
        const Tools = {
          trim: trim$2,
          isArray,
          is: is$3,
          toArray: toArray$1,
          makeMap: makeMap$4,
          each: each$c,
          map: map$1,
          grep: filter$3,
          inArray: indexOf2,
          hasOwn: hasOwnProperty$1,
          extend: extend$3,
          walk: walk$4,
          resolve: resolve$3,
          explode: explode$3,
          _addCacheSuffix
        };
        const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists((left2) => comparator(left2, rhs));
        const cat = (arr) => {
          const r3 = [];
          const push = (x2) => {
            r3.push(x2);
          };
          for (let i2 = 0; i2 < arr.length; i2++) {
            arr[i2].each(push);
          }
          return r3;
        };
        const lift2 = (oa, ob, f2) => oa.isSome() && ob.isSome() ? Optional.some(f2(oa.getOrDie(), ob.getOrDie())) : Optional.none();
        const lift3 = (oa, ob, oc, f2) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f2(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();
        const someIf = (b2, a2) => b2 ? Optional.some(a2) : Optional.none();
        const Global = typeof window !== "undefined" ? window : Function("return this;")();
        const path = (parts, scope) => {
          let o2 = scope !== void 0 && scope !== null ? scope : Global;
          for (let i2 = 0; i2 < parts.length && o2 !== void 0 && o2 !== null; ++i2) {
            o2 = o2[parts[i2]];
          }
          return o2;
        };
        const resolve$2 = (p2, scope) => {
          const parts = p2.split(".");
          return path(parts, scope);
        };
        const unsafe = (name2, scope) => {
          return resolve$2(name2, scope);
        };
        const getOrDie = (name2, scope) => {
          const actual = unsafe(name2, scope);
          if (actual === void 0 || actual === null) {
            throw new Error(name2 + " not available on this browser");
          }
          return actual;
        };
        const getPrototypeOf$1 = Object.getPrototypeOf;
        const sandHTMLElement = (scope) => {
          return getOrDie("HTMLElement", scope);
        };
        const isPrototypeOf = (x2) => {
          const scope = resolve$2("ownerDocument.defaultView", x2);
          return isObject(x2) && (sandHTMLElement(scope).prototype.isPrototypeOf(x2) || /^HTML\w*Element$/.test(getPrototypeOf$1(x2).constructor.name));
        };
        const COMMENT = 8;
        const DOCUMENT = 9;
        const DOCUMENT_FRAGMENT = 11;
        const ELEMENT = 1;
        const TEXT = 3;
        const name = (element) => {
          const r3 = element.dom.nodeName;
          return r3.toLowerCase();
        };
        const type$1 = (element) => element.dom.nodeType;
        const isType = (t2) => (element) => type$1(element) === t2;
        const isComment$1 = (element) => type$1(element) === COMMENT || name(element) === "#comment";
        const isHTMLElement2 = (element) => isElement$7(element) && isPrototypeOf(element.dom);
        const isElement$7 = isType(ELEMENT);
        const isText$b = isType(TEXT);
        const isDocument$2 = isType(DOCUMENT);
        const isDocumentFragment$1 = isType(DOCUMENT_FRAGMENT);
        const isTag = (tag) => (e2) => isElement$7(e2) && name(e2) === tag;
        const rawSet = (dom2, key, value2) => {
          if (isString(value2) || isBoolean(value2) || isNumber(value2)) {
            dom2.setAttribute(key, value2 + "");
          } else {
            console.error("Invalid call to Attribute.set. Key ", key, ":: Value ", value2, ":: Element ", dom2);
            throw new Error("Attribute value was not simple");
          }
        };
        const set$3 = (element, key, value2) => {
          rawSet(element.dom, key, value2);
        };
        const setAll$1 = (element, attrs) => {
          const dom2 = element.dom;
          each$d(attrs, (v2, k2) => {
            rawSet(dom2, k2, v2);
          });
        };
        const get$9 = (element, key) => {
          const v2 = element.dom.getAttribute(key);
          return v2 === null ? void 0 : v2;
        };
        const getOpt = (element, key) => Optional.from(get$9(element, key));
        const has$1 = (element, key) => {
          const dom2 = element.dom;
          return dom2 && dom2.hasAttribute ? dom2.hasAttribute(key) : false;
        };
        const remove$a = (element, key) => {
          element.dom.removeAttribute(key);
        };
        const hasNone = (element) => {
          const attrs = element.dom.attributes;
          return attrs === void 0 || attrs === null || attrs.length === 0;
        };
        const clone$4 = (element) => foldl(element.dom.attributes, (acc, attr) => {
          acc[attr.name] = attr.value;
          return acc;
        }, {});
        const read$4 = (element, attr) => {
          const value2 = get$9(element, attr);
          return value2 === void 0 || value2 === "" ? [] : value2.split(" ");
        };
        const add$4 = (element, attr, id) => {
          const old = read$4(element, attr);
          const nu2 = old.concat([id]);
          set$3(element, attr, nu2.join(" "));
          return true;
        };
        const remove$9 = (element, attr, id) => {
          const nu2 = filter$5(read$4(element, attr), (v2) => v2 !== id);
          if (nu2.length > 0) {
            set$3(element, attr, nu2.join(" "));
          } else {
            remove$a(element, attr);
          }
          return false;
        };
        const supports = (element) => element.dom.classList !== void 0;
        const get$8 = (element) => read$4(element, "class");
        const add$3 = (element, clazz) => add$4(element, "class", clazz);
        const remove$8 = (element, clazz) => remove$9(element, "class", clazz);
        const toggle$2 = (element, clazz) => {
          if (contains$2(get$8(element), clazz)) {
            return remove$8(element, clazz);
          } else {
            return add$3(element, clazz);
          }
        };
        const add$2 = (element, clazz) => {
          if (supports(element)) {
            element.dom.classList.add(clazz);
          } else {
            add$3(element, clazz);
          }
        };
        const cleanClass = (element) => {
          const classList = supports(element) ? element.dom.classList : get$8(element);
          if (classList.length === 0) {
            remove$a(element, "class");
          }
        };
        const remove$7 = (element, clazz) => {
          if (supports(element)) {
            const classList = element.dom.classList;
            classList.remove(clazz);
          } else {
            remove$8(element, clazz);
          }
          cleanClass(element);
        };
        const toggle$1 = (element, clazz) => {
          const result = supports(element) ? element.dom.classList.toggle(clazz) : toggle$2(element, clazz);
          cleanClass(element);
          return result;
        };
        const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);
        const fromHtml$1 = (html2, scope) => {
          const doc = scope || document;
          const div = doc.createElement("div");
          div.innerHTML = html2;
          if (!div.hasChildNodes() || div.childNodes.length > 1) {
            const message = "HTML does not have a single root node";
            console.error(message, html2);
            throw new Error(message);
          }
          return fromDom$2(div.childNodes[0]);
        };
        const fromTag = (tag, scope) => {
          const doc = scope || document;
          const node = doc.createElement(tag);
          return fromDom$2(node);
        };
        const fromText = (text2, scope) => {
          const doc = scope || document;
          const node = doc.createTextNode(text2);
          return fromDom$2(node);
        };
        const fromDom$2 = (node) => {
          if (node === null || node === void 0) {
            throw new Error("Node cannot be null or undefined");
          }
          return { dom: node };
        };
        const fromPoint$2 = (docElm, x2, y2) => Optional.from(docElm.dom.elementFromPoint(x2, y2)).map(fromDom$2);
        const SugarElement = {
          fromHtml: fromHtml$1,
          fromTag,
          fromText,
          fromDom: fromDom$2,
          fromPoint: fromPoint$2
        };
        const toArray = (target, f2) => {
          const r3 = [];
          const recurse = (e2) => {
            r3.push(e2);
            return f2(e2);
          };
          let cur = f2(target);
          do {
            cur = cur.bind(recurse);
          } while (cur.isSome());
          return r3;
        };
        const is$1 = (element, selector) => {
          const dom2 = element.dom;
          if (dom2.nodeType !== ELEMENT) {
            return false;
          } else {
            const elem = dom2;
            if (elem.matches !== void 0) {
              return elem.matches(selector);
            } else if (elem.msMatchesSelector !== void 0) {
              return elem.msMatchesSelector(selector);
            } else if (elem.webkitMatchesSelector !== void 0) {
              return elem.webkitMatchesSelector(selector);
            } else if (elem.mozMatchesSelector !== void 0) {
              return elem.mozMatchesSelector(selector);
            } else {
              throw new Error("Browser lacks native selectors");
            }
          }
        };
        const bypassSelector = (dom2) => dom2.nodeType !== ELEMENT && dom2.nodeType !== DOCUMENT && dom2.nodeType !== DOCUMENT_FRAGMENT || dom2.childElementCount === 0;
        const all = (selector, scope) => {
          const base = scope === void 0 ? document : scope.dom;
          return bypassSelector(base) ? [] : map$3(base.querySelectorAll(selector), SugarElement.fromDom);
        };
        const one = (selector, scope) => {
          const base = scope === void 0 ? document : scope.dom;
          return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);
        };
        const eq = (e1, e2) => e1.dom === e2.dom;
        const contains2 = (e1, e2) => {
          const d1 = e1.dom;
          const d2 = e2.dom;
          return d1 === d2 ? false : d1.contains(d2);
        };
        const owner$1 = (element) => SugarElement.fromDom(element.dom.ownerDocument);
        const documentOrOwner = (dos) => isDocument$2(dos) ? dos : owner$1(dos);
        const documentElement = (element) => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);
        const defaultView = (element) => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);
        const parent = (element) => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);
        const parentElement = (element) => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);
        const parents$1 = (element, isRoot2) => {
          const stop2 = isFunction(isRoot2) ? isRoot2 : never;
          let dom2 = element.dom;
          const ret = [];
          while (dom2.parentNode !== null && dom2.parentNode !== void 0) {
            const rawParent = dom2.parentNode;
            const p2 = SugarElement.fromDom(rawParent);
            ret.push(p2);
            if (stop2(p2) === true) {
              break;
            } else {
              dom2 = rawParent;
            }
          }
          return ret;
        };
        const siblings = (element) => {
          const filterSelf = (elements) => filter$5(elements, (x2) => !eq(element, x2));
          return parent(element).map(children$1).map(filterSelf).getOr([]);
        };
        const prevSibling = (element) => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);
        const nextSibling = (element) => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);
        const prevSiblings = (element) => reverse(toArray(element, prevSibling));
        const nextSiblings = (element) => toArray(element, nextSibling);
        const children$1 = (element) => map$3(element.dom.childNodes, SugarElement.fromDom);
        const child$1 = (element, index) => {
          const cs = element.dom.childNodes;
          return Optional.from(cs[index]).map(SugarElement.fromDom);
        };
        const firstChild = (element) => child$1(element, 0);
        const lastChild = (element) => child$1(element, element.dom.childNodes.length - 1);
        const childNodesCount = (element) => element.dom.childNodes.length;
        const hasChildNodes = (element) => element.dom.hasChildNodes();
        const getHead = (doc) => {
          const b2 = doc.dom.head;
          if (b2 === null || b2 === void 0) {
            throw new Error("Head is not available yet");
          }
          return SugarElement.fromDom(b2);
        };
        const isShadowRoot2 = (dos) => isDocumentFragment$1(dos) && isNonNullable(dos.dom.host);
        const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);
        const isSupported$1 = constant(supported);
        const getRootNode = supported ? (e2) => SugarElement.fromDom(e2.dom.getRootNode()) : documentOrOwner;
        const getStyleContainer = (dos) => isShadowRoot2(dos) ? dos : getHead(documentOrOwner(dos));
        const getContentContainer = (dos) => isShadowRoot2(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);
        const getShadowRoot = (e2) => {
          const r3 = getRootNode(e2);
          return isShadowRoot2(r3) ? Optional.some(r3) : Optional.none();
        };
        const getShadowHost = (e2) => SugarElement.fromDom(e2.dom.host);
        const getOriginalEventTarget = (event) => {
          if (isSupported$1() && isNonNullable(event.target)) {
            const el = SugarElement.fromDom(event.target);
            if (isElement$7(el) && isOpenShadowHost(el)) {
              if (event.composed && event.composedPath) {
                const composedPath = event.composedPath();
                if (composedPath) {
                  return head(composedPath);
                }
              }
            }
          }
          return Optional.from(event.target);
        };
        const isOpenShadowHost = (element) => isNonNullable(element.dom.shadowRoot);
        const inBody = (element) => {
          const dom2 = isText$b(element) ? element.dom.parentNode : element.dom;
          if (dom2 === void 0 || dom2 === null || dom2.ownerDocument === null) {
            return false;
          }
          const doc = dom2.ownerDocument;
          return getShadowRoot(SugarElement.fromDom(dom2)).fold(() => doc.body.contains(dom2), compose1(inBody, getShadowHost));
        };
        var ClosestOrAncestor = (is2, ancestor2, scope, a2, isRoot2) => {
          if (is2(scope, a2)) {
            return Optional.some(scope);
          } else if (isFunction(isRoot2) && isRoot2(scope)) {
            return Optional.none();
          } else {
            return ancestor2(scope, a2, isRoot2);
          }
        };
        const ancestor$4 = (scope, predicate, isRoot2) => {
          let element = scope.dom;
          const stop2 = isFunction(isRoot2) ? isRoot2 : never;
          while (element.parentNode) {
            element = element.parentNode;
            const el = SugarElement.fromDom(element);
            if (predicate(el)) {
              return Optional.some(el);
            } else if (stop2(el)) {
              break;
            }
          }
          return Optional.none();
        };
        const closest$4 = (scope, predicate, isRoot2) => {
          const is2 = (s2, test) => test(s2);
          return ClosestOrAncestor(is2, ancestor$4, scope, predicate, isRoot2);
        };
        const sibling$1 = (scope, predicate) => {
          const element = scope.dom;
          if (!element.parentNode) {
            return Optional.none();
          }
          return child(SugarElement.fromDom(element.parentNode), (x2) => !eq(scope, x2) && predicate(x2));
        };
        const child = (scope, predicate) => {
          const pred = (node) => predicate(SugarElement.fromDom(node));
          const result = find$2(scope.dom.childNodes, pred);
          return result.map(SugarElement.fromDom);
        };
        const descendant$1 = (scope, predicate) => {
          const descend2 = (node) => {
            for (let i2 = 0; i2 < node.childNodes.length; i2++) {
              const child2 = SugarElement.fromDom(node.childNodes[i2]);
              if (predicate(child2)) {
                return Optional.some(child2);
              }
              const res = descend2(node.childNodes[i2]);
              if (res.isSome()) {
                return res;
              }
            }
            return Optional.none();
          };
          return descend2(scope.dom);
        };
        const ancestor$3 = (scope, selector, isRoot2) => ancestor$4(scope, (e2) => is$1(e2, selector), isRoot2);
        const descendant = (scope, selector) => one(selector, scope);
        const closest$3 = (scope, selector, isRoot2) => {
          const is2 = (element, selector2) => is$1(element, selector2);
          return ClosestOrAncestor(is2, ancestor$3, scope, selector, isRoot2);
        };
        const closest$2 = (target) => closest$3(target, "[contenteditable]");
        const isEditable$3 = (element, assumeEditable = false) => {
          if (inBody(element)) {
            return element.dom.isContentEditable;
          } else {
            return closest$2(element).fold(constant(assumeEditable), (editable) => getRaw$1(editable) === "true");
          }
        };
        const getRaw$1 = (element) => element.dom.contentEditable;
        const isSupported = (dom2) => dom2.style !== void 0 && isFunction(dom2.style.getPropertyValue);
        const internalSet = (dom2, property, value2) => {
          if (!isString(value2)) {
            console.error("Invalid call to CSS.set. Property ", property, ":: Value ", value2, ":: Element ", dom2);
            throw new Error("CSS value must be a string: " + value2);
          }
          if (isSupported(dom2)) {
            dom2.style.setProperty(property, value2);
          }
        };
        const internalRemove = (dom2, property) => {
          if (isSupported(dom2)) {
            dom2.style.removeProperty(property);
          }
        };
        const set$2 = (element, property, value2) => {
          const dom2 = element.dom;
          internalSet(dom2, property, value2);
        };
        const setAll = (element, css) => {
          const dom2 = element.dom;
          each$d(css, (v2, k2) => {
            internalSet(dom2, k2, v2);
          });
        };
        const get$7 = (element, property) => {
          const dom2 = element.dom;
          const styles = window.getComputedStyle(dom2);
          const r3 = styles.getPropertyValue(property);
          return r3 === "" && !inBody(element) ? getUnsafeProperty(dom2, property) : r3;
        };
        const getUnsafeProperty = (dom2, property) => isSupported(dom2) ? dom2.style.getPropertyValue(property) : "";
        const getRaw = (element, property) => {
          const dom2 = element.dom;
          const raw = getUnsafeProperty(dom2, property);
          return Optional.from(raw).filter((r3) => r3.length > 0);
        };
        const getAllRaw = (element) => {
          const css = {};
          const dom2 = element.dom;
          if (isSupported(dom2)) {
            for (let i2 = 0; i2 < dom2.style.length; i2++) {
              const ruleName = dom2.style.item(i2);
              css[ruleName] = dom2.style[ruleName];
            }
          }
          return css;
        };
        const remove$6 = (element, property) => {
          const dom2 = element.dom;
          internalRemove(dom2, property);
          if (is$2(getOpt(element, "style").map(trim$3), "")) {
            remove$a(element, "style");
          }
        };
        const reflow2 = (e2) => e2.dom.offsetWidth;
        const before$3 = (marker, element) => {
          const parent$1 = parent(marker);
          parent$1.each((v2) => {
            v2.dom.insertBefore(element.dom, marker.dom);
          });
        };
        const after$4 = (marker, element) => {
          const sibling2 = nextSibling(marker);
          sibling2.fold(() => {
            const parent$1 = parent(marker);
            parent$1.each((v2) => {
              append$1(v2, element);
            });
          }, (v2) => {
            before$3(v2, element);
          });
        };
        const prepend = (parent2, element) => {
          const firstChild$1 = firstChild(parent2);
          firstChild$1.fold(() => {
            append$1(parent2, element);
          }, (v2) => {
            parent2.dom.insertBefore(element.dom, v2.dom);
          });
        };
        const append$1 = (parent2, element) => {
          parent2.dom.appendChild(element.dom);
        };
        const wrap$2 = (element, wrapper) => {
          before$3(element, wrapper);
          append$1(wrapper, element);
        };
        const after$3 = (marker, elements) => {
          each$e(elements, (x2, i2) => {
            const e2 = i2 === 0 ? marker : elements[i2 - 1];
            after$4(e2, x2);
          });
        };
        const append = (parent2, elements) => {
          each$e(elements, (x2) => {
            append$1(parent2, x2);
          });
        };
        const empty = (element) => {
          element.dom.textContent = "";
          each$e(children$1(element), (rogue) => {
            remove$5(rogue);
          });
        };
        const remove$5 = (element) => {
          const dom2 = element.dom;
          if (dom2.parentNode !== null) {
            dom2.parentNode.removeChild(dom2);
          }
        };
        const unwrap = (wrapper) => {
          const children2 = children$1(wrapper);
          if (children2.length > 0) {
            after$3(wrapper, children2);
          }
          remove$5(wrapper);
        };
        const fromHtml = (html2, scope) => {
          const doc = scope || document;
          const div = doc.createElement("div");
          div.innerHTML = html2;
          return children$1(SugarElement.fromDom(div));
        };
        const fromDom$1 = (nodes) => map$3(nodes, SugarElement.fromDom);
        const get$6 = (element) => element.dom.innerHTML;
        const set$1 = (element, content) => {
          const owner2 = owner$1(element);
          const docDom = owner2.dom;
          const fragment = SugarElement.fromDom(docDom.createDocumentFragment());
          const contentElements = fromHtml(content, docDom);
          append(fragment, contentElements);
          empty(element);
          append$1(element, fragment);
        };
        const getOuter = (element) => {
          const container = SugarElement.fromTag("div");
          const clone2 = SugarElement.fromDom(element.dom.cloneNode(true));
          append$1(container, clone2);
          return get$6(container);
        };
        const mkEvent = (target, x2, y2, stop2, prevent, kill, raw) => ({
          target,
          x: x2,
          y: y2,
          stop: stop2,
          prevent,
          kill,
          raw
        });
        const fromRawEvent = (rawEvent) => {
          const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));
          const stop2 = () => rawEvent.stopPropagation();
          const prevent = () => rawEvent.preventDefault();
          const kill = compose(prevent, stop2);
          return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop2, prevent, kill, rawEvent);
        };
        const handle$1 = (filter2, handler) => (rawEvent) => {
          if (filter2(rawEvent)) {
            handler(fromRawEvent(rawEvent));
          }
        };
        const binder = (element, event, filter2, handler, useCapture) => {
          const wrapped = handle$1(filter2, handler);
          element.dom.addEventListener(event, wrapped, useCapture);
          return { unbind: curry(unbind, element, event, wrapped, useCapture) };
        };
        const bind$2 = (element, event, filter2, handler) => binder(element, event, filter2, handler, false);
        const unbind = (element, event, handler, useCapture) => {
          element.dom.removeEventListener(event, handler, useCapture);
        };
        const r2 = (left2, top2) => {
          const translate2 = (x2, y2) => r2(left2 + x2, top2 + y2);
          return {
            left: left2,
            top: top2,
            translate: translate2
          };
        };
        const SugarPosition = r2;
        const boxPosition = (dom2) => {
          const box = dom2.getBoundingClientRect();
          return SugarPosition(box.left, box.top);
        };
        const firstDefinedOrZero = (a2, b2) => {
          if (a2 !== void 0) {
            return a2;
          } else {
            return b2 !== void 0 ? b2 : 0;
          }
        };
        const absolute = (element) => {
          const doc = element.dom.ownerDocument;
          const body = doc.body;
          const win = doc.defaultView;
          const html2 = doc.documentElement;
          if (body === element.dom) {
            return SugarPosition(body.offsetLeft, body.offsetTop);
          }
          const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html2.scrollTop);
          const scrollLeft2 = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html2.scrollLeft);
          const clientTop = firstDefinedOrZero(html2.clientTop, body.clientTop);
          const clientLeft = firstDefinedOrZero(html2.clientLeft, body.clientLeft);
          return viewport2(element).translate(scrollLeft2 - clientLeft, scrollTop - clientTop);
        };
        const viewport2 = (element) => {
          const dom2 = element.dom;
          const doc = dom2.ownerDocument;
          const body = doc.body;
          if (body === dom2) {
            return SugarPosition(body.offsetLeft, body.offsetTop);
          }
          if (!inBody(element)) {
            return SugarPosition(0, 0);
          }
          return boxPosition(dom2);
        };
        const get$5 = (_DOC) => {
          const doc = _DOC !== void 0 ? _DOC.dom : document;
          const x2 = doc.body.scrollLeft || doc.documentElement.scrollLeft;
          const y2 = doc.body.scrollTop || doc.documentElement.scrollTop;
          return SugarPosition(x2, y2);
        };
        const intoView = (element, alignToTop) => {
          const isSafari2 = detect$2().browser.isSafari();
          if (isSafari2 && isFunction(element.dom.scrollIntoViewIfNeeded)) {
            element.dom.scrollIntoViewIfNeeded(false);
          } else {
            element.dom.scrollIntoView(alignToTop);
          }
        };
        const get$4 = (_win) => {
          const win = _win === void 0 ? window : _win;
          if (detect$2().browser.isFirefox()) {
            return Optional.none();
          } else {
            return Optional.from(win.visualViewport);
          }
        };
        const bounds = (x2, y2, width, height) => ({
          x: x2,
          y: y2,
          width,
          height,
          right: x2 + width,
          bottom: y2 + height
        });
        const getBounds = (_win) => {
          const win = _win === void 0 ? window : _win;
          const doc = win.document;
          const scroll = get$5(SugarElement.fromDom(doc));
          return get$4(win).fold(() => {
            const html2 = win.document.documentElement;
            const width = html2.clientWidth;
            const height = html2.clientHeight;
            return bounds(scroll.left, scroll.top, width, height);
          }, (visualViewport) => bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));
        };
        const children = (scope, predicate) => filter$5(children$1(scope), predicate);
        const descendants$1 = (scope, predicate) => {
          let result = [];
          each$e(children$1(scope), (x2) => {
            if (predicate(x2)) {
              result = result.concat([x2]);
            }
            result = result.concat(descendants$1(x2, predicate));
          });
          return result;
        };
        const descendants = (scope, selector) => all(selector, scope);
        const ancestor$2 = (scope, selector, isRoot2) => ancestor$3(scope, selector, isRoot2).isSome();
        class DomTreeWalker {
          constructor(startNode, rootNode) {
            this.node = startNode;
            this.rootNode = rootNode;
            this.current = this.current.bind(this);
            this.next = this.next.bind(this);
            this.prev = this.prev.bind(this);
            this.prev2 = this.prev2.bind(this);
          }
          current() {
            return this.node;
          }
          next(shallow2) {
            this.node = this.findSibling(this.node, "firstChild", "nextSibling", shallow2);
            return this.node;
          }
          prev(shallow2) {
            this.node = this.findSibling(this.node, "lastChild", "previousSibling", shallow2);
            return this.node;
          }
          prev2(shallow2) {
            this.node = this.findPreviousNode(this.node, shallow2);
            return this.node;
          }
          findSibling(node, startName, siblingName, shallow2) {
            if (node) {
              if (!shallow2 && node[startName]) {
                return node[startName];
              }
              if (node !== this.rootNode) {
                let sibling2 = node[siblingName];
                if (sibling2) {
                  return sibling2;
                }
                for (let parent2 = node.parentNode; parent2 && parent2 !== this.rootNode; parent2 = parent2.parentNode) {
                  sibling2 = parent2[siblingName];
                  if (sibling2) {
                    return sibling2;
                  }
                }
              }
            }
            return void 0;
          }
          findPreviousNode(node, shallow2) {
            if (node) {
              const sibling2 = node.previousSibling;
              if (this.rootNode && sibling2 === this.rootNode) {
                return;
              }
              if (sibling2) {
                if (!shallow2) {
                  for (let child2 = sibling2.lastChild; child2; child2 = child2.lastChild) {
                    if (!child2.lastChild) {
                      return child2;
                    }
                  }
                }
                return sibling2;
              }
              const parent2 = node.parentNode;
              if (parent2 && parent2 !== this.rootNode) {
                return parent2;
              }
            }
            return void 0;
          }
        }
        const isNodeType = (type2) => {
          return (node) => {
            return !!node && node.nodeType === type2;
          };
        };
        const isRestrictedNode = (node) => !!node && !Object.getPrototypeOf(node);
        const isElement$6 = isNodeType(1);
        const matchNodeName = (name2) => {
          const lowerCasedName = name2.toLowerCase();
          return (node) => isNonNullable(node) && node.nodeName.toLowerCase() === lowerCasedName;
        };
        const matchNodeNames = (names) => {
          const lowerCasedNames = names.map((s2) => s2.toLowerCase());
          return (node) => {
            if (node && node.nodeName) {
              const nodeName = node.nodeName.toLowerCase();
              return contains$2(lowerCasedNames, nodeName);
            }
            return false;
          };
        };
        const matchStyleValues = (name2, values2) => {
          const items = values2.toLowerCase().split(" ");
          return (node) => {
            if (isElement$6(node)) {
              const win = node.ownerDocument.defaultView;
              if (win) {
                for (let i2 = 0; i2 < items.length; i2++) {
                  const computed = win.getComputedStyle(node, null);
                  const cssValue = computed ? computed.getPropertyValue(name2) : null;
                  if (cssValue === items[i2]) {
                    return true;
                  }
                }
              }
            }
            return false;
          };
        };
        const hasAttribute2 = (attrName) => {
          return (node) => {
            return isElement$6(node) && node.hasAttribute(attrName);
          };
        };
        const hasAttributeValue = (attrName, attrValue) => {
          return (node) => {
            return isElement$6(node) && node.getAttribute(attrName) === attrValue;
          };
        };
        const isBogus$2 = (node) => isElement$6(node) && node.hasAttribute("data-mce-bogus");
        const isBogusAll$1 = (node) => isElement$6(node) && node.getAttribute("data-mce-bogus") === "all";
        const isTable$2 = (node) => isElement$6(node) && node.tagName === "TABLE";
        const hasContentEditableState = (value2) => {
          return (node) => {
            if (isElement$6(node)) {
              if (node.contentEditable === value2) {
                return true;
              }
              if (node.getAttribute("data-mce-contenteditable") === value2) {
                return true;
              }
            }
            return false;
          };
        };
        const isTextareaOrInput = matchNodeNames([
          "textarea",
          "input"
        ]);
        const isText$a = isNodeType(3);
        const isCData = isNodeType(4);
        const isPi = isNodeType(7);
        const isComment = isNodeType(8);
        const isDocument$1 = isNodeType(9);
        const isDocumentFragment = isNodeType(11);
        const isBr$6 = matchNodeName("br");
        const isImg = matchNodeName("img");
        const isContentEditableTrue$3 = hasContentEditableState("true");
        const isContentEditableFalse$b = hasContentEditableState("false");
        const isTableCell$3 = matchNodeNames([
          "td",
          "th"
        ]);
        const isTableCellOrCaption = matchNodeNames([
          "td",
          "th",
          "caption"
        ]);
        const isMedia$2 = matchNodeNames([
          "video",
          "audio",
          "object",
          "embed"
        ]);
        const isListItem$2 = matchNodeName("li");
        const isDetails = matchNodeName("details");
        const isSummary = matchNodeName("summary");
        const zeroWidth = "\uFEFF";
        const nbsp = "\xA0";
        const isZwsp$2 = (char) => char === zeroWidth;
        const removeZwsp = (s2) => s2.replace(/\uFEFF/g, "");
        const NodeValue = (is2, name2) => {
          const get2 = (element) => {
            if (!is2(element)) {
              throw new Error("Can only get " + name2 + " value of a " + name2 + " node");
            }
            return getOption2(element).getOr("");
          };
          const getOption2 = (element) => is2(element) ? Optional.from(element.dom.nodeValue) : Optional.none();
          const set2 = (element, value2) => {
            if (!is2(element)) {
              throw new Error("Can only set raw " + name2 + " value of a " + name2 + " node");
            }
            element.dom.nodeValue = value2;
          };
          return {
            get: get2,
            getOption: getOption2,
            set: set2
          };
        };
        const api$1 = NodeValue(isText$b, "text");
        const get$3 = (element) => api$1.get(element);
        const getOption = (element) => api$1.getOption(element);
        const set = (element, value2) => api$1.set(element, value2);
        const blocks = [
          "article",
          "aside",
          "details",
          "div",
          "dt",
          "figcaption",
          "footer",
          "form",
          "fieldset",
          "header",
          "hgroup",
          "html",
          "main",
          "nav",
          "section",
          "summary",
          "body",
          "p",
          "dl",
          "multicol",
          "dd",
          "figure",
          "address",
          "center",
          "blockquote",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "listing",
          "xmp",
          "pre",
          "plaintext",
          "menu",
          "dir",
          "ul",
          "ol",
          "li",
          "hr",
          "table",
          "tbody",
          "thead",
          "tfoot",
          "th",
          "tr",
          "td",
          "caption"
        ];
        const tableCells = [
          "td",
          "th"
        ];
        const tableSections = [
          "thead",
          "tbody",
          "tfoot"
        ];
        const textBlocks = [
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "p",
          "div",
          "address",
          "pre",
          "form",
          "blockquote",
          "center",
          "dir",
          "fieldset",
          "header",
          "footer",
          "article",
          "section",
          "hgroup",
          "aside",
          "nav",
          "figure"
        ];
        const headings = [
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6"
        ];
        const listItems$1 = [
          "li",
          "dd",
          "dt"
        ];
        const lists = [
          "ul",
          "ol",
          "dl"
        ];
        const wsElements = [
          "pre",
          "script",
          "textarea",
          "style"
        ];
        const wrapBlockElements = ["pre"].concat(headings);
        const lazyLookup = (items) => {
          let lookup2;
          return (node) => {
            lookup2 = lookup2 ? lookup2 : mapToObject(items, always);
            return has$2(lookup2, name(node));
          };
        };
        const isBlock$2 = lazyLookup(blocks);
        const isTable$1 = (node) => name(node) === "table";
        const isInline$1 = (node) => isElement$7(node) && !isBlock$2(node);
        const isBr$5 = (node) => isElement$7(node) && name(node) === "br";
        const isTextBlock$2 = lazyLookup(textBlocks);
        const isList = lazyLookup(lists);
        const isListItem$1 = lazyLookup(listItems$1);
        const isTableSection = lazyLookup(tableSections);
        const isTableCell$2 = lazyLookup(tableCells);
        const isWsPreserveElement = lazyLookup(wsElements);
        const isWrapBlockElement = lazyLookup(wrapBlockElements);
        const isWrapElement = (node) => isWrapBlockElement(node) || isInline$1(node);
        const getLastChildren$1 = (elm) => {
          const children2 = [];
          let rawNode = elm.dom;
          while (rawNode) {
            children2.push(SugarElement.fromDom(rawNode));
            rawNode = rawNode.lastChild;
          }
          return children2;
        };
        const removeTrailingBr = (elm) => {
          const allBrs = descendants(elm, "br");
          const brs = filter$5(getLastChildren$1(elm).slice(-1), isBr$5);
          if (allBrs.length === brs.length) {
            each$e(brs, remove$5);
          }
        };
        const createPaddingBr = () => {
          const br = SugarElement.fromTag("br");
          set$3(br, "data-mce-bogus", "1");
          return br;
        };
        const fillWithPaddingBr = (elm) => {
          empty(elm);
          append$1(elm, createPaddingBr());
        };
        const trimBlockTrailingBr = (elm) => {
          lastChild(elm).each((lastChild2) => {
            prevSibling(lastChild2).each((lastChildPrevSibling) => {
              if (isBlock$2(elm) && isBr$5(lastChild2) && isBlock$2(lastChildPrevSibling)) {
                remove$5(lastChild2);
              }
            });
          });
        };
        const ZWSP$1 = zeroWidth;
        const isZwsp$1 = isZwsp$2;
        const trim$1 = removeZwsp;
        const isElement$5 = isElement$6;
        const isText$9 = isText$a;
        const isCaretContainerBlock$1 = (node) => {
          if (isText$9(node)) {
            node = node.parentNode;
          }
          return isElement$5(node) && node.hasAttribute("data-mce-caret");
        };
        const isCaretContainerInline = (node) => isText$9(node) && isZwsp$1(node.data);
        const isCaretContainer$2 = (node) => isCaretContainerBlock$1(node) || isCaretContainerInline(node);
        const hasContent = (node) => node.firstChild !== node.lastChild || !isBr$6(node.firstChild);
        const insertInline$1 = (node, before2) => {
          var _a;
          const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
          const textNode = doc.createTextNode(ZWSP$1);
          const parentNode = node.parentNode;
          if (!before2) {
            const sibling2 = node.nextSibling;
            if (isText$9(sibling2)) {
              if (isCaretContainer$2(sibling2)) {
                return sibling2;
              }
              if (startsWithCaretContainer$1(sibling2)) {
                sibling2.splitText(1);
                return sibling2;
              }
            }
            if (node.nextSibling) {
              parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node.nextSibling);
            } else {
              parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(textNode);
            }
          } else {
            const sibling2 = node.previousSibling;
            if (isText$9(sibling2)) {
              if (isCaretContainer$2(sibling2)) {
                return sibling2;
              }
              if (endsWithCaretContainer$1(sibling2)) {
                return sibling2.splitText(sibling2.data.length - 1);
              }
            }
            parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node);
          }
          return textNode;
        };
        const isBeforeInline = (pos) => {
          const container = pos.container();
          if (!isText$a(container)) {
            return false;
          }
          return container.data.charAt(pos.offset()) === ZWSP$1 || pos.isAtStart() && isCaretContainerInline(container.previousSibling);
        };
        const isAfterInline = (pos) => {
          const container = pos.container();
          if (!isText$a(container)) {
            return false;
          }
          return container.data.charAt(pos.offset() - 1) === ZWSP$1 || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);
        };
        const insertBlock = (blockName, node, before2) => {
          var _a;
          const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
          const blockNode = doc.createElement(blockName);
          blockNode.setAttribute("data-mce-caret", before2 ? "before" : "after");
          blockNode.setAttribute("data-mce-bogus", "all");
          blockNode.appendChild(createPaddingBr().dom);
          const parentNode = node.parentNode;
          if (!before2) {
            if (node.nextSibling) {
              parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node.nextSibling);
            } else {
              parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(blockNode);
            }
          } else {
            parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node);
          }
          return blockNode;
        };
        const startsWithCaretContainer$1 = (node) => isText$9(node) && node.data[0] === ZWSP$1;
        const endsWithCaretContainer$1 = (node) => isText$9(node) && node.data[node.data.length - 1] === ZWSP$1;
        const trimBogusBr = (elm) => {
          var _a;
          const brs = elm.getElementsByTagName("br");
          const lastBr = brs[brs.length - 1];
          if (isBogus$2(lastBr)) {
            (_a = lastBr.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(lastBr);
          }
        };
        const showCaretContainerBlock = (caretContainer) => {
          if (caretContainer && caretContainer.hasAttribute("data-mce-caret")) {
            trimBogusBr(caretContainer);
            caretContainer.removeAttribute("data-mce-caret");
            caretContainer.removeAttribute("data-mce-bogus");
            caretContainer.removeAttribute("style");
            caretContainer.removeAttribute("data-mce-style");
            caretContainer.removeAttribute("_moz_abspos");
            return caretContainer;
          }
          return null;
        };
        const isRangeInCaretContainerBlock = (range2) => isCaretContainerBlock$1(range2.startContainer);
        const isContentEditableTrue$2 = isContentEditableTrue$3;
        const isContentEditableFalse$a = isContentEditableFalse$b;
        const isBr$4 = isBr$6;
        const isText$8 = isText$a;
        const isInvalidTextElement = matchNodeNames([
          "script",
          "style",
          "textarea"
        ]);
        const isAtomicInline = matchNodeNames([
          "img",
          "input",
          "textarea",
          "hr",
          "iframe",
          "video",
          "audio",
          "object",
          "embed"
        ]);
        const isTable = matchNodeNames(["table"]);
        const isCaretContainer$1 = isCaretContainer$2;
        const isCaretCandidate$3 = (node) => {
          if (isCaretContainer$1(node)) {
            return false;
          }
          if (isText$8(node)) {
            return !isInvalidTextElement(node.parentNode);
          }
          return isAtomicInline(node) || isBr$4(node) || isTable(node) || isNonUiContentEditableFalse(node);
        };
        const isUnselectable = (node) => isElement$6(node) && node.getAttribute("unselectable") === "true";
        const isNonUiContentEditableFalse = (node) => !isUnselectable(node) && isContentEditableFalse$a(node);
        const isInEditable = (node, root) => {
          for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {
            if (isNonUiContentEditableFalse(tempNode)) {
              return false;
            }
            if (isContentEditableTrue$2(tempNode)) {
              return true;
            }
          }
          return true;
        };
        const isAtomicContentEditableFalse = (node) => {
          if (!isNonUiContentEditableFalse(node)) {
            return false;
          }
          return !foldl(from(node.getElementsByTagName("*")), (result, elm) => {
            return result || isContentEditableTrue$2(elm);
          }, false);
        };
        const isAtomic$1 = (node) => isAtomicInline(node) || isAtomicContentEditableFalse(node);
        const isEditableCaretCandidate$1 = (node, root) => isCaretCandidate$3(node) && isInEditable(node, root);
        const whiteSpaceRegExp = /^[ \t\r\n]*$/;
        const isWhitespaceText = (text2) => whiteSpaceRegExp.test(text2);
        const isZwsp = (text2) => {
          for (const c2 of text2) {
            if (!isZwsp$2(c2)) {
              return false;
            }
          }
          return true;
        };
        const isCollapsibleWhitespace$1 = (c2) => " \f	\v".indexOf(c2) !== -1;
        const isNewLineChar = (c2) => c2 === "\n" || c2 === "\r";
        const isNewline = (text2, idx) => idx < text2.length && idx >= 0 ? isNewLineChar(text2[idx]) : false;
        const normalize$4 = (text2, tabSpaces = 4, isStartOfContent = true, isEndOfContent = true) => {
          const tabSpace = repeat(" ", tabSpaces);
          const normalizedText = text2.replace(/\t/g, tabSpace);
          const result = foldl(normalizedText, (acc, c2) => {
            if (isCollapsibleWhitespace$1(c2) || c2 === nbsp) {
              if (acc.pcIsSpace || acc.str === "" && isStartOfContent || acc.str.length === normalizedText.length - 1 && isEndOfContent || isNewline(normalizedText, acc.str.length + 1)) {
                return {
                  pcIsSpace: false,
                  str: acc.str + nbsp
                };
              } else {
                return {
                  pcIsSpace: true,
                  str: acc.str + " "
                };
              }
            } else {
              return {
                pcIsSpace: isNewLineChar(c2),
                str: acc.str + c2
              };
            }
          }, {
            pcIsSpace: false,
            str: ""
          });
          return result.str;
        };
        const hasWhitespacePreserveParent = (node, rootNode) => {
          const rootElement = SugarElement.fromDom(rootNode);
          const startNode = SugarElement.fromDom(node);
          return ancestor$2(startNode, "pre,code", curry(eq, rootElement));
        };
        const isWhitespace$1 = (node, rootNode) => {
          return isText$a(node) && isWhitespaceText(node.data) && !hasWhitespacePreserveParent(node, rootNode);
        };
        const isNamedAnchor = (node) => {
          return isElement$6(node) && node.nodeName === "A" && !node.hasAttribute("href") && (node.hasAttribute("name") || node.hasAttribute("id"));
        };
        const isContent$1 = (node, rootNode) => {
          return isCaretCandidate$3(node) && !isWhitespace$1(node, rootNode) || isNamedAnchor(node) || isBookmark(node);
        };
        const isBookmark = hasAttribute2("data-mce-bookmark");
        const isBogus$1 = hasAttribute2("data-mce-bogus");
        const isBogusAll = hasAttributeValue("data-mce-bogus", "all");
        const isEmptyNode = (targetNode, skipBogus) => {
          let brCount = 0;
          if (isContent$1(targetNode, targetNode)) {
            return false;
          } else {
            let node = targetNode.firstChild;
            if (!node) {
              return true;
            }
            const walker = new DomTreeWalker(node, targetNode);
            do {
              if (skipBogus) {
                if (isBogusAll(node)) {
                  node = walker.next(true);
                  continue;
                }
                if (isBogus$1(node)) {
                  node = walker.next();
                  continue;
                }
              }
              if (isBr$6(node)) {
                brCount++;
                node = walker.next();
                continue;
              }
              if (isContent$1(node, targetNode)) {
                return false;
              }
              node = walker.next();
            } while (node);
            return brCount <= 1;
          }
        };
        const isEmpty$2 = (elm, skipBogus = true) => isEmptyNode(elm.dom, skipBogus);
        const transparentBlockAttr = "data-mce-block";
        const elementNames = (map2) => filter$5(keys(map2), (key) => !/[A-Z]/.test(key));
        const makeSelectorFromSchemaMap = (map2) => elementNames(map2).join(",");
        const updateTransparent = (blocksSelector, transparent) => {
          if (isNonNullable(transparent.querySelector(blocksSelector))) {
            transparent.setAttribute(transparentBlockAttr, "true");
            if (transparent.getAttribute("data-mce-selected") === "inline-boundary") {
              transparent.removeAttribute("data-mce-selected");
            }
            return true;
          } else {
            transparent.removeAttribute(transparentBlockAttr);
            return false;
          }
        };
        const updateBlockStateOnChildren = (schema, scope) => {
          const transparentSelector = makeSelectorFromSchemaMap(schema.getTransparentElements());
          const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());
          return filter$5(scope.querySelectorAll(transparentSelector), (transparent) => updateTransparent(blocksSelector, transparent));
        };
        const trimEdge = (el, leftSide) => {
          var _a;
          const childPropertyName = leftSide ? "lastChild" : "firstChild";
          for (let child2 = el[childPropertyName]; child2; child2 = child2[childPropertyName]) {
            if (isEmpty$2(SugarElement.fromDom(child2))) {
              (_a = child2.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(child2);
              return;
            }
          }
        };
        const split$2 = (parentElm, splitElm) => {
          const range2 = document.createRange();
          const parentNode = parentElm.parentNode;
          if (parentNode) {
            range2.setStartBefore(parentElm);
            range2.setEndBefore(splitElm);
            const beforeFragment = range2.extractContents();
            trimEdge(beforeFragment, true);
            range2.setStartAfter(splitElm);
            range2.setEndAfter(parentElm);
            const afterFragment = range2.extractContents();
            trimEdge(afterFragment, false);
            if (!isEmpty$2(SugarElement.fromDom(beforeFragment))) {
              parentNode.insertBefore(beforeFragment, parentElm);
            }
            if (!isEmpty$2(SugarElement.fromDom(splitElm))) {
              parentNode.insertBefore(splitElm, parentElm);
            }
            if (!isEmpty$2(SugarElement.fromDom(afterFragment))) {
              parentNode.insertBefore(afterFragment, parentElm);
            }
            parentNode.removeChild(parentElm);
          }
        };
        const splitInvalidChildren = (schema, scope, transparentBlocks) => {
          const blocksElements = schema.getBlockElements();
          const rootNode = SugarElement.fromDom(scope);
          const isBlock2 = (el) => name(el) in blocksElements;
          const isRoot2 = (el) => eq(el, rootNode);
          each$e(fromDom$1(transparentBlocks), (transparentBlock) => {
            ancestor$4(transparentBlock, isBlock2, isRoot2).each((parentBlock) => {
              const invalidChildren = children(transparentBlock, (el) => isBlock2(el) && !schema.isValidChild(name(parentBlock), name(el)));
              if (invalidChildren.length > 0) {
                const stateScope = parentElement(parentBlock);
                each$e(invalidChildren, (child2) => {
                  ancestor$4(child2, isBlock2, isRoot2).each((parentBlock2) => {
                    split$2(parentBlock2.dom, child2.dom);
                  });
                });
                stateScope.each((scope2) => updateBlockStateOnChildren(schema, scope2.dom));
              }
            });
          });
        };
        const unwrapInvalidChildren = (schema, scope, transparentBlocks) => {
          each$e([
            ...transparentBlocks,
            ...isTransparentBlock(schema, scope) ? [scope] : []
          ], (block) => each$e(descendants(SugarElement.fromDom(block), block.nodeName.toLowerCase()), (elm) => {
            if (isTransparentInline(schema, elm.dom)) {
              unwrap(elm);
            }
          }));
        };
        const updateChildren = (schema, scope) => {
          const transparentBlocks = updateBlockStateOnChildren(schema, scope);
          splitInvalidChildren(schema, scope, transparentBlocks);
          unwrapInvalidChildren(schema, scope, transparentBlocks);
        };
        const updateElement = (schema, target) => {
          if (isTransparentElement(schema, target)) {
            const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());
            updateTransparent(blocksSelector, target);
          }
        };
        const updateCaret = (schema, root, caretParent) => {
          const isRoot2 = (el) => eq(el, SugarElement.fromDom(root));
          const parents2 = parents$1(SugarElement.fromDom(caretParent), isRoot2);
          get$b(parents2, parents2.length - 2).filter(isElement$7).fold(() => updateChildren(schema, root), (scope) => updateChildren(schema, scope.dom));
        };
        const hasBlockAttr = (el) => el.hasAttribute(transparentBlockAttr);
        const isTransparentElementName = (schema, name2) => has$2(schema.getTransparentElements(), name2);
        const isTransparentElement = (schema, node) => isElement$6(node) && isTransparentElementName(schema, node.nodeName);
        const isTransparentBlock = (schema, node) => isTransparentElement(schema, node) && hasBlockAttr(node);
        const isTransparentInline = (schema, node) => isTransparentElement(schema, node) && !hasBlockAttr(node);
        const isTransparentAstBlock = (schema, node) => node.type === 1 && isTransparentElementName(schema, node.name) && isString(node.attr(transparentBlockAttr));
        const isTransparentAstInline = (schema, node) => node.type === 1 && isTransparentElementName(schema, node.name) && isUndefined(node.attr(transparentBlockAttr));
        const browser$1 = detect$2().browser;
        const firstElement = (nodes) => find$2(nodes, isElement$7);
        const getTableCaptionDeltaY = (elm) => {
          if (browser$1.isFirefox() && name(elm) === "table") {
            return firstElement(children$1(elm)).filter((elm2) => {
              return name(elm2) === "caption";
            }).bind((caption) => {
              return firstElement(nextSiblings(caption)).map((body) => {
                const bodyTop = body.dom.offsetTop;
                const captionTop = caption.dom.offsetTop;
                const captionHeight = caption.dom.offsetHeight;
                return bodyTop <= captionTop ? -captionHeight : 0;
              });
            }).getOr(0);
          } else {
            return 0;
          }
        };
        const hasChild = (elm, child2) => elm.children && contains$2(elm.children, child2);
        const getPos = (body, elm, rootElm) => {
          let x2 = 0, y2 = 0;
          const doc = body.ownerDocument;
          rootElm = rootElm ? rootElm : body;
          if (elm) {
            if (rootElm === body && elm.getBoundingClientRect && get$7(SugarElement.fromDom(body), "position") === "static") {
              const pos = elm.getBoundingClientRect();
              x2 = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;
              y2 = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;
              return {
                x: x2,
                y: y2
              };
            }
            let offsetParent = elm;
            while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
              const castOffsetParent = offsetParent;
              x2 += castOffsetParent.offsetLeft || 0;
              y2 += castOffsetParent.offsetTop || 0;
              offsetParent = castOffsetParent.offsetParent;
            }
            offsetParent = elm.parentNode;
            while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
              x2 -= offsetParent.scrollLeft || 0;
              y2 -= offsetParent.scrollTop || 0;
              offsetParent = offsetParent.parentNode;
            }
            y2 += getTableCaptionDeltaY(SugarElement.fromDom(elm));
          }
          return {
            x: x2,
            y: y2
          };
        };
        const StyleSheetLoader = (documentOrShadowRoot, settings = {}) => {
          let idCount = 0;
          const loadedStates = {};
          const edos = SugarElement.fromDom(documentOrShadowRoot);
          const doc = documentOrOwner(edos);
          const _setReferrerPolicy = (referrerPolicy) => {
            settings.referrerPolicy = referrerPolicy;
          };
          const _setContentCssCors = (contentCssCors) => {
            settings.contentCssCors = contentCssCors;
          };
          const addStyle = (element) => {
            append$1(getStyleContainer(edos), element);
          };
          const removeStyle = (id) => {
            const styleContainer = getStyleContainer(edos);
            descendant(styleContainer, "#" + id).each(remove$5);
          };
          const getOrCreateState = (url) => get$a(loadedStates, url).getOrThunk(() => ({
            id: "mce-u" + idCount++,
            passed: [],
            failed: [],
            count: 0
          }));
          const load = (url) => new Promise((success, failure) => {
            let link;
            const urlWithSuffix = Tools._addCacheSuffix(url);
            const state = getOrCreateState(urlWithSuffix);
            loadedStates[urlWithSuffix] = state;
            state.count++;
            const resolve2 = (callbacks, status) => {
              each$e(callbacks, call);
              state.status = status;
              state.passed = [];
              state.failed = [];
              if (link) {
                link.onload = null;
                link.onerror = null;
                link = null;
              }
            };
            const passed = () => resolve2(state.passed, 2);
            const failed = () => resolve2(state.failed, 3);
            if (success) {
              state.passed.push(success);
            }
            if (failure) {
              state.failed.push(failure);
            }
            if (state.status === 1) {
              return;
            }
            if (state.status === 2) {
              passed();
              return;
            }
            if (state.status === 3) {
              failed();
              return;
            }
            state.status = 1;
            const linkElem = SugarElement.fromTag("link", doc.dom);
            setAll$1(linkElem, {
              rel: "stylesheet",
              type: "text/css",
              id: state.id
            });
            if (settings.contentCssCors) {
              set$3(linkElem, "crossOrigin", "anonymous");
            }
            if (settings.referrerPolicy) {
              set$3(linkElem, "referrerpolicy", settings.referrerPolicy);
            }
            link = linkElem.dom;
            link.onload = passed;
            link.onerror = failed;
            addStyle(linkElem);
            set$3(linkElem, "href", urlWithSuffix);
          });
          const loadAll = (urls) => {
            const loadedUrls = Promise.allSettled(map$3(urls, (url) => load(url).then(constant(url))));
            return loadedUrls.then((results) => {
              const parts = partition$2(results, (r3) => r3.status === "fulfilled");
              if (parts.fail.length > 0) {
                return Promise.reject(map$3(parts.fail, (result) => result.reason));
              } else {
                return map$3(parts.pass, (result) => result.value);
              }
            });
          };
          const unload = (url) => {
            const urlWithSuffix = Tools._addCacheSuffix(url);
            get$a(loadedStates, urlWithSuffix).each((state) => {
              const count2 = --state.count;
              if (count2 === 0) {
                delete loadedStates[urlWithSuffix];
                removeStyle(state.id);
              }
            });
          };
          const unloadAll = (urls) => {
            each$e(urls, (url) => {
              unload(url);
            });
          };
          return {
            load,
            loadAll,
            unload,
            unloadAll,
            _setReferrerPolicy,
            _setContentCssCors
          };
        };
        const create$d = () => {
          const map2 = /* @__PURE__ */ new WeakMap();
          const forElement = (referenceElement, settings) => {
            const root = getRootNode(referenceElement);
            const rootDom = root.dom;
            return Optional.from(map2.get(rootDom)).getOrThunk(() => {
              const sl = StyleSheetLoader(rootDom, settings);
              map2.set(rootDom, sl);
              return sl;
            });
          };
          return { forElement };
        };
        const instance = create$d();
        const isSpan = (node) => node.nodeName.toLowerCase() === "span";
        const isInlineContent = (node, root) => isNonNullable(node) && (isContent$1(node, root) || isInline$1(SugarElement.fromDom(node)));
        const surroundedByInlineContent = (node, root) => {
          const prev2 = new DomTreeWalker(node, root).prev(false);
          const next2 = new DomTreeWalker(node, root).next(false);
          const prevIsInline = isUndefined(prev2) || isInlineContent(prev2, root);
          const nextIsInline = isUndefined(next2) || isInlineContent(next2, root);
          return prevIsInline && nextIsInline;
        };
        const isBookmarkNode$2 = (node) => isSpan(node) && node.getAttribute("data-mce-type") === "bookmark";
        const isKeepTextNode = (node, root) => isText$a(node) && node.data.length > 0 && surroundedByInlineContent(node, root);
        const isKeepElement = (node) => isElement$6(node) ? node.childNodes.length > 0 : false;
        const isDocument = (node) => isDocumentFragment(node) || isDocument$1(node);
        const trimNode = (dom2, node, root) => {
          var _a;
          const rootNode = root || node;
          if (isElement$6(node) && isBookmarkNode$2(node)) {
            return node;
          }
          const children2 = node.childNodes;
          for (let i2 = children2.length - 1; i2 >= 0; i2--) {
            trimNode(dom2, children2[i2], rootNode);
          }
          if (isElement$6(node)) {
            const currentChildren = node.childNodes;
            if (currentChildren.length === 1 && isBookmarkNode$2(currentChildren[0])) {
              (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(currentChildren[0], node);
            }
          }
          if (!isDocument(node) && !isContent$1(node, rootNode) && !isKeepElement(node) && !isKeepTextNode(node, rootNode)) {
            dom2.remove(node);
          }
          return node;
        };
        const makeMap$3 = Tools.makeMap;
        const attrsCharsRegExp = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        const textCharsRegExp = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        const rawCharsRegExp = /[<>&\"\']/g;
        const entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;
        const asciiMap = {
          128: "\u20AC",
          130: "\u201A",
          131: "\u0192",
          132: "\u201E",
          133: "\u2026",
          134: "\u2020",
          135: "\u2021",
          136: "\u02C6",
          137: "\u2030",
          138: "\u0160",
          139: "\u2039",
          140: "\u0152",
          142: "\u017D",
          145: "\u2018",
          146: "\u2019",
          147: "\u201C",
          148: "\u201D",
          149: "\u2022",
          150: "\u2013",
          151: "\u2014",
          152: "\u02DC",
          153: "\u2122",
          154: "\u0161",
          155: "\u203A",
          156: "\u0153",
          158: "\u017E",
          159: "\u0178"
        };
        const baseEntities = {
          '"': "&quot;",
          "'": "&#39;",
          "<": "&lt;",
          ">": "&gt;",
          "&": "&amp;",
          "`": "&#96;"
        };
        const reverseEntities = {
          "&lt;": "<",
          "&gt;": ">",
          "&amp;": "&",
          "&quot;": '"',
          "&apos;": `'`
        };
        const nativeDecode = (text2) => {
          const elm = SugarElement.fromTag("div").dom;
          elm.innerHTML = text2;
          return elm.textContent || elm.innerText || text2;
        };
        const buildEntitiesLookup = (items, radix) => {
          const lookup2 = {};
          if (items) {
            const itemList = items.split(",");
            radix = radix || 10;
            for (let i2 = 0; i2 < itemList.length; i2 += 2) {
              const chr = String.fromCharCode(parseInt(itemList[i2], radix));
              if (!baseEntities[chr]) {
                const entity = "&" + itemList[i2 + 1] + ";";
                lookup2[chr] = entity;
                lookup2[entity] = chr;
              }
            }
            return lookup2;
          } else {
            return void 0;
          }
        };
        const namedEntities = buildEntitiesLookup("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32);
        const encodeRaw = (text2, attr) => text2.replace(attr ? attrsCharsRegExp : textCharsRegExp, (chr) => {
          return baseEntities[chr] || chr;
        });
        const encodeAllRaw = (text2) => ("" + text2).replace(rawCharsRegExp, (chr) => {
          return baseEntities[chr] || chr;
        });
        const encodeNumeric = (text2, attr) => text2.replace(attr ? attrsCharsRegExp : textCharsRegExp, (chr) => {
          if (chr.length > 1) {
            return "&#" + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ";";
          }
          return baseEntities[chr] || "&#" + chr.charCodeAt(0) + ";";
        });
        const encodeNamed = (text2, attr, entities) => {
          const resolveEntities = entities || namedEntities;
          return text2.replace(attr ? attrsCharsRegExp : textCharsRegExp, (chr) => {
            return baseEntities[chr] || resolveEntities[chr] || chr;
          });
        };
        const getEncodeFunc = (name2, entities) => {
          const entitiesMap = buildEntitiesLookup(entities) || namedEntities;
          const encodeNamedAndNumeric = (text2, attr) => text2.replace(attr ? attrsCharsRegExp : textCharsRegExp, (chr) => {
            if (baseEntities[chr] !== void 0) {
              return baseEntities[chr];
            }
            if (entitiesMap[chr] !== void 0) {
              return entitiesMap[chr];
            }
            if (chr.length > 1) {
              return "&#" + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ";";
            }
            return "&#" + chr.charCodeAt(0) + ";";
          });
          const encodeCustomNamed = (text2, attr) => {
            return encodeNamed(text2, attr, entitiesMap);
          };
          const nameMap = makeMap$3(name2.replace(/\+/g, ","));
          if (nameMap.named && nameMap.numeric) {
            return encodeNamedAndNumeric;
          }
          if (nameMap.named) {
            if (entities) {
              return encodeCustomNamed;
            }
            return encodeNamed;
          }
          if (nameMap.numeric) {
            return encodeNumeric;
          }
          return encodeRaw;
        };
        const decode = (text2) => text2.replace(entityRegExp, (all2, numeric) => {
          if (numeric) {
            if (numeric.charAt(0).toLowerCase() === "x") {
              numeric = parseInt(numeric.substr(1), 16);
            } else {
              numeric = parseInt(numeric, 10);
            }
            if (numeric > 65535) {
              numeric -= 65536;
              return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));
            }
            return asciiMap[numeric] || String.fromCharCode(numeric);
          }
          return reverseEntities[all2] || namedEntities[all2] || nativeDecode(all2);
        });
        const Entities = {
          encodeRaw,
          encodeAllRaw,
          encodeNumeric,
          encodeNamed,
          getEncodeFunc,
          decode
        };
        const lookupCache = {};
        const mapCache = {};
        const dummyObj = {};
        const makeMap$2 = Tools.makeMap, each$b = Tools.each, extend$2 = Tools.extend, explode$2 = Tools.explode, inArray = Tools.inArray;
        const split$1 = (items, delim) => {
          items = Tools.trim(items);
          return items ? items.split(delim || " ") : [];
        };
        const createMap = (defaultValue, extendWith = {}) => {
          const value2 = makeMap$2(defaultValue, " ", makeMap$2(defaultValue.toUpperCase(), " "));
          return extend$2(value2, extendWith);
        };
        const getTextRootBlockElements = (schema) => createMap("td th li dt dd figcaption caption details summary", schema.getTextBlockElements());
        const compileSchema = (type2) => {
          const schema = {};
          let globalAttributes, blockContent;
          let phrasingContent, flowContent;
          const add3 = (name2, attributes = "", children2 = "") => {
            const childNames = split$1(children2);
            const names = split$1(name2);
            let ni = names.length;
            while (ni--) {
              const attributesOrder = split$1([
                globalAttributes,
                attributes
              ].join(" "));
              schema[names[ni]] = {
                attributes: mapToObject(attributesOrder, () => ({})),
                attributesOrder,
                children: mapToObject(childNames, constant(dummyObj))
              };
            }
          };
          const addAttrs = (name2, attributes) => {
            const names = split$1(name2);
            const attrs = split$1(attributes);
            let ni = names.length;
            while (ni--) {
              const schemaItem = schema[names[ni]];
              for (let i2 = 0, l2 = attrs.length; i2 < l2; i2++) {
                schemaItem.attributes[attrs[i2]] = {};
                schemaItem.attributesOrder.push(attrs[i2]);
              }
            }
          };
          if (lookupCache[type2]) {
            return lookupCache[type2];
          }
          globalAttributes = "id accesskey class dir lang style tabindex title role";
          blockContent = "address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul";
          phrasingContent = "a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd label map noscript object q s samp script select small span strong sub sup textarea u var #text #comment";
          if (type2 !== "html4") {
            const transparentContent = "a ins del canvas map";
            globalAttributes += " contenteditable contextmenu draggable dropzone hidden spellcheck translate";
            blockContent += " article aside details dialog figure main header footer hgroup section nav " + transparentContent;
            phrasingContent += " audio canvas command datalist mark meter output picture progress time wbr video ruby bdi keygen";
          }
          if (type2 !== "html5-strict") {
            globalAttributes += " xml:lang";
            const html4PhrasingContent = "acronym applet basefont big font strike tt";
            phrasingContent = [
              phrasingContent,
              html4PhrasingContent
            ].join(" ");
            each$b(split$1(html4PhrasingContent), (name2) => {
              add3(name2, "", phrasingContent);
            });
            const html4BlockContent = "center dir isindex noframes";
            blockContent = [
              blockContent,
              html4BlockContent
            ].join(" ");
            flowContent = [
              blockContent,
              phrasingContent
            ].join(" ");
            each$b(split$1(html4BlockContent), (name2) => {
              add3(name2, "", flowContent);
            });
          }
          flowContent = flowContent || [
            blockContent,
            phrasingContent
          ].join(" ");
          add3("html", "manifest", "head body");
          add3("head", "", "base command link meta noscript script style title");
          add3("title hr noscript br");
          add3("base", "href target");
          add3("link", "href rel media hreflang type sizes hreflang");
          add3("meta", "name http-equiv content charset");
          add3("style", "media type scoped");
          add3("script", "src async defer type charset");
          add3("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload onmessage onoffline ononline onpagehide onpageshow onpopstate onresize onscroll onstorage onunload", flowContent);
          add3("dd div", "", flowContent);
          add3("address dt caption", "", type2 === "html4" ? phrasingContent : flowContent);
          add3("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", phrasingContent);
          add3("blockquote", "cite", flowContent);
          add3("ol", "reversed start type", "li");
          add3("ul", "", "li");
          add3("li", "value", flowContent);
          add3("dl", "", "dt dd");
          add3("a", "href target rel media hreflang type", type2 === "html4" ? phrasingContent : flowContent);
          add3("q", "cite", phrasingContent);
          add3("ins del", "cite datetime", flowContent);
          add3("img", "src sizes srcset alt usemap ismap width height");
          add3("iframe", "src name width height", flowContent);
          add3("embed", "src type width height");
          add3("object", "data type typemustmatch name usemap form width height", [
            flowContent,
            "param"
          ].join(" "));
          add3("param", "name value");
          add3("map", "name", [
            flowContent,
            "area"
          ].join(" "));
          add3("area", "alt coords shape href target rel media hreflang type");
          add3("table", "border", "caption colgroup thead tfoot tbody tr" + (type2 === "html4" ? " col" : ""));
          add3("colgroup", "span", "col");
          add3("col", "span");
          add3("tbody thead tfoot", "", "tr");
          add3("tr", "", "td th");
          add3("td", "colspan rowspan headers", flowContent);
          add3("th", "colspan rowspan headers scope abbr", flowContent);
          add3("form", "accept-charset action autocomplete enctype method name novalidate target", flowContent);
          add3("fieldset", "disabled form name", [
            flowContent,
            "legend"
          ].join(" "));
          add3("label", "form for", phrasingContent);
          add3("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate formtarget height list max maxlength min multiple name pattern readonly required size src step type value width");
          add3("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value", type2 === "html4" ? flowContent : phrasingContent);
          add3("select", "disabled form multiple name required size", "option optgroup");
          add3("optgroup", "disabled label", "option");
          add3("option", "disabled label selected value");
          add3("textarea", "cols dirname disabled form maxlength name readonly required rows wrap");
          add3("menu", "type label", [
            flowContent,
            "li"
          ].join(" "));
          add3("noscript", "", flowContent);
          if (type2 !== "html4") {
            add3("wbr");
            add3("ruby", "", [
              phrasingContent,
              "rt rp"
            ].join(" "));
            add3("figcaption", "", flowContent);
            add3("mark rt rp summary bdi", "", phrasingContent);
            add3("canvas", "width height", flowContent);
            add3("video", "src crossorigin poster preload autoplay mediagroup loop muted controls width height buffered", [
              flowContent,
              "track source"
            ].join(" "));
            add3("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", [
              flowContent,
              "track source"
            ].join(" "));
            add3("picture", "", "img source");
            add3("source", "src srcset type media sizes");
            add3("track", "kind src srclang label default");
            add3("datalist", "", [
              phrasingContent,
              "option"
            ].join(" "));
            add3("article section nav aside main header footer", "", flowContent);
            add3("hgroup", "", "h1 h2 h3 h4 h5 h6");
            add3("figure", "", [
              flowContent,
              "figcaption"
            ].join(" "));
            add3("time", "datetime", phrasingContent);
            add3("dialog", "open", flowContent);
            add3("command", "type label icon disabled checked radiogroup command");
            add3("output", "for form name", phrasingContent);
            add3("progress", "value max", phrasingContent);
            add3("meter", "value min max low high optimum", phrasingContent);
            add3("details", "open", [
              flowContent,
              "summary"
            ].join(" "));
            add3("keygen", "autofocus challenge disabled form keytype name");
          }
          if (type2 !== "html5-strict") {
            addAttrs("script", "language xml:space");
            addAttrs("style", "xml:space");
            addAttrs("object", "declare classid code codebase codetype archive standby align border hspace vspace");
            addAttrs("embed", "align name hspace vspace");
            addAttrs("param", "valuetype type");
            addAttrs("a", "charset name rev shape coords");
            addAttrs("br", "clear");
            addAttrs("applet", "codebase archive code object alt name width height align hspace vspace");
            addAttrs("img", "name longdesc align border hspace vspace");
            addAttrs("iframe", "longdesc frameborder marginwidth marginheight scrolling align");
            addAttrs("font basefont", "size color face");
            addAttrs("input", "usemap align");
            addAttrs("select");
            addAttrs("textarea");
            addAttrs("h1 h2 h3 h4 h5 h6 div p legend caption", "align");
            addAttrs("ul", "type compact");
            addAttrs("li", "type");
            addAttrs("ol dl menu dir", "compact");
            addAttrs("pre", "width xml:space");
            addAttrs("hr", "align noshade size width");
            addAttrs("isindex", "prompt");
            addAttrs("table", "summary width frame rules cellspacing cellpadding align bgcolor");
            addAttrs("col", "width align char charoff valign");
            addAttrs("colgroup", "width align char charoff valign");
            addAttrs("thead", "align char charoff valign");
            addAttrs("tr", "align char charoff valign bgcolor");
            addAttrs("th", "axis align char charoff valign nowrap bgcolor width height");
            addAttrs("form", "accept");
            addAttrs("td", "abbr axis scope align char charoff valign nowrap bgcolor width height");
            addAttrs("tfoot", "align char charoff valign");
            addAttrs("tbody", "align char charoff valign");
            addAttrs("area", "nohref");
            addAttrs("body", "background bgcolor text link vlink alink");
          }
          if (type2 !== "html4") {
            addAttrs("input button select textarea", "autofocus");
            addAttrs("input textarea", "placeholder");
            addAttrs("a", "download");
            addAttrs("link script img", "crossorigin");
            addAttrs("img", "loading");
            addAttrs("iframe", "sandbox seamless allow allowfullscreen loading");
          }
          if (type2 !== "html4") {
            each$e([
              schema.video,
              schema.audio
            ], (item) => {
              delete item.children.audio;
              delete item.children.video;
            });
          }
          each$b(split$1("a form meter progress dfn"), (name2) => {
            if (schema[name2]) {
              delete schema[name2].children[name2];
            }
          });
          delete schema.caption.children.table;
          delete schema.script;
          lookupCache[type2] = schema;
          return schema;
        };
        const compileElementMap = (value2, mode) => {
          if (value2) {
            const styles = {};
            if (isString(value2)) {
              value2 = { "*": value2 };
            }
            each$b(value2, (value3, key) => {
              styles[key] = styles[key.toUpperCase()] = mode === "map" ? makeMap$2(value3, /[, ]/) : explode$2(value3, /[, ]/);
            });
            return styles;
          } else {
            return void 0;
          }
        };
        const Schema = (settings = {}) => {
          var _a;
          const elements = {};
          const children2 = {};
          let patternElements = [];
          const customElementsMap = {};
          const specialElements = {};
          const createLookupTable = (option2, defaultValue, extendWith) => {
            const value2 = settings[option2];
            if (!value2) {
              let newValue = mapCache[option2];
              if (!newValue) {
                newValue = createMap(defaultValue, extendWith);
                mapCache[option2] = newValue;
              }
              return newValue;
            } else {
              return makeMap$2(value2, /[, ]/, makeMap$2(value2.toUpperCase(), /[, ]/));
            }
          };
          const schemaType = (_a = settings.schema) !== null && _a !== void 0 ? _a : "html5";
          const schemaItems = compileSchema(schemaType);
          if (settings.verify_html === false) {
            settings.valid_elements = "*[*]";
          }
          const validStyles = compileElementMap(settings.valid_styles);
          const invalidStyles = compileElementMap(settings.invalid_styles, "map");
          const validClasses = compileElementMap(settings.valid_classes, "map");
          const whitespaceElementsMap = createLookupTable("whitespace_elements", "pre script noscript style textarea video audio iframe object code");
          const selfClosingElementsMap = createLookupTable("self_closing_elements", "colgroup dd dt li option p td tfoot th thead tr");
          const voidElementsMap = createLookupTable("void_elements", "area base basefont br col frame hr img input isindex link meta param embed source wbr track");
          const boolAttrMap = createLookupTable("boolean_attributes", "checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls allowfullscreen");
          const nonEmptyOrMoveCaretBeforeOnEnter = "td th iframe video audio object script code";
          const nonEmptyElementsMap = createLookupTable("non_empty_elements", nonEmptyOrMoveCaretBeforeOnEnter + " pre", voidElementsMap);
          const moveCaretBeforeOnEnterElementsMap = createLookupTable("move_caret_before_on_enter_elements", nonEmptyOrMoveCaretBeforeOnEnter + " table", voidElementsMap);
          const textBlockElementsMap = createLookupTable("text_block_elements", "h1 h2 h3 h4 h5 h6 p div address pre form blockquote center dir fieldset header footer article section hgroup aside main nav figure");
          const blockElementsMap = createLookupTable("block_elements", "hr table tbody thead tfoot th tr td li ol ul caption dl dt dd noscript menu isindex option datalist select optgroup figcaption details summary", textBlockElementsMap);
          const textInlineElementsMap = createLookupTable("text_inline_elements", "span strong b em i font s strike u var cite dfn code mark q sup sub samp");
          const transparentElementsMap = createLookupTable("transparent_elements", "a ins del canvas map");
          each$b("script noscript iframe noframes noembed title style textarea xmp plaintext".split(" "), (name2) => {
            specialElements[name2] = new RegExp("</" + name2 + "[^>]*>", "gi");
          });
          const patternToRegExp = (str) => new RegExp("^" + str.replace(/([?+*])/g, ".$1") + "$");
          const addValidElements = (validElements) => {
            const elementRuleRegExp = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/;
            const attrRuleRegExp = /^([!\-])?(\w+[\\:]:\w+|[^=~<]+)?(?:([=~<])(.*))?$/;
            const hasPatternsRegExp = /[*?+]/;
            if (validElements) {
              const validElementsArr = split$1(validElements, ",");
              let globalAttributes;
              let globalAttributesOrder;
              if (elements["@"]) {
                globalAttributes = elements["@"].attributes;
                globalAttributesOrder = elements["@"].attributesOrder;
              }
              for (let ei = 0, el = validElementsArr.length; ei < el; ei++) {
                let matches = elementRuleRegExp.exec(validElementsArr[ei]);
                if (matches) {
                  const prefix = matches[1];
                  const elementName = matches[2];
                  const outputName = matches[3];
                  const attrData = matches[5];
                  const attributes = {};
                  const attributesOrder = [];
                  const element = {
                    attributes,
                    attributesOrder
                  };
                  if (prefix === "#") {
                    element.paddEmpty = true;
                  }
                  if (prefix === "-") {
                    element.removeEmpty = true;
                  }
                  if (matches[4] === "!") {
                    element.removeEmptyAttrs = true;
                  }
                  if (globalAttributes) {
                    each$d(globalAttributes, (value2, key) => {
                      attributes[key] = value2;
                    });
                    if (globalAttributesOrder) {
                      attributesOrder.push(...globalAttributesOrder);
                    }
                  }
                  if (attrData) {
                    const attrDatas = split$1(attrData, "|");
                    for (let ai = 0, al = attrDatas.length; ai < al; ai++) {
                      matches = attrRuleRegExp.exec(attrDatas[ai]);
                      if (matches) {
                        const attr = {};
                        const attrType = matches[1];
                        const attrName = matches[2].replace(/[\\:]:/g, ":");
                        const attrPrefix = matches[3];
                        const value2 = matches[4];
                        if (attrType === "!") {
                          element.attributesRequired = element.attributesRequired || [];
                          element.attributesRequired.push(attrName);
                          attr.required = true;
                        }
                        if (attrType === "-") {
                          delete attributes[attrName];
                          attributesOrder.splice(inArray(attributesOrder, attrName), 1);
                          continue;
                        }
                        if (attrPrefix) {
                          if (attrPrefix === "=") {
                            element.attributesDefault = element.attributesDefault || [];
                            element.attributesDefault.push({
                              name: attrName,
                              value: value2
                            });
                            attr.defaultValue = value2;
                          }
                          if (attrPrefix === "~") {
                            element.attributesForced = element.attributesForced || [];
                            element.attributesForced.push({
                              name: attrName,
                              value: value2
                            });
                            attr.forcedValue = value2;
                          }
                          if (attrPrefix === "<") {
                            attr.validValues = makeMap$2(value2, "?");
                          }
                        }
                        if (hasPatternsRegExp.test(attrName)) {
                          const attrPattern = attr;
                          element.attributePatterns = element.attributePatterns || [];
                          attrPattern.pattern = patternToRegExp(attrName);
                          element.attributePatterns.push(attrPattern);
                        } else {
                          if (!attributes[attrName]) {
                            attributesOrder.push(attrName);
                          }
                          attributes[attrName] = attr;
                        }
                      }
                    }
                  }
                  if (!globalAttributes && elementName === "@") {
                    globalAttributes = attributes;
                    globalAttributesOrder = attributesOrder;
                  }
                  if (outputName) {
                    element.outputName = elementName;
                    elements[outputName] = element;
                  }
                  if (hasPatternsRegExp.test(elementName)) {
                    const patternElement = element;
                    patternElement.pattern = patternToRegExp(elementName);
                    patternElements.push(patternElement);
                  } else {
                    elements[elementName] = element;
                  }
                }
              }
            }
          };
          const setValidElements = (validElements) => {
            patternElements = [];
            each$e(keys(elements), (name2) => {
              delete elements[name2];
            });
            addValidElements(validElements);
            each$b(schemaItems, (element, name2) => {
              children2[name2] = element.children;
            });
          };
          const addCustomElements = (customElements2) => {
            const customElementRegExp = /^(~)?(.+)$/;
            if (customElements2) {
              delete mapCache.text_block_elements;
              delete mapCache.block_elements;
              each$b(split$1(customElements2, ","), (rule) => {
                const matches = customElementRegExp.exec(rule);
                if (matches) {
                  const inline = matches[1] === "~";
                  const cloneName = inline ? "span" : "div";
                  const name2 = matches[2];
                  children2[name2] = children2[cloneName];
                  customElementsMap[name2] = cloneName;
                  nonEmptyElementsMap[name2.toUpperCase()] = {};
                  nonEmptyElementsMap[name2] = {};
                  if (!inline) {
                    blockElementsMap[name2.toUpperCase()] = {};
                    blockElementsMap[name2] = {};
                  }
                  if (!elements[name2]) {
                    let customRule = elements[cloneName];
                    customRule = extend$2({}, customRule);
                    delete customRule.removeEmptyAttrs;
                    delete customRule.removeEmpty;
                    elements[name2] = customRule;
                  }
                  each$b(children2, (element, elmName) => {
                    if (element[cloneName]) {
                      children2[elmName] = element = extend$2({}, children2[elmName]);
                      element[name2] = element[cloneName];
                    }
                  });
                }
              });
            }
          };
          const addValidChildren = (validChildren) => {
            const childRuleRegExp = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
            delete lookupCache[schemaType];
            if (validChildren) {
              each$b(split$1(validChildren, ","), (rule) => {
                const matches = childRuleRegExp.exec(rule);
                if (matches) {
                  const prefix = matches[1];
                  let parent2;
                  if (prefix) {
                    parent2 = children2[matches[2]];
                  } else {
                    parent2 = children2[matches[2]] = { "#comment": {} };
                  }
                  parent2 = children2[matches[2]];
                  each$b(split$1(matches[3], "|"), (child2) => {
                    if (prefix === "-") {
                      delete parent2[child2];
                    } else {
                      parent2[child2] = {};
                    }
                  });
                }
              });
            }
          };
          const getElementRule = (name2) => {
            const element = elements[name2];
            if (element) {
              return element;
            }
            let i2 = patternElements.length;
            while (i2--) {
              const patternElement = patternElements[i2];
              if (patternElement.pattern.test(name2)) {
                return patternElement;
              }
            }
            return void 0;
          };
          if (!settings.valid_elements) {
            each$b(schemaItems, (element, name2) => {
              elements[name2] = {
                attributes: element.attributes,
                attributesOrder: element.attributesOrder
              };
              children2[name2] = element.children;
            });
            each$b(split$1("strong/b em/i"), (item) => {
              const items = split$1(item, "/");
              elements[items[1]].outputName = items[0];
            });
            each$b(textInlineElementsMap, (_val, name2) => {
              if (elements[name2]) {
                if (settings.padd_empty_block_inline_children) {
                  elements[name2].paddInEmptyBlock = true;
                }
                elements[name2].removeEmpty = true;
              }
            });
            each$b(split$1("ol ul blockquote a table tbody"), (name2) => {
              if (elements[name2]) {
                elements[name2].removeEmpty = true;
              }
            });
            each$b(split$1("p h1 h2 h3 h4 h5 h6 th td pre div address caption li summary"), (name2) => {
              if (elements[name2]) {
                elements[name2].paddEmpty = true;
              }
            });
            each$b(split$1("span"), (name2) => {
              elements[name2].removeEmptyAttrs = true;
            });
          } else {
            setValidElements(settings.valid_elements);
          }
          addCustomElements(settings.custom_elements);
          addValidChildren(settings.valid_children);
          addValidElements(settings.extended_valid_elements);
          addValidChildren("+ol[ul|ol],+ul[ul|ol]");
          each$b({
            dd: "dl",
            dt: "dl",
            li: "ul ol",
            td: "tr",
            th: "tr",
            tr: "tbody thead tfoot",
            tbody: "table",
            thead: "table",
            tfoot: "table",
            legend: "fieldset",
            area: "map",
            param: "video audio object"
          }, (parents2, item) => {
            if (elements[item]) {
              elements[item].parentsRequired = split$1(parents2);
            }
          });
          if (settings.invalid_elements) {
            each$b(explode$2(settings.invalid_elements), (item) => {
              if (elements[item]) {
                delete elements[item];
              }
            });
          }
          if (!getElementRule("span")) {
            addValidElements("span[!data-mce-type|*]");
          }
          const getValidStyles = constant(validStyles);
          const getInvalidStyles = constant(invalidStyles);
          const getValidClasses = constant(validClasses);
          const getBoolAttrs = constant(boolAttrMap);
          const getBlockElements = constant(blockElementsMap);
          const getTextBlockElements = constant(textBlockElementsMap);
          const getTextInlineElements = constant(textInlineElementsMap);
          const getVoidElements = constant(Object.seal(voidElementsMap));
          const getSelfClosingElements = constant(selfClosingElementsMap);
          const getNonEmptyElements = constant(nonEmptyElementsMap);
          const getMoveCaretBeforeOnEnterElements = constant(moveCaretBeforeOnEnterElementsMap);
          const getWhitespaceElements = constant(whitespaceElementsMap);
          const getTransparentElements = constant(transparentElementsMap);
          const getSpecialElements = constant(Object.seal(specialElements));
          const isValidChild = (name2, child2) => {
            const parent2 = children2[name2.toLowerCase()];
            return !!(parent2 && parent2[child2.toLowerCase()]);
          };
          const isValid2 = (name2, attr) => {
            const rule = getElementRule(name2);
            if (rule) {
              if (attr) {
                if (rule.attributes[attr]) {
                  return true;
                }
                const attrPatterns = rule.attributePatterns;
                if (attrPatterns) {
                  let i2 = attrPatterns.length;
                  while (i2--) {
                    if (attrPatterns[i2].pattern.test(attr)) {
                      return true;
                    }
                  }
                }
              } else {
                return true;
              }
            }
            return false;
          };
          const getCustomElements = constant(customElementsMap);
          return {
            type: schemaType,
            children: children2,
            elements,
            getValidStyles,
            getValidClasses,
            getBlockElements,
            getInvalidStyles,
            getVoidElements,
            getTextBlockElements,
            getTextInlineElements,
            getBoolAttrs,
            getElementRule,
            getSelfClosingElements,
            getNonEmptyElements,
            getMoveCaretBeforeOnEnterElements,
            getWhitespaceElements,
            getTransparentElements,
            getSpecialElements,
            isValidChild,
            isValid: isValid2,
            getCustomElements,
            addValidElements,
            setValidElements,
            addCustomElements,
            addValidChildren
          };
        };
        const Styles = (settings = {}, schema) => {
          const urlOrStrRegExp = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi;
          const styleRegExp = /\s*([^:]+):\s*([^;]+);?/g;
          const trimRightRegExp = /\s+$/;
          const encodingLookup = {};
          let validStyles;
          let invalidStyles;
          const invisibleChar = zeroWidth;
          if (schema) {
            validStyles = schema.getValidStyles();
            invalidStyles = schema.getInvalidStyles();
          }
          const encodingItems = (`\\" \\' \\; \\: ; : ` + invisibleChar).split(" ");
          for (let i2 = 0; i2 < encodingItems.length; i2++) {
            encodingLookup[encodingItems[i2]] = invisibleChar + i2;
            encodingLookup[invisibleChar + i2] = encodingItems[i2];
          }
          const self2 = {
            parse: (css) => {
              const styles = {};
              let isEncoded = false;
              const urlConverter = settings.url_converter;
              const urlConverterScope = settings.url_converter_scope || self2;
              const compress = (prefix, suffix, noJoin) => {
                const top2 = styles[prefix + "-top" + suffix];
                if (!top2) {
                  return;
                }
                const right2 = styles[prefix + "-right" + suffix];
                if (!right2) {
                  return;
                }
                const bottom2 = styles[prefix + "-bottom" + suffix];
                if (!bottom2) {
                  return;
                }
                const left2 = styles[prefix + "-left" + suffix];
                if (!left2) {
                  return;
                }
                const box = [
                  top2,
                  right2,
                  bottom2,
                  left2
                ];
                let i2 = box.length - 1;
                while (i2--) {
                  if (box[i2] !== box[i2 + 1]) {
                    break;
                  }
                }
                if (i2 > -1 && noJoin) {
                  return;
                }
                styles[prefix + suffix] = i2 === -1 ? box[0] : box.join(" ");
                delete styles[prefix + "-top" + suffix];
                delete styles[prefix + "-right" + suffix];
                delete styles[prefix + "-bottom" + suffix];
                delete styles[prefix + "-left" + suffix];
              };
              const canCompress = (key) => {
                const value2 = styles[key];
                if (!value2) {
                  return;
                }
                const values2 = value2.split(" ");
                let i2 = values2.length;
                while (i2--) {
                  if (values2[i2] !== values2[0]) {
                    return false;
                  }
                }
                styles[key] = values2[0];
                return true;
              };
              const compress2 = (target, a2, b2, c2) => {
                if (!canCompress(a2)) {
                  return;
                }
                if (!canCompress(b2)) {
                  return;
                }
                if (!canCompress(c2)) {
                  return;
                }
                styles[target] = styles[a2] + " " + styles[b2] + " " + styles[c2];
                delete styles[a2];
                delete styles[b2];
                delete styles[c2];
              };
              const encode = (str) => {
                isEncoded = true;
                return encodingLookup[str];
              };
              const decode2 = (str, keepSlashes) => {
                if (isEncoded) {
                  str = str.replace(/\uFEFF[0-9]/g, (str2) => {
                    return encodingLookup[str2];
                  });
                }
                if (!keepSlashes) {
                  str = str.replace(/\\([\'\";:])/g, "$1");
                }
                return str;
              };
              const decodeSingleHexSequence = (escSeq) => {
                return String.fromCharCode(parseInt(escSeq.slice(1), 16));
              };
              const decodeHexSequences = (value2) => {
                return value2.replace(/\\[0-9a-f]+/gi, decodeSingleHexSequence);
              };
              const processUrl = (match2, url, url2, url3, str, str2) => {
                str = str || str2;
                if (str) {
                  str = decode2(str);
                  return `'` + str.replace(/\'/g, `\\'`) + `'`;
                }
                url = decode2(url || url2 || url3 || "");
                if (!settings.allow_script_urls) {
                  const scriptUrl = url.replace(/[\s\r\n]+/g, "");
                  if (/(java|vb)script:/i.test(scriptUrl)) {
                    return "";
                  }
                  if (!settings.allow_svg_data_urls && /^data:image\/svg/i.test(scriptUrl)) {
                    return "";
                  }
                }
                if (urlConverter) {
                  url = urlConverter.call(urlConverterScope, url, "style");
                }
                return `url('` + url.replace(/\'/g, `\\'`) + `')`;
              };
              if (css) {
                css = css.replace(/[\u0000-\u001F]/g, "");
                css = css.replace(/\\[\"\';:\uFEFF]/g, encode).replace(/\"[^\"]+\"|\'[^\']+\'/g, (str) => {
                  return str.replace(/[;:]/g, encode);
                });
                let matches;
                while (matches = styleRegExp.exec(css)) {
                  styleRegExp.lastIndex = matches.index + matches[0].length;
                  let name2 = matches[1].replace(trimRightRegExp, "").toLowerCase();
                  let value2 = matches[2].replace(trimRightRegExp, "");
                  if (name2 && value2) {
                    name2 = decodeHexSequences(name2);
                    value2 = decodeHexSequences(value2);
                    if (name2.indexOf(invisibleChar) !== -1 || name2.indexOf('"') !== -1) {
                      continue;
                    }
                    if (!settings.allow_script_urls && (name2 === "behavior" || /expression\s*\(|\/\*|\*\//.test(value2))) {
                      continue;
                    }
                    if (name2 === "font-weight" && value2 === "700") {
                      value2 = "bold";
                    } else if (name2 === "color" || name2 === "background-color") {
                      value2 = value2.toLowerCase();
                    }
                    value2 = value2.replace(urlOrStrRegExp, processUrl);
                    styles[name2] = isEncoded ? decode2(value2, true) : value2;
                  }
                }
                compress("border", "", true);
                compress("border", "-width");
                compress("border", "-color");
                compress("border", "-style");
                compress("padding", "");
                compress("margin", "");
                compress2("border", "border-width", "border-style", "border-color");
                if (styles.border === "medium none") {
                  delete styles.border;
                }
                if (styles["border-image"] === "none") {
                  delete styles["border-image"];
                }
              }
              return styles;
            },
            serialize: (styles, elementName) => {
              let css = "";
              const serializeStyles = (elemName, validStyleList) => {
                const styleList = validStyleList[elemName];
                if (styleList) {
                  for (let i2 = 0, l2 = styleList.length; i2 < l2; i2++) {
                    const name2 = styleList[i2];
                    const value2 = styles[name2];
                    if (value2) {
                      css += (css.length > 0 ? " " : "") + name2 + ": " + value2 + ";";
                    }
                  }
                }
              };
              const isValid2 = (name2, elemName) => {
                if (!invalidStyles || !elemName) {
                  return true;
                }
                let styleMap = invalidStyles["*"];
                if (styleMap && styleMap[name2]) {
                  return false;
                }
                styleMap = invalidStyles[elemName];
                return !(styleMap && styleMap[name2]);
              };
              if (elementName && validStyles) {
                serializeStyles("*", validStyles);
                serializeStyles(elementName, validStyles);
              } else {
                each$d(styles, (value2, name2) => {
                  if (value2 && isValid2(name2, elementName)) {
                    css += (css.length > 0 ? " " : "") + name2 + ": " + value2 + ";";
                  }
                });
              }
              return css;
            }
          };
          return self2;
        };
        const deprecated = {
          keyLocation: true,
          layerX: true,
          layerY: true,
          returnValue: true,
          webkitMovementX: true,
          webkitMovementY: true,
          keyIdentifier: true,
          mozPressure: true
        };
        const isNativeEvent = (event) => event instanceof Event || isFunction(event.initEvent);
        const hasIsDefaultPrevented = (event) => event.isDefaultPrevented === always || event.isDefaultPrevented === never;
        const needsNormalizing = (event) => isNullable(event.preventDefault) || isNativeEvent(event);
        const clone$3 = (originalEvent, data2) => {
          const event = data2 !== null && data2 !== void 0 ? data2 : {};
          for (const name2 in originalEvent) {
            if (!has$2(deprecated, name2)) {
              event[name2] = originalEvent[name2];
            }
          }
          if (isNonNullable(originalEvent.composedPath)) {
            event.composedPath = () => originalEvent.composedPath();
          }
          return event;
        };
        const normalize$3 = (type2, originalEvent, fallbackTarget, data2) => {
          var _a;
          const event = clone$3(originalEvent, data2);
          event.type = type2;
          if (isNullable(event.target)) {
            event.target = (_a = event.srcElement) !== null && _a !== void 0 ? _a : fallbackTarget;
          }
          if (needsNormalizing(originalEvent)) {
            event.preventDefault = () => {
              event.defaultPrevented = true;
              event.isDefaultPrevented = always;
              if (isFunction(originalEvent.preventDefault)) {
                originalEvent.preventDefault();
              }
            };
            event.stopPropagation = () => {
              event.cancelBubble = true;
              event.isPropagationStopped = always;
              if (isFunction(originalEvent.stopPropagation)) {
                originalEvent.stopPropagation();
              }
            };
            event.stopImmediatePropagation = () => {
              event.isImmediatePropagationStopped = always;
              event.stopPropagation();
            };
            if (!hasIsDefaultPrevented(event)) {
              event.isDefaultPrevented = event.defaultPrevented === true ? always : never;
              event.isPropagationStopped = event.cancelBubble === true ? always : never;
              event.isImmediatePropagationStopped = never;
            }
          }
          return event;
        };
        const eventExpandoPrefix = "mce-data-";
        const mouseEventRe = /^(?:mouse|contextmenu)|click/;
        const addEvent = (target, name2, callback, capture) => {
          target.addEventListener(name2, callback, capture || false);
        };
        const removeEvent = (target, name2, callback, capture) => {
          target.removeEventListener(name2, callback, capture || false);
        };
        const isMouseEvent = (event) => isNonNullable(event) && mouseEventRe.test(event.type);
        const fix = (originalEvent, data2) => {
          const event = normalize$3(originalEvent.type, originalEvent, document, data2);
          if (isMouseEvent(originalEvent) && isUndefined(originalEvent.pageX) && !isUndefined(originalEvent.clientX)) {
            const eventDoc = event.target.ownerDocument || document;
            const doc = eventDoc.documentElement;
            const body = eventDoc.body;
            const mouseEvent = event;
            mouseEvent.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
            mouseEvent.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
          }
          return event;
        };
        const bindOnReady = (win, callback, eventUtils) => {
          const doc = win.document, event = { type: "ready" };
          if (eventUtils.domLoaded) {
            callback(event);
            return;
          }
          const isDocReady = () => {
            return doc.readyState === "complete" || doc.readyState === "interactive" && doc.body;
          };
          const readyHandler = () => {
            removeEvent(win, "DOMContentLoaded", readyHandler);
            removeEvent(win, "load", readyHandler);
            if (!eventUtils.domLoaded) {
              eventUtils.domLoaded = true;
              callback(event);
            }
            win = null;
          };
          if (isDocReady()) {
            readyHandler();
          } else {
            addEvent(win, "DOMContentLoaded", readyHandler);
          }
          if (!eventUtils.domLoaded) {
            addEvent(win, "load", readyHandler);
          }
        };
        class EventUtils {
          constructor() {
            this.domLoaded = false;
            this.events = {};
            this.count = 1;
            this.expando = eventExpandoPrefix + (+/* @__PURE__ */ new Date()).toString(32);
            this.hasFocusIn = "onfocusin" in document.documentElement;
            this.count = 1;
          }
          bind(target, names, callback, scope) {
            const self2 = this;
            let callbackList;
            const win = window;
            const defaultNativeHandler = (evt) => {
              self2.executeHandlers(fix(evt || win.event), id);
            };
            if (!target || isText$a(target) || isComment(target)) {
              return callback;
            }
            let id;
            if (!target[self2.expando]) {
              id = self2.count++;
              target[self2.expando] = id;
              self2.events[id] = {};
            } else {
              id = target[self2.expando];
            }
            scope = scope || target;
            const namesList = names.split(" ");
            let i2 = namesList.length;
            while (i2--) {
              let name2 = namesList[i2];
              let nativeHandler = defaultNativeHandler;
              let capture = false;
              let fakeName = false;
              if (name2 === "DOMContentLoaded") {
                name2 = "ready";
              }
              if (self2.domLoaded && name2 === "ready" && target.readyState === "complete") {
                callback.call(scope, fix({ type: name2 }));
                continue;
              }
              if (!self2.hasFocusIn && (name2 === "focusin" || name2 === "focusout")) {
                capture = true;
                fakeName = name2 === "focusin" ? "focus" : "blur";
                nativeHandler = (evt) => {
                  const event = fix(evt || win.event);
                  event.type = event.type === "focus" ? "focusin" : "focusout";
                  self2.executeHandlers(event, id);
                };
              }
              callbackList = self2.events[id][name2];
              if (!callbackList) {
                self2.events[id][name2] = callbackList = [{
                  func: callback,
                  scope
                }];
                callbackList.fakeName = fakeName;
                callbackList.capture = capture;
                callbackList.nativeHandler = nativeHandler;
                if (name2 === "ready") {
                  bindOnReady(target, nativeHandler, self2);
                } else {
                  addEvent(target, fakeName || name2, nativeHandler, capture);
                }
              } else {
                if (name2 === "ready" && self2.domLoaded) {
                  callback(fix({ type: name2 }));
                } else {
                  callbackList.push({
                    func: callback,
                    scope
                  });
                }
              }
            }
            target = callbackList = null;
            return callback;
          }
          unbind(target, names, callback) {
            if (!target || isText$a(target) || isComment(target)) {
              return this;
            }
            const id = target[this.expando];
            if (id) {
              let eventMap = this.events[id];
              if (names) {
                const namesList = names.split(" ");
                let i2 = namesList.length;
                while (i2--) {
                  const name2 = namesList[i2];
                  const callbackList = eventMap[name2];
                  if (callbackList) {
                    if (callback) {
                      let ci = callbackList.length;
                      while (ci--) {
                        if (callbackList[ci].func === callback) {
                          const nativeHandler = callbackList.nativeHandler;
                          const fakeName = callbackList.fakeName, capture = callbackList.capture;
                          const newCallbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));
                          newCallbackList.nativeHandler = nativeHandler;
                          newCallbackList.fakeName = fakeName;
                          newCallbackList.capture = capture;
                          eventMap[name2] = newCallbackList;
                        }
                      }
                    }
                    if (!callback || callbackList.length === 0) {
                      delete eventMap[name2];
                      removeEvent(target, callbackList.fakeName || name2, callbackList.nativeHandler, callbackList.capture);
                    }
                  }
                }
              } else {
                each$d(eventMap, (callbackList, name2) => {
                  removeEvent(target, callbackList.fakeName || name2, callbackList.nativeHandler, callbackList.capture);
                });
                eventMap = {};
              }
              for (const name2 in eventMap) {
                if (has$2(eventMap, name2)) {
                  return this;
                }
              }
              delete this.events[id];
              try {
                delete target[this.expando];
              } catch (ex) {
                target[this.expando] = null;
              }
            }
            return this;
          }
          fire(target, name2, args) {
            return this.dispatch(target, name2, args);
          }
          dispatch(target, name2, args) {
            if (!target || isText$a(target) || isComment(target)) {
              return this;
            }
            const event = fix({
              type: name2,
              target
            }, args);
            do {
              const id = target[this.expando];
              if (id) {
                this.executeHandlers(event, id);
              }
              target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;
            } while (target && !event.isPropagationStopped());
            return this;
          }
          clean(target) {
            if (!target || isText$a(target) || isComment(target)) {
              return this;
            }
            if (target[this.expando]) {
              this.unbind(target);
            }
            if (!target.getElementsByTagName) {
              target = target.document;
            }
            if (target && target.getElementsByTagName) {
              this.unbind(target);
              const children2 = target.getElementsByTagName("*");
              let i2 = children2.length;
              while (i2--) {
                target = children2[i2];
                if (target[this.expando]) {
                  this.unbind(target);
                }
              }
            }
            return this;
          }
          destroy() {
            this.events = {};
          }
          cancel(e2) {
            if (e2) {
              e2.preventDefault();
              e2.stopImmediatePropagation();
            }
            return false;
          }
          executeHandlers(evt, id) {
            const container = this.events[id];
            const callbackList = container && container[evt.type];
            if (callbackList) {
              for (let i2 = 0, l2 = callbackList.length; i2 < l2; i2++) {
                const callback = callbackList[i2];
                if (callback && callback.func.call(callback.scope, evt) === false) {
                  evt.preventDefault();
                }
                if (evt.isImmediatePropagationStopped()) {
                  return;
                }
              }
            }
          }
        }
        EventUtils.Event = new EventUtils();
        const each$a = Tools.each;
        const grep = Tools.grep;
        const internalStyleName = "data-mce-style";
        const numericalCssMap = Tools.makeMap("fill-opacity font-weight line-height opacity orphans widows z-index zoom", " ");
        const legacySetAttribute = (elm, name2, value2) => {
          if (isNullable(value2) || value2 === "") {
            remove$a(elm, name2);
          } else {
            set$3(elm, name2, value2);
          }
        };
        const camelCaseToHyphens = (name2) => name2.replace(/[A-Z]/g, (v2) => "-" + v2.toLowerCase());
        const findNodeIndex = (node, normalized) => {
          let idx = 0;
          if (node) {
            for (let lastNodeType = node.nodeType, tempNode = node.previousSibling; tempNode; tempNode = tempNode.previousSibling) {
              const nodeType = tempNode.nodeType;
              if (normalized && isText$a(tempNode)) {
                if (nodeType === lastNodeType || !tempNode.data.length) {
                  continue;
                }
              }
              idx++;
              lastNodeType = nodeType;
            }
          }
          return idx;
        };
        const updateInternalStyleAttr = (styles, elm) => {
          const rawValue = get$9(elm, "style");
          const value2 = styles.serialize(styles.parse(rawValue), name(elm));
          legacySetAttribute(elm, internalStyleName, value2);
        };
        const convertStyleToString = (cssValue, cssName) => {
          if (isNumber(cssValue)) {
            return has$2(numericalCssMap, cssName) ? cssValue + "" : cssValue + "px";
          } else {
            return cssValue;
          }
        };
        const applyStyle$1 = ($elm, cssName, cssValue) => {
          const normalizedName = camelCaseToHyphens(cssName);
          if (isNullable(cssValue) || cssValue === "") {
            remove$6($elm, normalizedName);
          } else {
            set$2($elm, normalizedName, convertStyleToString(cssValue, normalizedName));
          }
        };
        const setupAttrHooks = (styles, settings, getContext2) => {
          const keepValues = settings.keep_values;
          const keepUrlHook = {
            set: (elm, value2, name2) => {
              const sugarElm = SugarElement.fromDom(elm);
              if (isFunction(settings.url_converter) && isNonNullable(value2)) {
                value2 = settings.url_converter.call(settings.url_converter_scope || getContext2(), String(value2), name2, elm);
              }
              const internalName = "data-mce-" + name2;
              legacySetAttribute(sugarElm, internalName, value2);
              legacySetAttribute(sugarElm, name2, value2);
            },
            get: (elm, name2) => {
              const sugarElm = SugarElement.fromDom(elm);
              return get$9(sugarElm, "data-mce-" + name2) || get$9(sugarElm, name2);
            }
          };
          const attrHooks = {
            style: {
              set: (elm, value2) => {
                const sugarElm = SugarElement.fromDom(elm);
                if (keepValues) {
                  legacySetAttribute(sugarElm, internalStyleName, value2);
                }
                remove$a(sugarElm, "style");
                if (isString(value2)) {
                  setAll(sugarElm, styles.parse(value2));
                }
              },
              get: (elm) => {
                const sugarElm = SugarElement.fromDom(elm);
                const value2 = get$9(sugarElm, internalStyleName) || get$9(sugarElm, "style");
                return styles.serialize(styles.parse(value2), name(sugarElm));
              }
            }
          };
          if (keepValues) {
            attrHooks.href = attrHooks.src = keepUrlHook;
          }
          return attrHooks;
        };
        const DOMUtils = (doc, settings = {}) => {
          const addedStyles = {};
          const win = window;
          const files = {};
          let counter = 0;
          const stdMode = true;
          const boxModel = true;
          const styleSheetLoader = instance.forElement(SugarElement.fromDom(doc), {
            contentCssCors: settings.contentCssCors,
            referrerPolicy: settings.referrerPolicy
          });
          const boundEvents = [];
          const schema = settings.schema ? settings.schema : Schema({});
          const styles = Styles({
            url_converter: settings.url_converter,
            url_converter_scope: settings.url_converter_scope
          }, settings.schema);
          const events = settings.ownEvents ? new EventUtils() : EventUtils.Event;
          const blockElementsMap = schema.getBlockElements();
          const isBlock2 = (node) => {
            if (isString(node)) {
              return has$2(blockElementsMap, node);
            } else {
              return isElement$6(node) && (has$2(blockElementsMap, node.nodeName) || isTransparentBlock(schema, node));
            }
          };
          const get2 = (elm) => elm && doc && isString(elm) ? doc.getElementById(elm) : elm;
          const _get = (elm) => {
            const value2 = get2(elm);
            return isNonNullable(value2) ? SugarElement.fromDom(value2) : null;
          };
          const getAttrib = (elm, name2, defaultVal = "") => {
            let value2;
            const $elm = _get(elm);
            if (isNonNullable($elm) && isElement$7($elm)) {
              const hook = attrHooks[name2];
              if (hook && hook.get) {
                value2 = hook.get($elm.dom, name2);
              } else {
                value2 = get$9($elm, name2);
              }
            }
            return isNonNullable(value2) ? value2 : defaultVal;
          };
          const getAttribs = (elm) => {
            const node = get2(elm);
            return isNullable(node) ? [] : node.attributes;
          };
          const setAttrib = (elm, name2, value2) => {
            run(elm, (e2) => {
              if (isElement$6(e2)) {
                const $elm = SugarElement.fromDom(e2);
                const val = value2 === "" ? null : value2;
                const originalValue = get$9($elm, name2);
                const hook = attrHooks[name2];
                if (hook && hook.set) {
                  hook.set($elm.dom, val, name2);
                } else {
                  legacySetAttribute($elm, name2, val);
                }
                if (originalValue !== val && settings.onSetAttrib) {
                  settings.onSetAttrib({
                    attrElm: $elm.dom,
                    attrName: name2,
                    attrValue: val
                  });
                }
              }
            });
          };
          const clone2 = (node, deep2) => {
            return node.cloneNode(deep2);
          };
          const getRoot = () => settings.root_element || doc.body;
          const getViewPort = (argWin) => {
            const vp = getBounds(argWin);
            return {
              x: vp.x,
              y: vp.y,
              w: vp.width,
              h: vp.height
            };
          };
          const getPos$1 = (elm, rootElm) => getPos(doc.body, get2(elm), rootElm);
          const setStyle = (elm, name2, value2) => {
            run(elm, (e2) => {
              const $elm = SugarElement.fromDom(e2);
              applyStyle$1($elm, name2, value2);
              if (settings.update_styles) {
                updateInternalStyleAttr(styles, $elm);
              }
            });
          };
          const setStyles = (elm, stylesArg) => {
            run(elm, (e2) => {
              const $elm = SugarElement.fromDom(e2);
              each$d(stylesArg, (v2, n2) => {
                applyStyle$1($elm, n2, v2);
              });
              if (settings.update_styles) {
                updateInternalStyleAttr(styles, $elm);
              }
            });
          };
          const getStyle2 = (elm, name2, computed) => {
            const $elm = get2(elm);
            if (isNullable($elm) || !isElement$6($elm)) {
              return void 0;
            }
            if (computed) {
              return get$7(SugarElement.fromDom($elm), camelCaseToHyphens(name2));
            } else {
              name2 = name2.replace(/-(\D)/g, (a2, b2) => b2.toUpperCase());
              if (name2 === "float") {
                name2 = "cssFloat";
              }
              return $elm.style ? $elm.style[name2] : void 0;
            }
          };
          const getSize = (elm) => {
            const $elm = get2(elm);
            if (!$elm) {
              return {
                w: 0,
                h: 0
              };
            }
            let w2 = getStyle2($elm, "width");
            let h2 = getStyle2($elm, "height");
            if (!w2 || w2.indexOf("px") === -1) {
              w2 = "0";
            }
            if (!h2 || h2.indexOf("px") === -1) {
              h2 = "0";
            }
            return {
              w: parseInt(w2, 10) || $elm.offsetWidth || $elm.clientWidth,
              h: parseInt(h2, 10) || $elm.offsetHeight || $elm.clientHeight
            };
          };
          const getRect = (elm) => {
            const $elm = get2(elm);
            const pos = getPos$1($elm);
            const size = getSize($elm);
            return {
              x: pos.x,
              y: pos.y,
              w: size.w,
              h: size.h
            };
          };
          const is2 = (elm, selector) => {
            if (!elm) {
              return false;
            }
            const elms = isArray$1(elm) ? elm : [elm];
            return exists(elms, (e2) => {
              return is$1(SugarElement.fromDom(e2), selector);
            });
          };
          const getParents2 = (elm, selector, root, collect) => {
            const result = [];
            let node = get2(elm);
            collect = collect === void 0;
            const resolvedRoot = root || (getRoot().nodeName !== "BODY" ? getRoot().parentNode : null);
            if (isString(selector)) {
              if (selector === "*") {
                selector = isElement$6;
              } else {
                const selectorVal = selector;
                selector = (node2) => is2(node2, selectorVal);
              }
            }
            while (node) {
              if (node === resolvedRoot || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment(node)) {
                break;
              }
              if (!selector || selector(node)) {
                if (collect) {
                  result.push(node);
                } else {
                  return [node];
                }
              }
              node = node.parentNode;
            }
            return collect ? result : null;
          };
          const getParent = (node, selector, root) => {
            const parents2 = getParents2(node, selector, root, false);
            return parents2 && parents2.length > 0 ? parents2[0] : null;
          };
          const _findSib = (node, selector, name2) => {
            let func = selector;
            if (node) {
              if (isString(selector)) {
                func = (node2) => {
                  return is2(node2, selector);
                };
              }
              for (let tempNode = node[name2]; tempNode; tempNode = tempNode[name2]) {
                if (isFunction(func) && func(tempNode)) {
                  return tempNode;
                }
              }
            }
            return null;
          };
          const getNext = (node, selector) => _findSib(node, selector, "nextSibling");
          const getPrev = (node, selector) => _findSib(node, selector, "previousSibling");
          const isParentNode = (node) => isFunction(node.querySelectorAll);
          const select2 = (selector, scope) => {
            var _a, _b;
            const elm = (_b = (_a = get2(scope)) !== null && _a !== void 0 ? _a : settings.root_element) !== null && _b !== void 0 ? _b : doc;
            return isParentNode(elm) ? from(elm.querySelectorAll(selector)) : [];
          };
          const run = function(elm, func, scope) {
            const context2 = scope !== null && scope !== void 0 ? scope : this;
            if (isArray$1(elm)) {
              const result = [];
              each$a(elm, (e2, i2) => {
                const node = get2(e2);
                if (node) {
                  result.push(func.call(context2, node, i2));
                }
              });
              return result;
            } else {
              const node = get2(elm);
              return !node ? false : func.call(context2, node);
            }
          };
          const setAttribs = (elm, attrs) => {
            run(elm, ($elm) => {
              each$d(attrs, (value2, name2) => {
                setAttrib($elm, name2, value2);
              });
            });
          };
          const setHTML = (elm, html2) => {
            run(elm, (e2) => {
              const $elm = SugarElement.fromDom(e2);
              set$1($elm, html2);
            });
          };
          const add3 = (parentElm, name2, attrs, html2, create3) => run(parentElm, (parentElm2) => {
            const newElm = isString(name2) ? doc.createElement(name2) : name2;
            if (isNonNullable(attrs)) {
              setAttribs(newElm, attrs);
            }
            if (html2) {
              if (!isString(html2) && html2.nodeType) {
                newElm.appendChild(html2);
              } else if (isString(html2)) {
                setHTML(newElm, html2);
              }
            }
            return !create3 ? parentElm2.appendChild(newElm) : newElm;
          });
          const create2 = (name2, attrs, html2) => add3(doc.createElement(name2), name2, attrs, html2, true);
          const decode2 = Entities.decode;
          const encode = Entities.encodeAllRaw;
          const createHTML = (name2, attrs, html2 = "") => {
            let outHtml = "<" + name2;
            for (const key in attrs) {
              if (hasNonNullableKey(attrs, key)) {
                outHtml += " " + key + '="' + encode(attrs[key]) + '"';
              }
            }
            if (isEmpty$3(html2) && has$2(schema.getVoidElements(), name2)) {
              return outHtml + " />";
            } else {
              return outHtml + ">" + html2 + "</" + name2 + ">";
            }
          };
          const createFragment2 = (html2) => {
            const container = doc.createElement("div");
            const frag = doc.createDocumentFragment();
            frag.appendChild(container);
            if (html2) {
              container.innerHTML = html2;
            }
            let node;
            while (node = container.firstChild) {
              frag.appendChild(node);
            }
            frag.removeChild(container);
            return frag;
          };
          const remove2 = (node, keepChildren) => {
            return run(node, (n2) => {
              const $node = SugarElement.fromDom(n2);
              if (keepChildren) {
                each$e(children$1($node), (child2) => {
                  if (isText$b(child2) && child2.dom.length === 0) {
                    remove$5(child2);
                  } else {
                    before$3($node, child2);
                  }
                });
              }
              remove$5($node);
              return $node.dom;
            });
          };
          const removeAllAttribs = (e2) => run(e2, (e3) => {
            const attrs = e3.attributes;
            for (let i2 = attrs.length - 1; i2 >= 0; i2--) {
              e3.removeAttributeNode(attrs.item(i2));
            }
          });
          const parseStyle = (cssText) => styles.parse(cssText);
          const serializeStyle = (stylesArg, name2) => styles.serialize(stylesArg, name2);
          const addStyle = (cssText) => {
            if (self2 !== DOMUtils.DOM && doc === document) {
              if (addedStyles[cssText]) {
                return;
              }
              addedStyles[cssText] = true;
            }
            let styleElm = doc.getElementById("mceDefaultStyles");
            if (!styleElm) {
              styleElm = doc.createElement("style");
              styleElm.id = "mceDefaultStyles";
              styleElm.type = "text/css";
              const head2 = doc.head;
              if (head2.firstChild) {
                head2.insertBefore(styleElm, head2.firstChild);
              } else {
                head2.appendChild(styleElm);
              }
            }
            if (styleElm.styleSheet) {
              styleElm.styleSheet.cssText += cssText;
            } else {
              styleElm.appendChild(doc.createTextNode(cssText));
            }
          };
          const loadCSS = (urls) => {
            if (!urls) {
              urls = "";
            }
            each$e(urls.split(","), (url) => {
              files[url] = true;
              styleSheetLoader.load(url).catch(noop2);
            });
          };
          const toggleClass2 = (elm, cls, state) => {
            run(elm, (e2) => {
              if (isElement$6(e2)) {
                const $elm = SugarElement.fromDom(e2);
                const classes = cls.split(" ");
                each$e(classes, (c2) => {
                  if (isNonNullable(state)) {
                    const fn2 = state ? add$2 : remove$7;
                    fn2($elm, c2);
                  } else {
                    toggle$1($elm, c2);
                  }
                });
              }
            });
          };
          const addClass = (elm, cls) => {
            toggleClass2(elm, cls, true);
          };
          const removeClass = (elm, cls) => {
            toggleClass2(elm, cls, false);
          };
          const hasClass2 = (elm, cls) => {
            const $elm = _get(elm);
            const classes = cls.split(" ");
            return isNonNullable($elm) && forall(classes, (c2) => has($elm, c2));
          };
          const show = (elm) => {
            run(elm, (e2) => remove$6(SugarElement.fromDom(e2), "display"));
          };
          const hide2 = (elm) => {
            run(elm, (e2) => set$2(SugarElement.fromDom(e2), "display", "none"));
          };
          const isHidden = (elm) => {
            const $elm = _get(elm);
            return isNonNullable($elm) && is$2(getRaw($elm, "display"), "none");
          };
          const uniqueId2 = (prefix) => (!prefix ? "mce_" : prefix) + counter++;
          const getOuterHTML = (elm) => {
            const $elm = _get(elm);
            if (isNonNullable($elm)) {
              return isElement$6($elm.dom) ? $elm.dom.outerHTML : getOuter($elm);
            } else {
              return "";
            }
          };
          const setOuterHTML = (elm, html2) => {
            run(elm, ($elm) => {
              if (isElement$6($elm)) {
                $elm.outerHTML = html2;
              }
            });
          };
          const insertAfter2 = (node, reference2) => {
            const referenceNode = get2(reference2);
            return run(node, (node2) => {
              const parent2 = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.parentNode;
              const nextSibling2 = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.nextSibling;
              if (parent2) {
                if (nextSibling2) {
                  parent2.insertBefore(node2, nextSibling2);
                } else {
                  parent2.appendChild(node2);
                }
              }
              return node2;
            });
          };
          const replace = (newElm, oldElm, keepChildren) => run(oldElm, (elm) => {
            var _a;
            const replacee = isArray$1(oldElm) ? newElm.cloneNode(true) : newElm;
            if (keepChildren) {
              each$a(grep(elm.childNodes), (node) => {
                replacee.appendChild(node);
              });
            }
            (_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(replacee, elm);
            return elm;
          });
          const rename = (elm, name2) => {
            if (elm.nodeName !== name2.toUpperCase()) {
              const newElm = create2(name2);
              each$a(getAttribs(elm), (attrNode) => {
                setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));
              });
              replace(newElm, elm, true);
              return newElm;
            } else {
              return elm;
            }
          };
          const findCommonAncestor = (a2, b2) => {
            let ps = a2;
            while (ps) {
              let pe = b2;
              while (pe && ps !== pe) {
                pe = pe.parentNode;
              }
              if (ps === pe) {
                break;
              }
              ps = ps.parentNode;
            }
            if (!ps && a2.ownerDocument) {
              return a2.ownerDocument.documentElement;
            } else {
              return ps;
            }
          };
          const isNonEmptyElement2 = (node) => {
            if (isElement$6(node)) {
              const isNamedAnchor2 = node.nodeName.toLowerCase() === "a" && !getAttrib(node, "href") && getAttrib(node, "id");
              if (getAttrib(node, "name") || getAttrib(node, "data-mce-bookmark") || isNamedAnchor2) {
                return true;
              }
            }
            return false;
          };
          const isEmpty2 = (node, elements, options) => {
            let brCount = 0;
            if (isNonEmptyElement2(node)) {
              return false;
            }
            const firstChild2 = node.firstChild;
            if (firstChild2) {
              const walker = new DomTreeWalker(firstChild2, node);
              const whitespaceElements = schema ? schema.getWhitespaceElements() : {};
              const nonEmptyElements = elements || (schema ? schema.getNonEmptyElements() : null);
              let tempNode = firstChild2;
              do {
                if (isElement$6(tempNode)) {
                  const bogusVal = tempNode.getAttribute("data-mce-bogus");
                  if (bogusVal) {
                    tempNode = walker.next(bogusVal === "all");
                    continue;
                  }
                  const name2 = tempNode.nodeName.toLowerCase();
                  if (nonEmptyElements && nonEmptyElements[name2]) {
                    if (name2 === "br") {
                      brCount++;
                      tempNode = walker.next();
                      continue;
                    }
                    return false;
                  }
                  if (isNonEmptyElement2(tempNode)) {
                    return false;
                  }
                }
                if (isComment(tempNode)) {
                  return false;
                }
                if (isText$a(tempNode) && !isWhitespaceText(tempNode.data) && (!(options === null || options === void 0 ? void 0 : options.includeZwsp) || !isZwsp(tempNode.data))) {
                  return false;
                }
                if (isText$a(tempNode) && tempNode.parentNode && whitespaceElements[tempNode.parentNode.nodeName] && isWhitespaceText(tempNode.data)) {
                  return false;
                }
                tempNode = walker.next();
              } while (tempNode);
            }
            return brCount <= 1;
          };
          const createRng = () => doc.createRange();
          const split2 = (parentElm, splitElm, replacementElm) => {
            let range2 = createRng();
            let beforeFragment;
            let afterFragment;
            if (parentElm && splitElm && parentElm.parentNode && splitElm.parentNode) {
              const parentNode = parentElm.parentNode;
              range2.setStart(parentNode, findNodeIndex(parentElm));
              range2.setEnd(splitElm.parentNode, findNodeIndex(splitElm));
              beforeFragment = range2.extractContents();
              range2 = createRng();
              range2.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);
              range2.setEnd(parentNode, findNodeIndex(parentElm) + 1);
              afterFragment = range2.extractContents();
              parentNode.insertBefore(trimNode(self2, beforeFragment), parentElm);
              if (replacementElm) {
                parentNode.insertBefore(replacementElm, parentElm);
              } else {
                parentNode.insertBefore(splitElm, parentElm);
              }
              parentNode.insertBefore(trimNode(self2, afterFragment), parentElm);
              remove2(parentElm);
              return replacementElm || splitElm;
            } else {
              return void 0;
            }
          };
          const bind2 = (target, name2, func, scope) => {
            if (isArray$1(target)) {
              let i2 = target.length;
              const rv = [];
              while (i2--) {
                rv[i2] = bind2(target[i2], name2, func, scope);
              }
              return rv;
            } else {
              if (settings.collect && (target === doc || target === win)) {
                boundEvents.push([
                  target,
                  name2,
                  func,
                  scope
                ]);
              }
              return events.bind(target, name2, func, scope || self2);
            }
          };
          const unbind2 = (target, name2, func) => {
            if (isArray$1(target)) {
              let i2 = target.length;
              const rv = [];
              while (i2--) {
                rv[i2] = unbind2(target[i2], name2, func);
              }
              return rv;
            } else {
              if (boundEvents.length > 0 && (target === doc || target === win)) {
                let i2 = boundEvents.length;
                while (i2--) {
                  const [boundTarget, boundName, boundFunc] = boundEvents[i2];
                  if (target === boundTarget && (!name2 || name2 === boundName) && (!func || func === boundFunc)) {
                    events.unbind(boundTarget, boundName, boundFunc);
                  }
                }
              }
              return events.unbind(target, name2, func);
            }
          };
          const dispatch2 = (target, name2, evt) => events.dispatch(target, name2, evt);
          const fire = (target, name2, evt) => events.dispatch(target, name2, evt);
          const getContentEditable = (node) => {
            if (node && isElement$6(node)) {
              const contentEditable = node.getAttribute("data-mce-contenteditable");
              if (contentEditable && contentEditable !== "inherit") {
                return contentEditable;
              }
              return node.contentEditable !== "inherit" ? node.contentEditable : null;
            } else {
              return null;
            }
          };
          const getContentEditableParent = (node) => {
            const root = getRoot();
            let state = null;
            for (let tempNode = node; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {
              state = getContentEditable(tempNode);
              if (state !== null) {
                break;
              }
            }
            return state;
          };
          const isEditable2 = (node) => {
            if (isNonNullable(node)) {
              const scope = isElement$6(node) ? node : node.parentElement;
              return isNonNullable(scope) && isEditable$3(SugarElement.fromDom(scope));
            } else {
              return false;
            }
          };
          const destroy2 = () => {
            if (boundEvents.length > 0) {
              let i2 = boundEvents.length;
              while (i2--) {
                const [boundTarget, boundName, boundFunc] = boundEvents[i2];
                events.unbind(boundTarget, boundName, boundFunc);
              }
            }
            each$d(files, (_2, url) => {
              styleSheetLoader.unload(url);
              delete files[url];
            });
          };
          const isChildOf = (node, parent2) => {
            return node === parent2 || parent2.contains(node);
          };
          const dumpRng = (r3) => "startContainer: " + r3.startContainer.nodeName + ", startOffset: " + r3.startOffset + ", endContainer: " + r3.endContainer.nodeName + ", endOffset: " + r3.endOffset;
          const self2 = {
            doc,
            settings,
            win,
            files,
            stdMode,
            boxModel,
            styleSheetLoader,
            boundEvents,
            styles,
            schema,
            events,
            isBlock: isBlock2,
            root: null,
            clone: clone2,
            getRoot,
            getViewPort,
            getRect,
            getSize,
            getParent,
            getParents: getParents2,
            get: get2,
            getNext,
            getPrev,
            select: select2,
            is: is2,
            add: add3,
            create: create2,
            createHTML,
            createFragment: createFragment2,
            remove: remove2,
            setStyle,
            getStyle: getStyle2,
            setStyles,
            removeAllAttribs,
            setAttrib,
            setAttribs,
            getAttrib,
            getPos: getPos$1,
            parseStyle,
            serializeStyle,
            addStyle,
            loadCSS,
            addClass,
            removeClass,
            hasClass: hasClass2,
            toggleClass: toggleClass2,
            show,
            hide: hide2,
            isHidden,
            uniqueId: uniqueId2,
            setHTML,
            getOuterHTML,
            setOuterHTML,
            decode: decode2,
            encode,
            insertAfter: insertAfter2,
            replace,
            rename,
            findCommonAncestor,
            run,
            getAttribs,
            isEmpty: isEmpty2,
            createRng,
            nodeIndex: findNodeIndex,
            split: split2,
            bind: bind2,
            unbind: unbind2,
            fire,
            dispatch: dispatch2,
            getContentEditable,
            getContentEditableParent,
            isEditable: isEditable2,
            destroy: destroy2,
            isChildOf,
            dumpRng
          };
          const attrHooks = setupAttrHooks(styles, settings, constant(self2));
          return self2;
        };
        DOMUtils.DOM = DOMUtils(document);
        DOMUtils.nodeIndex = findNodeIndex;
        const DOM$b = DOMUtils.DOM;
        const QUEUED = 0;
        const LOADING = 1;
        const LOADED = 2;
        const FAILED = 3;
        class ScriptLoader {
          constructor(settings = {}) {
            this.states = {};
            this.queue = [];
            this.scriptLoadedCallbacks = {};
            this.queueLoadedCallbacks = [];
            this.loading = false;
            this.settings = settings;
          }
          _setReferrerPolicy(referrerPolicy) {
            this.settings.referrerPolicy = referrerPolicy;
          }
          loadScript(url) {
            return new Promise((resolve2, reject) => {
              const dom2 = DOM$b;
              let elm;
              const cleanup = () => {
                dom2.remove(id);
                if (elm) {
                  elm.onerror = elm.onload = elm = null;
                }
              };
              const done = () => {
                cleanup();
                resolve2();
              };
              const error3 = () => {
                cleanup();
                reject("Failed to load script: " + url);
              };
              const id = dom2.uniqueId();
              elm = document.createElement("script");
              elm.id = id;
              elm.type = "text/javascript";
              elm.src = Tools._addCacheSuffix(url);
              if (this.settings.referrerPolicy) {
                dom2.setAttrib(elm, "referrerpolicy", this.settings.referrerPolicy);
              }
              elm.onload = done;
              elm.onerror = error3;
              (document.getElementsByTagName("head")[0] || document.body).appendChild(elm);
            });
          }
          isDone(url) {
            return this.states[url] === LOADED;
          }
          markDone(url) {
            this.states[url] = LOADED;
          }
          add(url) {
            const self2 = this;
            self2.queue.push(url);
            const state = self2.states[url];
            if (state === void 0) {
              self2.states[url] = QUEUED;
            }
            return new Promise((resolve2, reject) => {
              if (!self2.scriptLoadedCallbacks[url]) {
                self2.scriptLoadedCallbacks[url] = [];
              }
              self2.scriptLoadedCallbacks[url].push({
                resolve: resolve2,
                reject
              });
            });
          }
          load(url) {
            return this.add(url);
          }
          remove(url) {
            delete this.states[url];
            delete this.scriptLoadedCallbacks[url];
          }
          loadQueue() {
            const queue = this.queue;
            this.queue = [];
            return this.loadScripts(queue);
          }
          loadScripts(scripts) {
            const self2 = this;
            const execCallbacks = (name2, url) => {
              get$a(self2.scriptLoadedCallbacks, url).each((callbacks) => {
                each$e(callbacks, (callback) => callback[name2](url));
              });
              delete self2.scriptLoadedCallbacks[url];
            };
            const processResults = (results) => {
              const failures = filter$5(results, (result) => result.status === "rejected");
              if (failures.length > 0) {
                return Promise.reject(bind$3(failures, ({ reason }) => isArray$1(reason) ? reason : [reason]));
              } else {
                return Promise.resolve();
              }
            };
            const load = (urls) => Promise.allSettled(map$3(urls, (url) => {
              if (self2.states[url] === LOADED) {
                execCallbacks("resolve", url);
                return Promise.resolve();
              } else if (self2.states[url] === FAILED) {
                execCallbacks("reject", url);
                return Promise.reject(url);
              } else {
                self2.states[url] = LOADING;
                return self2.loadScript(url).then(() => {
                  self2.states[url] = LOADED;
                  execCallbacks("resolve", url);
                  const queue = self2.queue;
                  if (queue.length > 0) {
                    self2.queue = [];
                    return load(queue).then(processResults);
                  } else {
                    return Promise.resolve();
                  }
                }, () => {
                  self2.states[url] = FAILED;
                  execCallbacks("reject", url);
                  return Promise.reject(url);
                });
              }
            }));
            const processQueue = (urls) => {
              self2.loading = true;
              return load(urls).then((results) => {
                self2.loading = false;
                const nextQueuedItem = self2.queueLoadedCallbacks.shift();
                Optional.from(nextQueuedItem).each(call);
                return processResults(results);
              });
            };
            const uniqueScripts = stringArray(scripts);
            if (self2.loading) {
              return new Promise((resolve2, reject) => {
                self2.queueLoadedCallbacks.push(() => {
                  processQueue(uniqueScripts).then(resolve2, reject);
                });
              });
            } else {
              return processQueue(uniqueScripts);
            }
          }
        }
        ScriptLoader.ScriptLoader = new ScriptLoader();
        const Cell = (initial) => {
          let value2 = initial;
          const get2 = () => {
            return value2;
          };
          const set2 = (v2) => {
            value2 = v2;
          };
          return {
            get: get2,
            set: set2
          };
        };
        const isRaw = (str) => isObject(str) && has$2(str, "raw");
        const isTokenised = (str) => isArray$1(str) && str.length > 1;
        const data = {};
        const currentCode = Cell("en");
        const getLanguageData = () => get$a(data, currentCode.get());
        const getData$1 = () => map$2(data, (value2) => ({ ...value2 }));
        const setCode = (newCode) => {
          if (newCode) {
            currentCode.set(newCode);
          }
        };
        const getCode = () => currentCode.get();
        const add$1 = (code, items) => {
          let langData = data[code];
          if (!langData) {
            data[code] = langData = {};
          }
          each$d(items, (translation, name2) => {
            langData[name2.toLowerCase()] = translation;
          });
        };
        const translate = (text2) => {
          const langData = getLanguageData().getOr({});
          const toString = (obj) => {
            if (isFunction(obj)) {
              return Object.prototype.toString.call(obj);
            }
            return !isEmpty2(obj) ? "" + obj : "";
          };
          const isEmpty2 = (text3) => text3 === "" || text3 === null || text3 === void 0;
          const getLangData = (text3) => {
            const textstr = toString(text3);
            return get$a(langData, textstr.toLowerCase()).map(toString).getOr(textstr);
          };
          const removeContext = (str) => str.replace(/{context:\w+}$/, "");
          if (isEmpty2(text2)) {
            return "";
          }
          if (isRaw(text2)) {
            return toString(text2.raw);
          }
          if (isTokenised(text2)) {
            const values2 = text2.slice(1);
            const substitued = getLangData(text2[0]).replace(/\{([0-9]+)\}/g, ($1, $22) => has$2(values2, $22) ? toString(values2[$22]) : $1);
            return removeContext(substitued);
          }
          return removeContext(getLangData(text2));
        };
        const isRtl$1 = () => getLanguageData().bind((items) => get$a(items, "_dir")).exists((dir) => dir === "rtl");
        const hasCode = (code) => has$2(data, code);
        const I18n = {
          getData: getData$1,
          setCode,
          getCode,
          add: add$1,
          translate,
          isRtl: isRtl$1,
          hasCode
        };
        const AddOnManager = () => {
          const items = [];
          const urls = {};
          const lookup2 = {};
          const _listeners = [];
          const runListeners = (name2, state) => {
            const matchedListeners = filter$5(_listeners, (listener) => listener.name === name2 && listener.state === state);
            each$e(matchedListeners, (listener) => listener.resolve());
          };
          const isLoaded = (name2) => has$2(urls, name2);
          const isAdded = (name2) => has$2(lookup2, name2);
          const get2 = (name2) => {
            if (lookup2[name2]) {
              return lookup2[name2].instance;
            }
            return void 0;
          };
          const loadLanguagePack = (name2, languages) => {
            const language = I18n.getCode();
            const wrappedLanguages = "," + (languages || "") + ",";
            if (!language || languages && wrappedLanguages.indexOf("," + language + ",") === -1) {
              return;
            }
            ScriptLoader.ScriptLoader.add(urls[name2] + "/langs/" + language + ".js");
          };
          const requireLangPack = (name2, languages) => {
            if (AddOnManager.languageLoad !== false) {
              if (isLoaded(name2)) {
                loadLanguagePack(name2, languages);
              } else {
                waitFor(name2, "loaded").then(() => loadLanguagePack(name2, languages));
              }
            }
          };
          const add3 = (id, addOn) => {
            items.push(addOn);
            lookup2[id] = { instance: addOn };
            runListeners(id, "added");
            return addOn;
          };
          const remove2 = (name2) => {
            delete urls[name2];
            delete lookup2[name2];
          };
          const createUrl = (baseUrl, dep) => {
            if (isString(dep)) {
              return isString(baseUrl) ? {
                prefix: "",
                resource: dep,
                suffix: ""
              } : {
                prefix: baseUrl.prefix,
                resource: dep,
                suffix: baseUrl.suffix
              };
            } else {
              return dep;
            }
          };
          const load = (name2, addOnUrl) => {
            if (urls[name2]) {
              return Promise.resolve();
            }
            let urlString = isString(addOnUrl) ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;
            if (urlString.indexOf("/") !== 0 && urlString.indexOf("://") === -1) {
              urlString = AddOnManager.baseURL + "/" + urlString;
            }
            urls[name2] = urlString.substring(0, urlString.lastIndexOf("/"));
            const done = () => {
              runListeners(name2, "loaded");
              return Promise.resolve();
            };
            if (lookup2[name2]) {
              return done();
            } else {
              return ScriptLoader.ScriptLoader.add(urlString).then(done);
            }
          };
          const waitFor = (name2, state = "added") => {
            if (state === "added" && isAdded(name2)) {
              return Promise.resolve();
            } else if (state === "loaded" && isLoaded(name2)) {
              return Promise.resolve();
            } else {
              return new Promise((resolve2) => {
                _listeners.push({
                  name: name2,
                  state,
                  resolve: resolve2
                });
              });
            }
          };
          return {
            items,
            urls,
            lookup: lookup2,
            get: get2,
            requireLangPack,
            add: add3,
            remove: remove2,
            createUrl,
            load,
            waitFor
          };
        };
        AddOnManager.languageLoad = true;
        AddOnManager.baseURL = "";
        AddOnManager.PluginManager = AddOnManager();
        AddOnManager.ThemeManager = AddOnManager();
        AddOnManager.ModelManager = AddOnManager();
        const singleton = (doRevoke) => {
          const subject = Cell(Optional.none());
          const revoke = () => subject.get().each(doRevoke);
          const clear2 = () => {
            revoke();
            subject.set(Optional.none());
          };
          const isSet = () => subject.get().isSome();
          const get2 = () => subject.get();
          const set2 = (s2) => {
            revoke();
            subject.set(Optional.some(s2));
          };
          return {
            clear: clear2,
            isSet,
            get: get2,
            set: set2
          };
        };
        const repeatable = (delay) => {
          const intervalId = Cell(Optional.none());
          const revoke = () => intervalId.get().each((id) => clearInterval(id));
          const clear2 = () => {
            revoke();
            intervalId.set(Optional.none());
          };
          const isSet = () => intervalId.get().isSome();
          const get2 = () => intervalId.get();
          const set2 = (functionToRepeat) => {
            revoke();
            intervalId.set(Optional.some(setInterval(functionToRepeat, delay)));
          };
          return {
            clear: clear2,
            isSet,
            get: get2,
            set: set2
          };
        };
        const value$2 = () => {
          const subject = singleton(noop2);
          const on2 = (f2) => subject.get().each(f2);
          return {
            ...subject,
            on: on2
          };
        };
        const first$1 = (fn2, rate) => {
          let timer = null;
          const cancel = () => {
            if (!isNull(timer)) {
              clearTimeout(timer);
              timer = null;
            }
          };
          const throttle = (...args) => {
            if (isNull(timer)) {
              timer = setTimeout(() => {
                timer = null;
                fn2.apply(null, args);
              }, rate);
            }
          };
          return {
            cancel,
            throttle
          };
        };
        const last$1 = (fn2, rate) => {
          let timer = null;
          const cancel = () => {
            if (!isNull(timer)) {
              clearTimeout(timer);
              timer = null;
            }
          };
          const throttle = (...args) => {
            cancel();
            timer = setTimeout(() => {
              timer = null;
              fn2.apply(null, args);
            }, rate);
          };
          return {
            cancel,
            throttle
          };
        };
        const annotation = constant("mce-annotation");
        const dataAnnotation = constant("data-mce-annotation");
        const dataAnnotationId = constant("data-mce-annotation-uid");
        const dataAnnotationActive = constant("data-mce-annotation-active");
        const dataAnnotationClasses = constant("data-mce-annotation-classes");
        const dataAnnotationAttributes = constant("data-mce-annotation-attrs");
        const isRoot$1 = (root) => (node) => eq(node, root);
        const identify = (editor, annotationName) => {
          const rng = editor.selection.getRng();
          const start4 = SugarElement.fromDom(rng.startContainer);
          const root = SugarElement.fromDom(editor.getBody());
          const selector = annotationName.fold(() => "." + annotation(), (an) => `[${dataAnnotation()}="${an}"]`);
          const newStart = child$1(start4, rng.startOffset).getOr(start4);
          const closest2 = closest$3(newStart, selector, isRoot$1(root));
          return closest2.bind((c2) => getOpt(c2, `${dataAnnotationId()}`).bind((uid2) => getOpt(c2, `${dataAnnotation()}`).map((name2) => {
            const elements = findMarkers(editor, uid2);
            return {
              uid: uid2,
              name: name2,
              elements
            };
          })));
        };
        const isAnnotation = (elem) => isElement$7(elem) && has(elem, annotation());
        const isBogusElement = (elem, root) => has$1(elem, "data-mce-bogus") || ancestor$2(elem, '[data-mce-bogus="all"]', isRoot$1(root));
        const findMarkers = (editor, uid2) => {
          const body = SugarElement.fromDom(editor.getBody());
          const descendants$12 = descendants(body, `[${dataAnnotationId()}="${uid2}"]`);
          return filter$5(descendants$12, (descendant2) => !isBogusElement(descendant2, body));
        };
        const findAll = (editor, name2) => {
          const body = SugarElement.fromDom(editor.getBody());
          const markers = descendants(body, `[${dataAnnotation()}="${name2}"]`);
          const directory = {};
          each$e(markers, (m2) => {
            if (!isBogusElement(m2, body)) {
              const uid2 = get$9(m2, dataAnnotationId());
              const nodesAlready = get$a(directory, uid2).getOr([]);
              directory[uid2] = nodesAlready.concat([m2]);
            }
          });
          return directory;
        };
        const setup$x = (editor, registry2) => {
          const changeCallbacks = Cell({});
          const initData = () => ({
            listeners: [],
            previous: value$2()
          });
          const withCallbacks = (name2, f2) => {
            updateCallbacks(name2, (data2) => {
              f2(data2);
              return data2;
            });
          };
          const updateCallbacks = (name2, f2) => {
            const callbackMap = changeCallbacks.get();
            const data2 = get$a(callbackMap, name2).getOrThunk(initData);
            const outputData = f2(data2);
            callbackMap[name2] = outputData;
            changeCallbacks.set(callbackMap);
          };
          const fireCallbacks = (name2, uid2, elements) => {
            withCallbacks(name2, (data2) => {
              each$e(data2.listeners, (f2) => f2(true, name2, {
                uid: uid2,
                nodes: map$3(elements, (elem) => elem.dom)
              }));
            });
          };
          const fireNoAnnotation = (name2) => {
            withCallbacks(name2, (data2) => {
              each$e(data2.listeners, (f2) => f2(false, name2));
            });
          };
          const toggleActiveAttr = (uid2, state) => {
            each$e(findMarkers(editor, uid2), (elem) => {
              if (state) {
                set$3(elem, dataAnnotationActive(), "true");
              } else {
                remove$a(elem, dataAnnotationActive());
              }
            });
          };
          const onNodeChange = last$1(() => {
            const annotations = sort(registry2.getNames());
            each$e(annotations, (name2) => {
              updateCallbacks(name2, (data2) => {
                const prev2 = data2.previous.get();
                identify(editor, Optional.some(name2)).fold(() => {
                  prev2.each((uid2) => {
                    fireNoAnnotation(name2);
                    data2.previous.clear();
                    toggleActiveAttr(uid2, false);
                  });
                }, ({ uid: uid2, name: name3, elements }) => {
                  if (!is$2(prev2, uid2)) {
                    prev2.each((uid3) => toggleActiveAttr(uid3, false));
                    fireCallbacks(name3, uid2, elements);
                    data2.previous.set(uid2);
                    toggleActiveAttr(uid2, true);
                  }
                });
                return {
                  previous: data2.previous,
                  listeners: data2.listeners
                };
              });
            });
          }, 30);
          editor.on("remove", () => {
            onNodeChange.cancel();
          });
          editor.on("NodeChange", () => {
            onNodeChange.throttle();
          });
          const addListener = (name2, f2) => {
            updateCallbacks(name2, (data2) => ({
              previous: data2.previous,
              listeners: data2.listeners.concat([f2])
            }));
          };
          return { addListener };
        };
        const setup$w = (editor, registry2) => {
          const dataAnnotation$1 = dataAnnotation();
          const identifyParserNode = (node) => Optional.from(node.attr(dataAnnotation$1)).bind(registry2.lookup);
          const removeDirectAnnotation2 = (node) => {
            var _a, _b;
            node.attr(dataAnnotationId(), null);
            node.attr(dataAnnotation(), null);
            node.attr(dataAnnotationActive(), null);
            const customAttrNames = Optional.from(node.attr(dataAnnotationAttributes())).map((names) => names.split(",")).getOr([]);
            const customClasses = Optional.from(node.attr(dataAnnotationClasses())).map((names) => names.split(",")).getOr([]);
            each$e(customAttrNames, (name2) => node.attr(name2, null));
            const classList = (_b = (_a = node.attr("class")) === null || _a === void 0 ? void 0 : _a.split(" ")) !== null && _b !== void 0 ? _b : [];
            const newClassList = difference(classList, [annotation()].concat(customClasses));
            node.attr("class", newClassList.length > 0 ? newClassList.join(" ") : null);
            node.attr(dataAnnotationClasses(), null);
            node.attr(dataAnnotationAttributes(), null);
          };
          editor.serializer.addTempAttr(dataAnnotationActive());
          editor.serializer.addAttributeFilter(dataAnnotation$1, (nodes) => {
            for (const node of nodes) {
              identifyParserNode(node).each((settings) => {
                if (settings.persistent === false) {
                  if (node.name === "span") {
                    node.unwrap();
                  } else {
                    removeDirectAnnotation2(node);
                  }
                }
              });
            }
          });
        };
        const create$c = () => {
          const annotations = {};
          const register2 = (name2, settings) => {
            annotations[name2] = {
              name: name2,
              settings
            };
          };
          const lookup2 = (name2) => get$a(annotations, name2).map((a2) => a2.settings);
          const getNames = () => keys(annotations);
          return {
            register: register2,
            lookup: lookup2,
            getNames
          };
        };
        let unique = 0;
        const generate$1 = (prefix) => {
          const date = /* @__PURE__ */ new Date();
          const time = date.getTime();
          const random = Math.floor(Math.random() * 1e9);
          unique++;
          return prefix + "_" + random + unique + String(time);
        };
        const add2 = (element, classes) => {
          each$e(classes, (x2) => {
            add$2(element, x2);
          });
        };
        const remove$4 = (element, classes) => {
          each$e(classes, (x2) => {
            remove$7(element, x2);
          });
        };
        const clone$2 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));
        const shallow$1 = (original) => clone$2(original, false);
        const deep$1 = (original) => clone$2(original, true);
        const shallowAs = (original, tag) => {
          const nu2 = SugarElement.fromTag(tag);
          const attributes = clone$4(original);
          setAll$1(nu2, attributes);
          return nu2;
        };
        const mutate = (original, tag) => {
          const nu2 = shallowAs(original, tag);
          after$4(original, nu2);
          const children2 = children$1(original);
          append(nu2, children2);
          remove$5(original);
          return nu2;
        };
        const TextWalker = (startNode, rootNode, isBoundary2 = never) => {
          const walker = new DomTreeWalker(startNode, rootNode);
          const walk3 = (direction) => {
            let next2;
            do {
              next2 = walker[direction]();
            } while (next2 && !isText$a(next2) && !isBoundary2(next2));
            return Optional.from(next2).filter(isText$a);
          };
          return {
            current: () => Optional.from(walker.current()).filter(isText$a),
            next: () => walk3("next"),
            prev: () => walk3("prev"),
            prev2: () => walk3("prev2")
          };
        };
        const TextSeeker = (dom2, isBoundary2) => {
          const isBlockBoundary = isBoundary2 ? isBoundary2 : (node) => dom2.isBlock(node) || isBr$6(node) || isContentEditableFalse$b(node);
          const walk3 = (node, offset2, walker, process2) => {
            if (isText$a(node)) {
              const newOffset = process2(node, offset2, node.data);
              if (newOffset !== -1) {
                return Optional.some({
                  container: node,
                  offset: newOffset
                });
              }
            }
            return walker().bind((next2) => walk3(next2.container, next2.offset, walker, process2));
          };
          const backwards = (node, offset2, process2, root) => {
            const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom2.getRoot(), isBlockBoundary);
            return walk3(node, offset2, () => walker.prev().map((prev2) => ({
              container: prev2,
              offset: prev2.length
            })), process2).getOrNull();
          };
          const forwards = (node, offset2, process2, root) => {
            const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom2.getRoot(), isBlockBoundary);
            return walk3(node, offset2, () => walker.next().map((next2) => ({
              container: next2,
              offset: 0
            })), process2).getOrNull();
          };
          return {
            backwards,
            forwards
          };
        };
        const round$2 = Math.round;
        const clone$1 = (rect) => {
          if (!rect) {
            return {
              left: 0,
              top: 0,
              bottom: 0,
              right: 0,
              width: 0,
              height: 0
            };
          }
          return {
            left: round$2(rect.left),
            top: round$2(rect.top),
            bottom: round$2(rect.bottom),
            right: round$2(rect.right),
            width: round$2(rect.width),
            height: round$2(rect.height)
          };
        };
        const collapse = (rect, toStart) => {
          rect = clone$1(rect);
          if (toStart) {
            rect.right = rect.left;
          } else {
            rect.left = rect.left + rect.width;
            rect.right = rect.left;
          }
          rect.width = 0;
          return rect;
        };
        const isEqual = (rect1, rect2) => rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;
        const isValidOverflow = (overflowY, rect1, rect2) => overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;
        const isAbove$1 = (rect1, rect2) => {
          const halfHeight = Math.min(rect2.height / 2, rect1.height / 2);
          if (rect1.bottom - halfHeight < rect2.top) {
            return true;
          }
          if (rect1.top > rect2.bottom) {
            return false;
          }
          return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);
        };
        const isBelow$1 = (rect1, rect2) => {
          if (rect1.top > rect2.bottom) {
            return true;
          }
          if (rect1.bottom < rect2.top) {
            return false;
          }
          return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);
        };
        const containsXY = (rect, clientX, clientY) => clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
        const boundingClientRectFromRects = (rects) => {
          return foldl(rects, (acc, rect) => {
            return acc.fold(() => Optional.some(rect), (prevRect) => {
              const left2 = Math.min(rect.left, prevRect.left);
              const top2 = Math.min(rect.top, prevRect.top);
              const right2 = Math.max(rect.right, prevRect.right);
              const bottom2 = Math.max(rect.bottom, prevRect.bottom);
              return Optional.some({
                top: top2,
                right: right2,
                bottom: bottom2,
                left: left2,
                width: right2 - left2,
                height: bottom2 - top2
              });
            });
          }, Optional.none());
        };
        const distanceToRectEdgeFromXY = (rect, x2, y2) => {
          const cx = Math.max(Math.min(x2, rect.left + rect.width), rect.left);
          const cy = Math.max(Math.min(y2, rect.top + rect.height), rect.top);
          return Math.sqrt((x2 - cx) * (x2 - cx) + (y2 - cy) * (y2 - cy));
        };
        const overlapY = (r1, r22) => Math.max(0, Math.min(r1.bottom, r22.bottom) - Math.max(r1.top, r22.top));
        const clamp$2 = (value2, min3, max3) => Math.min(Math.max(value2, min3), max3);
        const getSelectedNode = (range2) => {
          const startContainer = range2.startContainer, startOffset = range2.startOffset;
          if (startContainer === range2.endContainer && startContainer.hasChildNodes() && range2.endOffset === startOffset + 1) {
            return startContainer.childNodes[startOffset];
          }
          return null;
        };
        const getNode$1 = (container, offset2) => {
          if (isElement$6(container) && container.hasChildNodes()) {
            const childNodes = container.childNodes;
            const safeOffset = clamp$2(offset2, 0, childNodes.length - 1);
            return childNodes[safeOffset];
          } else {
            return container;
          }
        };
        const getNodeUnsafe = (container, offset2) => {
          if (offset2 < 0 && isElement$6(container) && container.hasChildNodes()) {
            return void 0;
          } else {
            return getNode$1(container, offset2);
          }
        };
        const extendingChars = new RegExp("[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962-\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2-\u09E3\u0A01-\u0A02\u0A3C\u0A41-\u0A42\u0A47-\u0A48\u0A4B-\u0A4D\u0A51\u0A70-\u0A71\u0A75\u0A81-\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7-\u0AC8\u0ACD\u0AE2-\u0AE3\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B57\u0B62-\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55-\u0C56\u0C62-\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC-\u0CCD\u0CD5-\u0CD6\u0CE2-\u0CE3\u0D01\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62-\u0D63\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB-\u0EBC\u0EC8-\u0ECD\u0F18-\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86-\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039-\u103A\u103D-\u103E\u1058-\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085-\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752-\u1753\u1772-\u1773\u17B4-\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927-\u1928\u1932\u1939-\u193B\u1A17-\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABD\u1ABE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80-\u1B81\u1BA2-\u1BA5\u1BA8-\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8-\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8-\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u200C-\u200D\u20D0-\u20DC\u20DD-\u20E0\u20E1\u20E2-\u20E4\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u302E-\u302F\u3099-\u309A\uA66F\uA670-\uA672\uA674-\uA67D\uA69E-\uA69F\uA6F0-\uA6F1\uA802\uA806\uA80B\uA825-\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31-\uAA32\uAA35-\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7-\uAAB8\uAABE-\uAABF\uAAC1\uAAEC-\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E-\uFF9F]");
        const isExtendingChar = (ch) => isString(ch) && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
        const or = (...args) => {
          return (x2) => {
            for (let i2 = 0; i2 < args.length; i2++) {
              if (args[i2](x2)) {
                return true;
              }
            }
            return false;
          };
        };
        const and = (...args) => {
          return (x2) => {
            for (let i2 = 0; i2 < args.length; i2++) {
              if (!args[i2](x2)) {
                return false;
              }
            }
            return true;
          };
        };
        const isElement$4 = isElement$6;
        const isCaretCandidate$2 = isCaretCandidate$3;
        const isBlock$1 = matchStyleValues("display", "block table");
        const isFloated = matchStyleValues("float", "left right");
        const isValidElementCaretCandidate = and(isElement$4, isCaretCandidate$2, not(isFloated));
        const isNotPre = not(matchStyleValues("white-space", "pre pre-line pre-wrap"));
        const isText$7 = isText$a;
        const isBr$3 = isBr$6;
        const nodeIndex$1 = DOMUtils.nodeIndex;
        const resolveIndex$1 = getNodeUnsafe;
        const createRange$1 = (doc) => doc ? doc.createRange() : DOMUtils.DOM.createRng();
        const isWhiteSpace$1 = (chr) => isString(chr) && /[\r\n\t ]/.test(chr);
        const isRange = (rng) => !!rng.setStart && !!rng.setEnd;
        const isHiddenWhiteSpaceRange = (range2) => {
          const container = range2.startContainer;
          const offset2 = range2.startOffset;
          if (isWhiteSpace$1(range2.toString()) && isNotPre(container.parentNode) && isText$a(container)) {
            const text2 = container.data;
            if (isWhiteSpace$1(text2[offset2 - 1]) || isWhiteSpace$1(text2[offset2 + 1])) {
              return true;
            }
          }
          return false;
        };
        const getBrClientRect = (brNode) => {
          const doc = brNode.ownerDocument;
          const rng = createRange$1(doc);
          const nbsp$1 = doc.createTextNode(nbsp);
          const parentNode = brNode.parentNode;
          parentNode.insertBefore(nbsp$1, brNode);
          rng.setStart(nbsp$1, 0);
          rng.setEnd(nbsp$1, 1);
          const clientRect = clone$1(rng.getBoundingClientRect());
          parentNode.removeChild(nbsp$1);
          return clientRect;
        };
        const getBoundingClientRectWebKitText = (rng) => {
          const sc = rng.startContainer;
          const ec = rng.endContainer;
          const so = rng.startOffset;
          const eo = rng.endOffset;
          if (sc === ec && isText$a(ec) && so === 0 && eo === 1) {
            const newRng = rng.cloneRange();
            newRng.setEndAfter(ec);
            return getBoundingClientRect$1(newRng);
          } else {
            return null;
          }
        };
        const isZeroRect = (r3) => r3.left === 0 && r3.right === 0 && r3.top === 0 && r3.bottom === 0;
        const getBoundingClientRect$1 = (item) => {
          var _a;
          let clientRect;
          const clientRects = item.getClientRects();
          if (clientRects.length > 0) {
            clientRect = clone$1(clientRects[0]);
          } else {
            clientRect = clone$1(item.getBoundingClientRect());
          }
          if (!isRange(item) && isBr$3(item) && isZeroRect(clientRect)) {
            return getBrClientRect(item);
          }
          if (isZeroRect(clientRect) && isRange(item)) {
            return (_a = getBoundingClientRectWebKitText(item)) !== null && _a !== void 0 ? _a : clientRect;
          }
          return clientRect;
        };
        const collapseAndInflateWidth = (clientRect, toStart) => {
          const newClientRect = collapse(clientRect, toStart);
          newClientRect.width = 1;
          newClientRect.right = newClientRect.left + 1;
          return newClientRect;
        };
        const getCaretPositionClientRects = (caretPosition) => {
          const clientRects = [];
          const addUniqueAndValidRect = (clientRect) => {
            if (clientRect.height === 0) {
              return;
            }
            if (clientRects.length > 0) {
              if (isEqual(clientRect, clientRects[clientRects.length - 1])) {
                return;
              }
            }
            clientRects.push(clientRect);
          };
          const addCharacterOffset = (container2, offset3) => {
            const range2 = createRange$1(container2.ownerDocument);
            if (offset3 < container2.data.length) {
              if (isExtendingChar(container2.data[offset3])) {
                return;
              }
              if (isExtendingChar(container2.data[offset3 - 1])) {
                range2.setStart(container2, offset3);
                range2.setEnd(container2, offset3 + 1);
                if (!isHiddenWhiteSpaceRange(range2)) {
                  addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range2), false));
                  return;
                }
              }
            }
            if (offset3 > 0) {
              range2.setStart(container2, offset3 - 1);
              range2.setEnd(container2, offset3);
              if (!isHiddenWhiteSpaceRange(range2)) {
                addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range2), false));
              }
            }
            if (offset3 < container2.data.length) {
              range2.setStart(container2, offset3);
              range2.setEnd(container2, offset3 + 1);
              if (!isHiddenWhiteSpaceRange(range2)) {
                addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range2), true));
              }
            }
          };
          const container = caretPosition.container();
          const offset2 = caretPosition.offset();
          if (isText$7(container)) {
            addCharacterOffset(container, offset2);
            return clientRects;
          }
          if (isElement$4(container)) {
            if (caretPosition.isAtEnd()) {
              const node = resolveIndex$1(container, offset2);
              if (isText$7(node)) {
                addCharacterOffset(node, node.data.length);
              }
              if (isValidElementCaretCandidate(node) && !isBr$3(node)) {
                addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));
              }
            } else {
              const node = resolveIndex$1(container, offset2);
              if (isText$7(node)) {
                addCharacterOffset(node, 0);
              }
              if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {
                addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));
                return clientRects;
              }
              const beforeNode = resolveIndex$1(caretPosition.container(), caretPosition.offset() - 1);
              if (isValidElementCaretCandidate(beforeNode) && !isBr$3(beforeNode)) {
                if (isBlock$1(beforeNode) || isBlock$1(node) || !isValidElementCaretCandidate(node)) {
                  addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(beforeNode), false));
                }
              }
              if (isValidElementCaretCandidate(node)) {
                addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), true));
              }
            }
          }
          return clientRects;
        };
        const CaretPosition = (container, offset2, clientRects) => {
          const isAtStart = () => {
            if (isText$7(container)) {
              return offset2 === 0;
            }
            return offset2 === 0;
          };
          const isAtEnd = () => {
            if (isText$7(container)) {
              return offset2 >= container.data.length;
            }
            return offset2 >= container.childNodes.length;
          };
          const toRange = () => {
            const range2 = createRange$1(container.ownerDocument);
            range2.setStart(container, offset2);
            range2.setEnd(container, offset2);
            return range2;
          };
          const getClientRects2 = () => {
            if (!clientRects) {
              clientRects = getCaretPositionClientRects(CaretPosition(container, offset2));
            }
            return clientRects;
          };
          const isVisible2 = () => getClientRects2().length > 0;
          const isEqual2 = (caretPosition) => caretPosition && container === caretPosition.container() && offset2 === caretPosition.offset();
          const getNode2 = (before2) => resolveIndex$1(container, before2 ? offset2 - 1 : offset2);
          return {
            container: constant(container),
            offset: constant(offset2),
            toRange,
            getClientRects: getClientRects2,
            isVisible: isVisible2,
            isAtStart,
            isAtEnd,
            isEqual: isEqual2,
            getNode: getNode2
          };
        };
        CaretPosition.fromRangeStart = (range2) => CaretPosition(range2.startContainer, range2.startOffset);
        CaretPosition.fromRangeEnd = (range2) => CaretPosition(range2.endContainer, range2.endOffset);
        CaretPosition.after = (node) => CaretPosition(node.parentNode, nodeIndex$1(node) + 1);
        CaretPosition.before = (node) => CaretPosition(node.parentNode, nodeIndex$1(node));
        CaretPosition.isAbove = (pos1, pos2) => lift2(head(pos2.getClientRects()), last$3(pos1.getClientRects()), isAbove$1).getOr(false);
        CaretPosition.isBelow = (pos1, pos2) => lift2(last$3(pos2.getClientRects()), head(pos1.getClientRects()), isBelow$1).getOr(false);
        CaretPosition.isAtStart = (pos) => pos ? pos.isAtStart() : false;
        CaretPosition.isAtEnd = (pos) => pos ? pos.isAtEnd() : false;
        CaretPosition.isTextPosition = (pos) => pos ? isText$a(pos.container()) : false;
        CaretPosition.isElementPosition = (pos) => !CaretPosition.isTextPosition(pos);
        const trimEmptyTextNode$1 = (dom2, node) => {
          if (isText$a(node) && node.data.length === 0) {
            dom2.remove(node);
          }
        };
        const insertNode = (dom2, rng, node) => {
          rng.insertNode(node);
          trimEmptyTextNode$1(dom2, node.previousSibling);
          trimEmptyTextNode$1(dom2, node.nextSibling);
        };
        const insertFragment = (dom2, rng, frag) => {
          const firstChild2 = Optional.from(frag.firstChild);
          const lastChild2 = Optional.from(frag.lastChild);
          rng.insertNode(frag);
          firstChild2.each((child2) => trimEmptyTextNode$1(dom2, child2.previousSibling));
          lastChild2.each((child2) => trimEmptyTextNode$1(dom2, child2.nextSibling));
        };
        const rangeInsertNode = (dom2, rng, node) => {
          if (isDocumentFragment(node)) {
            insertFragment(dom2, rng, node);
          } else {
            insertNode(dom2, rng, node);
          }
        };
        const isText$6 = isText$a;
        const isBogus = isBogus$2;
        const nodeIndex = DOMUtils.nodeIndex;
        const normalizedParent = (node) => {
          const parentNode = node.parentNode;
          if (isBogus(parentNode)) {
            return normalizedParent(parentNode);
          }
          return parentNode;
        };
        const getChildNodes = (node) => {
          if (!node) {
            return [];
          }
          return reduce(node.childNodes, (result, node2) => {
            if (isBogus(node2) && node2.nodeName !== "BR") {
              result = result.concat(getChildNodes(node2));
            } else {
              result.push(node2);
            }
            return result;
          }, []);
        };
        const normalizedTextOffset = (node, offset2) => {
          let tempNode = node;
          while (tempNode = tempNode.previousSibling) {
            if (!isText$6(tempNode)) {
              break;
            }
            offset2 += tempNode.data.length;
          }
          return offset2;
        };
        const equal = (a2) => (b2) => a2 === b2;
        const normalizedNodeIndex = (node) => {
          let nodes, index;
          nodes = getChildNodes(normalizedParent(node));
          index = findIndex$1(nodes, equal(node), node);
          nodes = nodes.slice(0, index + 1);
          const numTextFragments = reduce(nodes, (result, node2, i2) => {
            if (isText$6(node2) && isText$6(nodes[i2 - 1])) {
              result++;
            }
            return result;
          }, 0);
          nodes = filter$3(nodes, matchNodeNames([node.nodeName]));
          index = findIndex$1(nodes, equal(node), node);
          return index - numTextFragments;
        };
        const createPathItem = (node) => {
          const name2 = isText$6(node) ? "text()" : node.nodeName.toLowerCase();
          return name2 + "[" + normalizedNodeIndex(node) + "]";
        };
        const parentsUntil$1 = (root, node, predicate) => {
          const parents2 = [];
          for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {
            if (predicate && predicate(tempNode)) {
              break;
            }
            parents2.push(tempNode);
          }
          return parents2;
        };
        const create$b = (root, caretPosition) => {
          let path2 = [];
          let container = caretPosition.container();
          let offset2 = caretPosition.offset();
          let outputOffset;
          if (isText$6(container)) {
            outputOffset = normalizedTextOffset(container, offset2);
          } else {
            const childNodes = container.childNodes;
            if (offset2 >= childNodes.length) {
              outputOffset = "after";
              offset2 = childNodes.length - 1;
            } else {
              outputOffset = "before";
            }
            container = childNodes[offset2];
          }
          path2.push(createPathItem(container));
          let parents2 = parentsUntil$1(root, container);
          parents2 = filter$3(parents2, not(isBogus$2));
          path2 = path2.concat(map$1(parents2, (node) => {
            return createPathItem(node);
          }));
          return path2.reverse().join("/") + "," + outputOffset;
        };
        const resolvePathItem = (node, name2, index) => {
          let nodes = getChildNodes(node);
          nodes = filter$3(nodes, (node2, index2) => {
            return !isText$6(node2) || !isText$6(nodes[index2 - 1]);
          });
          nodes = filter$3(nodes, matchNodeNames([name2]));
          return nodes[index];
        };
        const findTextPosition = (container, offset2) => {
          let node = container;
          let targetOffset = 0;
          while (isText$6(node)) {
            const dataLen = node.data.length;
            if (offset2 >= targetOffset && offset2 <= targetOffset + dataLen) {
              container = node;
              offset2 = offset2 - targetOffset;
              break;
            }
            if (!isText$6(node.nextSibling)) {
              container = node;
              offset2 = dataLen;
              break;
            }
            targetOffset += dataLen;
            node = node.nextSibling;
          }
          if (isText$6(container) && offset2 > container.data.length) {
            offset2 = container.data.length;
          }
          return CaretPosition(container, offset2);
        };
        const resolve$1 = (root, path2) => {
          if (!path2) {
            return null;
          }
          const parts = path2.split(",");
          const paths = parts[0].split("/");
          const offset2 = parts.length > 1 ? parts[1] : "before";
          const container = reduce(paths, (result, value2) => {
            const match2 = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(value2);
            if (!match2) {
              return null;
            }
            if (match2[1] === "text()") {
              match2[1] = "#text";
            }
            return resolvePathItem(result, match2[1], parseInt(match2[2], 10));
          }, root);
          if (!container) {
            return null;
          }
          if (!isText$6(container) && container.parentNode) {
            let nodeOffset;
            if (offset2 === "after") {
              nodeOffset = nodeIndex(container) + 1;
            } else {
              nodeOffset = nodeIndex(container);
            }
            return CaretPosition(container.parentNode, nodeOffset);
          }
          return findTextPosition(container, parseInt(offset2, 10));
        };
        const isContentEditableFalse$9 = isContentEditableFalse$b;
        const getNormalizedTextOffset$1 = (trim2, container, offset2) => {
          let trimmedOffset = trim2(container.data.slice(0, offset2)).length;
          for (let node = container.previousSibling; node && isText$a(node); node = node.previousSibling) {
            trimmedOffset += trim2(node.data).length;
          }
          return trimmedOffset;
        };
        const getPoint = (dom2, trim2, normalized, rng, start4) => {
          const container = start4 ? rng.startContainer : rng.endContainer;
          let offset2 = start4 ? rng.startOffset : rng.endOffset;
          const point2 = [];
          const root = dom2.getRoot();
          if (isText$a(container)) {
            point2.push(normalized ? getNormalizedTextOffset$1(trim2, container, offset2) : offset2);
          } else {
            let after2 = 0;
            const childNodes = container.childNodes;
            if (offset2 >= childNodes.length && childNodes.length) {
              after2 = 1;
              offset2 = Math.max(0, childNodes.length - 1);
            }
            point2.push(dom2.nodeIndex(childNodes[offset2], normalized) + after2);
          }
          for (let node = container; node && node !== root; node = node.parentNode) {
            point2.push(dom2.nodeIndex(node, normalized));
          }
          return point2;
        };
        const getLocation = (trim2, selection, normalized, rng) => {
          const dom2 = selection.dom;
          const start4 = getPoint(dom2, trim2, normalized, rng, true);
          const forward = selection.isForward();
          const fakeCaret = isRangeInCaretContainerBlock(rng) ? { isFakeCaret: true } : {};
          if (!selection.isCollapsed()) {
            const end3 = getPoint(dom2, trim2, normalized, rng, false);
            return {
              start: start4,
              end: end3,
              forward,
              ...fakeCaret
            };
          } else {
            return {
              start: start4,
              forward,
              ...fakeCaret
            };
          }
        };
        const findIndex = (dom2, name2, element) => {
          let count2 = 0;
          Tools.each(dom2.select(name2), (node) => {
            if (node.getAttribute("data-mce-bogus") === "all") {
              return;
            } else if (node === element) {
              return false;
            } else {
              count2++;
              return;
            }
          });
          return count2;
        };
        const moveEndPoint$1 = (rng, start4) => {
          let container = start4 ? rng.startContainer : rng.endContainer;
          let offset2 = start4 ? rng.startOffset : rng.endOffset;
          if (isElement$6(container) && container.nodeName === "TR") {
            const childNodes = container.childNodes;
            container = childNodes[Math.min(start4 ? offset2 : offset2 - 1, childNodes.length - 1)];
            if (container) {
              offset2 = start4 ? 0 : container.childNodes.length;
              if (start4) {
                rng.setStart(container, offset2);
              } else {
                rng.setEnd(container, offset2);
              }
            }
          }
        };
        const normalizeTableCellSelection = (rng) => {
          moveEndPoint$1(rng, true);
          moveEndPoint$1(rng, false);
          return rng;
        };
        const findSibling = (node, offset2) => {
          if (isElement$6(node)) {
            node = getNode$1(node, offset2);
            if (isContentEditableFalse$9(node)) {
              return node;
            }
          }
          if (isCaretContainer$2(node)) {
            if (isText$a(node) && isCaretContainerBlock$1(node)) {
              node = node.parentNode;
            }
            let sibling2 = node.previousSibling;
            if (isContentEditableFalse$9(sibling2)) {
              return sibling2;
            }
            sibling2 = node.nextSibling;
            if (isContentEditableFalse$9(sibling2)) {
              return sibling2;
            }
          }
          return void 0;
        };
        const findAdjacentContentEditableFalseElm = (rng) => {
          return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);
        };
        const getOffsetBookmark = (trim2, normalized, selection) => {
          const element = selection.getNode();
          const rng = selection.getRng();
          if (element.nodeName === "IMG" || isContentEditableFalse$9(element)) {
            const name2 = element.nodeName;
            return {
              name: name2,
              index: findIndex(selection.dom, name2, element)
            };
          }
          const sibling2 = findAdjacentContentEditableFalseElm(rng);
          if (sibling2) {
            const name2 = sibling2.tagName;
            return {
              name: name2,
              index: findIndex(selection.dom, name2, sibling2)
            };
          }
          return getLocation(trim2, selection, normalized, rng);
        };
        const getCaretBookmark = (selection) => {
          const rng = selection.getRng();
          return {
            start: create$b(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),
            end: create$b(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng)),
            forward: selection.isForward()
          };
        };
        const getRangeBookmark = (selection) => {
          return {
            rng: selection.getRng(),
            forward: selection.isForward()
          };
        };
        const createBookmarkSpan = (dom2, id, filled) => {
          const args = {
            "data-mce-type": "bookmark",
            id,
            "style": "overflow:hidden;line-height:0px"
          };
          return filled ? dom2.create("span", args, "&#xFEFF;") : dom2.create("span", args);
        };
        const getPersistentBookmark = (selection, filled) => {
          const dom2 = selection.dom;
          let rng = selection.getRng();
          const id = dom2.uniqueId();
          const collapsed = selection.isCollapsed();
          const element = selection.getNode();
          const name2 = element.nodeName;
          const forward = selection.isForward();
          if (name2 === "IMG") {
            return {
              name: name2,
              index: findIndex(dom2, name2, element)
            };
          }
          const rng2 = normalizeTableCellSelection(rng.cloneRange());
          if (!collapsed) {
            rng2.collapse(false);
            const endBookmarkNode = createBookmarkSpan(dom2, id + "_end", filled);
            rangeInsertNode(dom2, rng2, endBookmarkNode);
          }
          rng = normalizeTableCellSelection(rng);
          rng.collapse(true);
          const startBookmarkNode = createBookmarkSpan(dom2, id + "_start", filled);
          rangeInsertNode(dom2, rng, startBookmarkNode);
          selection.moveToBookmark({
            id,
            keep: true,
            forward
          });
          return {
            id,
            forward
          };
        };
        const getBookmark$2 = (selection, type2, normalized = false) => {
          if (type2 === 2) {
            return getOffsetBookmark(trim$1, normalized, selection);
          } else if (type2 === 3) {
            return getCaretBookmark(selection);
          } else if (type2) {
            return getRangeBookmark(selection);
          } else {
            return getPersistentBookmark(selection, false);
          }
        };
        const getUndoBookmark = curry(getOffsetBookmark, identity, true);
        const value$1 = (value2) => {
          const applyHelper = (fn2) => fn2(value2);
          const constHelper = constant(value2);
          const outputHelper = () => output;
          const output = {
            tag: true,
            inner: value2,
            fold: (_onError, onValue) => onValue(value2),
            isValue: always,
            isError: never,
            map: (mapper) => Result.value(mapper(value2)),
            mapError: outputHelper,
            bind: applyHelper,
            exists: applyHelper,
            forall: applyHelper,
            getOr: constHelper,
            or: outputHelper,
            getOrThunk: constHelper,
            orThunk: outputHelper,
            getOrDie: constHelper,
            each: (fn2) => {
              fn2(value2);
            },
            toOptional: () => Optional.some(value2)
          };
          return output;
        };
        const error2 = (error3) => {
          const outputHelper = () => output;
          const output = {
            tag: false,
            inner: error3,
            fold: (onError, _onValue) => onError(error3),
            isValue: never,
            isError: always,
            map: outputHelper,
            mapError: (mapper) => Result.error(mapper(error3)),
            bind: outputHelper,
            exists: never,
            forall: always,
            getOr: identity,
            or: identity,
            getOrThunk: apply$1,
            orThunk: apply$1,
            getOrDie: die(String(error3)),
            each: noop2,
            toOptional: Optional.none
          };
          return output;
        };
        const fromOption = (optional, err) => optional.fold(() => error2(err), value$1);
        const Result = {
          value: value$1,
          error: error2,
          fromOption
        };
        const generate = (cases) => {
          if (!isArray$1(cases)) {
            throw new Error("cases must be an array");
          }
          if (cases.length === 0) {
            throw new Error("there must be at least one case");
          }
          const constructors = [];
          const adt2 = {};
          each$e(cases, (acase, count2) => {
            const keys$1 = keys(acase);
            if (keys$1.length !== 1) {
              throw new Error("one and only one name per case");
            }
            const key = keys$1[0];
            const value2 = acase[key];
            if (adt2[key] !== void 0) {
              throw new Error("duplicate key detected:" + key);
            } else if (key === "cata") {
              throw new Error("cannot have a case named cata (sorry)");
            } else if (!isArray$1(value2)) {
              throw new Error("case arguments must be an array");
            }
            constructors.push(key);
            adt2[key] = (...args) => {
              const argLength = args.length;
              if (argLength !== value2.length) {
                throw new Error("Wrong number of arguments to case " + key + ". Expected " + value2.length + " (" + value2 + "), got " + argLength);
              }
              const match2 = (branches) => {
                const branchKeys = keys(branches);
                if (constructors.length !== branchKeys.length) {
                  throw new Error("Wrong number of arguments to match. Expected: " + constructors.join(",") + "\nActual: " + branchKeys.join(","));
                }
                const allReqd = forall(constructors, (reqKey) => {
                  return contains$2(branchKeys, reqKey);
                });
                if (!allReqd) {
                  throw new Error("Not all branches were specified when using match. Specified: " + branchKeys.join(", ") + "\nRequired: " + constructors.join(", "));
                }
                return branches[key].apply(null, args);
              };
              return {
                fold: (...foldArgs) => {
                  if (foldArgs.length !== cases.length) {
                    throw new Error("Wrong number of arguments to fold. Expected " + cases.length + ", got " + foldArgs.length);
                  }
                  const target = foldArgs[count2];
                  return target.apply(null, args);
                },
                match: match2,
                log: (label) => {
                  console.log(label, {
                    constructors,
                    constructor: key,
                    params: args
                  });
                }
              };
            };
          });
          return adt2;
        };
        const Adt = { generate };
        Adt.generate([
          {
            bothErrors: [
              "error1",
              "error2"
            ]
          },
          {
            firstError: [
              "error1",
              "value2"
            ]
          },
          {
            secondError: [
              "value1",
              "error2"
            ]
          },
          {
            bothValues: [
              "value1",
              "value2"
            ]
          }
        ]);
        const partition$1 = (results) => {
          const errors = [];
          const values2 = [];
          each$e(results, (result) => {
            result.fold((err) => {
              errors.push(err);
            }, (value2) => {
              values2.push(value2);
            });
          });
          return {
            errors,
            values: values2
          };
        };
        const isInlinePattern = (pattern) => pattern.type === "inline-command" || pattern.type === "inline-format";
        const isBlockPattern = (pattern) => pattern.type === "block-command" || pattern.type === "block-format";
        const normalizePattern = (pattern) => {
          const err = (message) => Result.error({
            message,
            pattern
          });
          const formatOrCmd = (name2, onFormat, onCommand) => {
            if (pattern.format !== void 0) {
              let formats;
              if (isArray$1(pattern.format)) {
                if (!forall(pattern.format, isString)) {
                  return err(name2 + " pattern has non-string items in the `format` array");
                }
                formats = pattern.format;
              } else if (isString(pattern.format)) {
                formats = [pattern.format];
              } else {
                return err(name2 + " pattern has non-string `format` parameter");
              }
              return Result.value(onFormat(formats));
            } else if (pattern.cmd !== void 0) {
              if (!isString(pattern.cmd)) {
                return err(name2 + " pattern has non-string `cmd` parameter");
              }
              return Result.value(onCommand(pattern.cmd, pattern.value));
            } else {
              return err(name2 + " pattern is missing both `format` and `cmd` parameters");
            }
          };
          if (!isObject(pattern)) {
            return err("Raw pattern is not an object");
          }
          if (!isString(pattern.start)) {
            return err("Raw pattern is missing `start` parameter");
          }
          if (pattern.end !== void 0) {
            if (!isString(pattern.end)) {
              return err("Inline pattern has non-string `end` parameter");
            }
            if (pattern.start.length === 0 && pattern.end.length === 0) {
              return err("Inline pattern has empty `start` and `end` parameters");
            }
            let start4 = pattern.start;
            let end3 = pattern.end;
            if (end3.length === 0) {
              end3 = start4;
              start4 = "";
            }
            return formatOrCmd("Inline", (format) => ({
              type: "inline-format",
              start: start4,
              end: end3,
              format
            }), (cmd, value2) => ({
              type: "inline-command",
              start: start4,
              end: end3,
              cmd,
              value: value2
            }));
          } else if (pattern.replacement !== void 0) {
            if (!isString(pattern.replacement)) {
              return err("Replacement pattern has non-string `replacement` parameter");
            }
            if (pattern.start.length === 0) {
              return err("Replacement pattern has empty `start` parameter");
            }
            return Result.value({
              type: "inline-command",
              start: "",
              end: pattern.start,
              cmd: "mceInsertContent",
              value: pattern.replacement
            });
          } else {
            if (pattern.start.length === 0) {
              return err("Block pattern has empty `start` parameter");
            }
            return formatOrCmd("Block", (formats) => ({
              type: "block-format",
              start: pattern.start,
              format: formats[0]
            }), (command, commandValue) => ({
              type: "block-command",
              start: pattern.start,
              cmd: command,
              value: commandValue
            }));
          }
        };
        const getBlockPatterns = (patterns) => filter$5(patterns, isBlockPattern);
        const getInlinePatterns = (patterns) => filter$5(patterns, isInlinePattern);
        const createPatternSet = (patterns, dynamicPatternsLookup) => ({
          inlinePatterns: getInlinePatterns(patterns),
          blockPatterns: getBlockPatterns(patterns),
          dynamicPatternsLookup
        });
        const fromRawPatterns = (patterns) => {
          const normalized = partition$1(map$3(patterns, normalizePattern));
          each$e(normalized.errors, (err) => console.error(err.message, err.pattern));
          return normalized.values;
        };
        const fromRawPatternsLookup = (lookupFn) => {
          return (ctx) => {
            const rawPatterns = lookupFn(ctx);
            return fromRawPatterns(rawPatterns);
          };
        };
        const deviceDetection$1 = detect$2().deviceType;
        const isTouch = deviceDetection$1.isTouch();
        const DOM$a = DOMUtils.DOM;
        const getHash = (value2) => {
          const items = value2.indexOf("=") > 0 ? value2.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value2.split(",");
          return foldl(items, (output, item) => {
            const arr = item.split("=");
            const key = arr[0];
            const val = arr.length > 1 ? arr[1] : key;
            output[trim$3(key)] = trim$3(val);
            return output;
          }, {});
        };
        const isRegExp = (x2) => is$4(x2, RegExp);
        const option = (name2) => (editor) => editor.options.get(name2);
        const stringOrObjectProcessor = (value2) => isString(value2) || isObject(value2);
        const bodyOptionProcessor = (editor, defaultValue = "") => (value2) => {
          const valid = isString(value2);
          if (valid) {
            if (value2.indexOf("=") !== -1) {
              const bodyObj = getHash(value2);
              return {
                value: get$a(bodyObj, editor.id).getOr(defaultValue),
                valid
              };
            } else {
              return {
                value: value2,
                valid
              };
            }
          } else {
            return {
              valid: false,
              message: "Must be a string."
            };
          }
        };
        const register$7 = (editor) => {
          const registerOption = editor.options.register;
          registerOption("id", {
            processor: "string",
            default: editor.id
          });
          registerOption("selector", { processor: "string" });
          registerOption("target", { processor: "object" });
          registerOption("suffix", { processor: "string" });
          registerOption("cache_suffix", { processor: "string" });
          registerOption("base_url", { processor: "string" });
          registerOption("referrer_policy", {
            processor: "string",
            default: ""
          });
          registerOption("language_load", {
            processor: "boolean",
            default: true
          });
          registerOption("inline", {
            processor: "boolean",
            default: false
          });
          registerOption("iframe_attrs", {
            processor: "object",
            default: {}
          });
          registerOption("doctype", {
            processor: "string",
            default: "<!DOCTYPE html>"
          });
          registerOption("document_base_url", {
            processor: "string",
            default: editor.documentBaseUrl
          });
          registerOption("body_id", {
            processor: bodyOptionProcessor(editor, "tinymce"),
            default: "tinymce"
          });
          registerOption("body_class", {
            processor: bodyOptionProcessor(editor),
            default: ""
          });
          registerOption("content_security_policy", {
            processor: "string",
            default: ""
          });
          registerOption("br_in_pre", {
            processor: "boolean",
            default: true
          });
          registerOption("forced_root_block", {
            processor: (value2) => {
              const valid = isString(value2) && isNotEmpty(value2);
              if (valid) {
                return {
                  value: value2,
                  valid
                };
              } else {
                return {
                  valid: false,
                  message: "Must be a non-empty string."
                };
              }
            },
            default: "p"
          });
          registerOption("forced_root_block_attrs", {
            processor: "object",
            default: {}
          });
          registerOption("newline_behavior", {
            processor: (value2) => {
              const valid = contains$2([
                "block",
                "linebreak",
                "invert",
                "default"
              ], value2);
              return valid ? {
                value: value2,
                valid
              } : {
                valid: false,
                message: "Must be one of: block, linebreak, invert or default."
              };
            },
            default: "default"
          });
          registerOption("br_newline_selector", {
            processor: "string",
            default: ".mce-toc h2,figcaption,caption"
          });
          registerOption("no_newline_selector", {
            processor: "string",
            default: ""
          });
          registerOption("keep_styles", {
            processor: "boolean",
            default: true
          });
          registerOption("end_container_on_empty_block", {
            processor: (value2) => {
              if (isBoolean(value2)) {
                return {
                  valid: true,
                  value: value2
                };
              } else if (isString(value2)) {
                return {
                  valid: true,
                  value: value2
                };
              } else {
                return {
                  valid: false,
                  message: "Must be boolean or a string"
                };
              }
            },
            default: "blockquote"
          });
          registerOption("font_size_style_values", {
            processor: "string",
            default: "xx-small,x-small,small,medium,large,x-large,xx-large"
          });
          registerOption("font_size_legacy_values", {
            processor: "string",
            default: "xx-small,small,medium,large,x-large,xx-large,300%"
          });
          registerOption("font_size_classes", {
            processor: "string",
            default: ""
          });
          registerOption("automatic_uploads", {
            processor: "boolean",
            default: true
          });
          registerOption("images_reuse_filename", {
            processor: "boolean",
            default: false
          });
          registerOption("images_replace_blob_uris", {
            processor: "boolean",
            default: true
          });
          registerOption("icons", {
            processor: "string",
            default: ""
          });
          registerOption("icons_url", {
            processor: "string",
            default: ""
          });
          registerOption("images_upload_url", {
            processor: "string",
            default: ""
          });
          registerOption("images_upload_base_path", {
            processor: "string",
            default: ""
          });
          registerOption("images_upload_credentials", {
            processor: "boolean",
            default: false
          });
          registerOption("images_upload_handler", { processor: "function" });
          registerOption("language", {
            processor: "string",
            default: "en"
          });
          registerOption("language_url", {
            processor: "string",
            default: ""
          });
          registerOption("entity_encoding", {
            processor: "string",
            default: "named"
          });
          registerOption("indent", {
            processor: "boolean",
            default: true
          });
          registerOption("indent_before", {
            processor: "string",
            default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
          });
          registerOption("indent_after", {
            processor: "string",
            default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
          });
          registerOption("indent_use_margin", {
            processor: "boolean",
            default: false
          });
          registerOption("indentation", {
            processor: "string",
            default: "40px"
          });
          registerOption("content_css", {
            processor: (value2) => {
              const valid = value2 === false || isString(value2) || isArrayOf(value2, isString);
              if (valid) {
                if (isString(value2)) {
                  return {
                    value: map$3(value2.split(","), trim$3),
                    valid
                  };
                } else if (isArray$1(value2)) {
                  return {
                    value: value2,
                    valid
                  };
                } else if (value2 === false) {
                  return {
                    value: [],
                    valid
                  };
                } else {
                  return {
                    value: value2,
                    valid
                  };
                }
              } else {
                return {
                  valid: false,
                  message: "Must be false, a string or an array of strings."
                };
              }
            },
            default: isInline(editor) ? [] : ["default"]
          });
          registerOption("content_style", { processor: "string" });
          registerOption("content_css_cors", {
            processor: "boolean",
            default: false
          });
          registerOption("font_css", {
            processor: (value2) => {
              const valid = isString(value2) || isArrayOf(value2, isString);
              if (valid) {
                const newValue = isArray$1(value2) ? value2 : map$3(value2.split(","), trim$3);
                return {
                  value: newValue,
                  valid
                };
              } else {
                return {
                  valid: false,
                  message: "Must be a string or an array of strings."
                };
              }
            },
            default: []
          });
          registerOption("inline_boundaries", {
            processor: "boolean",
            default: true
          });
          registerOption("inline_boundaries_selector", {
            processor: "string",
            default: "a[href],code,span.mce-annotation"
          });
          registerOption("object_resizing", {
            processor: (value2) => {
              const valid = isBoolean(value2) || isString(value2);
              if (valid) {
                if (value2 === false || deviceDetection$1.isiPhone() || deviceDetection$1.isiPad()) {
                  return {
                    value: "",
                    valid
                  };
                } else {
                  return {
                    value: value2 === true ? "table,img,figure.image,div,video,iframe" : value2,
                    valid
                  };
                }
              } else {
                return {
                  valid: false,
                  message: "Must be boolean or a string"
                };
              }
            },
            default: !isTouch
          });
          registerOption("resize_img_proportional", {
            processor: "boolean",
            default: true
          });
          registerOption("event_root", { processor: "object" });
          registerOption("service_message", { processor: "string" });
          registerOption("theme", {
            processor: (value2) => value2 === false || isString(value2) || isFunction(value2),
            default: "silver"
          });
          registerOption("theme_url", { processor: "string" });
          registerOption("formats", { processor: "object" });
          registerOption("format_empty_lines", {
            processor: "boolean",
            default: false
          });
          registerOption("format_noneditable_selector", {
            processor: "string",
            default: ""
          });
          registerOption("preview_styles", {
            processor: (value2) => {
              const valid = value2 === false || isString(value2);
              if (valid) {
                return {
                  value: value2 === false ? "" : value2,
                  valid
                };
              } else {
                return {
                  valid: false,
                  message: "Must be false or a string"
                };
              }
            },
            default: "font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow"
          });
          registerOption("custom_ui_selector", {
            processor: "string",
            default: ""
          });
          registerOption("hidden_input", {
            processor: "boolean",
            default: true
          });
          registerOption("submit_patch", {
            processor: "boolean",
            default: true
          });
          registerOption("encoding", { processor: "string" });
          registerOption("add_form_submit_trigger", {
            processor: "boolean",
            default: true
          });
          registerOption("add_unload_trigger", {
            processor: "boolean",
            default: true
          });
          registerOption("custom_undo_redo_levels", {
            processor: "number",
            default: 0
          });
          registerOption("disable_nodechange", {
            processor: "boolean",
            default: false
          });
          registerOption("readonly", {
            processor: "boolean",
            default: false
          });
          registerOption("editable_root", {
            processor: "boolean",
            default: true
          });
          registerOption("plugins", {
            processor: "string[]",
            default: []
          });
          registerOption("external_plugins", { processor: "object" });
          registerOption("forced_plugins", { processor: "string[]" });
          registerOption("model", {
            processor: "string",
            default: editor.hasPlugin("rtc") ? "plugin" : "dom"
          });
          registerOption("model_url", { processor: "string" });
          registerOption("block_unsupported_drop", {
            processor: "boolean",
            default: true
          });
          registerOption("visual", {
            processor: "boolean",
            default: true
          });
          registerOption("visual_table_class", {
            processor: "string",
            default: "mce-item-table"
          });
          registerOption("visual_anchor_class", {
            processor: "string",
            default: "mce-item-anchor"
          });
          registerOption("iframe_aria_text", {
            processor: "string",
            default: "Rich Text Area. Press ALT-0 for help."
          });
          registerOption("setup", { processor: "function" });
          registerOption("init_instance_callback", { processor: "function" });
          registerOption("url_converter", {
            processor: "function",
            default: editor.convertURL
          });
          registerOption("url_converter_scope", {
            processor: "object",
            default: editor
          });
          registerOption("urlconverter_callback", { processor: "function" });
          registerOption("allow_conditional_comments", {
            processor: "boolean",
            default: false
          });
          registerOption("allow_html_data_urls", {
            processor: "boolean",
            default: false
          });
          registerOption("allow_svg_data_urls", { processor: "boolean" });
          registerOption("allow_html_in_named_anchor", {
            processor: "boolean",
            default: false
          });
          registerOption("allow_script_urls", {
            processor: "boolean",
            default: false
          });
          registerOption("allow_unsafe_link_target", {
            processor: "boolean",
            default: false
          });
          registerOption("convert_fonts_to_spans", {
            processor: "boolean",
            default: true,
            deprecated: true
          });
          registerOption("fix_list_elements", {
            processor: "boolean",
            default: false
          });
          registerOption("preserve_cdata", {
            processor: "boolean",
            default: false
          });
          registerOption("remove_trailing_brs", {
            processor: "boolean",
            default: true
          });
          registerOption("inline_styles", {
            processor: "boolean",
            default: true,
            deprecated: true
          });
          registerOption("element_format", {
            processor: "string",
            default: "html"
          });
          registerOption("entities", { processor: "string" });
          registerOption("schema", {
            processor: "string",
            default: "html5"
          });
          registerOption("convert_urls", {
            processor: "boolean",
            default: true
          });
          registerOption("relative_urls", {
            processor: "boolean",
            default: true
          });
          registerOption("remove_script_host", {
            processor: "boolean",
            default: true
          });
          registerOption("custom_elements", { processor: "string" });
          registerOption("extended_valid_elements", { processor: "string" });
          registerOption("invalid_elements", { processor: "string" });
          registerOption("invalid_styles", { processor: stringOrObjectProcessor });
          registerOption("valid_children", { processor: "string" });
          registerOption("valid_classes", { processor: stringOrObjectProcessor });
          registerOption("valid_elements", { processor: "string" });
          registerOption("valid_styles", { processor: stringOrObjectProcessor });
          registerOption("verify_html", {
            processor: "boolean",
            default: true
          });
          registerOption("auto_focus", { processor: (value2) => isString(value2) || value2 === true });
          registerOption("browser_spellcheck", {
            processor: "boolean",
            default: false
          });
          registerOption("protect", { processor: "array" });
          registerOption("images_file_types", {
            processor: "string",
            default: "jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp"
          });
          registerOption("deprecation_warnings", {
            processor: "boolean",
            default: true
          });
          registerOption("a11y_advanced_options", {
            processor: "boolean",
            default: false
          });
          registerOption("api_key", { processor: "string" });
          registerOption("paste_block_drop", {
            processor: "boolean",
            default: false
          });
          registerOption("paste_data_images", {
            processor: "boolean",
            default: true
          });
          registerOption("paste_preprocess", { processor: "function" });
          registerOption("paste_postprocess", { processor: "function" });
          registerOption("paste_webkit_styles", {
            processor: "string",
            default: "none"
          });
          registerOption("paste_remove_styles_if_webkit", {
            processor: "boolean",
            default: true
          });
          registerOption("paste_merge_formats", {
            processor: "boolean",
            default: true
          });
          registerOption("smart_paste", {
            processor: "boolean",
            default: true
          });
          registerOption("paste_as_text", {
            processor: "boolean",
            default: false
          });
          registerOption("paste_tab_spaces", {
            processor: "number",
            default: 4
          });
          registerOption("text_patterns", {
            processor: (value2) => {
              if (isArrayOf(value2, isObject) || value2 === false) {
                const patterns = value2 === false ? [] : value2;
                return {
                  value: fromRawPatterns(patterns),
                  valid: true
                };
              } else {
                return {
                  valid: false,
                  message: "Must be an array of objects or false."
                };
              }
            },
            default: [
              {
                start: "*",
                end: "*",
                format: "italic"
              },
              {
                start: "**",
                end: "**",
                format: "bold"
              },
              {
                start: "#",
                format: "h1"
              },
              {
                start: "##",
                format: "h2"
              },
              {
                start: "###",
                format: "h3"
              },
              {
                start: "####",
                format: "h4"
              },
              {
                start: "#####",
                format: "h5"
              },
              {
                start: "######",
                format: "h6"
              },
              {
                start: "1. ",
                cmd: "InsertOrderedList"
              },
              {
                start: "* ",
                cmd: "InsertUnorderedList"
              },
              {
                start: "- ",
                cmd: "InsertUnorderedList"
              }
            ]
          });
          registerOption("text_patterns_lookup", {
            processor: (value2) => {
              if (isFunction(value2)) {
                return {
                  value: fromRawPatternsLookup(value2),
                  valid: true
                };
              } else {
                return {
                  valid: false,
                  message: "Must be a single function"
                };
              }
            },
            default: (_ctx) => []
          });
          registerOption("noneditable_class", {
            processor: "string",
            default: "mceNonEditable"
          });
          registerOption("editable_class", {
            processor: "string",
            default: "mceEditable"
          });
          registerOption("noneditable_regexp", {
            processor: (value2) => {
              if (isArrayOf(value2, isRegExp)) {
                return {
                  value: value2,
                  valid: true
                };
              } else if (isRegExp(value2)) {
                return {
                  value: [value2],
                  valid: true
                };
              } else {
                return {
                  valid: false,
                  message: "Must be a RegExp or an array of RegExp."
                };
              }
            },
            default: []
          });
          registerOption("table_tab_navigation", {
            processor: "boolean",
            default: true
          });
          registerOption("highlight_on_focus", {
            processor: "boolean",
            default: false
          });
          registerOption("xss_sanitization", {
            processor: "boolean",
            default: true
          });
          registerOption("details_initial_state", {
            processor: (value2) => {
              const valid = contains$2([
                "inherited",
                "collapsed",
                "expanded"
              ], value2);
              return valid ? {
                value: value2,
                valid
              } : {
                valid: false,
                message: "Must be one of: inherited, collapsed, or expanded."
              };
            },
            default: "inherited"
          });
          registerOption("details_serialized_state", {
            processor: (value2) => {
              const valid = contains$2([
                "inherited",
                "collapsed",
                "expanded"
              ], value2);
              return valid ? {
                value: value2,
                valid
              } : {
                valid: false,
                message: "Must be one of: inherited, collapsed, or expanded."
              };
            },
            default: "inherited"
          });
          registerOption("init_content_sync", {
            processor: "boolean",
            default: false
          });
          registerOption("newdocument_content", {
            processor: "string",
            default: ""
          });
          editor.on("ScriptsLoaded", () => {
            registerOption("directionality", {
              processor: "string",
              default: I18n.isRtl() ? "rtl" : void 0
            });
            registerOption("placeholder", {
              processor: "string",
              default: DOM$a.getAttrib(editor.getElement(), "placeholder")
            });
          });
        };
        const getIframeAttrs = option("iframe_attrs");
        const getDocType = option("doctype");
        const getDocumentBaseUrl = option("document_base_url");
        const getBodyId = option("body_id");
        const getBodyClass = option("body_class");
        const getContentSecurityPolicy = option("content_security_policy");
        const shouldPutBrInPre$1 = option("br_in_pre");
        const getForcedRootBlock = option("forced_root_block");
        const getForcedRootBlockAttrs = option("forced_root_block_attrs");
        const getNewlineBehavior = option("newline_behavior");
        const getBrNewLineSelector = option("br_newline_selector");
        const getNoNewLineSelector = option("no_newline_selector");
        const shouldKeepStyles = option("keep_styles");
        const shouldEndContainerOnEmptyBlock = option("end_container_on_empty_block");
        const isAutomaticUploadsEnabled = option("automatic_uploads");
        const shouldReuseFileName = option("images_reuse_filename");
        const shouldReplaceBlobUris = option("images_replace_blob_uris");
        const getIconPackName = option("icons");
        const getIconsUrl = option("icons_url");
        const getImageUploadUrl = option("images_upload_url");
        const getImageUploadBasePath = option("images_upload_base_path");
        const getImagesUploadCredentials = option("images_upload_credentials");
        const getImagesUploadHandler = option("images_upload_handler");
        const shouldUseContentCssCors = option("content_css_cors");
        const getReferrerPolicy = option("referrer_policy");
        const getLanguageCode = option("language");
        const getLanguageUrl = option("language_url");
        const shouldIndentUseMargin = option("indent_use_margin");
        const getIndentation = option("indentation");
        const getContentCss = option("content_css");
        const getContentStyle = option("content_style");
        const getFontCss = option("font_css");
        const getDirectionality = option("directionality");
        const getInlineBoundarySelector = option("inline_boundaries_selector");
        const getObjectResizing = option("object_resizing");
        const getResizeImgProportional = option("resize_img_proportional");
        const getPlaceholder = option("placeholder");
        const getEventRoot = option("event_root");
        const getServiceMessage = option("service_message");
        const getTheme = option("theme");
        const getThemeUrl = option("theme_url");
        const getModel = option("model");
        const getModelUrl = option("model_url");
        const isInlineBoundariesEnabled = option("inline_boundaries");
        const getFormats = option("formats");
        const getPreviewStyles = option("preview_styles");
        const canFormatEmptyLines = option("format_empty_lines");
        const getFormatNoneditableSelector = option("format_noneditable_selector");
        const getCustomUiSelector = option("custom_ui_selector");
        const isInline = option("inline");
        const hasHiddenInput = option("hidden_input");
        const shouldPatchSubmit = option("submit_patch");
        const shouldAddFormSubmitTrigger = option("add_form_submit_trigger");
        const shouldAddUnloadTrigger = option("add_unload_trigger");
        const getCustomUndoRedoLevels = option("custom_undo_redo_levels");
        const shouldDisableNodeChange = option("disable_nodechange");
        const isReadOnly$1 = option("readonly");
        const hasEditableRoot$1 = option("editable_root");
        const hasContentCssCors = option("content_css_cors");
        const getPlugins = option("plugins");
        const getExternalPlugins$1 = option("external_plugins");
        const shouldBlockUnsupportedDrop = option("block_unsupported_drop");
        const isVisualAidsEnabled = option("visual");
        const getVisualAidsTableClass = option("visual_table_class");
        const getVisualAidsAnchorClass = option("visual_anchor_class");
        const getIframeAriaText = option("iframe_aria_text");
        const getSetupCallback = option("setup");
        const getInitInstanceCallback = option("init_instance_callback");
        const getUrlConverterCallback = option("urlconverter_callback");
        const getAutoFocus = option("auto_focus");
        const shouldBrowserSpellcheck = option("browser_spellcheck");
        const getProtect = option("protect");
        const shouldPasteBlockDrop = option("paste_block_drop");
        const shouldPasteDataImages = option("paste_data_images");
        const getPastePreProcess = option("paste_preprocess");
        const getPastePostProcess = option("paste_postprocess");
        const getNewDocumentContent = option("newdocument_content");
        const getPasteWebkitStyles = option("paste_webkit_styles");
        const shouldPasteRemoveWebKitStyles = option("paste_remove_styles_if_webkit");
        const shouldPasteMergeFormats = option("paste_merge_formats");
        const isSmartPasteEnabled = option("smart_paste");
        const isPasteAsTextEnabled = option("paste_as_text");
        const getPasteTabSpaces = option("paste_tab_spaces");
        const shouldAllowHtmlDataUrls = option("allow_html_data_urls");
        const getTextPatterns = option("text_patterns");
        const getTextPatternsLookup = option("text_patterns_lookup");
        const getNonEditableClass = option("noneditable_class");
        const getEditableClass = option("editable_class");
        const getNonEditableRegExps = option("noneditable_regexp");
        const shouldPreserveCData = option("preserve_cdata");
        const shouldHighlightOnFocus = option("highlight_on_focus");
        const shouldSanitizeXss = option("xss_sanitization");
        const shouldUseDocumentWrite = option("init_content_sync");
        const hasTextPatternsLookup = (editor) => editor.options.isSet("text_patterns_lookup");
        const getFontStyleValues = (editor) => Tools.explode(editor.options.get("font_size_style_values"));
        const getFontSizeClasses = (editor) => Tools.explode(editor.options.get("font_size_classes"));
        const isEncodingXml = (editor) => editor.options.get("encoding") === "xml";
        const getAllowedImageFileTypes = (editor) => Tools.explode(editor.options.get("images_file_types"));
        const hasTableTabNavigation = option("table_tab_navigation");
        const getDetailsInitialState = option("details_initial_state");
        const getDetailsSerializedState = option("details_serialized_state");
        const isElement$3 = isElement$6;
        const isText$5 = isText$a;
        const removeNode$1 = (node) => {
          const parentNode = node.parentNode;
          if (parentNode) {
            parentNode.removeChild(node);
          }
        };
        const trimCount = (text2) => {
          const trimmedText = trim$1(text2);
          return {
            count: text2.length - trimmedText.length,
            text: trimmedText
          };
        };
        const deleteZwspChars = (caretContainer) => {
          let idx;
          while ((idx = caretContainer.data.lastIndexOf(ZWSP$1)) !== -1) {
            caretContainer.deleteData(idx, 1);
          }
        };
        const removeUnchanged = (caretContainer, pos) => {
          remove$3(caretContainer);
          return pos;
        };
        const removeTextAndReposition = (caretContainer, pos) => {
          const before2 = trimCount(caretContainer.data.substr(0, pos.offset()));
          const after2 = trimCount(caretContainer.data.substr(pos.offset()));
          const text2 = before2.text + after2.text;
          if (text2.length > 0) {
            deleteZwspChars(caretContainer);
            return CaretPosition(caretContainer, pos.offset() - before2.count);
          } else {
            return pos;
          }
        };
        const removeElementAndReposition = (caretContainer, pos) => {
          const parentNode = pos.container();
          const newPosition = indexOf$1(from(parentNode.childNodes), caretContainer).map((index) => {
            return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;
          }).getOr(pos);
          remove$3(caretContainer);
          return newPosition;
        };
        const removeTextCaretContainer = (caretContainer, pos) => isText$5(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
        const removeElementCaretContainer = (caretContainer, pos) => pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
        const removeAndReposition = (container, pos) => CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);
        const remove$3 = (caretContainerNode) => {
          if (isElement$3(caretContainerNode) && isCaretContainer$2(caretContainerNode)) {
            if (hasContent(caretContainerNode)) {
              caretContainerNode.removeAttribute("data-mce-caret");
            } else {
              removeNode$1(caretContainerNode);
            }
          }
          if (isText$5(caretContainerNode)) {
            deleteZwspChars(caretContainerNode);
            if (caretContainerNode.data.length === 0) {
              removeNode$1(caretContainerNode);
            }
          }
        };
        const isContentEditableFalse$8 = isContentEditableFalse$b;
        const isMedia$1 = isMedia$2;
        const isTableCell$1 = isTableCell$3;
        const inlineFakeCaretSelector = "*[contentEditable=false],video,audio,embed,object";
        const getAbsoluteClientRect = (root, element, before2) => {
          const clientRect = collapse(element.getBoundingClientRect(), before2);
          let scrollX;
          let scrollY;
          if (root.tagName === "BODY") {
            const docElm = root.ownerDocument.documentElement;
            scrollX = root.scrollLeft || docElm.scrollLeft;
            scrollY = root.scrollTop || docElm.scrollTop;
          } else {
            const rootRect = root.getBoundingClientRect();
            scrollX = root.scrollLeft - rootRect.left;
            scrollY = root.scrollTop - rootRect.top;
          }
          clientRect.left += scrollX;
          clientRect.right += scrollX;
          clientRect.top += scrollY;
          clientRect.bottom += scrollY;
          clientRect.width = 1;
          let margin = element.offsetWidth - element.clientWidth;
          if (margin > 0) {
            if (before2) {
              margin *= -1;
            }
            clientRect.left += margin;
            clientRect.right += margin;
          }
          return clientRect;
        };
        const trimInlineCaretContainers = (root) => {
          var _a, _b;
          const fakeCaretTargetNodes = descendants(SugarElement.fromDom(root), inlineFakeCaretSelector);
          for (let i2 = 0; i2 < fakeCaretTargetNodes.length; i2++) {
            const node = fakeCaretTargetNodes[i2].dom;
            let sibling2 = node.previousSibling;
            if (endsWithCaretContainer$1(sibling2)) {
              const data2 = sibling2.data;
              if (data2.length === 1) {
                (_a = sibling2.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(sibling2);
              } else {
                sibling2.deleteData(data2.length - 1, 1);
              }
            }
            sibling2 = node.nextSibling;
            if (startsWithCaretContainer$1(sibling2)) {
              const data2 = sibling2.data;
              if (data2.length === 1) {
                (_b = sibling2.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(sibling2);
              } else {
                sibling2.deleteData(0, 1);
              }
            }
          }
        };
        const FakeCaret = (editor, root, isBlock2, hasFocus2) => {
          const lastVisualCaret = value$2();
          let cursorInterval;
          let caretContainerNode;
          const caretBlock = getForcedRootBlock(editor);
          const dom2 = editor.dom;
          const show = (before2, element) => {
            let rng;
            hide2();
            if (isTableCell$1(element)) {
              return null;
            }
            if (isBlock2(element)) {
              const caretContainer = insertBlock(caretBlock, element, before2);
              const clientRect = getAbsoluteClientRect(root, element, before2);
              dom2.setStyle(caretContainer, "top", clientRect.top);
              caretContainerNode = caretContainer;
              const caret = dom2.create("div", {
                "class": "mce-visual-caret",
                "data-mce-bogus": "all"
              });
              dom2.setStyles(caret, { ...clientRect });
              dom2.add(root, caret);
              lastVisualCaret.set({
                caret,
                element,
                before: before2
              });
              if (before2) {
                dom2.addClass(caret, "mce-visual-caret-before");
              }
              startBlink();
              rng = element.ownerDocument.createRange();
              rng.setStart(caretContainer, 0);
              rng.setEnd(caretContainer, 0);
            } else {
              caretContainerNode = insertInline$1(element, before2);
              rng = element.ownerDocument.createRange();
              if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {
                rng.setStart(caretContainerNode, 0);
                rng.setEnd(caretContainerNode, 0);
              } else {
                rng.setStart(caretContainerNode, 1);
                rng.setEnd(caretContainerNode, 1);
              }
              return rng;
            }
            return rng;
          };
          const hide2 = () => {
            trimInlineCaretContainers(root);
            if (caretContainerNode) {
              remove$3(caretContainerNode);
              caretContainerNode = null;
            }
            lastVisualCaret.on((caretState) => {
              dom2.remove(caretState.caret);
              lastVisualCaret.clear();
            });
            if (cursorInterval) {
              clearInterval(cursorInterval);
              cursorInterval = void 0;
            }
          };
          const startBlink = () => {
            cursorInterval = setInterval(() => {
              lastVisualCaret.on((caretState) => {
                if (hasFocus2()) {
                  dom2.toggleClass(caretState.caret, "mce-visual-caret-hidden");
                } else {
                  dom2.addClass(caretState.caret, "mce-visual-caret-hidden");
                }
              });
            }, 500);
          };
          const reposition2 = () => {
            lastVisualCaret.on((caretState) => {
              const clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);
              dom2.setStyles(caretState.caret, { ...clientRect });
            });
          };
          const destroy2 = () => clearInterval(cursorInterval);
          const getCss = () => ".mce-visual-caret {position: absolute;background-color: black;background-color: currentcolor;}.mce-visual-caret-hidden {display: none;}*[data-mce-caret] {position: absolute;left: -1000px;right: auto;top: 0;margin: 0;padding: 0;}";
          return {
            show,
            hide: hide2,
            getCss,
            reposition: reposition2,
            destroy: destroy2
          };
        };
        const isFakeCaretTableBrowser = () => Env.browser.isFirefox();
        const isInlineFakeCaretTarget = (node) => isContentEditableFalse$8(node) || isMedia$1(node);
        const isFakeCaretTarget = (node) => {
          const isTarget2 = isInlineFakeCaretTarget(node) || isTable$2(node) && isFakeCaretTableBrowser();
          return isTarget2 && parentElement(SugarElement.fromDom(node)).exists(isEditable$3);
        };
        const isContentEditableTrue$1 = isContentEditableTrue$3;
        const isContentEditableFalse$7 = isContentEditableFalse$b;
        const isMedia = isMedia$2;
        const isBlockLike = matchStyleValues("display", "block table table-cell table-caption list-item");
        const isCaretContainer = isCaretContainer$2;
        const isCaretContainerBlock = isCaretContainerBlock$1;
        const isElement$2 = isElement$6;
        const isText$4 = isText$a;
        const isCaretCandidate$1 = isCaretCandidate$3;
        const isForwards = (direction) => direction > 0;
        const isBackwards = (direction) => direction < 0;
        const skipCaretContainers = (walk3, shallow2) => {
          let node;
          while (node = walk3(shallow2)) {
            if (!isCaretContainerBlock(node)) {
              return node;
            }
          }
          return null;
        };
        const findNode = (node, direction, predicateFn, rootNode, shallow2) => {
          const walker = new DomTreeWalker(node, rootNode);
          const isCefOrCaretContainer = isContentEditableFalse$7(node) || isCaretContainerBlock(node);
          let tempNode;
          if (isBackwards(direction)) {
            if (isCefOrCaretContainer) {
              tempNode = skipCaretContainers(walker.prev.bind(walker), true);
              if (predicateFn(tempNode)) {
                return tempNode;
              }
            }
            while (tempNode = skipCaretContainers(walker.prev.bind(walker), shallow2)) {
              if (predicateFn(tempNode)) {
                return tempNode;
              }
            }
          }
          if (isForwards(direction)) {
            if (isCefOrCaretContainer) {
              tempNode = skipCaretContainers(walker.next.bind(walker), true);
              if (predicateFn(tempNode)) {
                return tempNode;
              }
            }
            while (tempNode = skipCaretContainers(walker.next.bind(walker), shallow2)) {
              if (predicateFn(tempNode)) {
                return tempNode;
              }
            }
          }
          return null;
        };
        const getEditingHost = (node, rootNode) => {
          const isCETrue = (node2) => isContentEditableTrue$1(node2.dom);
          const isRoot2 = (node2) => node2.dom === rootNode;
          return ancestor$4(SugarElement.fromDom(node), isCETrue, isRoot2).map((elm) => elm.dom).getOr(rootNode);
        };
        const getParentBlock$3 = (node, rootNode) => {
          while (node && node !== rootNode) {
            if (isBlockLike(node)) {
              return node;
            }
            node = node.parentNode;
          }
          return null;
        };
        const isInSameBlock = (caretPosition1, caretPosition2, rootNode) => getParentBlock$3(caretPosition1.container(), rootNode) === getParentBlock$3(caretPosition2.container(), rootNode);
        const getChildNodeAtRelativeOffset = (relativeOffset, caretPosition) => {
          if (!caretPosition) {
            return Optional.none();
          }
          const container = caretPosition.container();
          const offset2 = caretPosition.offset();
          if (!isElement$2(container)) {
            return Optional.none();
          }
          return Optional.from(container.childNodes[offset2 + relativeOffset]);
        };
        const beforeAfter = (before2, node) => {
          var _a;
          const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
          const range2 = doc.createRange();
          if (before2) {
            range2.setStartBefore(node);
            range2.setEndBefore(node);
          } else {
            range2.setStartAfter(node);
            range2.setEndAfter(node);
          }
          return range2;
        };
        const isNodesInSameBlock = (root, node1, node2) => getParentBlock$3(node1, root) === getParentBlock$3(node2, root);
        const lean = (left2, root, node) => {
          const siblingName = left2 ? "previousSibling" : "nextSibling";
          let tempNode = node;
          while (tempNode && tempNode !== root) {
            let sibling2 = tempNode[siblingName];
            if (sibling2 && isCaretContainer(sibling2)) {
              sibling2 = sibling2[siblingName];
            }
            if (isContentEditableFalse$7(sibling2) || isMedia(sibling2)) {
              if (isNodesInSameBlock(root, sibling2, tempNode)) {
                return sibling2;
              }
              break;
            }
            if (isCaretCandidate$1(sibling2)) {
              break;
            }
            tempNode = tempNode.parentNode;
          }
          return null;
        };
        const before$2 = curry(beforeAfter, true);
        const after$2 = curry(beforeAfter, false);
        const normalizeRange = (direction, root, range2) => {
          let node;
          const leanLeft = curry(lean, true, root);
          const leanRight2 = curry(lean, false, root);
          const container = range2.startContainer;
          const offset2 = range2.startOffset;
          if (isCaretContainerBlock$1(container)) {
            const block = isText$4(container) ? container.parentNode : container;
            const location2 = block.getAttribute("data-mce-caret");
            if (location2 === "before") {
              node = block.nextSibling;
              if (isFakeCaretTarget(node)) {
                return before$2(node);
              }
            }
            if (location2 === "after") {
              node = block.previousSibling;
              if (isFakeCaretTarget(node)) {
                return after$2(node);
              }
            }
          }
          if (!range2.collapsed) {
            return range2;
          }
          if (isText$a(container)) {
            if (isCaretContainer(container)) {
              if (direction === 1) {
                node = leanRight2(container);
                if (node) {
                  return before$2(node);
                }
                node = leanLeft(container);
                if (node) {
                  return after$2(node);
                }
              }
              if (direction === -1) {
                node = leanLeft(container);
                if (node) {
                  return after$2(node);
                }
                node = leanRight2(container);
                if (node) {
                  return before$2(node);
                }
              }
              return range2;
            }
            if (endsWithCaretContainer$1(container) && offset2 >= container.data.length - 1) {
              if (direction === 1) {
                node = leanRight2(container);
                if (node) {
                  return before$2(node);
                }
              }
              return range2;
            }
            if (startsWithCaretContainer$1(container) && offset2 <= 1) {
              if (direction === -1) {
                node = leanLeft(container);
                if (node) {
                  return after$2(node);
                }
              }
              return range2;
            }
            if (offset2 === container.data.length) {
              node = leanRight2(container);
              if (node) {
                return before$2(node);
              }
              return range2;
            }
            if (offset2 === 0) {
              node = leanLeft(container);
              if (node) {
                return after$2(node);
              }
              return range2;
            }
          }
          return range2;
        };
        const getRelativeCefElm = (forward, caretPosition) => getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition).filter(isContentEditableFalse$7);
        const getNormalizedRangeEndPoint = (direction, root, range2) => {
          const normalizedRange = normalizeRange(direction, root, range2);
          return direction === -1 ? CaretPosition.fromRangeStart(normalizedRange) : CaretPosition.fromRangeEnd(normalizedRange);
        };
        const getElementFromPosition = (pos) => Optional.from(pos.getNode()).map(SugarElement.fromDom);
        const getElementFromPrevPosition = (pos) => Optional.from(pos.getNode(true)).map(SugarElement.fromDom);
        const getVisualCaretPosition = (walkFn, caretPosition) => {
          let pos = caretPosition;
          while (pos = walkFn(pos)) {
            if (pos.isVisible()) {
              return pos;
            }
          }
          return pos;
        };
        const isMoveInsideSameBlock = (from2, to) => {
          const inSameBlock = isInSameBlock(from2, to);
          if (!inSameBlock && isBr$6(from2.getNode())) {
            return true;
          }
          return inSameBlock;
        };
        var HDirection;
        (function(HDirection2) {
          HDirection2[HDirection2["Backwards"] = -1] = "Backwards";
          HDirection2[HDirection2["Forwards"] = 1] = "Forwards";
        })(HDirection || (HDirection = {}));
        const isContentEditableFalse$6 = isContentEditableFalse$b;
        const isText$3 = isText$a;
        const isElement$1 = isElement$6;
        const isBr$2 = isBr$6;
        const isCaretCandidate = isCaretCandidate$3;
        const isAtomic = isAtomic$1;
        const isEditableCaretCandidate = isEditableCaretCandidate$1;
        const getParents$3 = (node, root) => {
          const parents2 = [];
          let tempNode = node;
          while (tempNode && tempNode !== root) {
            parents2.push(tempNode);
            tempNode = tempNode.parentNode;
          }
          return parents2;
        };
        const nodeAtIndex = (container, offset2) => {
          if (container.hasChildNodes() && offset2 < container.childNodes.length) {
            return container.childNodes[offset2];
          }
          return null;
        };
        const getCaretCandidatePosition = (direction, node) => {
          if (isForwards(direction)) {
            if (isCaretCandidate(node.previousSibling) && !isText$3(node.previousSibling)) {
              return CaretPosition.before(node);
            }
            if (isText$3(node)) {
              return CaretPosition(node, 0);
            }
          }
          if (isBackwards(direction)) {
            if (isCaretCandidate(node.nextSibling) && !isText$3(node.nextSibling)) {
              return CaretPosition.after(node);
            }
            if (isText$3(node)) {
              return CaretPosition(node, node.data.length);
            }
          }
          if (isBackwards(direction)) {
            if (isBr$2(node)) {
              return CaretPosition.before(node);
            }
            return CaretPosition.after(node);
          }
          return CaretPosition.before(node);
        };
        const moveForwardFromBr = (root, nextNode) => {
          const nextSibling2 = nextNode.nextSibling;
          if (nextSibling2 && isCaretCandidate(nextSibling2)) {
            if (isText$3(nextSibling2)) {
              return CaretPosition(nextSibling2, 0);
            } else {
              return CaretPosition.before(nextSibling2);
            }
          } else {
            return findCaretPosition$1(HDirection.Forwards, CaretPosition.after(nextNode), root);
          }
        };
        const findCaretPosition$1 = (direction, startPos, root) => {
          let node;
          let nextNode;
          let innerNode;
          let caretPosition;
          if (!isElement$1(root) || !startPos) {
            return null;
          }
          if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {
            caretPosition = CaretPosition.after(root.lastChild);
            if (isBackwards(direction) && isCaretCandidate(root.lastChild) && isElement$1(root.lastChild)) {
              return isBr$2(root.lastChild) ? CaretPosition.before(root.lastChild) : caretPosition;
            }
          } else {
            caretPosition = startPos;
          }
          const container = caretPosition.container();
          let offset2 = caretPosition.offset();
          if (isText$3(container)) {
            if (isBackwards(direction) && offset2 > 0) {
              return CaretPosition(container, --offset2);
            }
            if (isForwards(direction) && offset2 < container.length) {
              return CaretPosition(container, ++offset2);
            }
            node = container;
          } else {
            if (isBackwards(direction) && offset2 > 0) {
              nextNode = nodeAtIndex(container, offset2 - 1);
              if (isCaretCandidate(nextNode)) {
                if (!isAtomic(nextNode)) {
                  innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
                  if (innerNode) {
                    if (isText$3(innerNode)) {
                      return CaretPosition(innerNode, innerNode.data.length);
                    }
                    return CaretPosition.after(innerNode);
                  }
                }
                if (isText$3(nextNode)) {
                  return CaretPosition(nextNode, nextNode.data.length);
                }
                return CaretPosition.before(nextNode);
              }
            }
            if (isForwards(direction) && offset2 < container.childNodes.length) {
              nextNode = nodeAtIndex(container, offset2);
              if (isCaretCandidate(nextNode)) {
                if (isBr$2(nextNode)) {
                  return moveForwardFromBr(root, nextNode);
                }
                if (!isAtomic(nextNode)) {
                  innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
                  if (innerNode) {
                    if (isText$3(innerNode)) {
                      return CaretPosition(innerNode, 0);
                    }
                    return CaretPosition.before(innerNode);
                  }
                }
                if (isText$3(nextNode)) {
                  return CaretPosition(nextNode, 0);
                }
                return CaretPosition.after(nextNode);
              }
            }
            node = nextNode ? nextNode : caretPosition.getNode();
          }
          if (node && (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart())) {
            node = findNode(node, direction, always, root, true);
            if (isEditableCaretCandidate(node, root)) {
              return getCaretCandidatePosition(direction, node);
            }
          }
          nextNode = node ? findNode(node, direction, isEditableCaretCandidate, root) : node;
          const rootContentEditableFalseElm = last$2(filter$5(getParents$3(container, root), isContentEditableFalse$6));
          if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {
            if (isForwards(direction)) {
              caretPosition = CaretPosition.after(rootContentEditableFalseElm);
            } else {
              caretPosition = CaretPosition.before(rootContentEditableFalseElm);
            }
            return caretPosition;
          }
          if (nextNode) {
            return getCaretCandidatePosition(direction, nextNode);
          }
          return null;
        };
        const CaretWalker = (root) => ({
          next: (caretPosition) => {
            return findCaretPosition$1(HDirection.Forwards, caretPosition, root);
          },
          prev: (caretPosition) => {
            return findCaretPosition$1(HDirection.Backwards, caretPosition, root);
          }
        });
        const walkToPositionIn = (forward, root, start4) => {
          const position = forward ? CaretPosition.before(start4) : CaretPosition.after(start4);
          return fromPosition(forward, root, position);
        };
        const afterElement = (node) => isBr$6(node) ? CaretPosition.before(node) : CaretPosition.after(node);
        const isBeforeOrStart = (position) => {
          if (CaretPosition.isTextPosition(position)) {
            return position.offset() === 0;
          } else {
            return isCaretCandidate$3(position.getNode());
          }
        };
        const isAfterOrEnd = (position) => {
          if (CaretPosition.isTextPosition(position)) {
            const container = position.container();
            return position.offset() === container.data.length;
          } else {
            return isCaretCandidate$3(position.getNode(true));
          }
        };
        const isBeforeAfterSameElement = (from2, to) => !CaretPosition.isTextPosition(from2) && !CaretPosition.isTextPosition(to) && from2.getNode() === to.getNode(true);
        const isAtBr = (position) => !CaretPosition.isTextPosition(position) && isBr$6(position.getNode());
        const shouldSkipPosition = (forward, from2, to) => {
          if (forward) {
            return !isBeforeAfterSameElement(from2, to) && !isAtBr(from2) && isAfterOrEnd(from2) && isBeforeOrStart(to);
          } else {
            return !isBeforeAfterSameElement(to, from2) && isBeforeOrStart(from2) && isAfterOrEnd(to);
          }
        };
        const fromPosition = (forward, root, pos) => {
          const walker = CaretWalker(root);
          return Optional.from(forward ? walker.next(pos) : walker.prev(pos));
        };
        const navigate = (forward, root, from2) => fromPosition(forward, root, from2).bind((to) => {
          if (isInSameBlock(from2, to, root) && shouldSkipPosition(forward, from2, to)) {
            return fromPosition(forward, root, to);
          } else {
            return Optional.some(to);
          }
        });
        const navigateIgnore = (forward, root, from2, ignoreFilter) => navigate(forward, root, from2).bind((pos) => ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Optional.some(pos));
        const positionIn = (forward, element) => {
          const startNode = forward ? element.firstChild : element.lastChild;
          if (isText$a(startNode)) {
            return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));
          } else if (startNode) {
            if (isCaretCandidate$3(startNode)) {
              return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));
            } else {
              return walkToPositionIn(forward, element, startNode);
            }
          } else {
            return Optional.none();
          }
        };
        const nextPosition = curry(fromPosition, true);
        const prevPosition = curry(fromPosition, false);
        const firstPositionIn = curry(positionIn, true);
        const lastPositionIn = curry(positionIn, false);
        const CARET_ID = "_mce_caret";
        const isCaretNode = (node) => isElement$6(node) && node.id === CARET_ID;
        const getParentCaretContainer = (body, node) => {
          let currentNode = node;
          while (currentNode && currentNode !== body) {
            if (isCaretNode(currentNode)) {
              return currentNode;
            }
            currentNode = currentNode.parentNode;
          }
          return null;
        };
        const isStringPathBookmark = (bookmark) => isString(bookmark.start);
        const isRangeBookmark = (bookmark) => has$2(bookmark, "rng");
        const isIdBookmark = (bookmark) => has$2(bookmark, "id");
        const isIndexBookmark = (bookmark) => has$2(bookmark, "name");
        const isPathBookmark = (bookmark) => Tools.isArray(bookmark.start);
        const isForwardBookmark = (bookmark) => !isIndexBookmark(bookmark) && isBoolean(bookmark.forward) ? bookmark.forward : true;
        const addBogus = (dom2, node) => {
          if (isElement$6(node) && dom2.isBlock(node) && !node.innerHTML) {
            node.innerHTML = '<br data-mce-bogus="1" />';
          }
          return node;
        };
        const resolveCaretPositionBookmark = (dom2, bookmark) => {
          const startPos = Optional.from(resolve$1(dom2.getRoot(), bookmark.start));
          const endPos = Optional.from(resolve$1(dom2.getRoot(), bookmark.end));
          return lift2(startPos, endPos, (start4, end3) => {
            const range2 = dom2.createRng();
            range2.setStart(start4.container(), start4.offset());
            range2.setEnd(end3.container(), end3.offset());
            return {
              range: range2,
              forward: isForwardBookmark(bookmark)
            };
          });
        };
        const insertZwsp = (node, rng) => {
          var _a;
          const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
          const textNode = doc.createTextNode(ZWSP$1);
          node.appendChild(textNode);
          rng.setStart(textNode, 0);
          rng.setEnd(textNode, 0);
        };
        const isEmpty$1 = (node) => !node.hasChildNodes();
        const tryFindRangePosition = (node, rng) => lastPositionIn(node).fold(never, (pos) => {
          rng.setStart(pos.container(), pos.offset());
          rng.setEnd(pos.container(), pos.offset());
          return true;
        });
        const padEmptyCaretContainer = (root, node, rng) => {
          if (isEmpty$1(node) && getParentCaretContainer(root, node)) {
            insertZwsp(node, rng);
            return true;
          } else {
            return false;
          }
        };
        const setEndPoint = (dom2, start4, bookmark, rng) => {
          const point2 = bookmark[start4 ? "start" : "end"];
          const root = dom2.getRoot();
          if (point2) {
            let node = root;
            let offset2 = point2[0];
            for (let i2 = point2.length - 1; node && i2 >= 1; i2--) {
              const children2 = node.childNodes;
              if (padEmptyCaretContainer(root, node, rng)) {
                return true;
              }
              if (point2[i2] > children2.length - 1) {
                if (padEmptyCaretContainer(root, node, rng)) {
                  return true;
                }
                return tryFindRangePosition(node, rng);
              }
              node = children2[point2[i2]];
            }
            if (isText$a(node)) {
              offset2 = Math.min(point2[0], node.data.length);
            }
            if (isElement$6(node)) {
              offset2 = Math.min(point2[0], node.childNodes.length);
            }
            if (start4) {
              rng.setStart(node, offset2);
            } else {
              rng.setEnd(node, offset2);
            }
          }
          return true;
        };
        const isValidTextNode = (node) => isText$a(node) && node.data.length > 0;
        const restoreEndPoint = (dom2, suffix, bookmark) => {
          const marker = dom2.get(bookmark.id + "_" + suffix);
          const markerParent = marker === null || marker === void 0 ? void 0 : marker.parentNode;
          const keep = bookmark.keep;
          if (marker && markerParent) {
            let container;
            let offset2;
            if (suffix === "start") {
              if (!keep) {
                container = markerParent;
                offset2 = dom2.nodeIndex(marker);
              } else {
                if (marker.hasChildNodes()) {
                  container = marker.firstChild;
                  offset2 = 1;
                } else if (isValidTextNode(marker.nextSibling)) {
                  container = marker.nextSibling;
                  offset2 = 0;
                } else if (isValidTextNode(marker.previousSibling)) {
                  container = marker.previousSibling;
                  offset2 = marker.previousSibling.data.length;
                } else {
                  container = markerParent;
                  offset2 = dom2.nodeIndex(marker) + 1;
                }
              }
            } else {
              if (!keep) {
                container = markerParent;
                offset2 = dom2.nodeIndex(marker);
              } else {
                if (marker.hasChildNodes()) {
                  container = marker.firstChild;
                  offset2 = 1;
                } else if (isValidTextNode(marker.previousSibling)) {
                  container = marker.previousSibling;
                  offset2 = marker.previousSibling.data.length;
                } else {
                  container = markerParent;
                  offset2 = dom2.nodeIndex(marker);
                }
              }
            }
            if (!keep) {
              const prev2 = marker.previousSibling;
              const next2 = marker.nextSibling;
              Tools.each(Tools.grep(marker.childNodes), (node) => {
                if (isText$a(node)) {
                  node.data = node.data.replace(/\uFEFF/g, "");
                }
              });
              let otherMarker;
              while (otherMarker = dom2.get(bookmark.id + "_" + suffix)) {
                dom2.remove(otherMarker, true);
              }
              if (isText$a(next2) && isText$a(prev2) && !Env.browser.isOpera()) {
                const idx = prev2.data.length;
                prev2.appendData(next2.data);
                dom2.remove(next2);
                container = prev2;
                offset2 = idx;
              }
            }
            return Optional.some(CaretPosition(container, offset2));
          } else {
            return Optional.none();
          }
        };
        const resolvePaths = (dom2, bookmark) => {
          const range2 = dom2.createRng();
          if (setEndPoint(dom2, true, bookmark, range2) && setEndPoint(dom2, false, bookmark, range2)) {
            return Optional.some({
              range: range2,
              forward: isForwardBookmark(bookmark)
            });
          } else {
            return Optional.none();
          }
        };
        const resolveId = (dom2, bookmark) => {
          const startPos = restoreEndPoint(dom2, "start", bookmark);
          const endPos = restoreEndPoint(dom2, "end", bookmark);
          return lift2(startPos, endPos.or(startPos), (spos, epos) => {
            const range2 = dom2.createRng();
            range2.setStart(addBogus(dom2, spos.container()), spos.offset());
            range2.setEnd(addBogus(dom2, epos.container()), epos.offset());
            return {
              range: range2,
              forward: isForwardBookmark(bookmark)
            };
          });
        };
        const resolveIndex = (dom2, bookmark) => Optional.from(dom2.select(bookmark.name)[bookmark.index]).map((elm) => {
          const range2 = dom2.createRng();
          range2.selectNode(elm);
          return {
            range: range2,
            forward: true
          };
        });
        const resolve = (selection, bookmark) => {
          const dom2 = selection.dom;
          if (bookmark) {
            if (isPathBookmark(bookmark)) {
              return resolvePaths(dom2, bookmark);
            } else if (isStringPathBookmark(bookmark)) {
              return resolveCaretPositionBookmark(dom2, bookmark);
            } else if (isIdBookmark(bookmark)) {
              return resolveId(dom2, bookmark);
            } else if (isIndexBookmark(bookmark)) {
              return resolveIndex(dom2, bookmark);
            } else if (isRangeBookmark(bookmark)) {
              return Optional.some({
                range: bookmark.rng,
                forward: isForwardBookmark(bookmark)
              });
            }
          }
          return Optional.none();
        };
        const getBookmark$1 = (selection, type2, normalized) => {
          return getBookmark$2(selection, type2, normalized);
        };
        const moveToBookmark = (selection, bookmark) => {
          resolve(selection, bookmark).each(({ range: range2, forward }) => {
            selection.setRng(range2, forward);
          });
        };
        const isBookmarkNode$1 = (node) => {
          return isElement$6(node) && node.tagName === "SPAN" && node.getAttribute("data-mce-type") === "bookmark";
        };
        const is = (expected) => (actual) => expected === actual;
        const isNbsp = is(nbsp);
        const isWhiteSpace = (chr) => chr !== "" && " \f\n\r	\v".indexOf(chr) !== -1;
        const isContent = (chr) => !isWhiteSpace(chr) && !isNbsp(chr) && !isZwsp$2(chr);
        const hexColour = (value2) => ({ value: normalizeHex(value2) });
        const normalizeHex = (hex) => removeLeading(hex, "#").toUpperCase();
        const toHex = (component) => {
          const hex = component.toString(16);
          return (hex.length === 1 ? "0" + hex : hex).toUpperCase();
        };
        const fromRgba = (rgbaColour2) => {
          const value2 = toHex(rgbaColour2.red) + toHex(rgbaColour2.green) + toHex(rgbaColour2.blue);
          return hexColour(value2);
        };
        const rgbRegex = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i;
        const rgbaRegex = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i;
        const rgbaColour = (red, green, blue, alpha) => ({
          red,
          green,
          blue,
          alpha
        });
        const fromStringValues = (red, green, blue, alpha) => {
          const r3 = parseInt(red, 10);
          const g2 = parseInt(green, 10);
          const b2 = parseInt(blue, 10);
          const a2 = parseFloat(alpha);
          return rgbaColour(r3, g2, b2, a2);
        };
        const fromString = (rgbaString) => {
          if (rgbaString === "transparent") {
            return Optional.some(rgbaColour(0, 0, 0, 0));
          }
          const rgbMatch = rgbRegex.exec(rgbaString);
          if (rgbMatch !== null) {
            return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], "1"));
          }
          const rgbaMatch = rgbaRegex.exec(rgbaString);
          if (rgbaMatch !== null) {
            return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));
          }
          return Optional.none();
        };
        const rgbaToHexString = (color) => fromString(color).map(fromRgba).map((h2) => "#" + h2.value).getOr(color);
        const getRanges$1 = (selection) => {
          const ranges = [];
          if (selection) {
            for (let i2 = 0; i2 < selection.rangeCount; i2++) {
              ranges.push(selection.getRangeAt(i2));
            }
          }
          return ranges;
        };
        const getSelectedNodes = (ranges) => {
          return bind$3(ranges, (range2) => {
            const node = getSelectedNode(range2);
            return node ? [SugarElement.fromDom(node)] : [];
          });
        };
        const hasMultipleRanges = (selection) => {
          return getRanges$1(selection).length > 1;
        };
        const getCellsFromRanges = (ranges) => filter$5(getSelectedNodes(ranges), isTableCell$2);
        const getCellsFromElement = (elm) => descendants(elm, "td[data-mce-selected],th[data-mce-selected]");
        const getCellsFromElementOrRanges = (ranges, element) => {
          const selectedCells = getCellsFromElement(element);
          return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);
        };
        const getCellsFromEditor = (editor) => getCellsFromElementOrRanges(getRanges$1(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));
        const getClosestTable = (cell2, isRoot2) => ancestor$3(cell2, "table", isRoot2);
        const getStartNode = (rng) => {
          const sc = rng.startContainer, so = rng.startOffset;
          if (isText$a(sc)) {
            return so === 0 ? Optional.some(SugarElement.fromDom(sc)) : Optional.none();
          } else {
            return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);
          }
        };
        const getEndNode = (rng) => {
          const ec = rng.endContainer, eo = rng.endOffset;
          if (isText$a(ec)) {
            return eo === ec.data.length ? Optional.some(SugarElement.fromDom(ec)) : Optional.none();
          } else {
            return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);
          }
        };
        const getFirstChildren = (node) => {
          return firstChild(node).fold(constant([node]), (child2) => {
            return [node].concat(getFirstChildren(child2));
          });
        };
        const getLastChildren = (node) => {
          return lastChild(node).fold(constant([node]), (child2) => {
            if (name(child2) === "br") {
              return prevSibling(child2).map((sibling2) => {
                return [node].concat(getLastChildren(sibling2));
              }).getOr([]);
            } else {
              return [node].concat(getLastChildren(child2));
            }
          });
        };
        const hasAllContentsSelected = (elm, rng) => {
          return lift2(getStartNode(rng), getEndNode(rng), (startNode, endNode) => {
            const start4 = find$2(getFirstChildren(elm), curry(eq, startNode));
            const end3 = find$2(getLastChildren(elm), curry(eq, endNode));
            return start4.isSome() && end3.isSome();
          }).getOr(false);
        };
        const moveEndPoint = (dom2, rng, node, start4) => {
          const root = node;
          const walker = new DomTreeWalker(node, root);
          const moveCaretBeforeOnEnterElementsMap = filter$4(dom2.schema.getMoveCaretBeforeOnEnterElements(), (_2, name2) => !contains$2([
            "td",
            "th",
            "table"
          ], name2.toLowerCase()));
          let currentNode = node;
          do {
            if (isText$a(currentNode) && Tools.trim(currentNode.data).length !== 0) {
              if (start4) {
                rng.setStart(currentNode, 0);
              } else {
                rng.setEnd(currentNode, currentNode.data.length);
              }
              return;
            }
            if (moveCaretBeforeOnEnterElementsMap[currentNode.nodeName]) {
              if (start4) {
                rng.setStartBefore(currentNode);
              } else {
                if (currentNode.nodeName === "BR") {
                  rng.setEndBefore(currentNode);
                } else {
                  rng.setEndAfter(currentNode);
                }
              }
              return;
            }
          } while (currentNode = start4 ? walker.next() : walker.prev());
          if (root.nodeName === "BODY") {
            if (start4) {
              rng.setStart(root, 0);
            } else {
              rng.setEnd(root, root.childNodes.length);
            }
          }
        };
        const hasAnyRanges = (editor) => {
          const sel = editor.selection.getSel();
          return isNonNullable(sel) && sel.rangeCount > 0;
        };
        const runOnRanges = (editor, executor) => {
          const fakeSelectionNodes = getCellsFromEditor(editor);
          if (fakeSelectionNodes.length > 0) {
            each$e(fakeSelectionNodes, (elem) => {
              const node = elem.dom;
              const fakeNodeRng = editor.dom.createRng();
              fakeNodeRng.setStartBefore(node);
              fakeNodeRng.setEndAfter(node);
              executor(fakeNodeRng, true);
            });
          } else {
            executor(editor.selection.getRng(), false);
          }
        };
        const preserve = (selection, fillBookmark, executor) => {
          const bookmark = getPersistentBookmark(selection, fillBookmark);
          executor(bookmark);
          selection.moveToBookmark(bookmark);
        };
        const isNode = (node) => isNumber(node === null || node === void 0 ? void 0 : node.nodeType);
        const isElementNode$1 = (node) => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);
        const isElementDirectlySelected = (dom2, node) => {
          if (isElementNode$1(node) && !/^(TD|TH)$/.test(node.nodeName)) {
            const selectedAttr = dom2.getAttrib(node, "data-mce-selected");
            const value2 = parseInt(selectedAttr, 10);
            return !isNaN(value2) && value2 > 0;
          } else {
            return false;
          }
        };
        const isEditable$2 = (elm) => elm.isContentEditable === true;
        const preserveSelection = (editor, action2, shouldMoveStart) => {
          const { selection, dom: dom2 } = editor;
          const selectedNodeBeforeAction = selection.getNode();
          const isSelectedBeforeNodeNoneditable = isContentEditableFalse$b(selectedNodeBeforeAction);
          preserve(selection, true, () => {
            action2();
          });
          const isBeforeNodeStillNoneditable = isSelectedBeforeNodeNoneditable && isContentEditableFalse$b(selectedNodeBeforeAction);
          if (isBeforeNodeStillNoneditable && dom2.isChildOf(selectedNodeBeforeAction, editor.getBody())) {
            editor.selection.select(selectedNodeBeforeAction);
          } else if (shouldMoveStart(selection.getStart())) {
            moveStartToNearestText(dom2, selection);
          }
        };
        const moveStartToNearestText = (dom2, selection) => {
          var _a, _b;
          const rng = selection.getRng();
          const { startContainer, startOffset } = rng;
          const selectedNode = selection.getNode();
          if (isElementDirectlySelected(dom2, selectedNode)) {
            return;
          }
          if (isElement$6(startContainer)) {
            const nodes = startContainer.childNodes;
            const root = dom2.getRoot();
            let walker;
            if (startOffset < nodes.length) {
              const startNode = nodes[startOffset];
              walker = new DomTreeWalker(startNode, (_a = dom2.getParent(startNode, dom2.isBlock)) !== null && _a !== void 0 ? _a : root);
            } else {
              const startNode = nodes[nodes.length - 1];
              walker = new DomTreeWalker(startNode, (_b = dom2.getParent(startNode, dom2.isBlock)) !== null && _b !== void 0 ? _b : root);
              walker.next(true);
            }
            for (let node = walker.current(); node; node = walker.next()) {
              if (dom2.getContentEditable(node) === "false") {
                return;
              } else if (isText$a(node) && !isWhiteSpaceNode$1(node)) {
                rng.setStart(node, 0);
                selection.setRng(rng);
                return;
              }
            }
          }
        };
        const getNonWhiteSpaceSibling = (node, next2, inc) => {
          if (node) {
            const nextName = next2 ? "nextSibling" : "previousSibling";
            for (node = inc ? node : node[nextName]; node; node = node[nextName]) {
              if (isElement$6(node) || !isWhiteSpaceNode$1(node)) {
                return node;
              }
            }
          }
          return void 0;
        };
        const isTextBlock$1 = (schema, node) => !!schema.getTextBlockElements()[node.nodeName.toLowerCase()] || isTransparentBlock(schema, node);
        const isValid = (ed, parent2, child2) => {
          return ed.schema.isValidChild(parent2, child2);
        };
        const isWhiteSpaceNode$1 = (node, allowSpaces = false) => {
          if (isNonNullable(node) && isText$a(node)) {
            const data2 = allowSpaces ? node.data.replace(/ /g, "\xA0") : node.data;
            return isWhitespaceText(data2);
          } else {
            return false;
          }
        };
        const isEmptyTextNode$1 = (node) => {
          return isNonNullable(node) && isText$a(node) && node.length === 0;
        };
        const isWrapNoneditableTarget = (editor, node) => {
          const baseDataSelector = "[data-mce-cef-wrappable]";
          const formatNoneditableSelector = getFormatNoneditableSelector(editor);
          const selector = isEmpty$3(formatNoneditableSelector) ? baseDataSelector : `${baseDataSelector},${formatNoneditableSelector}`;
          return is$1(SugarElement.fromDom(node), selector);
        };
        const isWrappableNoneditable = (editor, node) => {
          const dom2 = editor.dom;
          return isElementNode$1(node) && dom2.getContentEditable(node) === "false" && isWrapNoneditableTarget(editor, node) && dom2.select('[contenteditable="true"]', node).length === 0;
        };
        const replaceVars = (value2, vars) => {
          if (isFunction(value2)) {
            return value2(vars);
          } else if (isNonNullable(vars)) {
            value2 = value2.replace(/%(\w+)/g, (str, name2) => {
              return vars[name2] || str;
            });
          }
          return value2;
        };
        const isEq$5 = (str1, str2) => {
          str1 = str1 || "";
          str2 = str2 || "";
          str1 = "" + (str1.nodeName || str1);
          str2 = "" + (str2.nodeName || str2);
          return str1.toLowerCase() === str2.toLowerCase();
        };
        const normalizeStyleValue = (value2, name2) => {
          if (isNullable(value2)) {
            return null;
          } else {
            let strValue = String(value2);
            if (name2 === "color" || name2 === "backgroundColor") {
              strValue = rgbaToHexString(strValue);
            }
            if (name2 === "fontWeight" && value2 === 700) {
              strValue = "bold";
            }
            if (name2 === "fontFamily") {
              strValue = strValue.replace(/[\'\"]/g, "").replace(/,\s+/g, ",");
            }
            return strValue;
          }
        };
        const getStyle = (dom2, node, name2) => {
          const style = dom2.getStyle(node, name2);
          return normalizeStyleValue(style, name2);
        };
        const getTextDecoration = (dom2, node) => {
          let decoration;
          dom2.getParent(node, (n2) => {
            if (isElement$6(n2)) {
              decoration = dom2.getStyle(n2, "text-decoration");
              return !!decoration && decoration !== "none";
            } else {
              return false;
            }
          });
          return decoration;
        };
        const getParents$2 = (dom2, node, selector) => {
          return dom2.getParents(node, selector, dom2.getRoot());
        };
        const isFormatPredicate = (editor, formatName, predicate) => {
          const formats = editor.formatter.get(formatName);
          return isNonNullable(formats) && exists(formats, predicate);
        };
        const isVariableFormatName = (editor, formatName) => {
          const hasVariableValues = (format) => {
            const isVariableValue = (val) => isFunction(val) || val.length > 1 && val.charAt(0) === "%";
            return exists([
              "styles",
              "attributes"
            ], (key) => get$a(format, key).exists((field2) => {
              const fieldValues = isArray$1(field2) ? field2 : values(field2);
              return exists(fieldValues, isVariableValue);
            }));
          };
          return isFormatPredicate(editor, formatName, hasVariableValues);
        };
        const areSimilarFormats = (editor, formatName, otherFormatName) => {
          const validKeys = [
            "inline",
            "block",
            "selector",
            "attributes",
            "styles",
            "classes"
          ];
          const filterObj = (format) => filter$4(format, (_2, key) => exists(validKeys, (validKey) => validKey === key));
          return isFormatPredicate(editor, formatName, (fmt1) => {
            const filteredFmt1 = filterObj(fmt1);
            return isFormatPredicate(editor, otherFormatName, (fmt2) => {
              const filteredFmt2 = filterObj(fmt2);
              return equal$1(filteredFmt1, filteredFmt2);
            });
          });
        };
        const isBlockFormat = (format) => hasNonNullableKey(format, "block");
        const isWrappingBlockFormat = (format) => isBlockFormat(format) && format.wrapper === true;
        const isNonWrappingBlockFormat = (format) => isBlockFormat(format) && format.wrapper !== true;
        const isSelectorFormat = (format) => hasNonNullableKey(format, "selector");
        const isInlineFormat = (format) => hasNonNullableKey(format, "inline");
        const isMixedFormat = (format) => isSelectorFormat(format) && isInlineFormat(format) && is$2(get$a(format, "mixed"), true);
        const shouldExpandToSelector = (format) => isSelectorFormat(format) && format.expand !== false && !isInlineFormat(format);
        const isBookmarkNode = isBookmarkNode$1;
        const getParents$1 = getParents$2;
        const isWhiteSpaceNode = isWhiteSpaceNode$1;
        const isTextBlock = isTextBlock$1;
        const isBogusBr = (node) => {
          return isBr$6(node) && node.getAttribute("data-mce-bogus") && !node.nextSibling;
        };
        const findParentContentEditable = (dom2, node) => {
          let parent2 = node;
          while (parent2) {
            if (isElement$6(parent2) && dom2.getContentEditable(parent2)) {
              return dom2.getContentEditable(parent2) === "false" ? parent2 : node;
            }
            parent2 = parent2.parentNode;
          }
          return node;
        };
        const walkText = (start4, node, offset2, predicate) => {
          const str = node.data;
          if (start4) {
            for (let i2 = offset2; i2 > 0; i2--) {
              if (predicate(str.charAt(i2 - 1))) {
                return i2;
              }
            }
          } else {
            for (let i2 = offset2; i2 < str.length; i2++) {
              if (predicate(str.charAt(i2))) {
                return i2;
              }
            }
          }
          return -1;
        };
        const findSpace = (start4, node, offset2) => walkText(start4, node, offset2, (c2) => isNbsp(c2) || isWhiteSpace(c2));
        const findContent = (start4, node, offset2) => walkText(start4, node, offset2, isContent);
        const findWordEndPoint = (dom2, body, container, offset2, start4, includeTrailingSpaces) => {
          let lastTextNode;
          const rootNode = dom2.getParent(container, dom2.isBlock) || body;
          const walk3 = (container2, offset3, pred) => {
            const textSeeker = TextSeeker(dom2);
            const walker = start4 ? textSeeker.backwards : textSeeker.forwards;
            return Optional.from(walker(container2, offset3, (text2, textOffset) => {
              if (isBookmarkNode(text2.parentNode)) {
                return -1;
              } else {
                lastTextNode = text2;
                return pred(start4, text2, textOffset);
              }
            }, rootNode));
          };
          const spaceResult = walk3(container, offset2, findSpace);
          return spaceResult.bind((result) => includeTrailingSpaces ? walk3(result.container, result.offset + (start4 ? -1 : 0), findContent) : Optional.some(result)).orThunk(() => lastTextNode ? Optional.some({
            container: lastTextNode,
            offset: start4 ? 0 : lastTextNode.length
          }) : Optional.none());
        };
        const findSelectorEndPoint = (dom2, formatList, rng, container, siblingName) => {
          const sibling2 = container[siblingName];
          if (isText$a(container) && isEmpty$3(container.data) && sibling2) {
            container = sibling2;
          }
          const parents2 = getParents$1(dom2, container);
          for (let i2 = 0; i2 < parents2.length; i2++) {
            for (let y2 = 0; y2 < formatList.length; y2++) {
              const curFormat = formatList[y2];
              if (isNonNullable(curFormat.collapsed) && curFormat.collapsed !== rng.collapsed) {
                continue;
              }
              if (isSelectorFormat(curFormat) && dom2.is(parents2[i2], curFormat.selector)) {
                return parents2[i2];
              }
            }
          }
          return container;
        };
        const findBlockEndPoint = (dom2, formatList, container, siblingName) => {
          var _a;
          let node = container;
          const root = dom2.getRoot();
          const format = formatList[0];
          if (isBlockFormat(format)) {
            node = format.wrapper ? null : dom2.getParent(container, format.block, root);
          }
          if (!node) {
            const scopeRoot = (_a = dom2.getParent(container, "LI,TD,TH")) !== null && _a !== void 0 ? _a : root;
            node = dom2.getParent(isText$a(container) ? container.parentNode : container, (node2) => node2 !== root && isTextBlock(dom2.schema, node2), scopeRoot);
          }
          if (node && isBlockFormat(format) && format.wrapper) {
            node = getParents$1(dom2, node, "ul,ol").reverse()[0] || node;
          }
          if (!node) {
            node = container;
            while (node && node[siblingName] && !dom2.isBlock(node[siblingName])) {
              node = node[siblingName];
              if (isEq$5(node, "br")) {
                break;
              }
            }
          }
          return node || container;
        };
        const isAtBlockBoundary$1 = (dom2, root, container, siblingName) => {
          const parent2 = container.parentNode;
          if (isNonNullable(container[siblingName])) {
            return false;
          } else if (parent2 === root || isNullable(parent2) || dom2.isBlock(parent2)) {
            return true;
          } else {
            return isAtBlockBoundary$1(dom2, root, parent2, siblingName);
          }
        };
        const findParentContainer = (dom2, formatList, container, offset2, start4) => {
          let parent2 = container;
          const siblingName = start4 ? "previousSibling" : "nextSibling";
          const root = dom2.getRoot();
          if (isText$a(container) && !isWhiteSpaceNode(container)) {
            if (start4 ? offset2 > 0 : offset2 < container.data.length) {
              return container;
            }
          }
          while (parent2) {
            if (!formatList[0].block_expand && dom2.isBlock(parent2)) {
              return parent2;
            }
            for (let sibling2 = parent2[siblingName]; sibling2; sibling2 = sibling2[siblingName]) {
              const allowSpaces = isText$a(sibling2) && !isAtBlockBoundary$1(dom2, root, sibling2, siblingName);
              if (!isBookmarkNode(sibling2) && !isBogusBr(sibling2) && !isWhiteSpaceNode(sibling2, allowSpaces)) {
                return parent2;
              }
            }
            if (parent2 === root || parent2.parentNode === root) {
              container = parent2;
              break;
            }
            parent2 = parent2.parentNode;
          }
          return container;
        };
        const isSelfOrParentBookmark = (container) => isBookmarkNode(container.parentNode) || isBookmarkNode(container);
        const expandRng = (dom2, rng, formatList, includeTrailingSpace = false) => {
          let { startContainer, startOffset, endContainer, endOffset } = rng;
          const format = formatList[0];
          if (isElement$6(startContainer) && startContainer.hasChildNodes()) {
            startContainer = getNode$1(startContainer, startOffset);
            if (isText$a(startContainer)) {
              startOffset = 0;
            }
          }
          if (isElement$6(endContainer) && endContainer.hasChildNodes()) {
            endContainer = getNode$1(endContainer, rng.collapsed ? endOffset : endOffset - 1);
            if (isText$a(endContainer)) {
              endOffset = endContainer.data.length;
            }
          }
          startContainer = findParentContentEditable(dom2, startContainer);
          endContainer = findParentContentEditable(dom2, endContainer);
          if (isSelfOrParentBookmark(startContainer)) {
            startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;
            if (rng.collapsed) {
              startContainer = startContainer.previousSibling || startContainer;
            } else {
              startContainer = startContainer.nextSibling || startContainer;
            }
            if (isText$a(startContainer)) {
              startOffset = rng.collapsed ? startContainer.length : 0;
            }
          }
          if (isSelfOrParentBookmark(endContainer)) {
            endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;
            if (rng.collapsed) {
              endContainer = endContainer.nextSibling || endContainer;
            } else {
              endContainer = endContainer.previousSibling || endContainer;
            }
            if (isText$a(endContainer)) {
              endOffset = rng.collapsed ? 0 : endContainer.length;
            }
          }
          if (rng.collapsed) {
            const startPoint = findWordEndPoint(dom2, dom2.getRoot(), startContainer, startOffset, true, includeTrailingSpace);
            startPoint.each(({ container, offset: offset2 }) => {
              startContainer = container;
              startOffset = offset2;
            });
            const endPoint = findWordEndPoint(dom2, dom2.getRoot(), endContainer, endOffset, false, includeTrailingSpace);
            endPoint.each(({ container, offset: offset2 }) => {
              endContainer = container;
              endOffset = offset2;
            });
          }
          if (isInlineFormat(format) || format.block_expand) {
            if (!isInlineFormat(format) || (!isText$a(startContainer) || startOffset === 0)) {
              startContainer = findParentContainer(dom2, formatList, startContainer, startOffset, true);
            }
            if (!isInlineFormat(format) || (!isText$a(endContainer) || endOffset === endContainer.data.length)) {
              endContainer = findParentContainer(dom2, formatList, endContainer, endOffset, false);
            }
          }
          if (shouldExpandToSelector(format)) {
            startContainer = findSelectorEndPoint(dom2, formatList, rng, startContainer, "previousSibling");
            endContainer = findSelectorEndPoint(dom2, formatList, rng, endContainer, "nextSibling");
          }
          if (isBlockFormat(format) || isSelectorFormat(format)) {
            startContainer = findBlockEndPoint(dom2, formatList, startContainer, "previousSibling");
            endContainer = findBlockEndPoint(dom2, formatList, endContainer, "nextSibling");
            if (isBlockFormat(format)) {
              if (!dom2.isBlock(startContainer)) {
                startContainer = findParentContainer(dom2, formatList, startContainer, startOffset, true);
              }
              if (!dom2.isBlock(endContainer)) {
                endContainer = findParentContainer(dom2, formatList, endContainer, endOffset, false);
              }
            }
          }
          if (isElement$6(startContainer) && startContainer.parentNode) {
            startOffset = dom2.nodeIndex(startContainer);
            startContainer = startContainer.parentNode;
          }
          if (isElement$6(endContainer) && endContainer.parentNode) {
            endOffset = dom2.nodeIndex(endContainer) + 1;
            endContainer = endContainer.parentNode;
          }
          return {
            startContainer,
            startOffset,
            endContainer,
            endOffset
          };
        };
        const walk$3 = (dom2, rng, callback) => {
          var _a;
          const startOffset = rng.startOffset;
          const startContainer = getNode$1(rng.startContainer, startOffset);
          const endOffset = rng.endOffset;
          const endContainer = getNode$1(rng.endContainer, endOffset - 1);
          const exclude = (nodes) => {
            const firstNode = nodes[0];
            if (isText$a(firstNode) && firstNode === startContainer && startOffset >= firstNode.data.length) {
              nodes.splice(0, 1);
            }
            const lastNode = nodes[nodes.length - 1];
            if (endOffset === 0 && nodes.length > 0 && lastNode === endContainer && isText$a(lastNode)) {
              nodes.splice(nodes.length - 1, 1);
            }
            return nodes;
          };
          const collectSiblings = (node, name2, endNode) => {
            const siblings3 = [];
            for (; node && node !== endNode; node = node[name2]) {
              siblings3.push(node);
            }
            return siblings3;
          };
          const findEndPoint = (node, root) => dom2.getParent(node, (node2) => node2.parentNode === root, root);
          const walkBoundary = (startNode, endNode, next2) => {
            const siblingName = next2 ? "nextSibling" : "previousSibling";
            for (let node = startNode, parent2 = node.parentNode; node && node !== endNode; node = parent2) {
              parent2 = node.parentNode;
              const siblings3 = collectSiblings(node === startNode ? node : node[siblingName], siblingName);
              if (siblings3.length) {
                if (!next2) {
                  siblings3.reverse();
                }
                callback(exclude(siblings3));
              }
            }
          };
          if (startContainer === endContainer) {
            return callback(exclude([startContainer]));
          }
          const ancestor2 = (_a = dom2.findCommonAncestor(startContainer, endContainer)) !== null && _a !== void 0 ? _a : dom2.getRoot();
          if (dom2.isChildOf(startContainer, endContainer)) {
            return walkBoundary(startContainer, ancestor2, true);
          }
          if (dom2.isChildOf(endContainer, startContainer)) {
            return walkBoundary(endContainer, ancestor2);
          }
          const startPoint = findEndPoint(startContainer, ancestor2) || startContainer;
          const endPoint = findEndPoint(endContainer, ancestor2) || endContainer;
          walkBoundary(startContainer, startPoint, true);
          const siblings2 = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, "nextSibling", endPoint === endContainer ? endPoint.nextSibling : endPoint);
          if (siblings2.length) {
            callback(exclude(siblings2));
          }
          walkBoundary(endContainer, endPoint);
        };
        const validBlocks = [
          'pre[class*=language-][contenteditable="false"]',
          "figure.image",
          "div[data-ephox-embed-iri]",
          "div.tiny-pageembed",
          "div.mce-toc",
          "div[data-mce-toc]"
        ];
        const isZeroWidth = (elem) => isText$b(elem) && get$3(elem) === ZWSP$1;
        const context = (editor, elem, wrapName, nodeName) => parent(elem).fold(() => "skipping", (parent2) => {
          if (nodeName === "br" || isZeroWidth(elem)) {
            return "valid";
          } else if (isAnnotation(elem)) {
            return "existing";
          } else if (isCaretNode(elem.dom)) {
            return "caret";
          } else if (exists(validBlocks, (selector) => is$1(elem, selector))) {
            return "valid-block";
          } else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent2), wrapName)) {
            return "invalid-child";
          } else {
            return "valid";
          }
        });
        const applyWordGrab = (editor, rng) => {
          const r3 = expandRng(editor.dom, rng, [{ inline: "span" }]);
          rng.setStart(r3.startContainer, r3.startOffset);
          rng.setEnd(r3.endContainer, r3.endOffset);
          editor.selection.setRng(rng);
        };
        const applyAnnotation = (elem, masterUId, data2, annotationName, decorate, directAnnotation) => {
          const { uid: uid2 = masterUId, ...otherData } = data2;
          add$2(elem, annotation());
          set$3(elem, `${dataAnnotationId()}`, uid2);
          set$3(elem, `${dataAnnotation()}`, annotationName);
          const { attributes = {}, classes = [] } = decorate(uid2, otherData);
          setAll$1(elem, attributes);
          add2(elem, classes);
          if (directAnnotation) {
            if (classes.length > 0) {
              set$3(elem, `${dataAnnotationClasses()}`, classes.join(","));
            }
            const attributeNames = keys(attributes);
            if (attributeNames.length > 0) {
              set$3(elem, `${dataAnnotationAttributes()}`, attributeNames.join(","));
            }
          }
        };
        const removeDirectAnnotation = (elem) => {
          remove$7(elem, annotation());
          remove$a(elem, `${dataAnnotationId()}`);
          remove$a(elem, `${dataAnnotation()}`);
          remove$a(elem, `${dataAnnotationActive()}`);
          const customAttrNames = getOpt(elem, `${dataAnnotationAttributes()}`).map((names) => names.split(",")).getOr([]);
          const customClasses = getOpt(elem, `${dataAnnotationClasses()}`).map((names) => names.split(",")).getOr([]);
          each$e(customAttrNames, (name2) => remove$a(elem, name2));
          remove$4(elem, customClasses);
          remove$a(elem, `${dataAnnotationClasses()}`);
          remove$a(elem, `${dataAnnotationAttributes()}`);
        };
        const makeAnnotation = (eDoc, uid2, data2, annotationName, decorate) => {
          const master = SugarElement.fromTag("span", eDoc);
          applyAnnotation(master, uid2, data2, annotationName, decorate, false);
          return master;
        };
        const annotate = (editor, rng, uid2, annotationName, decorate, data2) => {
          const newWrappers = [];
          const master = makeAnnotation(editor.getDoc(), uid2, data2, annotationName, decorate);
          const wrapper = value$2();
          const finishWrapper = () => {
            wrapper.clear();
          };
          const getOrOpenWrapper = () => wrapper.get().getOrThunk(() => {
            const nu2 = shallow$1(master);
            newWrappers.push(nu2);
            wrapper.set(nu2);
            return nu2;
          });
          const processElements = (elems) => {
            each$e(elems, processElement);
          };
          const processElement = (elem) => {
            const ctx = context(editor, elem, "span", name(elem));
            switch (ctx) {
              case "invalid-child": {
                finishWrapper();
                const children2 = children$1(elem);
                processElements(children2);
                finishWrapper();
                break;
              }
              case "valid-block": {
                finishWrapper();
                applyAnnotation(elem, uid2, data2, annotationName, decorate, true);
                break;
              }
              case "valid": {
                const w2 = getOrOpenWrapper();
                wrap$2(elem, w2);
                break;
              }
            }
          };
          const processNodes = (nodes) => {
            const elems = map$3(nodes, SugarElement.fromDom);
            processElements(elems);
          };
          walk$3(editor.dom, rng, (nodes) => {
            finishWrapper();
            processNodes(nodes);
          });
          return newWrappers;
        };
        const annotateWithBookmark = (editor, name2, settings, data2) => {
          editor.undoManager.transact(() => {
            const selection = editor.selection;
            const initialRng = selection.getRng();
            const hasFakeSelection = getCellsFromEditor(editor).length > 0;
            const masterUid = generate$1("mce-annotation");
            if (initialRng.collapsed && !hasFakeSelection) {
              applyWordGrab(editor, initialRng);
            }
            if (selection.getRng().collapsed && !hasFakeSelection) {
              const wrapper = makeAnnotation(editor.getDoc(), masterUid, data2, name2, settings.decorate);
              set$1(wrapper, nbsp);
              selection.getRng().insertNode(wrapper.dom);
              selection.select(wrapper.dom);
            } else {
              preserve(selection, false, () => {
                runOnRanges(editor, (selectionRng) => {
                  annotate(editor, selectionRng, masterUid, name2, settings.decorate, data2);
                });
              });
            }
          });
        };
        const Annotator = (editor) => {
          const registry2 = create$c();
          setup$w(editor, registry2);
          const changes = setup$x(editor, registry2);
          const isSpan2 = isTag("span");
          const removeAnnotations = (elements) => {
            each$e(elements, (element) => {
              if (isSpan2(element)) {
                unwrap(element);
              } else {
                removeDirectAnnotation(element);
              }
            });
          };
          return {
            register: (name2, settings) => {
              registry2.register(name2, settings);
            },
            annotate: (name2, data2) => {
              registry2.lookup(name2).each((settings) => {
                annotateWithBookmark(editor, name2, settings, data2);
              });
            },
            annotationChanged: (name2, callback) => {
              changes.addListener(name2, callback);
            },
            remove: (name2) => {
              identify(editor, Optional.some(name2)).each(({ elements }) => {
                const bookmark = editor.selection.getBookmark();
                removeAnnotations(elements);
                editor.selection.moveToBookmark(bookmark);
              });
            },
            removeAll: (name2) => {
              const bookmark = editor.selection.getBookmark();
              each$d(findAll(editor, name2), (elements, _2) => {
                removeAnnotations(elements);
              });
              editor.selection.moveToBookmark(bookmark);
            },
            getAll: (name2) => {
              const directory = findAll(editor, name2);
              return map$2(directory, (elems) => map$3(elems, (elem) => elem.dom));
            }
          };
        };
        const BookmarkManager = (selection) => {
          return {
            getBookmark: curry(getBookmark$1, selection),
            moveToBookmark: curry(moveToBookmark, selection)
          };
        };
        BookmarkManager.isBookmarkNode = isBookmarkNode$1;
        const isXYWithinRange = (clientX, clientY, range2) => {
          if (range2.collapsed) {
            return false;
          } else {
            return exists(range2.getClientRects(), (rect) => containsXY(rect, clientX, clientY));
          }
        };
        const firePreProcess = (editor, args) => editor.dispatch("PreProcess", args);
        const firePostProcess = (editor, args) => editor.dispatch("PostProcess", args);
        const fireRemove = (editor) => {
          editor.dispatch("remove");
        };
        const fireDetach = (editor) => {
          editor.dispatch("detach");
        };
        const fireSwitchMode = (editor, mode) => {
          editor.dispatch("SwitchMode", { mode });
        };
        const fireObjectResizeStart = (editor, target, width, height, origin) => {
          editor.dispatch("ObjectResizeStart", {
            target,
            width,
            height,
            origin
          });
        };
        const fireObjectResized = (editor, target, width, height, origin) => {
          editor.dispatch("ObjectResized", {
            target,
            width,
            height,
            origin
          });
        };
        const firePreInit = (editor) => {
          editor.dispatch("PreInit");
        };
        const firePostRender = (editor) => {
          editor.dispatch("PostRender");
        };
        const fireInit = (editor) => {
          editor.dispatch("Init");
        };
        const firePlaceholderToggle = (editor, state) => {
          editor.dispatch("PlaceholderToggle", { state });
        };
        const fireError = (editor, errorType, error3) => {
          editor.dispatch(errorType, error3);
        };
        const fireFormatApply = (editor, format, node, vars) => {
          editor.dispatch("FormatApply", {
            format,
            node,
            vars
          });
        };
        const fireFormatRemove = (editor, format, node, vars) => {
          editor.dispatch("FormatRemove", {
            format,
            node,
            vars
          });
        };
        const fireBeforeSetContent = (editor, args) => editor.dispatch("BeforeSetContent", args);
        const fireSetContent = (editor, args) => editor.dispatch("SetContent", args);
        const fireBeforeGetContent = (editor, args) => editor.dispatch("BeforeGetContent", args);
        const fireGetContent = (editor, args) => editor.dispatch("GetContent", args);
        const fireAutocompleterStart = (editor, args) => {
          editor.dispatch("AutocompleterStart", args);
        };
        const fireAutocompleterUpdate = (editor, args) => {
          editor.dispatch("AutocompleterUpdate", args);
        };
        const fireAutocompleterEnd = (editor) => {
          editor.dispatch("AutocompleterEnd");
        };
        const firePastePreProcess = (editor, html2, internal) => editor.dispatch("PastePreProcess", {
          content: html2,
          internal
        });
        const firePastePostProcess = (editor, node, internal) => editor.dispatch("PastePostProcess", {
          node,
          internal
        });
        const firePastePlainTextToggle = (editor, state) => editor.dispatch("PastePlainTextToggle", { state });
        const fireEditableRootStateChange = (editor, state) => editor.dispatch("EditableRootStateChange", { state });
        const VK = {
          BACKSPACE: 8,
          DELETE: 46,
          DOWN: 40,
          ENTER: 13,
          ESC: 27,
          LEFT: 37,
          RIGHT: 39,
          SPACEBAR: 32,
          TAB: 9,
          UP: 38,
          PAGE_UP: 33,
          PAGE_DOWN: 34,
          END: 35,
          HOME: 36,
          modifierPressed: (e2) => {
            return e2.shiftKey || e2.ctrlKey || e2.altKey || VK.metaKeyPressed(e2);
          },
          metaKeyPressed: (e2) => {
            return Env.os.isMacOS() || Env.os.isiOS() ? e2.metaKey : e2.ctrlKey && !e2.altKey;
          }
        };
        const elementSelectionAttr = "data-mce-selected";
        const controlElmSelector = "table,img,figure.image,hr,video,span.mce-preview-object,details";
        const abs = Math.abs;
        const round$1 = Math.round;
        const resizeHandles = {
          nw: [
            0,
            0,
            -1,
            -1
          ],
          ne: [
            1,
            0,
            1,
            -1
          ],
          se: [
            1,
            1,
            1,
            1
          ],
          sw: [
            0,
            1,
            -1,
            1
          ]
        };
        const isTouchEvent = (evt) => evt.type === "longpress" || evt.type.indexOf("touch") === 0;
        const ControlSelection = (selection, editor) => {
          const dom2 = editor.dom;
          const editableDoc = editor.getDoc();
          const rootDocument = document;
          const rootElement = editor.getBody();
          let selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;
          let startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;
          let width;
          let height;
          let startScrollWidth;
          let startScrollHeight;
          const isImage2 = (elm) => isNonNullable(elm) && (isImg(elm) || dom2.is(elm, "figure.image"));
          const isMedia2 = (elm) => isMedia$2(elm) || dom2.hasClass(elm, "mce-preview-object");
          const isEventOnImageOutsideRange = (evt, range2) => {
            if (isTouchEvent(evt)) {
              const touch = evt.touches[0];
              return isImage2(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range2);
            } else {
              return isImage2(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range2);
            }
          };
          const contextMenuSelectImage = (evt) => {
            const target = evt.target;
            if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {
              editor.selection.select(target);
            }
          };
          const getResizeTargets = (elm) => {
            if (dom2.hasClass(elm, "mce-preview-object") && isNonNullable(elm.firstElementChild)) {
              return [
                elm,
                elm.firstElementChild
              ];
            } else if (dom2.is(elm, "figure.image")) {
              return [elm.querySelector("img")];
            } else {
              return [elm];
            }
          };
          const isResizable = (elm) => {
            const selector = getObjectResizing(editor);
            if (!selector) {
              return false;
            }
            if (elm.getAttribute("data-mce-resize") === "false") {
              return false;
            }
            if (elm === editor.getBody()) {
              return false;
            }
            if (dom2.hasClass(elm, "mce-preview-object") && isNonNullable(elm.firstElementChild)) {
              return is$1(SugarElement.fromDom(elm.firstElementChild), selector);
            } else {
              return is$1(SugarElement.fromDom(elm), selector);
            }
          };
          const createGhostElement = (elm) => {
            if (isMedia2(elm)) {
              return dom2.create("img", { src: Env.transparentSrc });
            } else {
              return elm.cloneNode(true);
            }
          };
          const setSizeProp = (element, name2, value2) => {
            if (isNonNullable(value2)) {
              const targets = getResizeTargets(element);
              each$e(targets, (target) => {
                if (target.style[name2] || !editor.schema.isValid(target.nodeName.toLowerCase(), name2)) {
                  dom2.setStyle(target, name2, value2);
                } else {
                  dom2.setAttrib(target, name2, "" + value2);
                }
              });
            }
          };
          const setGhostElmSize = (ghostElm, width2, height2) => {
            setSizeProp(ghostElm, "width", width2);
            setSizeProp(ghostElm, "height", height2);
          };
          const resizeGhostElement = (e2) => {
            let deltaX, deltaY, proportional;
            let resizeHelperX, resizeHelperY;
            deltaX = e2.screenX - startX;
            deltaY = e2.screenY - startY;
            width = deltaX * selectedHandle[2] + startW;
            height = deltaY * selectedHandle[3] + startH;
            width = width < 5 ? 5 : width;
            height = height < 5 ? 5 : height;
            if ((isImage2(selectedElm) || isMedia2(selectedElm)) && getResizeImgProportional(editor) !== false) {
              proportional = !VK.modifierPressed(e2);
            } else {
              proportional = VK.modifierPressed(e2);
            }
            if (proportional) {
              if (abs(deltaX) > abs(deltaY)) {
                height = round$1(width * ratio);
                width = round$1(height / ratio);
              } else {
                width = round$1(height / ratio);
                height = round$1(width * ratio);
              }
            }
            setGhostElmSize(selectedElmGhost, width, height);
            resizeHelperX = selectedHandle.startPos.x + deltaX;
            resizeHelperY = selectedHandle.startPos.y + deltaY;
            resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;
            resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;
            dom2.setStyles(resizeHelper, {
              left: resizeHelperX,
              top: resizeHelperY,
              display: "block"
            });
            resizeHelper.innerHTML = width + " &times; " + height;
            if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {
              dom2.setStyle(selectedElmGhost, "left", selectedElmX + (startW - width));
            }
            if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {
              dom2.setStyle(selectedElmGhost, "top", selectedElmY + (startH - height));
            }
            deltaX = rootElement.scrollWidth - startScrollWidth;
            deltaY = rootElement.scrollHeight - startScrollHeight;
            if (deltaX + deltaY !== 0) {
              dom2.setStyles(resizeHelper, {
                left: resizeHelperX - deltaX,
                top: resizeHelperY - deltaY
              });
            }
            if (!resizeStarted) {
              fireObjectResizeStart(editor, selectedElm, startW, startH, "corner-" + selectedHandle.name);
              resizeStarted = true;
            }
          };
          const endGhostResize = () => {
            const wasResizeStarted = resizeStarted;
            resizeStarted = false;
            if (wasResizeStarted) {
              setSizeProp(selectedElm, "width", width);
              setSizeProp(selectedElm, "height", height);
            }
            dom2.unbind(editableDoc, "mousemove", resizeGhostElement);
            dom2.unbind(editableDoc, "mouseup", endGhostResize);
            if (rootDocument !== editableDoc) {
              dom2.unbind(rootDocument, "mousemove", resizeGhostElement);
              dom2.unbind(rootDocument, "mouseup", endGhostResize);
            }
            dom2.remove(selectedElmGhost);
            dom2.remove(resizeHelper);
            dom2.remove(resizeBackdrop);
            showResizeRect(selectedElm);
            if (wasResizeStarted) {
              fireObjectResized(editor, selectedElm, width, height, "corner-" + selectedHandle.name);
              dom2.setAttrib(selectedElm, "style", dom2.getAttrib(selectedElm, "style"));
            }
            editor.nodeChanged();
          };
          const showResizeRect = (targetElm) => {
            unbindResizeHandleEvents();
            const position = dom2.getPos(targetElm, rootElement);
            const selectedElmX2 = position.x;
            const selectedElmY2 = position.y;
            const rect = targetElm.getBoundingClientRect();
            const targetWidth = rect.width || rect.right - rect.left;
            const targetHeight = rect.height || rect.bottom - rect.top;
            if (selectedElm !== targetElm) {
              hideResizeRect();
              selectedElm = targetElm;
              width = height = 0;
            }
            const e2 = editor.dispatch("ObjectSelected", { target: targetElm });
            if (isResizable(targetElm) && !e2.isDefaultPrevented()) {
              each$d(resizeHandles, (handle2, name2) => {
                const startDrag = (e3) => {
                  const target = getResizeTargets(selectedElm)[0];
                  startX = e3.screenX;
                  startY = e3.screenY;
                  startW = target.clientWidth;
                  startH = target.clientHeight;
                  ratio = startH / startW;
                  selectedHandle = handle2;
                  selectedHandle.name = name2;
                  selectedHandle.startPos = {
                    x: targetWidth * handle2[0] + selectedElmX2,
                    y: targetHeight * handle2[1] + selectedElmY2
                  };
                  startScrollWidth = rootElement.scrollWidth;
                  startScrollHeight = rootElement.scrollHeight;
                  resizeBackdrop = dom2.add(rootElement, "div", {
                    "class": "mce-resize-backdrop",
                    "data-mce-bogus": "all"
                  });
                  dom2.setStyles(resizeBackdrop, {
                    position: "fixed",
                    left: "0",
                    top: "0",
                    width: "100%",
                    height: "100%"
                  });
                  selectedElmGhost = createGhostElement(selectedElm);
                  dom2.addClass(selectedElmGhost, "mce-clonedresizable");
                  dom2.setAttrib(selectedElmGhost, "data-mce-bogus", "all");
                  selectedElmGhost.contentEditable = "false";
                  dom2.setStyles(selectedElmGhost, {
                    left: selectedElmX2,
                    top: selectedElmY2,
                    margin: 0
                  });
                  setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);
                  selectedElmGhost.removeAttribute(elementSelectionAttr);
                  rootElement.appendChild(selectedElmGhost);
                  dom2.bind(editableDoc, "mousemove", resizeGhostElement);
                  dom2.bind(editableDoc, "mouseup", endGhostResize);
                  if (rootDocument !== editableDoc) {
                    dom2.bind(rootDocument, "mousemove", resizeGhostElement);
                    dom2.bind(rootDocument, "mouseup", endGhostResize);
                  }
                  resizeHelper = dom2.add(rootElement, "div", {
                    "class": "mce-resize-helper",
                    "data-mce-bogus": "all"
                  }, startW + " &times; " + startH);
                };
                let handleElm = dom2.get("mceResizeHandle" + name2);
                if (handleElm) {
                  dom2.remove(handleElm);
                }
                handleElm = dom2.add(rootElement, "div", {
                  "id": "mceResizeHandle" + name2,
                  "data-mce-bogus": "all",
                  "class": "mce-resizehandle",
                  "unselectable": true,
                  "style": "cursor:" + name2 + "-resize; margin:0; padding:0"
                });
                dom2.bind(handleElm, "mousedown", (e3) => {
                  e3.stopImmediatePropagation();
                  e3.preventDefault();
                  startDrag(e3);
                });
                handle2.elm = handleElm;
                dom2.setStyles(handleElm, {
                  left: targetWidth * handle2[0] + selectedElmX2 - handleElm.offsetWidth / 2,
                  top: targetHeight * handle2[1] + selectedElmY2 - handleElm.offsetHeight / 2
                });
              });
            } else {
              hideResizeRect(false);
            }
          };
          const throttledShowResizeRect = first$1(showResizeRect, 0);
          const hideResizeRect = (removeSelected = true) => {
            throttledShowResizeRect.cancel();
            unbindResizeHandleEvents();
            if (selectedElm && removeSelected) {
              selectedElm.removeAttribute(elementSelectionAttr);
            }
            each$d(resizeHandles, (value2, name2) => {
              const handleElm = dom2.get("mceResizeHandle" + name2);
              if (handleElm) {
                dom2.unbind(handleElm);
                dom2.remove(handleElm);
              }
            });
          };
          const isChildOrEqual = (node, parent2) => dom2.isChildOf(node, parent2);
          const updateResizeRect = (e2) => {
            if (resizeStarted || editor.removed || editor.composing) {
              return;
            }
            const targetElm = e2.type === "mousedown" ? e2.target : selection.getNode();
            const controlElm = closest$3(SugarElement.fromDom(targetElm), controlElmSelector).map((e3) => e3.dom).filter((e3) => dom2.isEditable(e3.parentElement)).getOrUndefined();
            const selectedValue = isNonNullable(controlElm) ? dom2.getAttrib(controlElm, elementSelectionAttr, "1") : "1";
            each$e(dom2.select(`img[${elementSelectionAttr}],hr[${elementSelectionAttr}]`), (img) => {
              img.removeAttribute(elementSelectionAttr);
            });
            if (isNonNullable(controlElm) && isChildOrEqual(controlElm, rootElement) && editor.hasFocus()) {
              disableGeckoResize();
              const startElm = selection.getStart(true);
              if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {
                dom2.setAttrib(controlElm, elementSelectionAttr, selectedValue);
                throttledShowResizeRect.throttle(controlElm);
                return;
              }
            }
            hideResizeRect();
          };
          const unbindResizeHandleEvents = () => {
            each$d(resizeHandles, (handle2) => {
              if (handle2.elm) {
                dom2.unbind(handle2.elm);
                delete handle2.elm;
              }
            });
          };
          const disableGeckoResize = () => {
            try {
              editor.getDoc().execCommand("enableObjectResizing", false, "false");
            } catch (ex) {
            }
          };
          editor.on("init", () => {
            disableGeckoResize();
            editor.on("NodeChange ResizeEditor ResizeWindow ResizeContent drop", updateResizeRect);
            editor.on("keyup compositionend", (e2) => {
              if (selectedElm && selectedElm.nodeName === "TABLE") {
                updateResizeRect(e2);
              }
            });
            editor.on("hide blur", hideResizeRect);
            editor.on("contextmenu longpress", contextMenuSelectImage, true);
          });
          editor.on("remove", unbindResizeHandleEvents);
          const destroy2 = () => {
            throttledShowResizeRect.cancel();
            selectedElm = selectedElmGhost = resizeBackdrop = null;
          };
          return {
            isResizable,
            showResizeRect,
            hideResizeRect,
            updateResizeRect,
            destroy: destroy2
          };
        };
        const setStart = (rng, situ) => {
          situ.fold((e2) => {
            rng.setStartBefore(e2.dom);
          }, (e2, o2) => {
            rng.setStart(e2.dom, o2);
          }, (e2) => {
            rng.setStartAfter(e2.dom);
          });
        };
        const setFinish = (rng, situ) => {
          situ.fold((e2) => {
            rng.setEndBefore(e2.dom);
          }, (e2, o2) => {
            rng.setEnd(e2.dom, o2);
          }, (e2) => {
            rng.setEndAfter(e2.dom);
          });
        };
        const relativeToNative = (win, startSitu, finishSitu) => {
          const range2 = win.document.createRange();
          setStart(range2, startSitu);
          setFinish(range2, finishSitu);
          return range2;
        };
        const exactToNative = (win, start4, soffset, finish, foffset) => {
          const rng = win.document.createRange();
          rng.setStart(start4.dom, soffset);
          rng.setEnd(finish.dom, foffset);
          return rng;
        };
        const adt$3 = Adt.generate([
          {
            ltr: [
              "start",
              "soffset",
              "finish",
              "foffset"
            ]
          },
          {
            rtl: [
              "start",
              "soffset",
              "finish",
              "foffset"
            ]
          }
        ]);
        const fromRange = (win, type2, range2) => type2(SugarElement.fromDom(range2.startContainer), range2.startOffset, SugarElement.fromDom(range2.endContainer), range2.endOffset);
        const getRanges = (win, selection) => selection.match({
          domRange: (rng) => {
            return {
              ltr: constant(rng),
              rtl: Optional.none
            };
          },
          relative: (startSitu, finishSitu) => {
            return {
              ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),
              rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))
            };
          },
          exact: (start4, soffset, finish, foffset) => {
            return {
              ltr: cached(() => exactToNative(win, start4, soffset, finish, foffset)),
              rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start4, soffset)))
            };
          }
        });
        const doDiagnose = (win, ranges) => {
          const rng = ranges.ltr();
          if (rng.collapsed) {
            const reversed = ranges.rtl().filter((rev) => rev.collapsed === false);
            return reversed.map((rev) => adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));
          } else {
            return fromRange(win, adt$3.ltr, rng);
          }
        };
        const diagnose = (win, selection) => {
          const ranges = getRanges(win, selection);
          return doDiagnose(win, ranges);
        };
        adt$3.ltr;
        adt$3.rtl;
        const create$a = (start4, soffset, finish, foffset) => ({
          start: start4,
          soffset,
          finish,
          foffset
        });
        const SimRange = { create: create$a };
        const caretPositionFromPoint = (doc, x2, y2) => {
          var _a, _b;
          return Optional.from((_b = (_a = doc.dom).caretPositionFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x2, y2)).bind((pos) => {
            if (pos.offsetNode === null) {
              return Optional.none();
            }
            const r3 = doc.dom.createRange();
            r3.setStart(pos.offsetNode, pos.offset);
            r3.collapse();
            return Optional.some(r3);
          });
        };
        const caretRangeFromPoint = (doc, x2, y2) => {
          var _a, _b;
          return Optional.from((_b = (_a = doc.dom).caretRangeFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x2, y2));
        };
        const availableSearch = (() => {
          if (document.caretPositionFromPoint) {
            return caretPositionFromPoint;
          } else if (document.caretRangeFromPoint) {
            return caretRangeFromPoint;
          } else {
            return Optional.none;
          }
        })();
        const fromPoint$1 = (win, x2, y2) => {
          const doc = SugarElement.fromDom(win.document);
          return availableSearch(doc, x2, y2).map((rng) => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));
        };
        const adt$2 = Adt.generate([
          { before: ["element"] },
          {
            on: [
              "element",
              "offset"
            ]
          },
          { after: ["element"] }
        ]);
        const cata = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);
        const getStart$2 = (situ) => situ.fold(identity, identity, identity);
        const before$1 = adt$2.before;
        const on = adt$2.on;
        const after$1 = adt$2.after;
        const Situ = {
          before: before$1,
          on,
          after: after$1,
          cata,
          getStart: getStart$2
        };
        const adt$1 = Adt.generate([
          { domRange: ["rng"] },
          {
            relative: [
              "startSitu",
              "finishSitu"
            ]
          },
          {
            exact: [
              "start",
              "soffset",
              "finish",
              "foffset"
            ]
          }
        ]);
        const exactFromRange = (simRange) => adt$1.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);
        const getStart$1 = (selection) => selection.match({
          domRange: (rng) => SugarElement.fromDom(rng.startContainer),
          relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),
          exact: (start4, _soffset, _finish, _foffset) => start4
        });
        const domRange = adt$1.domRange;
        const relative = adt$1.relative;
        const exact = adt$1.exact;
        const getWin = (selection) => {
          const start4 = getStart$1(selection);
          return defaultView(start4);
        };
        const range = SimRange.create;
        const SimSelection = {
          domRange,
          relative,
          exact,
          exactFromRange,
          getWin,
          range
        };
        const beforeSpecial = (element, offset2) => {
          const name$1 = name(element);
          if ("input" === name$1) {
            return Situ.after(element);
          } else if (!contains$2([
            "br",
            "img"
          ], name$1)) {
            return Situ.on(element, offset2);
          } else {
            return offset2 === 0 ? Situ.before(element) : Situ.after(element);
          }
        };
        const preprocessRelative = (startSitu, finishSitu) => {
          const start4 = startSitu.fold(Situ.before, beforeSpecial, Situ.after);
          const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);
          return SimSelection.relative(start4, finish);
        };
        const preprocessExact = (start4, soffset, finish, foffset) => {
          const startSitu = beforeSpecial(start4, soffset);
          const finishSitu = beforeSpecial(finish, foffset);
          return SimSelection.relative(startSitu, finishSitu);
        };
        const preprocess = (selection) => selection.match({
          domRange: (rng) => {
            const start4 = SugarElement.fromDom(rng.startContainer);
            const finish = SugarElement.fromDom(rng.endContainer);
            return preprocessExact(start4, rng.startOffset, finish, rng.endOffset);
          },
          relative: preprocessRelative,
          exact: preprocessExact
        });
        const fromElements = (elements, scope) => {
          const doc = scope || document;
          const fragment = doc.createDocumentFragment();
          each$e(elements, (element) => {
            fragment.appendChild(element.dom);
          });
          return SugarElement.fromDom(fragment);
        };
        const toNative = (selection) => {
          const win = SimSelection.getWin(selection).dom;
          const getDomRange = (start4, soffset, finish, foffset) => exactToNative(win, start4, soffset, finish, foffset);
          const filtered = preprocess(selection);
          return diagnose(win, filtered).match({
            ltr: getDomRange,
            rtl: getDomRange
          });
        };
        const getAtPoint = (win, x2, y2) => fromPoint$1(win, x2, y2);
        const fromPoint = (clientX, clientY, doc) => {
          const win = defaultView(SugarElement.fromDom(doc));
          return getAtPoint(win.dom, clientX, clientY).map((simRange) => {
            const rng = doc.createRange();
            rng.setStart(simRange.start.dom, simRange.soffset);
            rng.setEnd(simRange.finish.dom, simRange.foffset);
            return rng;
          }).getOrUndefined();
        };
        const isEq$4 = (rng1, rng2) => {
          return isNonNullable(rng1) && isNonNullable(rng2) && (rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset) && (rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset);
        };
        const findParent = (node, rootNode, predicate) => {
          let currentNode = node;
          while (currentNode && currentNode !== rootNode) {
            if (predicate(currentNode)) {
              return currentNode;
            }
            currentNode = currentNode.parentNode;
          }
          return null;
        };
        const hasParent$1 = (node, rootNode, predicate) => findParent(node, rootNode, predicate) !== null;
        const hasParentWithName = (node, rootNode, name2) => hasParent$1(node, rootNode, (node2) => node2.nodeName === name2);
        const isCeFalseCaretContainer = (node, rootNode) => isCaretContainer$2(node) && !hasParent$1(node, rootNode, isCaretNode);
        const hasBrBeforeAfter = (dom2, node, left2) => {
          const parentNode = node.parentNode;
          if (parentNode) {
            const walker = new DomTreeWalker(node, dom2.getParent(parentNode, dom2.isBlock) || dom2.getRoot());
            let currentNode;
            while (currentNode = walker[left2 ? "prev" : "next"]()) {
              if (isBr$6(currentNode)) {
                return true;
              }
            }
          }
          return false;
        };
        const isPrevNode = (node, name2) => {
          var _a;
          return ((_a = node.previousSibling) === null || _a === void 0 ? void 0 : _a.nodeName) === name2;
        };
        const hasContentEditableFalseParent = (root, node) => {
          let currentNode = node;
          while (currentNode && currentNode !== root) {
            if (isContentEditableFalse$b(currentNode)) {
              return true;
            }
            currentNode = currentNode.parentNode;
          }
          return false;
        };
        const findTextNodeRelative = (dom2, isAfterNode, collapsed, left2, startNode) => {
          const body = dom2.getRoot();
          const nonEmptyElementsMap = dom2.schema.getNonEmptyElements();
          const parentNode = startNode.parentNode;
          let lastInlineElement;
          let node;
          if (!parentNode) {
            return Optional.none();
          }
          const parentBlockContainer = dom2.getParent(parentNode, dom2.isBlock) || body;
          if (left2 && isBr$6(startNode) && isAfterNode && dom2.isEmpty(parentBlockContainer)) {
            return Optional.some(CaretPosition(parentNode, dom2.nodeIndex(startNode)));
          }
          const walker = new DomTreeWalker(startNode, parentBlockContainer);
          while (node = walker[left2 ? "prev" : "next"]()) {
            if (dom2.getContentEditableParent(node) === "false" || isCeFalseCaretContainer(node, body)) {
              return Optional.none();
            }
            if (isText$a(node) && node.data.length > 0) {
              if (!hasParentWithName(node, body, "A")) {
                return Optional.some(CaretPosition(node, left2 ? node.data.length : 0));
              }
              return Optional.none();
            }
            if (dom2.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
              return Optional.none();
            }
            lastInlineElement = node;
          }
          if (isComment(lastInlineElement)) {
            return Optional.none();
          }
          if (collapsed && lastInlineElement) {
            return Optional.some(CaretPosition(lastInlineElement, 0));
          }
          return Optional.none();
        };
        const normalizeEndPoint = (dom2, collapsed, start4, rng) => {
          const body = dom2.getRoot();
          let node;
          let normalized = false;
          let container = start4 ? rng.startContainer : rng.endContainer;
          let offset2 = start4 ? rng.startOffset : rng.endOffset;
          const isAfterNode = isElement$6(container) && offset2 === container.childNodes.length;
          const nonEmptyElementsMap = dom2.schema.getNonEmptyElements();
          let directionLeft = start4;
          if (isCaretContainer$2(container)) {
            return Optional.none();
          }
          if (isElement$6(container) && offset2 > container.childNodes.length - 1) {
            directionLeft = false;
          }
          if (isDocument$1(container)) {
            container = body;
            offset2 = 0;
          }
          if (container === body) {
            if (directionLeft) {
              node = container.childNodes[offset2 > 0 ? offset2 - 1 : 0];
              if (node) {
                if (isCaretContainer$2(node)) {
                  return Optional.none();
                }
                if (nonEmptyElementsMap[node.nodeName] || isTable$2(node)) {
                  return Optional.none();
                }
              }
            }
            if (container.hasChildNodes()) {
              offset2 = Math.min(!directionLeft && offset2 > 0 ? offset2 - 1 : offset2, container.childNodes.length - 1);
              container = container.childNodes[offset2];
              offset2 = isText$a(container) && isAfterNode ? container.data.length : 0;
              if (!collapsed && container === body.lastChild && isTable$2(container)) {
                return Optional.none();
              }
              if (hasContentEditableFalseParent(body, container) || isCaretContainer$2(container)) {
                return Optional.none();
              }
              if (container.hasChildNodes() && !isTable$2(container)) {
                node = container;
                const walker = new DomTreeWalker(container, body);
                do {
                  if (isContentEditableFalse$b(node) || isCaretContainer$2(node)) {
                    normalized = false;
                    break;
                  }
                  if (isText$a(node) && node.data.length > 0) {
                    offset2 = directionLeft ? 0 : node.data.length;
                    container = node;
                    normalized = true;
                    break;
                  }
                  if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCellOrCaption(node)) {
                    offset2 = dom2.nodeIndex(node);
                    container = node.parentNode;
                    if (!directionLeft) {
                      offset2++;
                    }
                    normalized = true;
                    break;
                  }
                } while (node = directionLeft ? walker.next() : walker.prev());
              }
            }
          }
          if (collapsed) {
            if (isText$a(container) && offset2 === 0) {
              findTextNodeRelative(dom2, isAfterNode, collapsed, true, container).each((pos) => {
                container = pos.container();
                offset2 = pos.offset();
                normalized = true;
              });
            }
            if (isElement$6(container)) {
              node = container.childNodes[offset2];
              if (!node) {
                node = container.childNodes[offset2 - 1];
              }
              if (node && isBr$6(node) && !isPrevNode(node, "A") && !hasBrBeforeAfter(dom2, node, false) && !hasBrBeforeAfter(dom2, node, true)) {
                findTextNodeRelative(dom2, isAfterNode, collapsed, true, node).each((pos) => {
                  container = pos.container();
                  offset2 = pos.offset();
                  normalized = true;
                });
              }
            }
          }
          if (directionLeft && !collapsed && isText$a(container) && offset2 === container.data.length) {
            findTextNodeRelative(dom2, isAfterNode, collapsed, false, container).each((pos) => {
              container = pos.container();
              offset2 = pos.offset();
              normalized = true;
            });
          }
          return normalized && container ? Optional.some(CaretPosition(container, offset2)) : Optional.none();
        };
        const normalize$2 = (dom2, rng) => {
          const collapsed = rng.collapsed, normRng = rng.cloneRange();
          const startPos = CaretPosition.fromRangeStart(rng);
          normalizeEndPoint(dom2, collapsed, true, normRng).each((pos) => {
            if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {
              normRng.setStart(pos.container(), pos.offset());
            }
          });
          if (!collapsed) {
            normalizeEndPoint(dom2, collapsed, false, normRng).each((pos) => {
              normRng.setEnd(pos.container(), pos.offset());
            });
          }
          if (collapsed) {
            normRng.collapse(true);
          }
          return isEq$4(rng, normRng) ? Optional.none() : Optional.some(normRng);
        };
        const splitText = (node, offset2) => {
          return node.splitText(offset2);
        };
        const split = (rng) => {
          let startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
          if (startContainer === endContainer && isText$a(startContainer)) {
            if (startOffset > 0 && startOffset < startContainer.data.length) {
              endContainer = splitText(startContainer, startOffset);
              startContainer = endContainer.previousSibling;
              if (endOffset > startOffset) {
                endOffset = endOffset - startOffset;
                const newContainer = splitText(endContainer, endOffset).previousSibling;
                startContainer = endContainer = newContainer;
                endOffset = newContainer.data.length;
                startOffset = 0;
              } else {
                endOffset = 0;
              }
            }
          } else {
            if (isText$a(startContainer) && startOffset > 0 && startOffset < startContainer.data.length) {
              startContainer = splitText(startContainer, startOffset);
              startOffset = 0;
            }
            if (isText$a(endContainer) && endOffset > 0 && endOffset < endContainer.data.length) {
              const newContainer = splitText(endContainer, endOffset).previousSibling;
              endContainer = newContainer;
              endOffset = newContainer.data.length;
            }
          }
          return {
            startContainer,
            startOffset,
            endContainer,
            endOffset
          };
        };
        const RangeUtils = (dom2) => {
          const walk3 = (rng, callback) => {
            return walk$3(dom2, rng, callback);
          };
          const split$12 = split;
          const normalize2 = (rng) => {
            return normalize$2(dom2, rng).fold(never, (normalizedRng) => {
              rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);
              rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);
              return true;
            });
          };
          const expand = (rng, options = { type: "word" }) => {
            if (options.type === "word") {
              const rangeLike = expandRng(dom2, rng, [{ inline: "span" }]);
              const newRange = dom2.createRng();
              newRange.setStart(rangeLike.startContainer, rangeLike.startOffset);
              newRange.setEnd(rangeLike.endContainer, rangeLike.endOffset);
              return newRange;
            }
            return rng;
          };
          return {
            walk: walk3,
            split: split$12,
            expand,
            normalize: normalize2
          };
        };
        RangeUtils.compareRanges = isEq$4;
        RangeUtils.getCaretRangeFromPoint = fromPoint;
        RangeUtils.getSelectedNode = getSelectedNode;
        RangeUtils.getNode = getNode$1;
        const Dimension = (name2, getOffset) => {
          const set2 = (element, h2) => {
            if (!isNumber(h2) && !h2.match(/^[0-9]+$/)) {
              throw new Error(name2 + ".set accepts only positive integer values. Value was " + h2);
            }
            const dom2 = element.dom;
            if (isSupported(dom2)) {
              dom2.style[name2] = h2 + "px";
            }
          };
          const get2 = (element) => {
            const r3 = getOffset(element);
            if (r3 <= 0 || r3 === null) {
              const css = get$7(element, name2);
              return parseFloat(css) || 0;
            }
            return r3;
          };
          const getOuter2 = get2;
          const aggregate = (element, properties) => foldl(properties, (acc, property) => {
            const val = get$7(element, property);
            const value2 = val === void 0 ? 0 : parseInt(val, 10);
            return isNaN(value2) ? acc : acc + value2;
          }, 0);
          const max3 = (element, value2, properties) => {
            const cumulativeInclusions = aggregate(element, properties);
            const absoluteMax = value2 > cumulativeInclusions ? value2 - cumulativeInclusions : 0;
            return absoluteMax;
          };
          return {
            set: set2,
            get: get2,
            getOuter: getOuter2,
            aggregate,
            max: max3
          };
        };
        const api = Dimension("height", (element) => {
          const dom2 = element.dom;
          return inBody(element) ? dom2.getBoundingClientRect().height : dom2.offsetHeight;
        });
        const get$2 = (element) => api.get(element);
        const getDocument = () => SugarElement.fromDom(document);
        const walkUp = (navigation, doc) => {
          const frame = navigation.view(doc);
          return frame.fold(constant([]), (f2) => {
            const parent2 = navigation.owner(f2);
            const rest = walkUp(navigation, parent2);
            return [f2].concat(rest);
          });
        };
        const pathTo = (element, navigation) => {
          const d2 = navigation.owner(element);
          return walkUp(navigation, d2);
        };
        const view = (doc) => {
          var _a;
          const element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);
          return element.map(SugarElement.fromDom);
        };
        const owner = (element) => documentOrOwner(element);
        var Navigation = /* @__PURE__ */ Object.freeze({
          __proto__: null,
          view,
          owner
        });
        const find = (element) => {
          const doc = getDocument();
          const scroll = get$5(doc);
          const frames = pathTo(element, Navigation);
          const offset2 = viewport2(element);
          const r3 = foldr(frames, (b2, a2) => {
            const loc = viewport2(a2);
            return {
              left: b2.left + loc.left,
              top: b2.top + loc.top
            };
          }, {
            left: 0,
            top: 0
          });
          return SugarPosition(r3.left + offset2.left + scroll.left, r3.top + offset2.top + scroll.top);
        };
        const excludeFromDescend = (element) => name(element) === "textarea";
        const fireScrollIntoViewEvent = (editor, data2) => {
          const scrollEvent = editor.dispatch("ScrollIntoView", data2);
          return scrollEvent.isDefaultPrevented();
        };
        const fireAfterScrollIntoViewEvent = (editor, data2) => {
          editor.dispatch("AfterScrollIntoView", data2);
        };
        const descend = (element, offset2) => {
          const children2 = children$1(element);
          if (children2.length === 0 || excludeFromDescend(element)) {
            return {
              element,
              offset: offset2
            };
          } else if (offset2 < children2.length && !excludeFromDescend(children2[offset2])) {
            return {
              element: children2[offset2],
              offset: 0
            };
          } else {
            const last2 = children2[children2.length - 1];
            if (excludeFromDescend(last2)) {
              return {
                element,
                offset: offset2
              };
            } else {
              if (name(last2) === "img") {
                return {
                  element: last2,
                  offset: 1
                };
              } else if (isText$b(last2)) {
                return {
                  element: last2,
                  offset: get$3(last2).length
                };
              } else {
                return {
                  element: last2,
                  offset: children$1(last2).length
                };
              }
            }
          }
        };
        const markerInfo = (element, cleanupFun) => {
          const pos = absolute(element);
          const height = get$2(element);
          return {
            element,
            bottom: pos.top + height,
            height,
            pos,
            cleanup: cleanupFun
          };
        };
        const createMarker$1 = (element, offset2) => {
          const startPoint = descend(element, offset2);
          const span = SugarElement.fromHtml('<span data-mce-bogus="all" style="display: inline-block;">' + ZWSP$1 + "</span>");
          before$3(startPoint.element, span);
          return markerInfo(span, () => remove$5(span));
        };
        const elementMarker = (element) => markerInfo(SugarElement.fromDom(element), noop2);
        const withMarker = (editor, f2, rng, alignToTop) => {
          preserveWith(editor, (_s, _e) => applyWithMarker(editor, f2, rng, alignToTop), rng);
        };
        const withScrollEvents = (editor, doc, f2, marker, alignToTop) => {
          const data2 = {
            elm: marker.element.dom,
            alignToTop
          };
          if (fireScrollIntoViewEvent(editor, data2)) {
            return;
          }
          const scrollTop = get$5(doc).top;
          f2(doc, scrollTop, marker, alignToTop);
          fireAfterScrollIntoViewEvent(editor, data2);
        };
        const applyWithMarker = (editor, f2, rng, alignToTop) => {
          const body = SugarElement.fromDom(editor.getBody());
          const doc = SugarElement.fromDom(editor.getDoc());
          reflow2(body);
          const marker = createMarker$1(SugarElement.fromDom(rng.startContainer), rng.startOffset);
          withScrollEvents(editor, doc, f2, marker, alignToTop);
          marker.cleanup();
        };
        const withElement = (editor, element, f2, alignToTop) => {
          const doc = SugarElement.fromDom(editor.getDoc());
          withScrollEvents(editor, doc, f2, elementMarker(element), alignToTop);
        };
        const preserveWith = (editor, f2, rng) => {
          const startElement = rng.startContainer;
          const startOffset = rng.startOffset;
          const endElement = rng.endContainer;
          const endOffset = rng.endOffset;
          f2(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));
          const newRng = editor.dom.createRng();
          newRng.setStart(startElement, startOffset);
          newRng.setEnd(endElement, endOffset);
          editor.selection.setRng(rng);
        };
        const scrollToMarker = (marker, alignToTop) => marker.element.dom.scrollIntoView({ block: alignToTop ? "start" : "end" });
        const intoWindowIfNeeded = (scrollTop, viewHeight, marker, alignToTop) => {
          const viewportBottom = viewHeight + scrollTop;
          const markerTop = marker.pos.top;
          const markerBottom = marker.bottom;
          const largerThanViewport = markerBottom - markerTop >= viewHeight;
          if (markerTop < scrollTop) {
            scrollToMarker(marker, alignToTop !== false);
          } else if (markerTop > viewportBottom) {
            const align = largerThanViewport ? alignToTop !== false : alignToTop === true;
            scrollToMarker(marker, align);
          } else if (markerBottom > viewportBottom && !largerThanViewport) {
            scrollToMarker(marker, alignToTop === true);
          }
        };
        const intoWindow = (doc, scrollTop, marker, alignToTop) => {
          const viewHeight = defaultView(doc).dom.innerHeight;
          intoWindowIfNeeded(scrollTop, viewHeight, marker, alignToTop);
        };
        const intoFrame = (doc, scrollTop, marker, alignToTop) => {
          const frameViewHeight = defaultView(doc).dom.innerHeight;
          intoWindowIfNeeded(scrollTop, frameViewHeight, marker, alignToTop);
          const op = find(marker.element);
          const viewportBounds = getBounds(window);
          if (op.top < viewportBounds.y) {
            intoView(marker.element, alignToTop !== false);
          } else if (op.top > viewportBounds.bottom) {
            intoView(marker.element, alignToTop === true);
          }
        };
        const rangeIntoWindow = (editor, rng, alignToTop) => withMarker(editor, intoWindow, rng, alignToTop);
        const elementIntoWindow = (editor, element, alignToTop) => withElement(editor, element, intoWindow, alignToTop);
        const rangeIntoFrame = (editor, rng, alignToTop) => withMarker(editor, intoFrame, rng, alignToTop);
        const elementIntoFrame = (editor, element, alignToTop) => withElement(editor, element, intoFrame, alignToTop);
        const scrollElementIntoView = (editor, element, alignToTop) => {
          const scroller = editor.inline ? elementIntoWindow : elementIntoFrame;
          scroller(editor, element, alignToTop);
        };
        const scrollRangeIntoView = (editor, rng, alignToTop) => {
          const scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;
          scroller(editor, rng, alignToTop);
        };
        const focus$1 = (element) => element.dom.focus();
        const hasFocus$1 = (element) => {
          const root = getRootNode(element).dom;
          return element.dom === root.activeElement;
        };
        const active$1 = (root = getDocument()) => Optional.from(root.dom.activeElement).map(SugarElement.fromDom);
        const search = (element) => active$1(getRootNode(element)).filter((e2) => element.dom.contains(e2.dom));
        const clamp$1 = (offset2, element) => {
          const max3 = isText$b(element) ? get$3(element).length : children$1(element).length + 1;
          if (offset2 > max3) {
            return max3;
          } else if (offset2 < 0) {
            return 0;
          }
          return offset2;
        };
        const normalizeRng = (rng) => SimSelection.range(rng.start, clamp$1(rng.soffset, rng.start), rng.finish, clamp$1(rng.foffset, rng.finish));
        const isOrContains = (root, elm) => !isRestrictedNode(elm.dom) && (contains2(root, elm) || eq(root, elm));
        const isRngInRoot = (root) => (rng) => isOrContains(root, rng.start) && isOrContains(root, rng.finish);
        const shouldStore = (editor) => editor.inline || Env.browser.isFirefox();
        const nativeRangeToSelectionRange = (r3) => SimSelection.range(SugarElement.fromDom(r3.startContainer), r3.startOffset, SugarElement.fromDom(r3.endContainer), r3.endOffset);
        const readRange = (win) => {
          const selection = win.getSelection();
          const rng = !selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0));
          return rng.map(nativeRangeToSelectionRange);
        };
        const getBookmark = (root) => {
          const win = defaultView(root);
          return readRange(win.dom).filter(isRngInRoot(root));
        };
        const validate = (root, bookmark) => Optional.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);
        const bookmarkToNativeRng = (bookmark) => {
          const rng = document.createRange();
          try {
            rng.setStart(bookmark.start.dom, bookmark.soffset);
            rng.setEnd(bookmark.finish.dom, bookmark.foffset);
            return Optional.some(rng);
          } catch (_2) {
            return Optional.none();
          }
        };
        const store = (editor) => {
          const newBookmark = shouldStore(editor) ? getBookmark(SugarElement.fromDom(editor.getBody())) : Optional.none();
          editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
        };
        const getRng = (editor) => {
          const bookmark = editor.bookmark ? editor.bookmark : Optional.none();
          return bookmark.bind((x2) => validate(SugarElement.fromDom(editor.getBody()), x2)).bind(bookmarkToNativeRng);
        };
        const restore = (editor) => {
          getRng(editor).each((rng) => editor.selection.setRng(rng));
        };
        const isEditorUIElement$1 = (elm) => {
          const className = elm.className.toString();
          return className.indexOf("tox-") !== -1 || className.indexOf("mce-") !== -1;
        };
        const FocusManager = { isEditorUIElement: isEditorUIElement$1 };
        const wrappedSetTimeout = (callback, time) => {
          if (!isNumber(time)) {
            time = 0;
          }
          return setTimeout(callback, time);
        };
        const wrappedSetInterval = (callback, time) => {
          if (!isNumber(time)) {
            time = 0;
          }
          return setInterval(callback, time);
        };
        const Delay = {
          setEditorTimeout: (editor, callback, time) => {
            return wrappedSetTimeout(() => {
              if (!editor.removed) {
                callback();
              }
            }, time);
          },
          setEditorInterval: (editor, callback, time) => {
            const timer = wrappedSetInterval(() => {
              if (!editor.removed) {
                callback();
              } else {
                clearInterval(timer);
              }
            }, time);
            return timer;
          }
        };
        const isManualNodeChange = (e2) => {
          return e2.type === "nodechange" && e2.selectionChange;
        };
        const registerPageMouseUp = (editor, throttledStore) => {
          const mouseUpPage = () => {
            throttledStore.throttle();
          };
          DOMUtils.DOM.bind(document, "mouseup", mouseUpPage);
          editor.on("remove", () => {
            DOMUtils.DOM.unbind(document, "mouseup", mouseUpPage);
          });
        };
        const registerMouseUp = (editor, throttledStore) => {
          editor.on("mouseup touchend", (_e) => {
            throttledStore.throttle();
          });
        };
        const registerEditorEvents = (editor, throttledStore) => {
          registerMouseUp(editor, throttledStore);
          editor.on("keyup NodeChange AfterSetSelectionRange", (e2) => {
            if (!isManualNodeChange(e2)) {
              store(editor);
            }
          });
        };
        const register$6 = (editor) => {
          const throttledStore = first$1(() => {
            store(editor);
          }, 0);
          editor.on("init", () => {
            if (editor.inline) {
              registerPageMouseUp(editor, throttledStore);
            }
            registerEditorEvents(editor, throttledStore);
          });
          editor.on("remove", () => {
            throttledStore.cancel();
          });
        };
        let documentFocusInHandler;
        const DOM$9 = DOMUtils.DOM;
        const isEditorUIElement = (elm) => {
          return isElement$6(elm) && FocusManager.isEditorUIElement(elm);
        };
        const isEditorContentAreaElement = (elm) => {
          const classList = elm.classList;
          if (classList !== void 0) {
            return classList.contains("tox-edit-area") || classList.contains("tox-edit-area__iframe") || classList.contains("mce-content-body");
          } else {
            return false;
          }
        };
        const isUIElement = (editor, elm) => {
          const customSelector = getCustomUiSelector(editor);
          const parent2 = DOM$9.getParent(elm, (elm2) => {
            return isEditorUIElement(elm2) || (customSelector ? editor.dom.is(elm2, customSelector) : false);
          });
          return parent2 !== null;
        };
        const getActiveElement = (editor) => {
          try {
            const root = getRootNode(SugarElement.fromDom(editor.getElement()));
            return active$1(root).fold(() => document.body, (x2) => x2.dom);
          } catch (ex) {
            return document.body;
          }
        };
        const registerEvents$1 = (editorManager, e2) => {
          const editor = e2.editor;
          register$6(editor);
          const toggleContentAreaOnFocus = (editor2, fn2) => {
            if (shouldHighlightOnFocus(editor2) && editor2.inline !== true) {
              const contentArea = SugarElement.fromDom(editor2.getContainer());
              fn2(contentArea, "tox-edit-focus");
            }
          };
          editor.on("focusin", () => {
            const focusedEditor = editorManager.focusedEditor;
            if (isEditorContentAreaElement(getActiveElement(editor))) {
              toggleContentAreaOnFocus(editor, add$2);
            }
            if (focusedEditor !== editor) {
              if (focusedEditor) {
                focusedEditor.dispatch("blur", { focusedEditor: editor });
              }
              editorManager.setActive(editor);
              editorManager.focusedEditor = editor;
              editor.dispatch("focus", { blurredEditor: focusedEditor });
              editor.focus(true);
            }
          });
          editor.on("focusout", () => {
            Delay.setEditorTimeout(editor, () => {
              const focusedEditor = editorManager.focusedEditor;
              if (!isEditorContentAreaElement(getActiveElement(editor)) || focusedEditor !== editor) {
                toggleContentAreaOnFocus(editor, remove$7);
              }
              if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {
                editor.dispatch("blur", { focusedEditor: null });
                editorManager.focusedEditor = null;
              }
            });
          });
          if (!documentFocusInHandler) {
            documentFocusInHandler = (e3) => {
              const activeEditor = editorManager.activeEditor;
              if (activeEditor) {
                getOriginalEventTarget(e3).each((target) => {
                  const elem = target;
                  if (elem.ownerDocument === document) {
                    if (elem !== document.body && !isUIElement(activeEditor, elem) && editorManager.focusedEditor === activeEditor) {
                      activeEditor.dispatch("blur", { focusedEditor: null });
                      editorManager.focusedEditor = null;
                    }
                  }
                });
              }
            };
            DOM$9.bind(document, "focusin", documentFocusInHandler);
          }
        };
        const unregisterDocumentEvents = (editorManager, e2) => {
          if (editorManager.focusedEditor === e2.editor) {
            editorManager.focusedEditor = null;
          }
          if (!editorManager.activeEditor && documentFocusInHandler) {
            DOM$9.unbind(document, "focusin", documentFocusInHandler);
            documentFocusInHandler = null;
          }
        };
        const setup$v = (editorManager) => {
          editorManager.on("AddEditor", curry(registerEvents$1, editorManager));
          editorManager.on("RemoveEditor", curry(unregisterDocumentEvents, editorManager));
        };
        const getContentEditableHost = (editor, node) => editor.dom.getParent(node, (node2) => editor.dom.getContentEditable(node2) === "true");
        const getCollapsedNode = (rng) => rng.collapsed ? Optional.from(getNode$1(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();
        const getFocusInElement = (root, rng) => getCollapsedNode(rng).bind((node) => {
          if (isTableSection(node)) {
            return Optional.some(node);
          } else if (!contains2(root, node)) {
            return Optional.some(root);
          } else {
            return Optional.none();
          }
        });
        const normalizeSelection = (editor, rng) => {
          getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind((elm) => {
            return firstPositionIn(elm.dom);
          }).fold(() => {
            editor.selection.normalize();
          }, (caretPos) => editor.selection.setRng(caretPos.toRange()));
        };
        const focusBody = (body) => {
          if (body.setActive) {
            try {
              body.setActive();
            } catch (ex) {
              body.focus();
            }
          } else {
            body.focus();
          }
        };
        const hasElementFocus = (elm) => hasFocus$1(elm) || search(elm).isSome();
        const hasIframeFocus = (editor) => isNonNullable(editor.iframeElement) && hasFocus$1(SugarElement.fromDom(editor.iframeElement));
        const hasInlineFocus = (editor) => {
          const rawBody = editor.getBody();
          return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));
        };
        const hasUiFocus = (editor) => {
          const dos = getRootNode(SugarElement.fromDom(editor.getElement()));
          return active$1(dos).filter((elem) => !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom)).isSome();
        };
        const hasFocus = (editor) => editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);
        const hasEditorOrUiFocus = (editor) => hasFocus(editor) || hasUiFocus(editor);
        const focusEditor = (editor) => {
          const selection = editor.selection;
          const body = editor.getBody();
          let rng = selection.getRng();
          editor.quirks.refreshContentEditable();
          if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {
            getRng(editor).each((bookmarkRng) => {
              editor.selection.setRng(bookmarkRng);
              rng = bookmarkRng;
            });
          }
          const contentEditableHost = getContentEditableHost(editor, selection.getNode());
          if (contentEditableHost && editor.dom.isChildOf(contentEditableHost, body)) {
            focusBody(contentEditableHost);
            normalizeSelection(editor, rng);
            activateEditor(editor);
            return;
          }
          if (!editor.inline) {
            if (!Env.browser.isOpera()) {
              focusBody(body);
            }
            editor.getWin().focus();
          }
          if (Env.browser.isFirefox() || editor.inline) {
            focusBody(body);
            normalizeSelection(editor, rng);
          }
          activateEditor(editor);
        };
        const activateEditor = (editor) => editor.editorManager.setActive(editor);
        const focus = (editor, skipFocus) => {
          if (editor.removed) {
            return;
          }
          if (skipFocus) {
            activateEditor(editor);
          } else {
            focusEditor(editor);
          }
        };
        const getEndpointElement = (root, rng, start4, real, resolve2) => {
          const container = start4 ? rng.startContainer : rng.endContainer;
          const offset2 = start4 ? rng.startOffset : rng.endOffset;
          return Optional.from(container).map(SugarElement.fromDom).map((elm) => !real || !rng.collapsed ? child$1(elm, resolve2(elm, offset2)).getOr(elm) : elm).bind((elm) => isElement$7(elm) ? Optional.some(elm) : parent(elm).filter(isElement$7)).map((elm) => elm.dom).getOr(root);
        };
        const getStart = (root, rng, real = false) => getEndpointElement(root, rng, true, real, (elm, offset2) => Math.min(childNodesCount(elm), offset2));
        const getEnd$1 = (root, rng, real = false) => getEndpointElement(root, rng, false, real, (elm, offset2) => offset2 > 0 ? offset2 - 1 : offset2);
        const skipEmptyTextNodes = (node, forwards) => {
          const orig = node;
          while (node && isText$a(node) && node.length === 0) {
            node = forwards ? node.nextSibling : node.previousSibling;
          }
          return node || orig;
        };
        const getNode = (root, rng) => {
          if (!rng) {
            return root;
          }
          let startContainer = rng.startContainer;
          let endContainer = rng.endContainer;
          const startOffset = rng.startOffset;
          const endOffset = rng.endOffset;
          let node = rng.commonAncestorContainer;
          if (!rng.collapsed) {
            if (startContainer === endContainer) {
              if (endOffset - startOffset < 2) {
                if (startContainer.hasChildNodes()) {
                  node = startContainer.childNodes[startOffset];
                }
              }
            }
            if (isText$a(startContainer) && isText$a(endContainer)) {
              if (startContainer.length === startOffset) {
                startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);
              } else {
                startContainer = startContainer.parentNode;
              }
              if (endOffset === 0) {
                endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);
              } else {
                endContainer = endContainer.parentNode;
              }
              if (startContainer && startContainer === endContainer) {
                node = startContainer;
              }
            }
          }
          const elm = isText$a(node) ? node.parentNode : node;
          return isElement$6(elm) ? elm : root;
        };
        const getSelectedBlocks = (dom2, rng, startElm, endElm) => {
          const selectedBlocks = [];
          const root = dom2.getRoot();
          const start4 = dom2.getParent(startElm || getStart(root, rng, rng.collapsed), dom2.isBlock);
          const end3 = dom2.getParent(endElm || getEnd$1(root, rng, rng.collapsed), dom2.isBlock);
          if (start4 && start4 !== root) {
            selectedBlocks.push(start4);
          }
          if (start4 && end3 && start4 !== end3) {
            let node;
            const walker = new DomTreeWalker(start4, root);
            while ((node = walker.next()) && node !== end3) {
              if (dom2.isBlock(node)) {
                selectedBlocks.push(node);
              }
            }
          }
          if (end3 && start4 !== end3 && end3 !== root) {
            selectedBlocks.push(end3);
          }
          return selectedBlocks;
        };
        const select = (dom2, node, content) => Optional.from(node).bind((node2) => Optional.from(node2.parentNode).map((parent2) => {
          const idx = dom2.nodeIndex(node2);
          const rng = dom2.createRng();
          rng.setStart(parent2, idx);
          rng.setEnd(parent2, idx + 1);
          if (content) {
            moveEndPoint(dom2, rng, node2, true);
            moveEndPoint(dom2, rng, node2, false);
          }
          return rng;
        }));
        const processRanges = (editor, ranges) => map$3(ranges, (range2) => {
          const evt = editor.dispatch("GetSelectionRange", { range: range2 });
          return evt.range !== range2 ? evt.range : range2;
        });
        const getEnd = (element) => name(element) === "img" ? 1 : getOption(element).fold(() => children$1(element).length, (v2) => v2.length);
        const isTextNodeWithCursorPosition = (el) => getOption(el).filter((text2) => text2.trim().length !== 0 || text2.indexOf(nbsp) > -1).isSome();
        const isContentEditableFalse$5 = (elem) => isHTMLElement2(elem) && get$9(elem, "contenteditable") === "false";
        const elementsWithCursorPosition = [
          "img",
          "br"
        ];
        const isCursorPosition = (elem) => {
          const hasCursorPosition = isTextNodeWithCursorPosition(elem);
          return hasCursorPosition || contains$2(elementsWithCursorPosition, name(elem)) || isContentEditableFalse$5(elem);
        };
        const first = (element) => descendant$1(element, isCursorPosition);
        const last = (element) => descendantRtl(element, isCursorPosition);
        const descendantRtl = (scope, predicate) => {
          const descend2 = (element) => {
            const children2 = children$1(element);
            for (let i2 = children2.length - 1; i2 >= 0; i2--) {
              const child2 = children2[i2];
              if (predicate(child2)) {
                return Optional.some(child2);
              }
              const res = descend2(child2);
              if (res.isSome()) {
                return res;
              }
            }
            return Optional.none();
          };
          return descend2(scope);
        };
        const autocompleteSelector = "[data-mce-autocompleter]";
        const create$9 = (editor, range2) => {
          if (findIn(SugarElement.fromDom(editor.getBody())).isNone()) {
            const wrapper = SugarElement.fromHtml('<span data-mce-autocompleter="1" data-mce-bogus="1"></span>', editor.getDoc());
            append$1(wrapper, SugarElement.fromDom(range2.extractContents()));
            range2.insertNode(wrapper.dom);
            parent(wrapper).each((elm) => elm.dom.normalize());
            last(wrapper).map((last2) => {
              editor.selection.setCursorLocation(last2.dom, getEnd(last2));
            });
          }
        };
        const detect$1 = (elm) => closest$3(elm, autocompleteSelector);
        const findIn = (elm) => descendant(elm, autocompleteSelector);
        const remove$2 = (editor, elm) => findIn(elm).each((wrapper) => {
          const bookmark = editor.selection.getBookmark();
          unwrap(wrapper);
          editor.selection.moveToBookmark(bookmark);
        });
        const typeLookup = {
          "#text": 3,
          "#comment": 8,
          "#cdata": 4,
          "#pi": 7,
          "#doctype": 10,
          "#document-fragment": 11
        };
        const walk$2 = (node, root, prev2) => {
          const startName = prev2 ? "lastChild" : "firstChild";
          const siblingName = prev2 ? "prev" : "next";
          if (node[startName]) {
            return node[startName];
          }
          if (node !== root) {
            let sibling2 = node[siblingName];
            if (sibling2) {
              return sibling2;
            }
            for (let parent2 = node.parent; parent2 && parent2 !== root; parent2 = parent2.parent) {
              sibling2 = parent2[siblingName];
              if (sibling2) {
                return sibling2;
              }
            }
          }
          return void 0;
        };
        const isEmptyTextNode = (node) => {
          var _a;
          const text2 = (_a = node.value) !== null && _a !== void 0 ? _a : "";
          if (!isWhitespaceText(text2)) {
            return false;
          }
          const parentNode = node.parent;
          if (parentNode && (parentNode.name !== "span" || parentNode.attr("style")) && /^[ ]+$/.test(text2)) {
            return false;
          }
          return true;
        };
        const isNonEmptyElement = (node) => {
          const isNamedAnchor2 = node.name === "a" && !node.attr("href") && node.attr("id");
          return node.attr("name") || node.attr("id") && !node.firstChild || node.attr("data-mce-bookmark") || isNamedAnchor2;
        };
        class AstNode {
          static create(name2, attrs) {
            const node = new AstNode(name2, typeLookup[name2] || 1);
            if (attrs) {
              each$d(attrs, (value2, attrName) => {
                node.attr(attrName, value2);
              });
            }
            return node;
          }
          constructor(name2, type2) {
            this.name = name2;
            this.type = type2;
            if (type2 === 1) {
              this.attributes = [];
              this.attributes.map = {};
            }
          }
          replace(node) {
            const self2 = this;
            if (node.parent) {
              node.remove();
            }
            self2.insert(node, self2);
            self2.remove();
            return self2;
          }
          attr(name2, value2) {
            const self2 = this;
            if (!isString(name2)) {
              if (isNonNullable(name2)) {
                each$d(name2, (value3, key) => {
                  self2.attr(key, value3);
                });
              }
              return self2;
            }
            const attrs = self2.attributes;
            if (attrs) {
              if (value2 !== void 0) {
                if (value2 === null) {
                  if (name2 in attrs.map) {
                    delete attrs.map[name2];
                    let i2 = attrs.length;
                    while (i2--) {
                      if (attrs[i2].name === name2) {
                        attrs.splice(i2, 1);
                        return self2;
                      }
                    }
                  }
                  return self2;
                }
                if (name2 in attrs.map) {
                  let i2 = attrs.length;
                  while (i2--) {
                    if (attrs[i2].name === name2) {
                      attrs[i2].value = value2;
                      break;
                    }
                  }
                } else {
                  attrs.push({
                    name: name2,
                    value: value2
                  });
                }
                attrs.map[name2] = value2;
                return self2;
              }
              return attrs.map[name2];
            }
            return void 0;
          }
          clone() {
            const self2 = this;
            const clone2 = new AstNode(self2.name, self2.type);
            const selfAttrs = self2.attributes;
            if (selfAttrs) {
              const cloneAttrs = [];
              cloneAttrs.map = {};
              for (let i2 = 0, l2 = selfAttrs.length; i2 < l2; i2++) {
                const selfAttr = selfAttrs[i2];
                if (selfAttr.name !== "id") {
                  cloneAttrs[cloneAttrs.length] = {
                    name: selfAttr.name,
                    value: selfAttr.value
                  };
                  cloneAttrs.map[selfAttr.name] = selfAttr.value;
                }
              }
              clone2.attributes = cloneAttrs;
            }
            clone2.value = self2.value;
            return clone2;
          }
          wrap(wrapper) {
            const self2 = this;
            if (self2.parent) {
              self2.parent.insert(wrapper, self2);
              wrapper.append(self2);
            }
            return self2;
          }
          unwrap() {
            const self2 = this;
            for (let node = self2.firstChild; node; ) {
              const next2 = node.next;
              self2.insert(node, self2, true);
              node = next2;
            }
            self2.remove();
          }
          remove() {
            const self2 = this, parent2 = self2.parent, next2 = self2.next, prev2 = self2.prev;
            if (parent2) {
              if (parent2.firstChild === self2) {
                parent2.firstChild = next2;
                if (next2) {
                  next2.prev = null;
                }
              } else if (prev2) {
                prev2.next = next2;
              }
              if (parent2.lastChild === self2) {
                parent2.lastChild = prev2;
                if (prev2) {
                  prev2.next = null;
                }
              } else if (next2) {
                next2.prev = prev2;
              }
              self2.parent = self2.next = self2.prev = null;
            }
            return self2;
          }
          append(node) {
            const self2 = this;
            if (node.parent) {
              node.remove();
            }
            const last2 = self2.lastChild;
            if (last2) {
              last2.next = node;
              node.prev = last2;
              self2.lastChild = node;
            } else {
              self2.lastChild = self2.firstChild = node;
            }
            node.parent = self2;
            return node;
          }
          insert(node, refNode, before2) {
            if (node.parent) {
              node.remove();
            }
            const parent2 = refNode.parent || this;
            if (before2) {
              if (refNode === parent2.firstChild) {
                parent2.firstChild = node;
              } else if (refNode.prev) {
                refNode.prev.next = node;
              }
              node.prev = refNode.prev;
              node.next = refNode;
              refNode.prev = node;
            } else {
              if (refNode === parent2.lastChild) {
                parent2.lastChild = node;
              } else if (refNode.next) {
                refNode.next.prev = node;
              }
              node.next = refNode.next;
              node.prev = refNode;
              refNode.next = node;
            }
            node.parent = parent2;
            return node;
          }
          getAll(name2) {
            const self2 = this;
            const collection = [];
            for (let node = self2.firstChild; node; node = walk$2(node, self2)) {
              if (node.name === name2) {
                collection.push(node);
              }
            }
            return collection;
          }
          children() {
            const self2 = this;
            const collection = [];
            for (let node = self2.firstChild; node; node = node.next) {
              collection.push(node);
            }
            return collection;
          }
          empty() {
            const self2 = this;
            if (self2.firstChild) {
              const nodes = [];
              for (let node = self2.firstChild; node; node = walk$2(node, self2)) {
                nodes.push(node);
              }
              let i2 = nodes.length;
              while (i2--) {
                const node = nodes[i2];
                node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;
              }
            }
            self2.firstChild = self2.lastChild = null;
            return self2;
          }
          isEmpty(elements, whitespace = {}, predicate) {
            var _a;
            const self2 = this;
            let node = self2.firstChild;
            if (isNonEmptyElement(self2)) {
              return false;
            }
            if (node) {
              do {
                if (node.type === 1) {
                  if (node.attr("data-mce-bogus")) {
                    continue;
                  }
                  if (elements[node.name]) {
                    return false;
                  }
                  if (isNonEmptyElement(node)) {
                    return false;
                  }
                }
                if (node.type === 8) {
                  return false;
                }
                if (node.type === 3 && !isEmptyTextNode(node)) {
                  return false;
                }
                if (node.type === 3 && node.parent && whitespace[node.parent.name] && isWhitespaceText((_a = node.value) !== null && _a !== void 0 ? _a : "")) {
                  return false;
                }
                if (predicate && predicate(node)) {
                  return false;
                }
              } while (node = walk$2(node, self2));
            }
            return true;
          }
          walk(prev2) {
            return walk$2(this, null, prev2);
          }
        }
        const isConditionalComment = (html2, startIndex) => /^\s*\[if [\w\W]+\]>.*<!\[endif\](--!?)?>/.test(html2.substr(startIndex));
        const findCommentEndIndex = (html2, isBogus2, startIndex = 0) => {
          const lcHtml = html2.toLowerCase();
          if (lcHtml.indexOf("[if ", startIndex) !== -1 && isConditionalComment(lcHtml, startIndex)) {
            const endIfIndex = lcHtml.indexOf("[endif]", startIndex);
            return lcHtml.indexOf(">", endIfIndex);
          } else {
            if (isBogus2) {
              const endIndex = lcHtml.indexOf(">", startIndex);
              return endIndex !== -1 ? endIndex : lcHtml.length;
            } else {
              const endCommentRegexp = /--!?>/g;
              endCommentRegexp.lastIndex = startIndex;
              const match2 = endCommentRegexp.exec(html2);
              return match2 ? match2.index + match2[0].length : lcHtml.length;
            }
          }
        };
        const findMatchingEndTagIndex = (schema, html2, startIndex) => {
          const startTagRegExp = /<([!?\/])?([A-Za-z0-9\-_:.]+)/g;
          const endTagRegExp = /(?:\s(?:[^'">]+(?:"[^"]*"|'[^']*'))*[^"'>]*(?:"[^">]*|'[^'>]*)?|\s*|\/)>/g;
          const voidElements = schema.getVoidElements();
          let count2 = 1, index = startIndex;
          while (count2 !== 0) {
            startTagRegExp.lastIndex = index;
            while (true) {
              const startMatch = startTagRegExp.exec(html2);
              if (startMatch === null) {
                return index;
              } else if (startMatch[1] === "!") {
                if (startsWith(startMatch[2], "--")) {
                  index = findCommentEndIndex(html2, false, startMatch.index + "!--".length);
                } else {
                  index = findCommentEndIndex(html2, true, startMatch.index + 1);
                }
                break;
              } else {
                endTagRegExp.lastIndex = startTagRegExp.lastIndex;
                const endMatch = endTagRegExp.exec(html2);
                if (isNull(endMatch) || endMatch.index !== startTagRegExp.lastIndex) {
                  continue;
                }
                if (startMatch[1] === "/") {
                  count2 -= 1;
                } else if (!has$2(voidElements, startMatch[2])) {
                  count2 += 1;
                }
                index = startTagRegExp.lastIndex + endMatch[0].length;
                break;
              }
            }
          }
          return index;
        };
        const trimHtml$1 = (tempAttrs, html2) => {
          const trimContentRegExp = new RegExp(["\\s?(" + tempAttrs.join("|") + ')="[^"]+"'].join("|"), "gi");
          return html2.replace(trimContentRegExp, "");
        };
        const trimInternal = (serializer, html2) => {
          const bogusAllRegExp = /<(\w+) [^>]*data-mce-bogus="all"[^>]*>/g;
          const schema = serializer.schema;
          let content = trimHtml$1(serializer.getTempAttrs(), html2);
          const voidElements = schema.getVoidElements();
          let matches;
          while (matches = bogusAllRegExp.exec(content)) {
            const index = bogusAllRegExp.lastIndex;
            const matchLength = matches[0].length;
            let endTagIndex;
            if (voidElements[matches[1]]) {
              endTagIndex = index;
            } else {
              endTagIndex = findMatchingEndTagIndex(schema, content, index);
            }
            content = content.substring(0, index - matchLength) + content.substring(endTagIndex);
            bogusAllRegExp.lastIndex = index - matchLength;
          }
          return trim$1(content);
        };
        const trimExternal = trimInternal;
        const cleanupBogusElements = (parent2) => {
          const bogusElements = descendants(parent2, "[data-mce-bogus]");
          each$e(bogusElements, (elem) => {
            const bogusValue = get$9(elem, "data-mce-bogus");
            if (bogusValue === "all") {
              remove$5(elem);
            } else if (isBr$5(elem)) {
              before$3(elem, SugarElement.fromText(zeroWidth));
              remove$5(elem);
            } else {
              unwrap(elem);
            }
          });
        };
        const cleanupInputNames = (parent2) => {
          const inputs = descendants(parent2, "input");
          each$e(inputs, (input) => {
            remove$a(input, "name");
          });
        };
        const trimEmptyContents = (editor, html2) => {
          const blockName = getForcedRootBlock(editor);
          const emptyRegExp = new RegExp(`^(<${blockName}[^>]*>(&nbsp;|&#160;|\\s|\xA0|<br \\/>|)<\\/${blockName}>[\r
]*|<br \\/>[\r
]*)$`);
          return html2.replace(emptyRegExp, "");
        };
        const getPlainTextContent = (editor, body) => {
          const doc = editor.getDoc();
          const dos = getRootNode(SugarElement.fromDom(editor.getBody()));
          const offscreenDiv = SugarElement.fromTag("div", doc);
          set$3(offscreenDiv, "data-mce-bogus", "all");
          setAll(offscreenDiv, {
            position: "fixed",
            left: "-9999999px",
            top: "0"
          });
          set$1(offscreenDiv, body.innerHTML);
          cleanupBogusElements(offscreenDiv);
          cleanupInputNames(offscreenDiv);
          const root = getContentContainer(dos);
          append$1(root, offscreenDiv);
          const content = trim$1(offscreenDiv.dom.innerText);
          remove$5(offscreenDiv);
          return content;
        };
        const getContentFromBody = (editor, args, body) => {
          let content;
          if (args.format === "raw") {
            content = Tools.trim(trimExternal(editor.serializer, body.innerHTML));
          } else if (args.format === "text") {
            content = getPlainTextContent(editor, body);
          } else if (args.format === "tree") {
            content = editor.serializer.serialize(body, args);
          } else {
            content = trimEmptyContents(editor, editor.serializer.serialize(body, args));
          }
          const shouldTrim = args.format !== "text" && !isWsPreserveElement(SugarElement.fromDom(body));
          return shouldTrim && isString(content) ? Tools.trim(content) : content;
        };
        const getContentInternal = (editor, args) => Optional.from(editor.getBody()).fold(constant(args.format === "tree" ? new AstNode("body", 11) : ""), (body) => getContentFromBody(editor, args, body));
        const makeMap$1 = Tools.makeMap;
        const Writer = (settings) => {
          const html2 = [];
          settings = settings || {};
          const indent2 = settings.indent;
          const indentBefore = makeMap$1(settings.indent_before || "");
          const indentAfter = makeMap$1(settings.indent_after || "");
          const encode = Entities.getEncodeFunc(settings.entity_encoding || "raw", settings.entities);
          const htmlOutput = settings.element_format !== "xhtml";
          return {
            start: (name2, attrs, empty2) => {
              if (indent2 && indentBefore[name2] && html2.length > 0) {
                const value2 = html2[html2.length - 1];
                if (value2.length > 0 && value2 !== "\n") {
                  html2.push("\n");
                }
              }
              html2.push("<", name2);
              if (attrs) {
                for (let i2 = 0, l2 = attrs.length; i2 < l2; i2++) {
                  const attr = attrs[i2];
                  html2.push(" ", attr.name, '="', encode(attr.value, true), '"');
                }
              }
              if (!empty2 || htmlOutput) {
                html2[html2.length] = ">";
              } else {
                html2[html2.length] = " />";
              }
              if (empty2 && indent2 && indentAfter[name2] && html2.length > 0) {
                const value2 = html2[html2.length - 1];
                if (value2.length > 0 && value2 !== "\n") {
                  html2.push("\n");
                }
              }
            },
            end: (name2) => {
              let value2;
              html2.push("</", name2, ">");
              if (indent2 && indentAfter[name2] && html2.length > 0) {
                value2 = html2[html2.length - 1];
                if (value2.length > 0 && value2 !== "\n") {
                  html2.push("\n");
                }
              }
            },
            text: (text2, raw) => {
              if (text2.length > 0) {
                html2[html2.length] = raw ? text2 : encode(text2);
              }
            },
            cdata: (text2) => {
              html2.push("<![CDATA[", text2, "]]>");
            },
            comment: (text2) => {
              html2.push("<!--", text2, "-->");
            },
            pi: (name2, text2) => {
              if (text2) {
                html2.push("<?", name2, " ", encode(text2), "?>");
              } else {
                html2.push("<?", name2, "?>");
              }
              if (indent2) {
                html2.push("\n");
              }
            },
            doctype: (text2) => {
              html2.push("<!DOCTYPE", text2, ">", indent2 ? "\n" : "");
            },
            reset: () => {
              html2.length = 0;
            },
            getContent: () => {
              return html2.join("").replace(/\n$/, "");
            }
          };
        };
        const HtmlSerializer = (settings = {}, schema = Schema()) => {
          const writer = Writer(settings);
          settings.validate = "validate" in settings ? settings.validate : true;
          const serialize = (node) => {
            const validate2 = settings.validate;
            const handlers = {
              3: (node2) => {
                var _a;
                writer.text((_a = node2.value) !== null && _a !== void 0 ? _a : "", node2.raw);
              },
              8: (node2) => {
                var _a;
                writer.comment((_a = node2.value) !== null && _a !== void 0 ? _a : "");
              },
              7: (node2) => {
                writer.pi(node2.name, node2.value);
              },
              10: (node2) => {
                var _a;
                writer.doctype((_a = node2.value) !== null && _a !== void 0 ? _a : "");
              },
              4: (node2) => {
                var _a;
                writer.cdata((_a = node2.value) !== null && _a !== void 0 ? _a : "");
              },
              11: (node2) => {
                let tempNode = node2;
                if (tempNode = tempNode.firstChild) {
                  do {
                    walk3(tempNode);
                  } while (tempNode = tempNode.next);
                }
              }
            };
            writer.reset();
            const walk3 = (node2) => {
              var _a;
              const handler = handlers[node2.type];
              if (!handler) {
                const name2 = node2.name;
                const isEmpty2 = name2 in schema.getVoidElements();
                let attrs = node2.attributes;
                if (validate2 && attrs && attrs.length > 1) {
                  const sortedAttrs = [];
                  sortedAttrs.map = {};
                  const elementRule = schema.getElementRule(node2.name);
                  if (elementRule) {
                    for (let i2 = 0, l2 = elementRule.attributesOrder.length; i2 < l2; i2++) {
                      const attrName = elementRule.attributesOrder[i2];
                      if (attrName in attrs.map) {
                        const attrValue = attrs.map[attrName];
                        sortedAttrs.map[attrName] = attrValue;
                        sortedAttrs.push({
                          name: attrName,
                          value: attrValue
                        });
                      }
                    }
                    for (let i2 = 0, l2 = attrs.length; i2 < l2; i2++) {
                      const attrName = attrs[i2].name;
                      if (!(attrName in sortedAttrs.map)) {
                        const attrValue = attrs.map[attrName];
                        sortedAttrs.map[attrName] = attrValue;
                        sortedAttrs.push({
                          name: attrName,
                          value: attrValue
                        });
                      }
                    }
                    attrs = sortedAttrs;
                  }
                }
                writer.start(name2, attrs, isEmpty2);
                if (!isEmpty2) {
                  let child2 = node2.firstChild;
                  if (child2) {
                    if ((name2 === "pre" || name2 === "textarea") && child2.type === 3 && ((_a = child2.value) === null || _a === void 0 ? void 0 : _a[0]) === "\n") {
                      writer.text("\n", true);
                    }
                    do {
                      walk3(child2);
                    } while (child2 = child2.next);
                  }
                  writer.end(name2);
                }
              } else {
                handler(node2);
              }
            };
            if (node.type === 1 && !settings.inner) {
              walk3(node);
            } else if (node.type === 3) {
              handlers[3](node);
            } else {
              handlers[11](node);
            }
            return writer.getContent();
          };
          return { serialize };
        };
        const nonInheritableStyles = /* @__PURE__ */ new Set();
        (() => {
          const nonInheritableStylesArr = [
            "margin",
            "margin-left",
            "margin-right",
            "margin-top",
            "margin-bottom",
            "padding",
            "padding-left",
            "padding-right",
            "padding-top",
            "padding-bottom",
            "border",
            "border-width",
            "border-style",
            "border-color",
            "background",
            "background-attachment",
            "background-clip",
            "background-color",
            "background-image",
            "background-origin",
            "background-position",
            "background-repeat",
            "background-size",
            "float",
            "position",
            "left",
            "right",
            "top",
            "bottom",
            "z-index",
            "display",
            "transform",
            "width",
            "max-width",
            "min-width",
            "height",
            "max-height",
            "min-height",
            "overflow",
            "overflow-x",
            "overflow-y",
            "text-overflow",
            "vertical-align",
            "transition",
            "transition-delay",
            "transition-duration",
            "transition-property",
            "transition-timing-function"
          ];
          each$e(nonInheritableStylesArr, (style) => {
            nonInheritableStyles.add(style);
          });
        })();
        const shorthandStyleProps = [
          "font",
          "text-decoration",
          "text-emphasis"
        ];
        const getStyleProps = (dom2, node) => keys(dom2.parseStyle(dom2.getAttrib(node, "style")));
        const isNonInheritableStyle = (style) => nonInheritableStyles.has(style);
        const hasInheritableStyles = (dom2, node) => forall(getStyleProps(dom2, node), (style) => !isNonInheritableStyle(style));
        const getLonghandStyleProps = (styles) => filter$5(styles, (style) => exists(shorthandStyleProps, (prop) => startsWith(style, prop)));
        const hasStyleConflict = (dom2, node, parentNode) => {
          const nodeStyleProps = getStyleProps(dom2, node);
          const parentNodeStyleProps = getStyleProps(dom2, parentNode);
          const valueMismatch = (prop) => {
            var _a, _b;
            const nodeValue = (_a = dom2.getStyle(node, prop)) !== null && _a !== void 0 ? _a : "";
            const parentValue = (_b = dom2.getStyle(parentNode, prop)) !== null && _b !== void 0 ? _b : "";
            return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;
          };
          return exists(nodeStyleProps, (nodeStyleProp) => {
            const propExists = (props) => exists(props, (prop) => prop === nodeStyleProp);
            if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) {
              const longhandProps = getLonghandStyleProps(parentNodeStyleProps);
              return exists(longhandProps, valueMismatch);
            } else {
              return valueMismatch(nodeStyleProp);
            }
          });
        };
        const isChar = (forward, predicate, pos) => Optional.from(pos.container()).filter(isText$a).exists((text2) => {
          const delta = forward ? 0 : -1;
          return predicate(text2.data.charAt(pos.offset() + delta));
        });
        const isBeforeSpace = curry(isChar, true, isWhiteSpace);
        const isAfterSpace = curry(isChar, false, isWhiteSpace);
        const isEmptyText = (pos) => {
          const container = pos.container();
          return isText$a(container) && (container.data.length === 0 || isZwsp$1(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));
        };
        const matchesElementPosition = (before2, predicate) => (pos) => getChildNodeAtRelativeOffset(before2 ? 0 : -1, pos).filter(predicate).isSome();
        const isImageBlock = (node) => isImg(node) && get$7(SugarElement.fromDom(node), "display") === "block";
        const isCefNode = (node) => isContentEditableFalse$b(node) && !isBogusAll$1(node);
        const isBeforeImageBlock = matchesElementPosition(true, isImageBlock);
        const isAfterImageBlock = matchesElementPosition(false, isImageBlock);
        const isBeforeMedia = matchesElementPosition(true, isMedia$2);
        const isAfterMedia = matchesElementPosition(false, isMedia$2);
        const isBeforeTable = matchesElementPosition(true, isTable$2);
        const isAfterTable = matchesElementPosition(false, isTable$2);
        const isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);
        const isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);
        const dropLast = (xs) => xs.slice(0, -1);
        const parentsUntil = (start4, root, predicate) => {
          if (contains2(root, start4)) {
            return dropLast(parents$1(start4, (elm) => {
              return predicate(elm) || eq(elm, root);
            }));
          } else {
            return [];
          }
        };
        const parents = (start4, root) => parentsUntil(start4, root, never);
        const parentsAndSelf = (start4, root) => [start4].concat(parents(start4, root));
        const navigateIgnoreEmptyTextNodes = (forward, root, from2) => navigateIgnore(forward, root, from2, isEmptyText);
        const getClosestBlock$1 = (root, pos) => find$2(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);
        const isAtBeforeAfterBlockBoundary = (forward, root, pos) => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall((newPos) => getClosestBlock$1(root, pos).fold(() => !isInSameBlock(newPos, pos, root.dom), (fromBlock) => !isInSameBlock(newPos, pos, root.dom) && contains2(fromBlock, SugarElement.fromDom(newPos.container()))));
        const isAtBlockBoundary = (forward, root, pos) => getClosestBlock$1(root, pos).fold(() => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall((newPos) => !isInSameBlock(newPos, pos, root.dom)), (parent2) => navigateIgnoreEmptyTextNodes(forward, parent2.dom, pos).isNone());
        const isAtStartOfBlock = curry(isAtBlockBoundary, false);
        const isAtEndOfBlock = curry(isAtBlockBoundary, true);
        const isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);
        const isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);
        const isBr$1 = (pos) => getElementFromPosition(pos).exists(isBr$5);
        const findBr = (forward, root, pos) => {
          const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);
          const scope = head(parentBlocks).getOr(root);
          return fromPosition(forward, scope.dom, pos).filter(isBr$1);
        };
        const isBeforeBr$1 = (root, pos) => getElementFromPosition(pos).exists(isBr$5) || findBr(true, root, pos).isSome();
        const isAfterBr = (root, pos) => getElementFromPrevPosition(pos).exists(isBr$5) || findBr(false, root, pos).isSome();
        const findPreviousBr = curry(findBr, false);
        const findNextBr = curry(findBr, true);
        const isInMiddleOfText = (pos) => CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();
        const getClosestBlock = (root, pos) => {
          const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$2);
          return head(parentBlocks).getOr(root);
        };
        const hasSpaceBefore = (root, pos) => {
          if (isInMiddleOfText(pos)) {
            return isAfterSpace(pos);
          } else {
            return isAfterSpace(pos) || prevPosition(getClosestBlock(root, pos).dom, pos).exists(isAfterSpace);
          }
        };
        const hasSpaceAfter = (root, pos) => {
          if (isInMiddleOfText(pos)) {
            return isBeforeSpace(pos);
          } else {
            return isBeforeSpace(pos) || nextPosition(getClosestBlock(root, pos).dom, pos).exists(isBeforeSpace);
          }
        };
        const isPreValue = (value2) => contains$2([
          "pre",
          "pre-wrap"
        ], value2);
        const isInPre = (pos) => getElementFromPosition(pos).bind((elm) => closest$4(elm, isElement$7)).exists((elm) => isPreValue(get$7(elm, "white-space")));
        const isAtBeginningOfBody = (root, pos) => prevPosition(root.dom, pos).isNone();
        const isAtEndOfBody = (root, pos) => nextPosition(root.dom, pos).isNone();
        const isAtLineBoundary = (root, pos) => isAtBeginningOfBody(root, pos) || isAtEndOfBody(root, pos) || isAtStartOfBlock(root, pos) || isAtEndOfBlock(root, pos) || isAfterBr(root, pos) || isBeforeBr$1(root, pos);
        const isCefBlock = (node) => isNonNullable(node) && isContentEditableFalse$b(node) && isBlockLike(node);
        const isSiblingCefBlock = (root, direction) => (container) => {
          return isCefBlock(new DomTreeWalker(container, root)[direction]());
        };
        const isBeforeCefBlock = (root, pos) => {
          const nextPos = nextPosition(root.dom, pos).getOr(pos);
          const isNextCefBlock = isSiblingCefBlock(root.dom, "next");
          return pos.isAtEnd() && (isNextCefBlock(pos.container()) || isNextCefBlock(nextPos.container()));
        };
        const isAfterCefBlock = (root, pos) => {
          const prevPos = prevPosition(root.dom, pos).getOr(pos);
          const isPrevCefBlock = isSiblingCefBlock(root.dom, "prev");
          return pos.isAtStart() && (isPrevCefBlock(pos.container()) || isPrevCefBlock(prevPos.container()));
        };
        const needsToHaveNbsp = (root, pos) => {
          if (isInPre(pos)) {
            return false;
          } else {
            return isAtLineBoundary(root, pos) || hasSpaceBefore(root, pos) || hasSpaceAfter(root, pos);
          }
        };
        const needsToBeNbspLeft = (root, pos) => {
          if (isInPre(pos)) {
            return false;
          } else {
            return isAtStartOfBlock(root, pos) || isBeforeBlock(root, pos) || isAfterBr(root, pos) || hasSpaceBefore(root, pos) || isAfterCefBlock(root, pos);
          }
        };
        const leanRight = (pos) => {
          const container = pos.container();
          const offset2 = pos.offset();
          if (isText$a(container) && offset2 < container.data.length) {
            return CaretPosition(container, offset2 + 1);
          } else {
            return pos;
          }
        };
        const needsToBeNbspRight = (root, pos) => {
          if (isInPre(pos)) {
            return false;
          } else {
            return isAtEndOfBlock(root, pos) || isAfterBlock(root, pos) || isBeforeBr$1(root, pos) || hasSpaceAfter(root, pos) || isBeforeCefBlock(root, pos);
          }
        };
        const needsToBeNbsp = (root, pos) => needsToBeNbspLeft(root, pos) || needsToBeNbspRight(root, leanRight(pos));
        const isNbspAt = (text2, offset2) => isNbsp(text2.charAt(offset2));
        const isWhiteSpaceAt = (text2, offset2) => isWhiteSpace(text2.charAt(offset2));
        const hasNbsp = (pos) => {
          const container = pos.container();
          return isText$a(container) && contains$1(container.data, nbsp);
        };
        const normalizeNbspMiddle = (text2) => {
          const chars = text2.split("");
          return map$3(chars, (chr, i2) => {
            if (isNbsp(chr) && i2 > 0 && i2 < chars.length - 1 && isContent(chars[i2 - 1]) && isContent(chars[i2 + 1])) {
              return " ";
            } else {
              return chr;
            }
          }).join("");
        };
        const normalizeNbspAtStart = (root, node, makeNbsp) => {
          const text2 = node.data;
          const firstPos = CaretPosition(node, 0);
          if (!makeNbsp && isNbspAt(text2, 0) && !needsToBeNbsp(root, firstPos)) {
            node.data = " " + text2.slice(1);
            return true;
          } else if (makeNbsp && isWhiteSpaceAt(text2, 0) && needsToBeNbspLeft(root, firstPos)) {
            node.data = nbsp + text2.slice(1);
            return true;
          } else {
            return false;
          }
        };
        const normalizeNbspInMiddleOfTextNode = (node) => {
          const text2 = node.data;
          const newText = normalizeNbspMiddle(text2);
          if (newText !== text2) {
            node.data = newText;
            return true;
          } else {
            return false;
          }
        };
        const normalizeNbspAtEnd = (root, node, makeNbsp) => {
          const text2 = node.data;
          const lastPos = CaretPosition(node, text2.length - 1);
          if (!makeNbsp && isNbspAt(text2, text2.length - 1) && !needsToBeNbsp(root, lastPos)) {
            node.data = text2.slice(0, -1) + " ";
            return true;
          } else if (makeNbsp && isWhiteSpaceAt(text2, text2.length - 1) && needsToBeNbspRight(root, lastPos)) {
            node.data = text2.slice(0, -1) + nbsp;
            return true;
          } else {
            return false;
          }
        };
        const normalizeNbsps = (root, pos) => {
          const container = pos.container();
          if (!isText$a(container)) {
            return Optional.none();
          }
          if (hasNbsp(pos)) {
            const normalized = normalizeNbspAtStart(root, container, false) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container, false);
            return someIf(normalized, pos);
          } else if (needsToBeNbsp(root, pos)) {
            const normalized = normalizeNbspAtStart(root, container, true) || normalizeNbspAtEnd(root, container, true);
            return someIf(normalized, pos);
          } else {
            return Optional.none();
          }
        };
        const normalizeNbspsInEditor = (editor) => {
          const root = SugarElement.fromDom(editor.getBody());
          if (editor.selection.isCollapsed()) {
            normalizeNbsps(root, CaretPosition.fromRangeStart(editor.selection.getRng())).each((pos) => {
              editor.selection.setRng(pos.toRange());
            });
          }
        };
        const normalize$1 = (node, offset2, count2) => {
          if (count2 === 0) {
            return;
          }
          const elm = SugarElement.fromDom(node);
          const root = ancestor$4(elm, isBlock$2).getOr(elm);
          const whitespace = node.data.slice(offset2, offset2 + count2);
          const isEndOfContent = offset2 + count2 >= node.data.length && needsToBeNbspRight(root, CaretPosition(node, node.data.length));
          const isStartOfContent = offset2 === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0));
          node.replaceData(offset2, count2, normalize$4(whitespace, 4, isStartOfContent, isEndOfContent));
        };
        const normalizeWhitespaceAfter = (node, offset2) => {
          const content = node.data.slice(offset2);
          const whitespaceCount = content.length - lTrim(content).length;
          normalize$1(node, offset2, whitespaceCount);
        };
        const normalizeWhitespaceBefore = (node, offset2) => {
          const content = node.data.slice(0, offset2);
          const whitespaceCount = content.length - rTrim(content).length;
          normalize$1(node, offset2 - whitespaceCount, whitespaceCount);
        };
        const mergeTextNodes = (prevNode, nextNode, normalizeWhitespace, mergeToPrev = true) => {
          const whitespaceOffset = rTrim(prevNode.data).length;
          const newNode = mergeToPrev ? prevNode : nextNode;
          const removeNode2 = mergeToPrev ? nextNode : prevNode;
          if (mergeToPrev) {
            newNode.appendData(removeNode2.data);
          } else {
            newNode.insertData(0, removeNode2.data);
          }
          remove$5(SugarElement.fromDom(removeNode2));
          if (normalizeWhitespace) {
            normalizeWhitespaceAfter(newNode, whitespaceOffset);
          }
          return newNode;
        };
        const needsReposition = (pos, elm) => {
          const container = pos.container();
          const offset2 = pos.offset();
          return !CaretPosition.isTextPosition(pos) && container === elm.parentNode && offset2 > CaretPosition.before(elm).offset();
        };
        const reposition = (elm, pos) => needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;
        const beforeOrStartOf = (node) => isText$a(node) ? CaretPosition(node, 0) : CaretPosition.before(node);
        const afterOrEndOf = (node) => isText$a(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);
        const getPreviousSiblingCaretPosition = (elm) => {
          if (isCaretCandidate$3(elm.previousSibling)) {
            return Optional.some(afterOrEndOf(elm.previousSibling));
          } else {
            return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();
          }
        };
        const getNextSiblingCaretPosition = (elm) => {
          if (isCaretCandidate$3(elm.nextSibling)) {
            return Optional.some(beforeOrStartOf(elm.nextSibling));
          } else {
            return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();
          }
        };
        const findCaretPositionBackwardsFromElm = (rootElement, elm) => {
          return Optional.from(elm.previousSibling ? elm.previousSibling : elm.parentNode).bind((node) => prevPosition(rootElement, CaretPosition.before(node))).orThunk(() => nextPosition(rootElement, CaretPosition.after(elm)));
        };
        const findCaretPositionForwardsFromElm = (rootElement, elm) => nextPosition(rootElement, CaretPosition.after(elm)).orThunk(() => prevPosition(rootElement, CaretPosition.before(elm)));
        const findCaretPositionBackwards = (rootElement, elm) => getPreviousSiblingCaretPosition(elm).orThunk(() => getNextSiblingCaretPosition(elm)).orThunk(() => findCaretPositionBackwardsFromElm(rootElement, elm));
        const findCaretPositionForward = (rootElement, elm) => getNextSiblingCaretPosition(elm).orThunk(() => getPreviousSiblingCaretPosition(elm)).orThunk(() => findCaretPositionForwardsFromElm(rootElement, elm));
        const findCaretPosition = (forward, rootElement, elm) => forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);
        const findCaretPosOutsideElmAfterDelete = (forward, rootElement, elm) => findCaretPosition(forward, rootElement, elm).map(curry(reposition, elm));
        const setSelection$1 = (editor, forward, pos) => {
          pos.fold(() => {
            editor.focus();
          }, (pos2) => {
            editor.selection.setRng(pos2.toRange(), forward);
          });
        };
        const eqRawNode = (rawNode) => (elm) => elm.dom === rawNode;
        const isBlock = (editor, elm) => elm && has$2(editor.schema.getBlockElements(), name(elm));
        const paddEmptyBlock = (elm) => {
          if (isEmpty$2(elm)) {
            const br = SugarElement.fromHtml('<br data-mce-bogus="1">');
            empty(elm);
            append$1(elm, br);
            return Optional.some(CaretPosition.before(br.dom));
          } else {
            return Optional.none();
          }
        };
        const deleteNormalized = (elm, afterDeletePosOpt, normalizeWhitespace) => {
          const prevTextOpt = prevSibling(elm).filter(isText$b);
          const nextTextOpt = nextSibling(elm).filter(isText$b);
          remove$5(elm);
          return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, (prev2, next2, pos) => {
            const prevNode = prev2.dom, nextNode = next2.dom;
            const offset2 = prevNode.data.length;
            mergeTextNodes(prevNode, nextNode, normalizeWhitespace);
            return pos.container() === nextNode ? CaretPosition(prevNode, offset2) : pos;
          }).orThunk(() => {
            if (normalizeWhitespace) {
              prevTextOpt.each((elm2) => normalizeWhitespaceBefore(elm2.dom, elm2.dom.length));
              nextTextOpt.each((elm2) => normalizeWhitespaceAfter(elm2.dom, 0));
            }
            return afterDeletePosOpt;
          });
        };
        const isInlineElement = (editor, element) => has$2(editor.schema.getTextInlineElements(), name(element));
        const deleteElement$2 = (editor, forward, elm, moveCaret2 = true) => {
          const afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);
          const parentBlock = ancestor$4(elm, curry(isBlock, editor), eqRawNode(editor.getBody()));
          const normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, isInlineElement(editor, elm));
          if (editor.dom.isEmpty(editor.getBody())) {
            editor.setContent("");
            editor.selection.setCursorLocation();
          } else {
            parentBlock.bind(paddEmptyBlock).fold(() => {
              if (moveCaret2) {
                setSelection$1(editor, forward, normalizedAfterDeletePos);
              }
            }, (paddPos) => {
              if (moveCaret2) {
                setSelection$1(editor, forward, Optional.some(paddPos));
              }
            });
          }
        };
        const strongRtl = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/;
        const hasStrongRtl = (text2) => strongRtl.test(text2);
        const isInlineTarget = (editor, elm) => is$1(SugarElement.fromDom(elm), getInlineBoundarySelector(editor)) && !isTransparentBlock(editor.schema, elm) && editor.dom.isEditable(elm);
        const isRtl = (element) => {
          var _a;
          return DOMUtils.DOM.getStyle(element, "direction", true) === "rtl" || hasStrongRtl((_a = element.textContent) !== null && _a !== void 0 ? _a : "");
        };
        const findInlineParents = (isInlineTarget2, rootNode, pos) => filter$5(DOMUtils.DOM.getParents(pos.container(), "*", rootNode), isInlineTarget2);
        const findRootInline = (isInlineTarget2, rootNode, pos) => {
          const parents2 = findInlineParents(isInlineTarget2, rootNode, pos);
          return Optional.from(parents2[parents2.length - 1]);
        };
        const hasSameParentBlock = (rootNode, node1, node2) => {
          const block1 = getParentBlock$3(node1, rootNode);
          const block2 = getParentBlock$3(node2, rootNode);
          return isNonNullable(block1) && block1 === block2;
        };
        const isAtZwsp = (pos) => isBeforeInline(pos) || isAfterInline(pos);
        const normalizePosition = (forward, pos) => {
          const container = pos.container(), offset2 = pos.offset();
          if (forward) {
            if (isCaretContainerInline(container)) {
              if (isText$a(container.nextSibling)) {
                return CaretPosition(container.nextSibling, 0);
              } else {
                return CaretPosition.after(container);
              }
            } else {
              return isBeforeInline(pos) ? CaretPosition(container, offset2 + 1) : pos;
            }
          } else {
            if (isCaretContainerInline(container)) {
              if (isText$a(container.previousSibling)) {
                return CaretPosition(container.previousSibling, container.previousSibling.data.length);
              } else {
                return CaretPosition.before(container);
              }
            } else {
              return isAfterInline(pos) ? CaretPosition(container, offset2 - 1) : pos;
            }
          }
        };
        const normalizeForwards = curry(normalizePosition, true);
        const normalizeBackwards = curry(normalizePosition, false);
        const execCommandIgnoreInputEvents = (editor, command) => {
          const inputBlocker = (e2) => e2.stopImmediatePropagation();
          editor.on("beforeinput input", inputBlocker, true);
          editor.getDoc().execCommand(command);
          editor.off("beforeinput input", inputBlocker);
        };
        const execEditorDeleteCommand = (editor) => {
          editor.execCommand("delete");
        };
        const execNativeDeleteCommand = (editor) => execCommandIgnoreInputEvents(editor, "Delete");
        const execNativeForwardDeleteCommand = (editor) => execCommandIgnoreInputEvents(editor, "ForwardDelete");
        const isBeforeRoot = (rootNode) => (elm) => is$2(parent(elm), rootNode, eq);
        const isTextBlockOrListItem = (element) => isTextBlock$2(element) || isListItem$1(element);
        const getParentBlock$2 = (rootNode, elm) => {
          if (contains2(rootNode, elm)) {
            return closest$4(elm, isTextBlockOrListItem, isBeforeRoot(rootNode));
          } else {
            return Optional.none();
          }
        };
        const paddEmptyBody = (editor, moveSelection2 = true) => {
          if (editor.dom.isEmpty(editor.getBody())) {
            editor.setContent("", { no_selection: !moveSelection2 });
          }
        };
        const willDeleteLastPositionInElement = (forward, fromPos, elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {
          const normalizedFirstPos = normalizePosition(true, firstPos);
          const normalizedLastPos = normalizePosition(false, lastPos);
          const normalizedFromPos = normalizePosition(false, fromPos);
          if (forward) {
            return nextPosition(elm, normalizedFromPos).exists((nextPos) => nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos));
          } else {
            return prevPosition(elm, normalizedFromPos).exists((prevPos) => prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos));
          }
        }).getOr(true);
        const freefallRtl = (root) => {
          const child2 = isComment$1(root) ? prevSibling(root) : lastChild(root);
          return child2.bind(freefallRtl).orThunk(() => Optional.some(root));
        };
        const deleteRangeContents = (editor, rng, root, moveSelection2 = true) => {
          var _a;
          rng.deleteContents();
          const lastNode = freefallRtl(root).getOr(root);
          const lastBlock = SugarElement.fromDom((_a = editor.dom.getParent(lastNode.dom, editor.dom.isBlock)) !== null && _a !== void 0 ? _a : root.dom);
          if (lastBlock.dom === editor.getBody()) {
            paddEmptyBody(editor, moveSelection2);
          } else if (isEmpty$2(lastBlock)) {
            fillWithPaddingBr(lastBlock);
            if (moveSelection2) {
              editor.selection.setCursorLocation(lastBlock.dom, 0);
            }
          }
          if (!eq(root, lastBlock)) {
            const additionalCleanupNodes = is$2(parent(lastBlock), root) ? [] : siblings(lastBlock);
            each$e(additionalCleanupNodes.concat(children$1(root)), (node) => {
              if (!eq(node, lastBlock) && !contains2(node, lastBlock) && isEmpty$2(node)) {
                remove$5(node);
              }
            });
          }
        };
        const isRootFromElement = (root) => (cur) => eq(root, cur);
        const getTableCells = (table2) => descendants(table2, "td,th");
        const getTableDetailsFromRange = (rng, isRoot2) => {
          const getTable2 = (node) => getClosestTable(SugarElement.fromDom(node), isRoot2);
          const startTable = getTable2(rng.startContainer);
          const endTable = getTable2(rng.endContainer);
          const isStartInTable = startTable.isSome();
          const isEndInTable = endTable.isSome();
          const isSameTable = lift2(startTable, endTable, eq).getOr(false);
          const isMultiTable = !isSameTable && isStartInTable && isEndInTable;
          return {
            startTable,
            endTable,
            isStartInTable,
            isEndInTable,
            isSameTable,
            isMultiTable
          };
        };
        const tableCellRng = (start4, end3) => ({
          start: start4,
          end: end3
        });
        const tableSelection = (rng, table2, cells2) => ({
          rng,
          table: table2,
          cells: cells2
        });
        const deleteAction = Adt.generate([
          {
            singleCellTable: [
              "rng",
              "cell"
            ]
          },
          { fullTable: ["table"] },
          {
            partialTable: [
              "cells",
              "outsideDetails"
            ]
          },
          {
            multiTable: [
              "startTableCells",
              "endTableCells",
              "betweenRng"
            ]
          }
        ]);
        const getClosestCell$1 = (container, isRoot2) => closest$3(SugarElement.fromDom(container), "td,th", isRoot2);
        const isExpandedCellRng = (cellRng) => !eq(cellRng.start, cellRng.end);
        const getTableFromCellRng = (cellRng, isRoot2) => getClosestTable(cellRng.start, isRoot2).bind((startParentTable) => getClosestTable(cellRng.end, isRoot2).bind((endParentTable) => someIf(eq(startParentTable, endParentTable), startParentTable)));
        const isSingleCellTable = (cellRng, isRoot2) => !isExpandedCellRng(cellRng) && getTableFromCellRng(cellRng, isRoot2).exists((table2) => {
          const rows = table2.dom.rows;
          return rows.length === 1 && rows[0].cells.length === 1;
        });
        const getCellRng = (rng, isRoot2) => {
          const startCell = getClosestCell$1(rng.startContainer, isRoot2);
          const endCell = getClosestCell$1(rng.endContainer, isRoot2);
          return lift2(startCell, endCell, tableCellRng);
        };
        const getCellRangeFromStartTable = (isRoot2) => (startCell) => getClosestTable(startCell, isRoot2).bind((table2) => last$3(getTableCells(table2)).map((endCell) => tableCellRng(startCell, endCell)));
        const getCellRangeFromEndTable = (isRoot2) => (endCell) => getClosestTable(endCell, isRoot2).bind((table2) => head(getTableCells(table2)).map((startCell) => tableCellRng(startCell, endCell)));
        const getTableSelectionFromCellRng = (isRoot2) => (cellRng) => getTableFromCellRng(cellRng, isRoot2).map((table2) => tableSelection(cellRng, table2, getTableCells(table2)));
        const getTableSelections = (cellRng, selectionDetails, rng, isRoot2) => {
          if (rng.collapsed || !cellRng.forall(isExpandedCellRng)) {
            return Optional.none();
          } else if (selectionDetails.isSameTable) {
            const sameTableSelection = cellRng.bind(getTableSelectionFromCellRng(isRoot2));
            return Optional.some({
              start: sameTableSelection,
              end: sameTableSelection
            });
          } else {
            const startCell = getClosestCell$1(rng.startContainer, isRoot2);
            const endCell = getClosestCell$1(rng.endContainer, isRoot2);
            const startTableSelection = startCell.bind(getCellRangeFromStartTable(isRoot2)).bind(getTableSelectionFromCellRng(isRoot2));
            const endTableSelection = endCell.bind(getCellRangeFromEndTable(isRoot2)).bind(getTableSelectionFromCellRng(isRoot2));
            return Optional.some({
              start: startTableSelection,
              end: endTableSelection
            });
          }
        };
        const getCellIndex = (cells2, cell2) => findIndex$2(cells2, (x2) => eq(x2, cell2));
        const getSelectedCells = (tableSelection2) => lift2(getCellIndex(tableSelection2.cells, tableSelection2.rng.start), getCellIndex(tableSelection2.cells, tableSelection2.rng.end), (startIndex, endIndex) => tableSelection2.cells.slice(startIndex, endIndex + 1));
        const isSingleCellTableContentSelected = (optCellRng, rng, isRoot2) => optCellRng.exists((cellRng) => isSingleCellTable(cellRng, isRoot2) && hasAllContentsSelected(cellRng.start, rng));
        const unselectCells = (rng, selectionDetails) => {
          const { startTable, endTable } = selectionDetails;
          const otherContentRng = rng.cloneRange();
          startTable.each((table2) => otherContentRng.setStartAfter(table2.dom));
          endTable.each((table2) => otherContentRng.setEndBefore(table2.dom));
          return otherContentRng;
        };
        const handleSingleTable = (cellRng, selectionDetails, rng, isRoot2) => getTableSelections(cellRng, selectionDetails, rng, isRoot2).bind(({ start: start4, end: end3 }) => start4.or(end3)).bind((tableSelection2) => {
          const { isSameTable } = selectionDetails;
          const selectedCells = getSelectedCells(tableSelection2).getOr([]);
          if (isSameTable && tableSelection2.cells.length === selectedCells.length) {
            return Optional.some(deleteAction.fullTable(tableSelection2.table));
          } else if (selectedCells.length > 0) {
            if (isSameTable) {
              return Optional.some(deleteAction.partialTable(selectedCells, Optional.none()));
            } else {
              const otherContentRng = unselectCells(rng, selectionDetails);
              return Optional.some(deleteAction.partialTable(selectedCells, Optional.some({
                ...selectionDetails,
                rng: otherContentRng
              })));
            }
          } else {
            return Optional.none();
          }
        });
        const handleMultiTable = (cellRng, selectionDetails, rng, isRoot2) => getTableSelections(cellRng, selectionDetails, rng, isRoot2).bind(({ start: start4, end: end3 }) => {
          const startTableSelectedCells = start4.bind(getSelectedCells).getOr([]);
          const endTableSelectedCells = end3.bind(getSelectedCells).getOr([]);
          if (startTableSelectedCells.length > 0 && endTableSelectedCells.length > 0) {
            const otherContentRng = unselectCells(rng, selectionDetails);
            return Optional.some(deleteAction.multiTable(startTableSelectedCells, endTableSelectedCells, otherContentRng));
          } else {
            return Optional.none();
          }
        });
        const getActionFromRange = (root, rng) => {
          const isRoot2 = isRootFromElement(root);
          const optCellRng = getCellRng(rng, isRoot2);
          const selectionDetails = getTableDetailsFromRange(rng, isRoot2);
          if (isSingleCellTableContentSelected(optCellRng, rng, isRoot2)) {
            return optCellRng.map((cellRng) => deleteAction.singleCellTable(rng, cellRng.start));
          } else if (selectionDetails.isMultiTable) {
            return handleMultiTable(optCellRng, selectionDetails, rng, isRoot2);
          } else {
            return handleSingleTable(optCellRng, selectionDetails, rng, isRoot2);
          }
        };
        const cleanCells = (cells2) => each$e(cells2, (cell2) => {
          remove$a(cell2, "contenteditable");
          fillWithPaddingBr(cell2);
        });
        const getOutsideBlock = (editor, container) => Optional.from(editor.dom.getParent(container, editor.dom.isBlock)).map(SugarElement.fromDom);
        const handleEmptyBlock = (editor, startInTable, emptyBlock2) => {
          emptyBlock2.each((block) => {
            if (startInTable) {
              remove$5(block);
            } else {
              fillWithPaddingBr(block);
              editor.selection.setCursorLocation(block.dom, 0);
            }
          });
        };
        const deleteContentInsideCell = (editor, cell2, rng, isFirstCellInSelection) => {
          const insideTableRng = rng.cloneRange();
          if (isFirstCellInSelection) {
            insideTableRng.setStart(rng.startContainer, rng.startOffset);
            insideTableRng.setEndAfter(cell2.dom.lastChild);
          } else {
            insideTableRng.setStartBefore(cell2.dom.firstChild);
            insideTableRng.setEnd(rng.endContainer, rng.endOffset);
          }
          deleteCellContents(editor, insideTableRng, cell2, false).each((action2) => action2());
        };
        const collapseAndRestoreCellSelection = (editor) => {
          const selectedCells = getCellsFromEditor(editor);
          const selectedNode = SugarElement.fromDom(editor.selection.getNode());
          if (isTableCell$3(selectedNode.dom) && isEmpty$2(selectedNode)) {
            editor.selection.setCursorLocation(selectedNode.dom, 0);
          } else {
            editor.selection.collapse(true);
          }
          if (selectedCells.length > 1 && exists(selectedCells, (cell2) => eq(cell2, selectedNode))) {
            set$3(selectedNode, "data-mce-selected", "1");
          }
        };
        const emptySingleTableCells = (editor, cells2, outsideDetails) => Optional.some(() => {
          const editorRng = editor.selection.getRng();
          const cellsToClean = outsideDetails.bind(({ rng, isStartInTable }) => {
            const outsideBlock = getOutsideBlock(editor, isStartInTable ? rng.endContainer : rng.startContainer);
            rng.deleteContents();
            handleEmptyBlock(editor, isStartInTable, outsideBlock.filter(isEmpty$2));
            const endPointCell = isStartInTable ? cells2[0] : cells2[cells2.length - 1];
            deleteContentInsideCell(editor, endPointCell, editorRng, isStartInTable);
            if (!isEmpty$2(endPointCell)) {
              return Optional.some(isStartInTable ? cells2.slice(1) : cells2.slice(0, -1));
            } else {
              return Optional.none();
            }
          }).getOr(cells2);
          cleanCells(cellsToClean);
          collapseAndRestoreCellSelection(editor);
        });
        const emptyMultiTableCells = (editor, startTableCells, endTableCells, betweenRng) => Optional.some(() => {
          const rng = editor.selection.getRng();
          const startCell = startTableCells[0];
          const endCell = endTableCells[endTableCells.length - 1];
          deleteContentInsideCell(editor, startCell, rng, true);
          deleteContentInsideCell(editor, endCell, rng, false);
          const startTableCellsToClean = isEmpty$2(startCell) ? startTableCells : startTableCells.slice(1);
          const endTableCellsToClean = isEmpty$2(endCell) ? endTableCells : endTableCells.slice(0, -1);
          cleanCells(startTableCellsToClean.concat(endTableCellsToClean));
          betweenRng.deleteContents();
          collapseAndRestoreCellSelection(editor);
        });
        const deleteCellContents = (editor, rng, cell2, moveSelection2 = true) => Optional.some(() => {
          deleteRangeContents(editor, rng, cell2, moveSelection2);
        });
        const deleteTableElement = (editor, table2) => Optional.some(() => deleteElement$2(editor, false, table2));
        const deleteCellRange = (editor, rootElm, rng) => getActionFromRange(rootElm, rng).bind((action2) => action2.fold(curry(deleteCellContents, editor), curry(deleteTableElement, editor), curry(emptySingleTableCells, editor), curry(emptyMultiTableCells, editor)));
        const deleteCaptionRange = (editor, caption) => emptyElement(editor, caption);
        const deleteTableRange = (editor, rootElm, rng, startElm) => getParentCaption(rootElm, startElm).fold(() => deleteCellRange(editor, rootElm, rng), (caption) => deleteCaptionRange(editor, caption));
        const deleteRange$3 = (editor, startElm, selectedCells) => {
          const rootNode = SugarElement.fromDom(editor.getBody());
          const rng = editor.selection.getRng();
          return selectedCells.length !== 0 ? emptySingleTableCells(editor, selectedCells, Optional.none()) : deleteTableRange(editor, rootNode, rng, startElm);
        };
        const getParentCell = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTableCell$2);
        const getParentCaption = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTag("caption"));
        const deleteBetweenCells = (editor, rootElm, forward, fromCell, from2) => navigate(forward, editor.getBody(), from2).bind((to) => getParentCell(rootElm, SugarElement.fromDom(to.getNode())).bind((toCell) => eq(toCell, fromCell) ? Optional.none() : Optional.some(noop2)));
        const emptyElement = (editor, elm) => Optional.some(() => {
          fillWithPaddingBr(elm);
          editor.selection.setCursorLocation(elm.dom, 0);
        });
        const isDeleteOfLastCharPos = (fromCaption, forward, from2, to) => firstPositionIn(fromCaption.dom).bind((first2) => lastPositionIn(fromCaption.dom).map((last2) => forward ? from2.isEqual(first2) && to.isEqual(last2) : from2.isEqual(last2) && to.isEqual(first2))).getOr(true);
        const emptyCaretCaption = (editor, elm) => emptyElement(editor, elm);
        const validateCaretCaption = (rootElm, fromCaption, to) => getParentCaption(rootElm, SugarElement.fromDom(to.getNode())).fold(() => Optional.some(noop2), (toCaption) => someIf(!eq(toCaption, fromCaption), noop2));
        const deleteCaretInsideCaption = (editor, rootElm, forward, fromCaption, from2) => navigate(forward, editor.getBody(), from2).fold(() => Optional.some(noop2), (to) => isDeleteOfLastCharPos(fromCaption, forward, from2, to) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to));
        const deleteCaretCells = (editor, forward, rootElm, startElm) => {
          const from2 = CaretPosition.fromRangeStart(editor.selection.getRng());
          return getParentCell(rootElm, startElm).bind((fromCell) => isEmpty$2(fromCell) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from2));
        };
        const deleteCaretCaption = (editor, forward, rootElm, fromCaption) => {
          const from2 = CaretPosition.fromRangeStart(editor.selection.getRng());
          return isEmpty$2(fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from2);
        };
        const isNearTable = (forward, pos) => forward ? isBeforeTable(pos) : isAfterTable(pos);
        const isBeforeOrAfterTable = (editor, forward) => {
          const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
          return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos).exists((pos) => isNearTable(forward, pos));
        };
        const deleteCaret$3 = (editor, forward, startElm) => {
          const rootElm = SugarElement.fromDom(editor.getBody());
          return getParentCaption(rootElm, startElm).fold(() => deleteCaretCells(editor, forward, rootElm, startElm).orThunk(() => someIf(isBeforeOrAfterTable(editor, forward), noop2)), (fromCaption) => deleteCaretCaption(editor, forward, rootElm, fromCaption));
        };
        const backspaceDelete$9 = (editor, forward) => {
          const startElm = SugarElement.fromDom(editor.selection.getStart(true));
          const cells2 = getCellsFromEditor(editor);
          return editor.selection.isCollapsed() && cells2.length === 0 ? deleteCaret$3(editor, forward, startElm) : deleteRange$3(editor, startElm, cells2);
        };
        const getContentEditableRoot$1 = (root, node) => {
          let tempNode = node;
          while (tempNode && tempNode !== root) {
            if (isContentEditableTrue$3(tempNode) || isContentEditableFalse$b(tempNode)) {
              return tempNode;
            }
            tempNode = tempNode.parentNode;
          }
          return null;
        };
        const internalAttributesPrefixes = [
          "data-ephox-",
          "data-mce-",
          "data-alloy-",
          "data-snooker-",
          "_"
        ];
        const each$9 = Tools.each;
        const ElementUtils = (editor) => {
          const dom2 = editor.dom;
          const internalAttributes = new Set(editor.serializer.getTempAttrs());
          const compare = (node1, node2) => {
            if (node1.nodeName !== node2.nodeName || node1.nodeType !== node2.nodeType) {
              return false;
            }
            const getAttribs = (node) => {
              const attribs = {};
              each$9(dom2.getAttribs(node), (attr) => {
                const name2 = attr.nodeName.toLowerCase();
                if (name2 !== "style" && !isAttributeInternal(name2)) {
                  attribs[name2] = dom2.getAttrib(node, name2);
                }
              });
              return attribs;
            };
            const compareObjects = (obj1, obj2) => {
              for (const name2 in obj1) {
                if (has$2(obj1, name2)) {
                  const value2 = obj2[name2];
                  if (isUndefined(value2)) {
                    return false;
                  }
                  if (obj1[name2] !== value2) {
                    return false;
                  }
                  delete obj2[name2];
                }
              }
              for (const name2 in obj2) {
                if (has$2(obj2, name2)) {
                  return false;
                }
              }
              return true;
            };
            if (isElement$6(node1) && isElement$6(node2)) {
              if (!compareObjects(getAttribs(node1), getAttribs(node2))) {
                return false;
              }
              if (!compareObjects(dom2.parseStyle(dom2.getAttrib(node1, "style")), dom2.parseStyle(dom2.getAttrib(node2, "style")))) {
                return false;
              }
            }
            return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);
          };
          const isAttributeInternal = (attributeName) => exists(internalAttributesPrefixes, (value2) => startsWith(attributeName, value2)) || internalAttributes.has(attributeName);
          return {
            compare,
            isAttributeInternal
          };
        };
        const traverse = (root, fn2) => {
          let node = root;
          while (node = node.walk()) {
            fn2(node);
          }
        };
        const matchNode$1 = (nodeFilters, attributeFilters, node, matches) => {
          const name2 = node.name;
          for (let ni = 0, nl = nodeFilters.length; ni < nl; ni++) {
            const filter2 = nodeFilters[ni];
            if (filter2.name === name2) {
              const match2 = matches.nodes[name2];
              if (match2) {
                match2.nodes.push(node);
              } else {
                matches.nodes[name2] = {
                  filter: filter2,
                  nodes: [node]
                };
              }
            }
          }
          if (node.attributes) {
            for (let ai = 0, al = attributeFilters.length; ai < al; ai++) {
              const filter2 = attributeFilters[ai];
              const attrName = filter2.name;
              if (attrName in node.attributes.map) {
                const match2 = matches.attributes[attrName];
                if (match2) {
                  match2.nodes.push(node);
                } else {
                  matches.attributes[attrName] = {
                    filter: filter2,
                    nodes: [node]
                  };
                }
              }
            }
          }
        };
        const findMatchingNodes = (nodeFilters, attributeFilters, node) => {
          const matches = {
            nodes: {},
            attributes: {}
          };
          if (node.firstChild) {
            traverse(node, (childNode) => {
              matchNode$1(nodeFilters, attributeFilters, childNode, matches);
            });
          }
          return matches;
        };
        const runFilters = (matches, args) => {
          const run = (matchRecord, filteringAttributes) => {
            each$d(matchRecord, (match2) => {
              const nodes = from(match2.nodes);
              each$e(match2.filter.callbacks, (callback) => {
                for (let i2 = nodes.length - 1; i2 >= 0; i2--) {
                  const node = nodes[i2];
                  const valueMatches = filteringAttributes ? node.attr(match2.filter.name) !== void 0 : node.name === match2.filter.name;
                  if (!valueMatches || isNullable(node.parent)) {
                    nodes.splice(i2, 1);
                  }
                }
                if (nodes.length > 0) {
                  callback(nodes, match2.filter.name, args);
                }
              });
            });
          };
          run(matches.nodes, false);
          run(matches.attributes, true);
        };
        const filter$2 = (nodeFilters, attributeFilters, node, args = {}) => {
          const matches = findMatchingNodes(nodeFilters, attributeFilters, node);
          runFilters(matches, args);
        };
        const paddEmptyNode = (args, isBlock2, node) => {
          if (args.insert && isBlock2(node)) {
            const astNode = new AstNode("br", 1);
            astNode.attr("data-mce-bogus", "1");
            node.empty().append(astNode);
          } else {
            node.empty().append(new AstNode("#text", 3)).value = nbsp;
          }
        };
        const isPaddedWithNbsp = (node) => {
          var _a;
          return hasOnlyChild(node, "#text") && ((_a = node === null || node === void 0 ? void 0 : node.firstChild) === null || _a === void 0 ? void 0 : _a.value) === nbsp;
        };
        const hasOnlyChild = (node, name2) => {
          const firstChild2 = node === null || node === void 0 ? void 0 : node.firstChild;
          return isNonNullable(firstChild2) && firstChild2 === node.lastChild && firstChild2.name === name2;
        };
        const isPadded = (schema, node) => {
          const rule = schema.getElementRule(node.name);
          return (rule === null || rule === void 0 ? void 0 : rule.paddEmpty) === true;
        };
        const isEmpty = (schema, nonEmptyElements, whitespaceElements, node) => node.isEmpty(nonEmptyElements, whitespaceElements, (node2) => isPadded(schema, node2));
        const isLineBreakNode = (node, isBlock2) => isNonNullable(node) && (isBlock2(node) || node.name === "br");
        const findClosestEditingHost = (scope) => {
          let editableNode;
          for (let node = scope; node; node = node.parent) {
            const contentEditable = node.attr("contenteditable");
            if (contentEditable === "false") {
              break;
            } else if (contentEditable === "true") {
              editableNode = node;
            }
          }
          return Optional.from(editableNode);
        };
        const removeOrUnwrapInvalidNode = (node, schema, originalNodeParent = node.parent) => {
          if (schema.getSpecialElements()[node.name]) {
            node.empty().remove();
          } else {
            const children2 = node.children();
            for (const childNode of children2) {
              if (originalNodeParent && !schema.isValidChild(originalNodeParent.name, childNode.name)) {
                removeOrUnwrapInvalidNode(childNode, schema, originalNodeParent);
              }
            }
            node.unwrap();
          }
        };
        const cleanInvalidNodes = (nodes, schema, rootNode, onCreate = noop2) => {
          const textBlockElements = schema.getTextBlockElements();
          const nonEmptyElements = schema.getNonEmptyElements();
          const whitespaceElements = schema.getWhitespaceElements();
          const nonSplittableElements = Tools.makeMap("tr,td,th,tbody,thead,tfoot,table");
          const fixed = /* @__PURE__ */ new Set();
          const isSplittableElement = (node) => node !== rootNode && !nonSplittableElements[node.name];
          for (let ni = 0; ni < nodes.length; ni++) {
            const node = nodes[ni];
            let parent2;
            let newParent;
            let tempNode;
            if (!node.parent || fixed.has(node)) {
              continue;
            }
            if (textBlockElements[node.name] && node.parent.name === "li") {
              let sibling2 = node.next;
              while (sibling2) {
                if (textBlockElements[sibling2.name]) {
                  sibling2.name = "li";
                  fixed.add(sibling2);
                  node.parent.insert(sibling2, node.parent);
                } else {
                  break;
                }
                sibling2 = sibling2.next;
              }
              node.unwrap();
              continue;
            }
            const parents2 = [node];
            for (parent2 = node.parent; parent2 && !schema.isValidChild(parent2.name, node.name) && isSplittableElement(parent2); parent2 = parent2.parent) {
              parents2.push(parent2);
            }
            if (parent2 && parents2.length > 1) {
              if (schema.isValidChild(parent2.name, node.name)) {
                parents2.reverse();
                newParent = parents2[0].clone();
                onCreate(newParent);
                let currentNode = newParent;
                for (let i2 = 0; i2 < parents2.length - 1; i2++) {
                  if (schema.isValidChild(currentNode.name, parents2[i2].name) && i2 > 0) {
                    tempNode = parents2[i2].clone();
                    onCreate(tempNode);
                    currentNode.append(tempNode);
                  } else {
                    tempNode = currentNode;
                  }
                  for (let childNode = parents2[i2].firstChild; childNode && childNode !== parents2[i2 + 1]; ) {
                    const nextNode = childNode.next;
                    tempNode.append(childNode);
                    childNode = nextNode;
                  }
                  currentNode = tempNode;
                }
                if (!isEmpty(schema, nonEmptyElements, whitespaceElements, newParent)) {
                  parent2.insert(newParent, parents2[0], true);
                  parent2.insert(node, newParent);
                } else {
                  parent2.insert(node, parents2[0], true);
                }
                parent2 = parents2[0];
                if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent2) || hasOnlyChild(parent2, "br")) {
                  parent2.empty().remove();
                }
              } else {
                removeOrUnwrapInvalidNode(node, schema);
              }
            } else if (node.parent) {
              if (node.name === "li") {
                let sibling2 = node.prev;
                if (sibling2 && (sibling2.name === "ul" || sibling2.name === "ol")) {
                  sibling2.append(node);
                  continue;
                }
                sibling2 = node.next;
                if (sibling2 && (sibling2.name === "ul" || sibling2.name === "ol") && sibling2.firstChild) {
                  sibling2.insert(node, sibling2.firstChild, true);
                  continue;
                }
                const wrapper = new AstNode("ul", 1);
                onCreate(wrapper);
                node.wrap(wrapper);
                continue;
              }
              if (schema.isValidChild(node.parent.name, "div") && schema.isValidChild("div", node.name)) {
                const wrapper = new AstNode("div", 1);
                onCreate(wrapper);
                node.wrap(wrapper);
              } else {
                removeOrUnwrapInvalidNode(node, schema);
              }
            }
          }
        };
        const hasClosest = (node, parentName) => {
          let tempNode = node;
          while (tempNode) {
            if (tempNode.name === parentName) {
              return true;
            }
            tempNode = tempNode.parent;
          }
          return false;
        };
        const isInvalid = (schema, node, parent2 = node.parent) => {
          if (parent2 && schema.children[node.name] && !schema.isValidChild(parent2.name, node.name)) {
            return true;
          } else if (parent2 && node.name === "a" && hasClosest(parent2, "a")) {
            return true;
          } else {
            return false;
          }
        };
        const createRange = (sc, so, ec, eo) => {
          const rng = document.createRange();
          rng.setStart(sc, so);
          rng.setEnd(ec, eo);
          return rng;
        };
        const normalizeBlockSelectionRange = (rng) => {
          const startPos = CaretPosition.fromRangeStart(rng);
          const endPos = CaretPosition.fromRangeEnd(rng);
          const rootNode = rng.commonAncestorContainer;
          return fromPosition(false, rootNode, endPos).map((newEndPos) => {
            if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {
              return createRange(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());
            } else {
              return rng;
            }
          }).getOr(rng);
        };
        const normalize = (rng) => rng.collapsed ? rng : normalizeBlockSelectionRange(rng);
        const hasOnlyOneChild$1 = (node) => {
          return isNonNullable(node.firstChild) && node.firstChild === node.lastChild;
        };
        const isPaddingNode = (node) => {
          return node.name === "br" || node.value === nbsp;
        };
        const isPaddedEmptyBlock = (schema, node) => {
          const blockElements = schema.getBlockElements();
          return blockElements[node.name] && hasOnlyOneChild$1(node) && isPaddingNode(node.firstChild);
        };
        const isEmptyFragmentElement = (schema, node) => {
          const nonEmptyElements = schema.getNonEmptyElements();
          return isNonNullable(node) && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));
        };
        const isListFragment = (schema, fragment) => {
          let firstChild2 = fragment.firstChild;
          let lastChild2 = fragment.lastChild;
          if (firstChild2 && firstChild2.name === "meta") {
            firstChild2 = firstChild2.next;
          }
          if (lastChild2 && lastChild2.attr("id") === "mce_marker") {
            lastChild2 = lastChild2.prev;
          }
          if (isEmptyFragmentElement(schema, lastChild2)) {
            lastChild2 = lastChild2 === null || lastChild2 === void 0 ? void 0 : lastChild2.prev;
          }
          if (!firstChild2 || firstChild2 !== lastChild2) {
            return false;
          }
          return firstChild2.name === "ul" || firstChild2.name === "ol";
        };
        const cleanupDomFragment = (domFragment) => {
          var _a, _b;
          const firstChild2 = domFragment.firstChild;
          const lastChild2 = domFragment.lastChild;
          if (firstChild2 && firstChild2.nodeName === "META") {
            (_a = firstChild2.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(firstChild2);
          }
          if (lastChild2 && lastChild2.id === "mce_marker") {
            (_b = lastChild2.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(lastChild2);
          }
          return domFragment;
        };
        const toDomFragment = (dom2, serializer, fragment) => {
          const html2 = serializer.serialize(fragment);
          const domFragment = dom2.createFragment(html2);
          return cleanupDomFragment(domFragment);
        };
        const listItems = (elm) => {
          var _a;
          return filter$5((_a = elm === null || elm === void 0 ? void 0 : elm.childNodes) !== null && _a !== void 0 ? _a : [], (child2) => {
            return child2.nodeName === "LI";
          });
        };
        const isPadding = (node) => {
          return node.data === nbsp || isBr$6(node);
        };
        const isListItemPadded = (node) => {
          return isNonNullable(node === null || node === void 0 ? void 0 : node.firstChild) && node.firstChild === node.lastChild && isPadding(node.firstChild);
        };
        const isEmptyOrPadded = (elm) => {
          return !elm.firstChild || isListItemPadded(elm);
        };
        const trimListItems = (elms) => {
          return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;
        };
        const getParentLi = (dom2, node) => {
          const parentBlock = dom2.getParent(node, dom2.isBlock);
          return parentBlock && parentBlock.nodeName === "LI" ? parentBlock : null;
        };
        const isParentBlockLi = (dom2, node) => {
          return !!getParentLi(dom2, node);
        };
        const getSplit = (parentNode, rng) => {
          const beforeRng = rng.cloneRange();
          const afterRng = rng.cloneRange();
          beforeRng.setStartBefore(parentNode);
          afterRng.setEndAfter(parentNode);
          return [
            beforeRng.cloneContents(),
            afterRng.cloneContents()
          ];
        };
        const findFirstIn = (node, rootNode) => {
          const caretPos = CaretPosition.before(node);
          const caretWalker = CaretWalker(rootNode);
          const newCaretPos = caretWalker.next(caretPos);
          return newCaretPos ? newCaretPos.toRange() : null;
        };
        const findLastOf = (node, rootNode) => {
          const caretPos = CaretPosition.after(node);
          const caretWalker = CaretWalker(rootNode);
          const newCaretPos = caretWalker.prev(caretPos);
          return newCaretPos ? newCaretPos.toRange() : null;
        };
        const insertMiddle = (target, elms, rootNode, rng) => {
          const parts = getSplit(target, rng);
          const parentElm = target.parentNode;
          if (parentElm) {
            parentElm.insertBefore(parts[0], target);
            Tools.each(elms, (li) => {
              parentElm.insertBefore(li, target);
            });
            parentElm.insertBefore(parts[1], target);
            parentElm.removeChild(target);
          }
          return findLastOf(elms[elms.length - 1], rootNode);
        };
        const insertBefore$1 = (target, elms, rootNode) => {
          const parentElm = target.parentNode;
          if (parentElm) {
            Tools.each(elms, (elm) => {
              parentElm.insertBefore(elm, target);
            });
          }
          return findFirstIn(target, rootNode);
        };
        const insertAfter$1 = (target, elms, rootNode, dom2) => {
          dom2.insertAfter(elms.reverse(), target);
          return findLastOf(elms[0], rootNode);
        };
        const insertAtCaret$1 = (serializer, dom2, rng, fragment) => {
          const domFragment = toDomFragment(dom2, serializer, fragment);
          const liTarget = getParentLi(dom2, rng.startContainer);
          const liElms = trimListItems(listItems(domFragment.firstChild));
          const BEGINNING = 1, END = 2;
          const rootNode = dom2.getRoot();
          const isAt = (location2) => {
            const caretPos = CaretPosition.fromRangeStart(rng);
            const caretWalker = CaretWalker(dom2.getRoot());
            const newPos = location2 === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);
            const newPosNode = newPos === null || newPos === void 0 ? void 0 : newPos.getNode();
            return newPosNode ? getParentLi(dom2, newPosNode) !== liTarget : true;
          };
          if (!liTarget) {
            return null;
          } else if (isAt(BEGINNING)) {
            return insertBefore$1(liTarget, liElms, rootNode);
          } else if (isAt(END)) {
            return insertAfter$1(liTarget, liElms, rootNode, dom2);
          } else {
            return insertMiddle(liTarget, liElms, rootNode, rng);
          }
        };
        const mergeableWrappedElements = ["pre"];
        const shouldPasteContentOnly = (dom2, fragment, parentNode, root) => {
          var _a;
          const firstNode = fragment.firstChild;
          const lastNode = fragment.lastChild;
          const last2 = lastNode.attr("data-mce-type") === "bookmark" ? lastNode.prev : lastNode;
          const isPastingSingleElement = firstNode === last2;
          const isWrappedElement = contains$2(mergeableWrappedElements, firstNode.name);
          if (isPastingSingleElement && isWrappedElement) {
            const isContentEditable2 = firstNode.attr("contenteditable") !== "false";
            const isPastingInTheSameBlockTag = ((_a = dom2.getParent(parentNode, dom2.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase()) === firstNode.name;
            const isPastingInContentEditable = Optional.from(getContentEditableRoot$1(root, parentNode)).forall(isContentEditableTrue$3);
            return isContentEditable2 && isPastingInTheSameBlockTag && isPastingInContentEditable;
          } else {
            return false;
          }
        };
        const isTableCell = isTableCell$3;
        const isTableCellContentSelected = (dom2, rng, cell2) => {
          if (isNonNullable(cell2)) {
            const endCell = dom2.getParent(rng.endContainer, isTableCell);
            return cell2 === endCell && hasAllContentsSelected(SugarElement.fromDom(cell2), rng);
          } else {
            return false;
          }
        };
        const validInsertion = (editor, value2, parentNode) => {
          var _a;
          if (parentNode.getAttribute("data-mce-bogus") === "all") {
            (_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(editor.dom.createFragment(value2), parentNode);
          } else {
            const node = parentNode.firstChild;
            const node2 = parentNode.lastChild;
            if (!node || node === node2 && node.nodeName === "BR") {
              editor.dom.setHTML(parentNode, value2);
            } else {
              editor.selection.setContent(value2, { no_events: true });
            }
          }
        };
        const trimBrsFromTableCell = (dom2, elm) => {
          Optional.from(dom2.getParent(elm, "td,th")).map(SugarElement.fromDom).each(trimBlockTrailingBr);
        };
        const reduceInlineTextElements = (editor, merge2) => {
          const textInlineElements = editor.schema.getTextInlineElements();
          const dom2 = editor.dom;
          if (merge2) {
            const root = editor.getBody();
            const elementUtils = ElementUtils(editor);
            Tools.each(dom2.select("*[data-mce-fragment]"), (node) => {
              const isInline2 = isNonNullable(textInlineElements[node.nodeName.toLowerCase()]);
              if (isInline2 && hasInheritableStyles(dom2, node)) {
                for (let parentNode = node.parentElement; isNonNullable(parentNode) && parentNode !== root; parentNode = parentNode.parentElement) {
                  const styleConflict = hasStyleConflict(dom2, node, parentNode);
                  if (styleConflict) {
                    break;
                  }
                  if (elementUtils.compare(parentNode, node)) {
                    dom2.remove(node, true);
                    break;
                  }
                }
              }
            });
          }
        };
        const markFragmentElements = (fragment) => {
          let node = fragment;
          while (node = node.walk()) {
            if (node.type === 1) {
              node.attr("data-mce-fragment", "1");
            }
          }
        };
        const unmarkFragmentElements = (elm) => {
          Tools.each(elm.getElementsByTagName("*"), (elm2) => {
            elm2.removeAttribute("data-mce-fragment");
          });
        };
        const isPartOfFragment = (node) => {
          return !!node.getAttribute("data-mce-fragment");
        };
        const canHaveChildren = (editor, node) => {
          return isNonNullable(node) && !editor.schema.getVoidElements()[node.nodeName];
        };
        const moveSelectionToMarker = (editor, marker) => {
          var _a, _b, _c;
          let nextRng;
          const dom2 = editor.dom;
          const selection = editor.selection;
          if (!marker) {
            return;
          }
          selection.scrollIntoView(marker);
          const parentEditableElm = getContentEditableRoot$1(editor.getBody(), marker);
          if (parentEditableElm && dom2.getContentEditable(parentEditableElm) === "false") {
            dom2.remove(marker);
            selection.select(parentEditableElm);
            return;
          }
          let rng = dom2.createRng();
          const node = marker.previousSibling;
          if (isText$a(node)) {
            rng.setStart(node, (_b = (_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);
            const node2 = marker.nextSibling;
            if (isText$a(node2)) {
              node.appendData(node2.data);
              (_c = node2.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(node2);
            }
          } else {
            rng.setStartBefore(marker);
            rng.setEndBefore(marker);
          }
          const findNextCaretRng = (rng2) => {
            let caretPos = CaretPosition.fromRangeStart(rng2);
            const caretWalker = CaretWalker(editor.getBody());
            caretPos = caretWalker.next(caretPos);
            return caretPos === null || caretPos === void 0 ? void 0 : caretPos.toRange();
          };
          const parentBlock = dom2.getParent(marker, dom2.isBlock);
          dom2.remove(marker);
          if (parentBlock && dom2.isEmpty(parentBlock)) {
            empty(SugarElement.fromDom(parentBlock));
            rng.setStart(parentBlock, 0);
            rng.setEnd(parentBlock, 0);
            if (!isTableCell(parentBlock) && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {
              rng = nextRng;
              dom2.remove(parentBlock);
            } else {
              dom2.add(parentBlock, dom2.create("br", { "data-mce-bogus": "1" }));
            }
          }
          selection.setRng(rng);
        };
        const deleteSelectedContent = (editor) => {
          const dom2 = editor.dom;
          const rng = normalize(editor.selection.getRng());
          editor.selection.setRng(rng);
          const startCell = dom2.getParent(rng.startContainer, isTableCell);
          if (isTableCellContentSelected(dom2, rng, startCell)) {
            deleteCellContents(editor, rng, SugarElement.fromDom(startCell));
          } else if (rng.startContainer === rng.endContainer && rng.endOffset - rng.startOffset === 1 && isText$a(rng.startContainer.childNodes[rng.startOffset])) {
            rng.deleteContents();
          } else {
            editor.getDoc().execCommand("Delete", false);
          }
        };
        const findMarkerNode = (scope) => {
          for (let markerNode = scope; markerNode; markerNode = markerNode.walk()) {
            if (markerNode.attr("id") === "mce_marker") {
              return Optional.some(markerNode);
            }
          }
          return Optional.none();
        };
        const preventSplittingSummary = (editor) => {
          each$e(from(editor.getBody().querySelectorAll("details")), (accordion) => {
            const summaries = filter$5(from(accordion.children), (node) => node.nodeName === "SUMMARY");
            if (summaries.length > 1) {
              each$e(summaries.slice(1), (summary) => {
                const element = SugarElement.fromDom(summary);
                remove$7(element, "mce-accordion-summary");
                mutate(element, "p");
              });
            }
          });
        };
        const insertHtmlAtCaret = (editor, value2, details) => {
          var _a, _b;
          const selection = editor.selection;
          const dom2 = editor.dom;
          const parser = editor.parser;
          const merge2 = details.merge;
          const serializer = HtmlSerializer({ validate: true }, editor.schema);
          const bookmarkHtml = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>';
          if (value2.indexOf("{$caret}") === -1) {
            value2 += "{$caret}";
          }
          value2 = value2.replace(/\{\$caret\}/, bookmarkHtml);
          let rng = selection.getRng();
          const caretElement = rng.startContainer;
          const body = editor.getBody();
          if (caretElement === body && selection.isCollapsed()) {
            if (dom2.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom2.isEmpty(body.firstChild)) {
              rng = dom2.createRng();
              rng.setStart(body.firstChild, 0);
              rng.setEnd(body.firstChild, 0);
              selection.setRng(rng);
            }
          }
          if (!selection.isCollapsed()) {
            deleteSelectedContent(editor);
          }
          const parentNode = selection.getNode();
          const parserArgs = {
            context: parentNode.nodeName.toLowerCase(),
            data: details.data,
            insert: true
          };
          const fragment = parser.parse(value2, parserArgs);
          if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom2, parentNode)) {
            rng = insertAtCaret$1(serializer, dom2, selection.getRng(), fragment);
            if (rng) {
              selection.setRng(rng);
            }
            return value2;
          }
          if (details.paste === true && shouldPasteContentOnly(dom2, fragment, parentNode, editor.getBody())) {
            (_a = fragment.firstChild) === null || _a === void 0 ? void 0 : _a.unwrap();
          }
          markFragmentElements(fragment);
          let node = fragment.lastChild;
          if (node && node.attr("id") === "mce_marker") {
            const marker = node;
            for (node = node.prev; node; node = node.walk(true)) {
              if (node.type === 3 || !dom2.isBlock(node.name)) {
                if (node.parent && editor.schema.isValidChild(node.parent.name, "span")) {
                  node.parent.insert(marker, node, node.name === "br");
                }
                break;
              }
            }
          }
          editor._selectionOverrides.showBlockCaretContainer(parentNode);
          if (!parserArgs.invalid) {
            value2 = serializer.serialize(fragment);
            validInsertion(editor, value2, parentNode);
          } else {
            editor.selection.setContent(bookmarkHtml);
            let parentNode2 = selection.getNode();
            let tempNode;
            const rootNode = editor.getBody();
            if (isDocument$1(parentNode2)) {
              parentNode2 = tempNode = rootNode;
            } else {
              tempNode = parentNode2;
            }
            while (tempNode && tempNode !== rootNode) {
              parentNode2 = tempNode;
              tempNode = tempNode.parentNode;
            }
            value2 = parentNode2 === rootNode ? rootNode.innerHTML : dom2.getOuterHTML(parentNode2);
            const root = parser.parse(value2);
            const markerNode = findMarkerNode(root);
            const editingHost = markerNode.bind(findClosestEditingHost).getOr(root);
            markerNode.each((marker) => marker.replace(fragment));
            const toExtract = fragment.children();
            const parent2 = (_b = fragment.parent) !== null && _b !== void 0 ? _b : root;
            fragment.unwrap();
            const invalidChildren = filter$5(toExtract, (node2) => isInvalid(editor.schema, node2, parent2));
            cleanInvalidNodes(invalidChildren, editor.schema, editingHost);
            filter$2(parser.getNodeFilters(), parser.getAttributeFilters(), root);
            value2 = serializer.serialize(root);
            if (parentNode2 === rootNode) {
              dom2.setHTML(rootNode, value2);
            } else {
              dom2.setOuterHTML(parentNode2, value2);
            }
          }
          reduceInlineTextElements(editor, merge2);
          moveSelectionToMarker(editor, dom2.get("mce_marker"));
          unmarkFragmentElements(editor.getBody());
          trimBrsFromTableCell(dom2, selection.getStart());
          preventSplittingSummary(editor);
          updateCaret(editor.schema, editor.getBody(), selection.getStart());
          return value2;
        };
        const isTreeNode = (content) => content instanceof AstNode;
        const moveSelection = (editor) => {
          if (hasFocus(editor)) {
            firstPositionIn(editor.getBody()).each((pos) => {
              const node = pos.getNode();
              const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;
              editor.selection.setRng(caretPos.toRange());
            });
          }
        };
        const setEditorHtml = (editor, html2, noSelection) => {
          editor.dom.setHTML(editor.getBody(), html2);
          if (noSelection !== true) {
            moveSelection(editor);
          }
        };
        const setContentString = (editor, body, content, args) => {
          if (content.length === 0 || /^\s+$/.test(content)) {
            const padd = '<br data-mce-bogus="1">';
            if (body.nodeName === "TABLE") {
              content = "<tr><td>" + padd + "</td></tr>";
            } else if (/^(UL|OL)$/.test(body.nodeName)) {
              content = "<li>" + padd + "</li>";
            }
            const forcedRootBlockName = getForcedRootBlock(editor);
            if (editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {
              content = padd;
              content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);
            } else if (!content) {
              content = padd;
            }
            setEditorHtml(editor, content, args.no_selection);
            return {
              content,
              html: content
            };
          } else {
            if (args.format !== "raw") {
              content = HtmlSerializer({ validate: false }, editor.schema).serialize(editor.parser.parse(content, {
                isRootContent: true,
                insert: true
              }));
            }
            const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);
            setEditorHtml(editor, trimmedHtml, args.no_selection);
            return {
              content: trimmedHtml,
              html: trimmedHtml
            };
          }
        };
        const setContentTree = (editor, body, content, args) => {
          filter$2(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);
          const html2 = HtmlSerializer({ validate: false }, editor.schema).serialize(content);
          const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? html2 : Tools.trim(html2);
          setEditorHtml(editor, trimmedHtml, args.no_selection);
          return {
            content,
            html: trimmedHtml
          };
        };
        const setContentInternal = (editor, content, args) => {
          return Optional.from(editor.getBody()).map((body) => {
            if (isTreeNode(content)) {
              return setContentTree(editor, body, content, args);
            } else {
              return setContentString(editor, body, content, args);
            }
          }).getOr({
            content,
            html: isTreeNode(args.content) ? "" : args.content
          });
        };
        const ancestor$1 = (scope, predicate, isRoot2) => ancestor$4(scope, predicate, isRoot2).isSome();
        const sibling = (scope, predicate) => sibling$1(scope, predicate).isSome();
        const ensureIsRoot = (isRoot2) => isFunction(isRoot2) ? isRoot2 : never;
        const ancestor = (scope, transform, isRoot2) => {
          let element = scope.dom;
          const stop2 = ensureIsRoot(isRoot2);
          while (element.parentNode) {
            element = element.parentNode;
            const el = SugarElement.fromDom(element);
            const transformed = transform(el);
            if (transformed.isSome()) {
              return transformed;
            } else if (stop2(el)) {
              break;
            }
          }
          return Optional.none();
        };
        const closest$1 = (scope, transform, isRoot2) => {
          const current = transform(scope);
          const stop2 = ensureIsRoot(isRoot2);
          return current.orThunk(() => stop2(scope) ? Optional.none() : ancestor(scope, transform, stop2));
        };
        const isEq$3 = isEq$5;
        const matchesUnInheritedFormatSelector = (ed, node, name2) => {
          const formatList = ed.formatter.get(name2);
          if (formatList) {
            for (let i2 = 0; i2 < formatList.length; i2++) {
              const format = formatList[i2];
              if (isSelectorFormat(format) && format.inherit === false && ed.dom.is(node, format.selector)) {
                return true;
              }
            }
          }
          return false;
        };
        const matchParents = (editor, node, name2, vars, similar) => {
          const root = editor.dom.getRoot();
          if (node === root) {
            return false;
          }
          const matchedNode = editor.dom.getParent(node, (elm) => {
            if (matchesUnInheritedFormatSelector(editor, elm, name2)) {
              return true;
            }
            return elm.parentNode === root || !!matchNode(editor, elm, name2, vars, true);
          });
          return !!matchNode(editor, matchedNode, name2, vars, similar);
        };
        const matchName = (dom2, node, format) => {
          if (isInlineFormat(format) && isEq$3(node, format.inline)) {
            return true;
          }
          if (isBlockFormat(format) && isEq$3(node, format.block)) {
            return true;
          }
          if (isSelectorFormat(format)) {
            return isElement$6(node) && dom2.is(node, format.selector);
          }
          return false;
        };
        const matchItems = (dom2, node, format, itemName, similar, vars) => {
          const items = format[itemName];
          const matchAttributes = itemName === "attributes";
          if (isFunction(format.onmatch)) {
            return format.onmatch(node, format, itemName);
          }
          if (items) {
            if (!isArrayLike(items)) {
              for (const key in items) {
                if (has$2(items, key)) {
                  const value2 = matchAttributes ? dom2.getAttrib(node, key) : getStyle(dom2, node, key);
                  const expectedValue = replaceVars(items[key], vars);
                  const isEmptyValue = isNullable(value2) || isEmpty$3(value2);
                  if (isEmptyValue && isNullable(expectedValue)) {
                    continue;
                  }
                  if (similar && isEmptyValue && !format.exact) {
                    return false;
                  }
                  if ((!similar || format.exact) && !isEq$3(value2, normalizeStyleValue(expectedValue, key))) {
                    return false;
                  }
                }
              }
            } else {
              for (let i2 = 0; i2 < items.length; i2++) {
                if (matchAttributes ? dom2.getAttrib(node, items[i2]) : getStyle(dom2, node, items[i2])) {
                  return true;
                }
              }
            }
          }
          return true;
        };
        const matchNode = (ed, node, name2, vars, similar) => {
          const formatList = ed.formatter.get(name2);
          const dom2 = ed.dom;
          if (formatList && isElement$6(node)) {
            for (let i2 = 0; i2 < formatList.length; i2++) {
              const format = formatList[i2];
              if (matchName(ed.dom, node, format) && matchItems(dom2, node, format, "attributes", similar, vars) && matchItems(dom2, node, format, "styles", similar, vars)) {
                const classes = format.classes;
                if (classes) {
                  for (let x2 = 0; x2 < classes.length; x2++) {
                    if (!ed.dom.hasClass(node, replaceVars(classes[x2], vars))) {
                      return;
                    }
                  }
                }
                return format;
              }
            }
          }
          return void 0;
        };
        const match$2 = (editor, name2, vars, node, similar) => {
          if (node) {
            return matchParents(editor, node, name2, vars, similar);
          }
          node = editor.selection.getNode();
          if (matchParents(editor, node, name2, vars, similar)) {
            return true;
          }
          const startNode = editor.selection.getStart();
          if (startNode !== node) {
            if (matchParents(editor, startNode, name2, vars, similar)) {
              return true;
            }
          }
          return false;
        };
        const matchAll = (editor, names, vars) => {
          const matchedFormatNames = [];
          const checkedMap = {};
          const startElement = editor.selection.getStart();
          editor.dom.getParent(startElement, (node) => {
            for (let i2 = 0; i2 < names.length; i2++) {
              const name2 = names[i2];
              if (!checkedMap[name2] && matchNode(editor, node, name2, vars)) {
                checkedMap[name2] = true;
                matchedFormatNames.push(name2);
              }
            }
          }, editor.dom.getRoot());
          return matchedFormatNames;
        };
        const closest = (editor, names) => {
          const isRoot2 = (elm) => eq(elm, SugarElement.fromDom(editor.getBody()));
          const match2 = (elm, name2) => matchNode(editor, elm.dom, name2) ? Optional.some(name2) : Optional.none();
          return Optional.from(editor.selection.getStart(true)).bind((rawElm) => closest$1(SugarElement.fromDom(rawElm), (elm) => findMap(names, (name2) => match2(elm, name2)), isRoot2)).getOrNull();
        };
        const canApply = (editor, name2) => {
          const formatList = editor.formatter.get(name2);
          const dom2 = editor.dom;
          if (formatList && editor.selection.isEditable()) {
            const startNode = editor.selection.getStart();
            const parents2 = getParents$2(dom2, startNode);
            for (let x2 = formatList.length - 1; x2 >= 0; x2--) {
              const format = formatList[x2];
              if (!isSelectorFormat(format)) {
                return true;
              }
              for (let i2 = parents2.length - 1; i2 >= 0; i2--) {
                if (dom2.is(parents2[i2], format.selector)) {
                  return true;
                }
              }
            }
          }
          return false;
        };
        const matchAllOnNode = (editor, node, formatNames) => foldl(formatNames, (acc, name2) => {
          const matchSimilar = isVariableFormatName(editor, name2);
          if (editor.formatter.matchNode(node, name2, {}, matchSimilar)) {
            return acc.concat([name2]);
          } else {
            return acc;
          }
        }, []);
        const ZWSP = ZWSP$1;
        const importNode = (ownerDocument, node) => {
          return ownerDocument.importNode(node, true);
        };
        const getEmptyCaretContainers = (node) => {
          const nodes = [];
          let tempNode = node;
          while (tempNode) {
            if (isText$a(tempNode) && tempNode.data !== ZWSP || tempNode.childNodes.length > 1) {
              return [];
            }
            if (isElement$6(tempNode)) {
              nodes.push(tempNode);
            }
            tempNode = tempNode.firstChild;
          }
          return nodes;
        };
        const isCaretContainerEmpty = (node) => {
          return getEmptyCaretContainers(node).length > 0;
        };
        const findFirstTextNode = (node) => {
          if (node) {
            const walker = new DomTreeWalker(node, node);
            for (let tempNode = walker.current(); tempNode; tempNode = walker.next()) {
              if (isText$a(tempNode)) {
                return tempNode;
              }
            }
          }
          return null;
        };
        const createCaretContainer = (fill) => {
          const caretContainer = SugarElement.fromTag("span");
          setAll$1(caretContainer, {
            "id": CARET_ID,
            "data-mce-bogus": "1",
            "data-mce-type": "format-caret"
          });
          if (fill) {
            append$1(caretContainer, SugarElement.fromText(ZWSP));
          }
          return caretContainer;
        };
        const trimZwspFromCaretContainer = (caretContainerNode) => {
          const textNode = findFirstTextNode(caretContainerNode);
          if (textNode && textNode.data.charAt(0) === ZWSP) {
            textNode.deleteData(0, 1);
          }
          return textNode;
        };
        const removeCaretContainerNode = (editor, node, moveCaret2 = true) => {
          const dom2 = editor.dom, selection = editor.selection;
          if (isCaretContainerEmpty(node)) {
            deleteElement$2(editor, false, SugarElement.fromDom(node), moveCaret2);
          } else {
            const rng = selection.getRng();
            const block = dom2.getParent(node, dom2.isBlock);
            const startContainer = rng.startContainer;
            const startOffset = rng.startOffset;
            const endContainer = rng.endContainer;
            const endOffset = rng.endOffset;
            const textNode = trimZwspFromCaretContainer(node);
            dom2.remove(node, true);
            if (startContainer === textNode && startOffset > 0) {
              rng.setStart(textNode, startOffset - 1);
            }
            if (endContainer === textNode && endOffset > 0) {
              rng.setEnd(textNode, endOffset - 1);
            }
            if (block && dom2.isEmpty(block)) {
              fillWithPaddingBr(SugarElement.fromDom(block));
            }
            selection.setRng(rng);
          }
        };
        const removeCaretContainer = (editor, node, moveCaret2 = true) => {
          const dom2 = editor.dom, selection = editor.selection;
          if (!node) {
            node = getParentCaretContainer(editor.getBody(), selection.getStart());
            if (!node) {
              while (node = dom2.get(CARET_ID)) {
                removeCaretContainerNode(editor, node, moveCaret2);
              }
            }
          } else {
            removeCaretContainerNode(editor, node, moveCaret2);
          }
        };
        const insertCaretContainerNode = (editor, caretContainer, formatNode) => {
          var _a, _b;
          const dom2 = editor.dom;
          const block = dom2.getParent(formatNode, curry(isTextBlock$1, editor.schema));
          if (block && dom2.isEmpty(block)) {
            (_a = formatNode.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(caretContainer, formatNode);
          } else {
            removeTrailingBr(SugarElement.fromDom(formatNode));
            if (dom2.isEmpty(formatNode)) {
              (_b = formatNode.parentNode) === null || _b === void 0 ? void 0 : _b.replaceChild(caretContainer, formatNode);
            } else {
              dom2.insertAfter(caretContainer, formatNode);
            }
          }
        };
        const appendNode = (parentNode, node) => {
          parentNode.appendChild(node);
          return node;
        };
        const insertFormatNodesIntoCaretContainer = (formatNodes, caretContainer) => {
          var _a;
          const innerMostFormatNode = foldr(formatNodes, (parentNode, formatNode) => {
            return appendNode(parentNode, formatNode.cloneNode(false));
          }, caretContainer);
          const doc = (_a = innerMostFormatNode.ownerDocument) !== null && _a !== void 0 ? _a : document;
          return appendNode(innerMostFormatNode, doc.createTextNode(ZWSP));
        };
        const cleanFormatNode = (editor, caretContainer, formatNode, name2, vars, similar) => {
          const formatter = editor.formatter;
          const dom2 = editor.dom;
          const validFormats = filter$5(keys(formatter.get()), (formatName) => formatName !== name2 && !contains$1(formatName, "removeformat"));
          const matchedFormats = matchAllOnNode(editor, formatNode, validFormats);
          const uniqueFormats = filter$5(matchedFormats, (fmtName) => !areSimilarFormats(editor, fmtName, name2));
          if (uniqueFormats.length > 0) {
            const clonedFormatNode = formatNode.cloneNode(false);
            dom2.add(caretContainer, clonedFormatNode);
            formatter.remove(name2, vars, clonedFormatNode, similar);
            dom2.remove(clonedFormatNode);
            return Optional.some(clonedFormatNode);
          } else {
            return Optional.none();
          }
        };
        const applyCaretFormat = (editor, name2, vars) => {
          let caretContainer;
          const selection = editor.selection;
          const formatList = editor.formatter.get(name2);
          if (!formatList) {
            return;
          }
          const selectionRng = selection.getRng();
          let offset2 = selectionRng.startOffset;
          const container = selectionRng.startContainer;
          const text2 = container.nodeValue;
          caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());
          const wordcharRegex = /[^\s\u00a0\u00ad\u200b\ufeff]/;
          if (text2 && offset2 > 0 && offset2 < text2.length && wordcharRegex.test(text2.charAt(offset2)) && wordcharRegex.test(text2.charAt(offset2 - 1))) {
            const bookmark = selection.getBookmark();
            selectionRng.collapse(true);
            let rng = expandRng(editor.dom, selectionRng, formatList);
            rng = split(rng);
            editor.formatter.apply(name2, vars, rng);
            selection.moveToBookmark(bookmark);
          } else {
            let textNode = caretContainer ? findFirstTextNode(caretContainer) : null;
            if (!caretContainer || (textNode === null || textNode === void 0 ? void 0 : textNode.data) !== ZWSP) {
              caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);
              textNode = caretContainer.firstChild;
              selectionRng.insertNode(caretContainer);
              offset2 = 1;
              editor.formatter.apply(name2, vars, caretContainer);
            } else {
              editor.formatter.apply(name2, vars, caretContainer);
            }
            selection.setCursorLocation(textNode, offset2);
          }
        };
        const removeCaretFormat = (editor, name2, vars, similar) => {
          const dom2 = editor.dom;
          const selection = editor.selection;
          let hasContentAfter = false;
          const formatList = editor.formatter.get(name2);
          if (!formatList) {
            return;
          }
          const rng = selection.getRng();
          const container = rng.startContainer;
          const offset2 = rng.startOffset;
          let node = container;
          if (isText$a(container)) {
            if (offset2 !== container.data.length) {
              hasContentAfter = true;
            }
            node = node.parentNode;
          }
          const parents2 = [];
          let formatNode;
          while (node) {
            if (matchNode(editor, node, name2, vars, similar)) {
              formatNode = node;
              break;
            }
            if (node.nextSibling) {
              hasContentAfter = true;
            }
            parents2.push(node);
            node = node.parentNode;
          }
          if (!formatNode) {
            return;
          }
          if (hasContentAfter) {
            const bookmark = selection.getBookmark();
            rng.collapse(true);
            let expandedRng = expandRng(dom2, rng, formatList, true);
            expandedRng = split(expandedRng);
            editor.formatter.remove(name2, vars, expandedRng, similar);
            selection.moveToBookmark(bookmark);
          } else {
            const caretContainer = getParentCaretContainer(editor.getBody(), formatNode);
            const newCaretContainer = createCaretContainer(false).dom;
            insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null && caretContainer !== void 0 ? caretContainer : formatNode);
            const cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name2, vars, similar);
            const caretTextNode = insertFormatNodesIntoCaretContainer(parents2.concat(cleanedFormatNode.toArray()), newCaretContainer);
            if (caretContainer) {
              removeCaretContainerNode(editor, caretContainer, false);
            }
            selection.setCursorLocation(caretTextNode, 1);
            if (dom2.isEmpty(formatNode)) {
              dom2.remove(formatNode);
            }
          }
        };
        const disableCaretContainer = (editor, keyCode, moveCaret2) => {
          const selection = editor.selection, body = editor.getBody();
          removeCaretContainer(editor, null, moveCaret2);
          if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP) {
            removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
          }
          if (keyCode === 37 || keyCode === 39) {
            removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
          }
        };
        const endsWithNbsp = (element) => isText$a(element) && endsWith(element.data, nbsp);
        const setup$u = (editor) => {
          editor.on("mouseup keydown", (e2) => {
            disableCaretContainer(editor, e2.keyCode, endsWithNbsp(editor.selection.getRng().endContainer));
          });
        };
        const createCaretFormat = (formatNodes) => {
          const caretContainer = createCaretContainer(false);
          const innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom);
          return {
            caretContainer,
            caretPosition: CaretPosition(innerMost, 0)
          };
        };
        const replaceWithCaretFormat = (targetNode, formatNodes) => {
          const { caretContainer, caretPosition } = createCaretFormat(formatNodes);
          before$3(SugarElement.fromDom(targetNode), caretContainer);
          remove$5(SugarElement.fromDom(targetNode));
          return caretPosition;
        };
        const createCaretFormatAtStart$1 = (rng, formatNodes) => {
          const { caretContainer, caretPosition } = createCaretFormat(formatNodes);
          rng.insertNode(caretContainer.dom);
          return caretPosition;
        };
        const isFormatElement = (editor, element) => {
          const inlineElements = editor.schema.getTextInlineElements();
          return has$2(inlineElements, name(element)) && !isCaretNode(element.dom) && !isBogus$2(element.dom);
        };
        const isEmptyCaretFormatElement = (element) => {
          return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);
        };
        const postProcessHooks = {};
        const isPre = matchNodeNames(["pre"]);
        const addPostProcessHook = (name2, hook) => {
          const hooks = postProcessHooks[name2];
          if (!hooks) {
            postProcessHooks[name2] = [];
          }
          postProcessHooks[name2].push(hook);
        };
        const postProcess$1 = (name2, editor) => {
          if (has$2(postProcessHooks, name2)) {
            each$e(postProcessHooks[name2], (hook) => {
              hook(editor);
            });
          }
        };
        addPostProcessHook("pre", (editor) => {
          const rng = editor.selection.getRng();
          const hasPreSibling = (blocks2) => (pre) => {
            const prev2 = pre.previousSibling;
            return isPre(prev2) && contains$2(blocks2, prev2);
          };
          const joinPre = (pre1, pre2) => {
            const sPre2 = SugarElement.fromDom(pre2);
            const doc = documentOrOwner(sPre2).dom;
            remove$5(sPre2);
            append(SugarElement.fromDom(pre1), [
              SugarElement.fromTag("br", doc),
              SugarElement.fromTag("br", doc),
              ...children$1(sPre2)
            ]);
          };
          if (!rng.collapsed) {
            const blocks2 = editor.selection.getSelectedBlocks();
            const preBlocks = filter$5(filter$5(blocks2, isPre), hasPreSibling(blocks2));
            each$e(preBlocks, (pre) => {
              joinPre(pre.previousSibling, pre);
            });
          }
        });
        const listItemStyles = [
          "fontWeight",
          "fontStyle",
          "color",
          "fontSize",
          "fontFamily"
        ];
        const hasListStyles = (fmt) => isObject(fmt.styles) && exists(keys(fmt.styles), (name2) => contains$2(listItemStyles, name2));
        const findExpandedListItemFormat = (formats) => find$2(formats, (fmt) => isInlineFormat(fmt) && fmt.inline === "span" && hasListStyles(fmt));
        const getExpandedListItemFormat = (formatter, format) => {
          const formatList = formatter.get(format);
          return isArray$1(formatList) ? findExpandedListItemFormat(formatList) : Optional.none();
        };
        const isRngStartAtStartOfElement = (rng, elm) => prevPosition(elm, CaretPosition.fromRangeStart(rng)).isNone();
        const isRngEndAtEndOfElement = (rng, elm) => {
          return nextPosition(elm, CaretPosition.fromRangeEnd(rng)).exists((pos) => !isBr$6(pos.getNode()) || nextPosition(elm, pos).isSome()) === false;
        };
        const isEditableListItem = (dom2) => (elm) => isListItem$2(elm) && dom2.isEditable(elm);
        const getFullySelectedBlocks = (selection) => {
          const blocks2 = selection.getSelectedBlocks();
          const rng = selection.getRng();
          if (selection.isCollapsed()) {
            return [];
          }
          if (blocks2.length === 1) {
            return isRngStartAtStartOfElement(rng, blocks2[0]) && isRngEndAtEndOfElement(rng, blocks2[0]) ? blocks2 : [];
          } else {
            const first2 = head(blocks2).filter((elm) => isRngStartAtStartOfElement(rng, elm)).toArray();
            const last2 = last$3(blocks2).filter((elm) => isRngEndAtEndOfElement(rng, elm)).toArray();
            const middle = blocks2.slice(1, -1);
            return first2.concat(middle).concat(last2);
          }
        };
        const getFullySelectedListItems = (selection) => filter$5(getFullySelectedBlocks(selection), isEditableListItem(selection.dom));
        const getPartiallySelectedListItems = (selection) => filter$5(selection.getSelectedBlocks(), isEditableListItem(selection.dom));
        const each$8 = Tools.each;
        const isElementNode = (node) => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);
        const findElementSibling = (node, siblingName) => {
          for (let sibling2 = node; sibling2; sibling2 = sibling2[siblingName]) {
            if (isText$a(sibling2) && isNotEmpty(sibling2.data)) {
              return node;
            }
            if (isElement$6(sibling2) && !isBookmarkNode$1(sibling2)) {
              return sibling2;
            }
          }
          return node;
        };
        const mergeSiblingsNodes = (editor, prev2, next2) => {
          const elementUtils = ElementUtils(editor);
          const isPrevEditable = isElement$6(prev2) && isEditable$2(prev2);
          const isNextEditable = isElement$6(next2) && isEditable$2(next2);
          if (isPrevEditable && isNextEditable) {
            const prevSibling2 = findElementSibling(prev2, "previousSibling");
            const nextSibling2 = findElementSibling(next2, "nextSibling");
            if (elementUtils.compare(prevSibling2, nextSibling2)) {
              for (let sibling2 = prevSibling2.nextSibling; sibling2 && sibling2 !== nextSibling2; ) {
                const tmpSibling = sibling2;
                sibling2 = sibling2.nextSibling;
                prevSibling2.appendChild(tmpSibling);
              }
              editor.dom.remove(nextSibling2);
              Tools.each(Tools.grep(nextSibling2.childNodes), (node) => {
                prevSibling2.appendChild(node);
              });
              return prevSibling2;
            }
          }
          return next2;
        };
        const mergeSiblings = (editor, format, vars, node) => {
          var _a;
          if (node && format.merge_siblings !== false) {
            const newNode = (_a = mergeSiblingsNodes(editor, getNonWhiteSpaceSibling(node), node)) !== null && _a !== void 0 ? _a : node;
            mergeSiblingsNodes(editor, newNode, getNonWhiteSpaceSibling(newNode, true));
          }
        };
        const clearChildStyles = (dom2, format, node) => {
          if (format.clear_child_styles) {
            const selector = format.links ? "*:not(a)" : "*";
            each$8(dom2.select(selector, node), (childNode) => {
              if (isElementNode(childNode) && isEditable$2(childNode)) {
                each$8(format.styles, (_value, name2) => {
                  dom2.setStyle(childNode, name2, "");
                });
              }
            });
          }
        };
        const processChildElements = (node, filter2, process2) => {
          each$8(node.childNodes, (node2) => {
            if (isElementNode(node2)) {
              if (filter2(node2)) {
                process2(node2);
              }
              if (node2.hasChildNodes()) {
                processChildElements(node2, filter2, process2);
              }
            }
          });
        };
        const unwrapEmptySpan = (dom2, node) => {
          if (node.nodeName === "SPAN" && dom2.getAttribs(node).length === 0) {
            dom2.remove(node, true);
          }
        };
        const hasStyle = (dom2, name2) => (node) => !!(node && getStyle(dom2, node, name2));
        const applyStyle = (dom2, name2, value2) => (node) => {
          dom2.setStyle(node, name2, value2);
          if (node.getAttribute("style") === "") {
            node.removeAttribute("style");
          }
          unwrapEmptySpan(dom2, node);
        };
        const removeResult = Adt.generate([
          { keep: [] },
          { rename: ["name"] },
          { removed: [] }
        ]);
        const MCE_ATTR_RE = /^(src|href|style)$/;
        const each$7 = Tools.each;
        const isEq$2 = isEq$5;
        const isTableCellOrRow = (node) => /^(TR|TH|TD)$/.test(node.nodeName);
        const isChildOfInlineParent = (dom2, node, parent2) => dom2.isChildOf(node, parent2) && node !== parent2 && !dom2.isBlock(parent2);
        const getContainer = (ed, rng, start4) => {
          let container = rng[start4 ? "startContainer" : "endContainer"];
          let offset2 = rng[start4 ? "startOffset" : "endOffset"];
          if (isElement$6(container)) {
            const lastIdx = container.childNodes.length - 1;
            if (!start4 && offset2) {
              offset2--;
            }
            container = container.childNodes[offset2 > lastIdx ? lastIdx : offset2];
          }
          if (isText$a(container) && start4 && offset2 >= container.data.length) {
            container = new DomTreeWalker(container, ed.getBody()).next() || container;
          }
          if (isText$a(container) && !start4 && offset2 === 0) {
            container = new DomTreeWalker(container, ed.getBody()).prev() || container;
          }
          return container;
        };
        const normalizeTableSelection = (node, start4) => {
          const prop = start4 ? "firstChild" : "lastChild";
          const childNode = node[prop];
          if (isTableCellOrRow(node) && childNode) {
            if (node.nodeName === "TR") {
              return childNode[prop] || childNode;
            } else {
              return childNode;
            }
          }
          return node;
        };
        const wrap$1 = (dom2, node, name2, attrs) => {
          var _a;
          const wrapper = dom2.create(name2, attrs);
          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(wrapper, node);
          wrapper.appendChild(node);
          return wrapper;
        };
        const wrapWithSiblings = (dom2, node, next2, name2, attrs) => {
          const start4 = SugarElement.fromDom(node);
          const wrapper = SugarElement.fromDom(dom2.create(name2, attrs));
          const siblings2 = next2 ? nextSiblings(start4) : prevSiblings(start4);
          append(wrapper, siblings2);
          if (next2) {
            before$3(start4, wrapper);
            prepend(wrapper, start4);
          } else {
            after$4(start4, wrapper);
            append$1(wrapper, start4);
          }
          return wrapper.dom;
        };
        const isColorFormatAndAnchor = (node, format) => format.links && node.nodeName === "A";
        const removeNode = (ed, node, format) => {
          const parentNode = node.parentNode;
          let rootBlockElm;
          const dom2 = ed.dom;
          const forcedRootBlock = getForcedRootBlock(ed);
          if (isBlockFormat(format)) {
            if (parentNode === dom2.getRoot()) {
              if (!format.list_block || !isEq$2(node, format.list_block)) {
                each$e(from(node.childNodes), (node2) => {
                  if (isValid(ed, forcedRootBlock, node2.nodeName.toLowerCase())) {
                    if (!rootBlockElm) {
                      rootBlockElm = wrap$1(dom2, node2, forcedRootBlock);
                      dom2.setAttribs(rootBlockElm, getForcedRootBlockAttrs(ed));
                    } else {
                      rootBlockElm.appendChild(node2);
                    }
                  } else {
                    rootBlockElm = null;
                  }
                });
              }
            }
          }
          if (isMixedFormat(format) && !isEq$2(format.inline, node)) {
            return;
          }
          dom2.remove(node, true);
        };
        const processFormatAttrOrStyle = (name2, value2, vars) => {
          if (isNumber(name2)) {
            return {
              name: value2,
              value: null
            };
          } else {
            return {
              name: name2,
              value: replaceVars(value2, vars)
            };
          }
        };
        const removeEmptyStyleAttributeIfNeeded = (dom2, elm) => {
          if (dom2.getAttrib(elm, "style") === "") {
            elm.removeAttribute("style");
            elm.removeAttribute("data-mce-style");
          }
        };
        const removeStyles = (dom2, elm, format, vars, compareNode) => {
          let stylesModified = false;
          each$7(format.styles, (value2, name2) => {
            const {
              name: styleName,
              value: styleValue
            } = processFormatAttrOrStyle(name2, value2, vars);
            const normalizedStyleValue = normalizeStyleValue(styleValue, styleName);
            if (format.remove_similar || isNull(styleValue) || !isElement$6(compareNode) || isEq$2(getStyle(dom2, compareNode, styleName), normalizedStyleValue)) {
              dom2.setStyle(elm, styleName, "");
            }
            stylesModified = true;
          });
          if (stylesModified) {
            removeEmptyStyleAttributeIfNeeded(dom2, elm);
          }
        };
        const removeListStyleFormats = (editor, name2, vars) => {
          if (name2 === "removeformat") {
            each$e(getPartiallySelectedListItems(editor.selection), (li) => {
              each$e(listItemStyles, (name3) => editor.dom.setStyle(li, name3, ""));
              removeEmptyStyleAttributeIfNeeded(editor.dom, li);
            });
          } else {
            getExpandedListItemFormat(editor.formatter, name2).each((liFmt) => {
              each$e(getPartiallySelectedListItems(editor.selection), (li) => removeStyles(editor.dom, li, liFmt, vars, null));
            });
          }
        };
        const removeNodeFormatInternal = (ed, format, vars, node, compareNode) => {
          const dom2 = ed.dom;
          const elementUtils = ElementUtils(ed);
          const schema = ed.schema;
          if (isInlineFormat(format) && isTransparentElementName(schema, format.inline) && isTransparentBlock(schema, node) && node.parentElement === ed.getBody()) {
            removeNode(ed, node, format);
            return removeResult.removed();
          }
          if (!format.ceFalseOverride && node && dom2.getContentEditableParent(node) === "false") {
            return removeResult.keep();
          }
          if (node && !matchName(dom2, node, format) && !isColorFormatAndAnchor(node, format)) {
            return removeResult.keep();
          }
          const elm = node;
          const preserveAttributes = format.preserve_attributes;
          if (isInlineFormat(format) && format.remove === "all" && isArray$1(preserveAttributes)) {
            const attrsToPreserve = filter$5(dom2.getAttribs(elm), (attr) => contains$2(preserveAttributes, attr.name.toLowerCase()));
            dom2.removeAllAttribs(elm);
            each$e(attrsToPreserve, (attr) => dom2.setAttrib(elm, attr.name, attr.value));
            if (attrsToPreserve.length > 0) {
              return removeResult.rename("span");
            }
          }
          if (format.remove !== "all") {
            removeStyles(dom2, elm, format, vars, compareNode);
            each$7(format.attributes, (value2, name2) => {
              const {
                name: attrName,
                value: attrValue
              } = processFormatAttrOrStyle(name2, value2, vars);
              if (format.remove_similar || isNull(attrValue) || !isElement$6(compareNode) || isEq$2(dom2.getAttrib(compareNode, attrName), attrValue)) {
                if (attrName === "class") {
                  const currentValue = dom2.getAttrib(elm, attrName);
                  if (currentValue) {
                    let valueOut = "";
                    each$e(currentValue.split(/\s+/), (cls) => {
                      if (/mce\-\w+/.test(cls)) {
                        valueOut += (valueOut ? " " : "") + cls;
                      }
                    });
                    if (valueOut) {
                      dom2.setAttrib(elm, attrName, valueOut);
                      return;
                    }
                  }
                }
                if (MCE_ATTR_RE.test(attrName)) {
                  elm.removeAttribute("data-mce-" + attrName);
                }
                if (attrName === "style" && matchNodeNames(["li"])(elm) && dom2.getStyle(elm, "list-style-type") === "none") {
                  elm.removeAttribute(attrName);
                  dom2.setStyle(elm, "list-style-type", "none");
                  return;
                }
                if (attrName === "class") {
                  elm.removeAttribute("className");
                }
                elm.removeAttribute(attrName);
              }
            });
            each$7(format.classes, (value2) => {
              value2 = replaceVars(value2, vars);
              if (!isElement$6(compareNode) || dom2.hasClass(compareNode, value2)) {
                dom2.removeClass(elm, value2);
              }
            });
            const attrs = dom2.getAttribs(elm);
            for (let i2 = 0; i2 < attrs.length; i2++) {
              const attrName = attrs[i2].nodeName;
              if (!elementUtils.isAttributeInternal(attrName)) {
                return removeResult.keep();
              }
            }
          }
          if (format.remove !== "none") {
            removeNode(ed, elm, format);
            return removeResult.removed();
          }
          return removeResult.keep();
        };
        const findFormatRoot = (editor, container, name2, vars, similar) => {
          let formatRoot;
          if (container.parentNode) {
            each$e(getParents$2(editor.dom, container.parentNode).reverse(), (parent2) => {
              if (!formatRoot && isElement$6(parent2) && parent2.id !== "_start" && parent2.id !== "_end") {
                const format = matchNode(editor, parent2, name2, vars, similar);
                if (format && format.split !== false) {
                  formatRoot = parent2;
                }
              }
            });
          }
          return formatRoot;
        };
        const removeNodeFormatFromClone = (editor, format, vars, clone2) => removeNodeFormatInternal(editor, format, vars, clone2, clone2).fold(constant(clone2), (newName) => {
          const fragment = editor.dom.createFragment();
          fragment.appendChild(clone2);
          return editor.dom.rename(clone2, newName);
        }, constant(null));
        const wrapAndSplit = (editor, formatList, formatRoot, container, target, split2, format, vars) => {
          var _a, _b;
          let lastClone;
          let firstClone;
          const dom2 = editor.dom;
          if (formatRoot) {
            const formatRootParent = formatRoot.parentNode;
            for (let parent2 = container.parentNode; parent2 && parent2 !== formatRootParent; parent2 = parent2.parentNode) {
              let clone2 = dom2.clone(parent2, false);
              for (let i2 = 0; i2 < formatList.length; i2++) {
                clone2 = removeNodeFormatFromClone(editor, formatList[i2], vars, clone2);
                if (clone2 === null) {
                  break;
                }
              }
              if (clone2) {
                if (lastClone) {
                  clone2.appendChild(lastClone);
                }
                if (!firstClone) {
                  firstClone = clone2;
                }
                lastClone = clone2;
              }
            }
            if (split2 && (!format.mixed || !dom2.isBlock(formatRoot))) {
              container = (_a = dom2.split(formatRoot, container)) !== null && _a !== void 0 ? _a : container;
            }
            if (lastClone && firstClone) {
              (_b = target.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(lastClone, target);
              firstClone.appendChild(target);
              if (isInlineFormat(format)) {
                mergeSiblings(editor, format, vars, lastClone);
              }
            }
          }
          return container;
        };
        const removeFormatInternal = (ed, name2, vars, node, similar) => {
          const formatList = ed.formatter.get(name2);
          const format = formatList[0];
          const dom2 = ed.dom;
          const selection = ed.selection;
          const splitToFormatRoot = (container) => {
            const formatRoot = findFormatRoot(ed, container, name2, vars, similar);
            return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);
          };
          const isRemoveBookmarkNode = (node2) => isBookmarkNode$1(node2) && isElement$6(node2) && (node2.id === "_start" || node2.id === "_end");
          const removeFormatOnNode = (node2) => exists(formatList, (fmt) => removeNodeFormat(ed, fmt, vars, node2, node2));
          const process2 = (node2) => {
            const children2 = from(node2.childNodes);
            const removed = removeFormatOnNode(node2);
            const currentNodeMatches = removed || exists(formatList, (f2) => matchName(dom2, node2, f2));
            const parentNode = node2.parentNode;
            if (!currentNodeMatches && isNonNullable(parentNode) && shouldExpandToSelector(format)) {
              removeFormatOnNode(parentNode);
            }
            if (format.deep) {
              if (children2.length) {
                for (let i2 = 0; i2 < children2.length; i2++) {
                  process2(children2[i2]);
                }
              }
            }
            const textDecorations = [
              "underline",
              "line-through",
              "overline"
            ];
            each$e(textDecorations, (decoration) => {
              if (isElement$6(node2) && ed.dom.getStyle(node2, "text-decoration") === decoration && node2.parentNode && getTextDecoration(dom2, node2.parentNode) === decoration) {
                removeNodeFormat(ed, {
                  deep: false,
                  exact: true,
                  inline: "span",
                  styles: { textDecoration: decoration }
                }, void 0, node2);
              }
            });
          };
          const unwrap2 = (start4) => {
            const node2 = dom2.get(start4 ? "_start" : "_end");
            if (node2) {
              let out = node2[start4 ? "firstChild" : "lastChild"];
              if (isRemoveBookmarkNode(out)) {
                out = out[start4 ? "firstChild" : "lastChild"];
              }
              if (isText$a(out) && out.data.length === 0) {
                out = start4 ? node2.previousSibling || node2.nextSibling : node2.nextSibling || node2.previousSibling;
              }
              dom2.remove(node2, true);
              return out;
            } else {
              return null;
            }
          };
          const removeRngStyle = (rng) => {
            let startContainer;
            let endContainer;
            let expandedRng = expandRng(dom2, rng, formatList, rng.collapsed);
            if (format.split) {
              expandedRng = split(expandedRng);
              startContainer = getContainer(ed, expandedRng, true);
              endContainer = getContainer(ed, expandedRng);
              if (startContainer !== endContainer) {
                startContainer = normalizeTableSelection(startContainer, true);
                endContainer = normalizeTableSelection(endContainer, false);
                if (isChildOfInlineParent(dom2, startContainer, endContainer)) {
                  const marker = Optional.from(startContainer.firstChild).getOr(startContainer);
                  splitToFormatRoot(wrapWithSiblings(dom2, marker, true, "span", {
                    "id": "_start",
                    "data-mce-type": "bookmark"
                  }));
                  unwrap2(true);
                  return;
                }
                if (isChildOfInlineParent(dom2, endContainer, startContainer)) {
                  const marker = Optional.from(endContainer.lastChild).getOr(endContainer);
                  splitToFormatRoot(wrapWithSiblings(dom2, marker, false, "span", {
                    "id": "_end",
                    "data-mce-type": "bookmark"
                  }));
                  unwrap2(false);
                  return;
                }
                startContainer = wrap$1(dom2, startContainer, "span", {
                  "id": "_start",
                  "data-mce-type": "bookmark"
                });
                endContainer = wrap$1(dom2, endContainer, "span", {
                  "id": "_end",
                  "data-mce-type": "bookmark"
                });
                const newRng = dom2.createRng();
                newRng.setStartAfter(startContainer);
                newRng.setEndBefore(endContainer);
                walk$3(dom2, newRng, (nodes) => {
                  each$e(nodes, (n2) => {
                    if (!isBookmarkNode$1(n2) && !isBookmarkNode$1(n2.parentNode)) {
                      splitToFormatRoot(n2);
                    }
                  });
                });
                splitToFormatRoot(startContainer);
                splitToFormatRoot(endContainer);
                startContainer = unwrap2(true);
                endContainer = unwrap2();
              } else {
                startContainer = endContainer = splitToFormatRoot(startContainer);
              }
              expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;
              expandedRng.startOffset = dom2.nodeIndex(startContainer);
              expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;
              expandedRng.endOffset = dom2.nodeIndex(endContainer) + 1;
            }
            walk$3(dom2, expandedRng, (nodes) => {
              each$e(nodes, process2);
            });
          };
          if (node) {
            if (isNode(node)) {
              const rng = dom2.createRng();
              rng.setStartBefore(node);
              rng.setEndAfter(node);
              removeRngStyle(rng);
            } else {
              removeRngStyle(node);
            }
            fireFormatRemove(ed, name2, node, vars);
            return;
          }
          if (!selection.isCollapsed() || !isInlineFormat(format) || getCellsFromEditor(ed).length) {
            preserveSelection(ed, () => runOnRanges(ed, removeRngStyle), (startNode) => isInlineFormat(format) && match$2(ed, name2, vars, startNode));
            ed.nodeChanged();
          } else {
            removeCaretFormat(ed, name2, vars, similar);
          }
          removeListStyleFormats(ed, name2, vars);
          fireFormatRemove(ed, name2, node, vars);
        };
        const removeFormat$1 = (ed, name2, vars, node, similar) => {
          if (node || ed.selection.isEditable()) {
            removeFormatInternal(ed, name2, vars, node, similar);
          }
        };
        const removeNodeFormat = (editor, format, vars, node, compareNode) => {
          return removeNodeFormatInternal(editor, format, vars, node, compareNode).fold(never, (newName) => {
            editor.dom.rename(node, newName);
            return true;
          }, always);
        };
        const each$6 = Tools.each;
        const mergeTextDecorationsAndColor = (dom2, format, vars, node) => {
          const processTextDecorationsAndColor = (n2) => {
            if (isElement$6(n2) && isElement$6(n2.parentNode) && isEditable$2(n2)) {
              const parentTextDecoration = getTextDecoration(dom2, n2.parentNode);
              if (dom2.getStyle(n2, "color") && parentTextDecoration) {
                dom2.setStyle(n2, "text-decoration", parentTextDecoration);
              } else if (dom2.getStyle(n2, "text-decoration") === parentTextDecoration) {
                dom2.setStyle(n2, "text-decoration", null);
              }
            }
          };
          if (format.styles && (format.styles.color || format.styles.textDecoration)) {
            Tools.walk(node, processTextDecorationsAndColor, "childNodes");
            processTextDecorationsAndColor(node);
          }
        };
        const mergeBackgroundColorAndFontSize = (dom2, format, vars, node) => {
          if (format.styles && format.styles.backgroundColor) {
            const hasFontSize = hasStyle(dom2, "fontSize");
            processChildElements(node, (elm) => hasFontSize(elm) && isEditable$2(elm), applyStyle(dom2, "backgroundColor", replaceVars(format.styles.backgroundColor, vars)));
          }
        };
        const mergeSubSup = (dom2, format, vars, node) => {
          if (isInlineFormat(format) && (format.inline === "sub" || format.inline === "sup")) {
            const hasFontSize = hasStyle(dom2, "fontSize");
            processChildElements(node, (elm) => hasFontSize(elm) && isEditable$2(elm), applyStyle(dom2, "fontSize", ""));
            const inverseTagDescendants = filter$5(dom2.select(format.inline === "sup" ? "sub" : "sup", node), isEditable$2);
            dom2.remove(inverseTagDescendants, true);
          }
        };
        const mergeWithChildren = (editor, formatList, vars, node) => {
          each$6(formatList, (format) => {
            if (isInlineFormat(format)) {
              each$6(editor.dom.select(format.inline, node), (child2) => {
                if (isElementNode(child2)) {
                  removeNodeFormat(editor, format, vars, child2, format.exact ? child2 : null);
                }
              });
            }
            clearChildStyles(editor.dom, format, node);
          });
        };
        const mergeWithParents = (editor, format, name2, vars, node) => {
          const parentNode = node.parentNode;
          if (matchNode(editor, parentNode, name2, vars)) {
            if (removeNodeFormat(editor, format, vars, node)) {
              return;
            }
          }
          if (format.merge_with_parents && parentNode) {
            editor.dom.getParent(parentNode, (parent2) => {
              if (matchNode(editor, parent2, name2, vars)) {
                removeNodeFormat(editor, format, vars, node);
                return true;
              } else {
                return false;
              }
            });
          }
        };
        const each$5 = Tools.each;
        const canFormatBR = (editor, format, node, parentName) => {
          if (canFormatEmptyLines(editor) && isInlineFormat(format) && node.parentNode) {
            const validBRParentElements = getTextRootBlockElements(editor.schema);
            const hasCaretNodeSibling = sibling(SugarElement.fromDom(node), (sibling2) => isCaretNode(sibling2.dom));
            return hasNonNullableKey(validBRParentElements, parentName) && isEmpty$2(SugarElement.fromDom(node.parentNode), false) && !hasCaretNodeSibling;
          } else {
            return false;
          }
        };
        const applyStyles2 = (dom2, elm, format, vars) => {
          each$5(format.styles, (value2, name2) => {
            dom2.setStyle(elm, name2, replaceVars(value2, vars));
          });
          if (format.styles) {
            const styleVal = dom2.getAttrib(elm, "style");
            if (styleVal) {
              dom2.setAttrib(elm, "data-mce-style", styleVal);
            }
          }
        };
        const applyFormatAction = (ed, name2, vars, node) => {
          const formatList = ed.formatter.get(name2);
          const format = formatList[0];
          const isCollapsed = !node && ed.selection.isCollapsed();
          const dom2 = ed.dom;
          const selection = ed.selection;
          const setElementFormat = (elm, fmt = format) => {
            if (isFunction(fmt.onformat)) {
              fmt.onformat(elm, fmt, vars, node);
            }
            applyStyles2(dom2, elm, fmt, vars);
            each$5(fmt.attributes, (value2, name3) => {
              dom2.setAttrib(elm, name3, replaceVars(value2, vars));
            });
            each$5(fmt.classes, (value2) => {
              const newValue = replaceVars(value2, vars);
              if (!dom2.hasClass(elm, newValue)) {
                dom2.addClass(elm, newValue);
              }
            });
          };
          const applyNodeStyle = (formatList2, node2) => {
            let found = false;
            each$5(formatList2, (format2) => {
              if (!isSelectorFormat(format2)) {
                return false;
              }
              if (dom2.getContentEditable(node2) === "false" && !format2.ceFalseOverride) {
                return true;
              }
              if (isNonNullable(format2.collapsed) && format2.collapsed !== isCollapsed) {
                return true;
              }
              if (dom2.is(node2, format2.selector) && !isCaretNode(node2)) {
                setElementFormat(node2, format2);
                found = true;
                return false;
              }
              return true;
            });
            return found;
          };
          const createWrapElement = (wrapName) => {
            if (isString(wrapName)) {
              const wrapElm = dom2.create(wrapName);
              setElementFormat(wrapElm);
              return wrapElm;
            } else {
              return null;
            }
          };
          const applyRngStyle = (dom3, rng, nodeSpecific) => {
            const newWrappers = [];
            let contentEditable = true;
            const wrapName = format.inline || format.block;
            const wrapElm = createWrapElement(wrapName);
            const isMatchingWrappingBlock = (node2) => isWrappingBlockFormat(format) && matchNode(ed, node2, name2, vars);
            const canRenameBlock = (node2, parentName, isEditableDescendant) => {
              const isValidBlockFormatForNode = isNonWrappingBlockFormat(format) && isTextBlock$1(ed.schema, node2) && isValid(ed, parentName, wrapName);
              return isEditableDescendant && isValidBlockFormatForNode;
            };
            const canWrapNode = (node2, parentName, isEditableDescendant, isWrappableNoneditableElm) => {
              const nodeName = node2.nodeName.toLowerCase();
              const isValidWrapNode = isValid(ed, wrapName, nodeName) && isValid(ed, parentName, wrapName);
              const isZwsp2 = !nodeSpecific && isText$a(node2) && isZwsp$1(node2.data);
              const isCaret = isCaretNode(node2);
              const isCorrectFormatForNode = !isInlineFormat(format) || !dom3.isBlock(node2);
              return (isEditableDescendant || isWrappableNoneditableElm) && isValidWrapNode && !isZwsp2 && !isCaret && isCorrectFormatForNode;
            };
            walk$3(dom3, rng, (nodes) => {
              let currentWrapElm;
              const process2 = (node2) => {
                let hasContentEditableState2 = false;
                let lastContentEditable = contentEditable;
                let isWrappableNoneditableElm = false;
                const parentNode = node2.parentNode;
                const parentName = parentNode.nodeName.toLowerCase();
                const contentEditableValue = dom3.getContentEditable(node2);
                if (isNonNullable(contentEditableValue)) {
                  lastContentEditable = contentEditable;
                  contentEditable = contentEditableValue === "true";
                  hasContentEditableState2 = true;
                  isWrappableNoneditableElm = isWrappableNoneditable(ed, node2);
                }
                const isEditableDescendant = contentEditable && !hasContentEditableState2;
                if (isBr$6(node2) && !canFormatBR(ed, format, node2, parentName)) {
                  currentWrapElm = null;
                  if (isBlockFormat(format)) {
                    dom3.remove(node2);
                  }
                  return;
                }
                if (isMatchingWrappingBlock(node2)) {
                  currentWrapElm = null;
                  return;
                }
                if (canRenameBlock(node2, parentName, isEditableDescendant)) {
                  const elm = dom3.rename(node2, wrapName);
                  setElementFormat(elm);
                  newWrappers.push(elm);
                  currentWrapElm = null;
                  return;
                }
                if (isSelectorFormat(format)) {
                  let found = applyNodeStyle(formatList, node2);
                  if (!found && isNonNullable(parentNode) && shouldExpandToSelector(format)) {
                    found = applyNodeStyle(formatList, parentNode);
                  }
                  if (!isInlineFormat(format) || found) {
                    currentWrapElm = null;
                    return;
                  }
                }
                if (isNonNullable(wrapElm) && canWrapNode(node2, parentName, isEditableDescendant, isWrappableNoneditableElm)) {
                  if (!currentWrapElm) {
                    currentWrapElm = dom3.clone(wrapElm, false);
                    parentNode.insertBefore(currentWrapElm, node2);
                    newWrappers.push(currentWrapElm);
                  }
                  if (isWrappableNoneditableElm && hasContentEditableState2) {
                    contentEditable = lastContentEditable;
                  }
                  currentWrapElm.appendChild(node2);
                } else {
                  currentWrapElm = null;
                  each$e(from(node2.childNodes), process2);
                  if (hasContentEditableState2) {
                    contentEditable = lastContentEditable;
                  }
                  currentWrapElm = null;
                }
              };
              each$e(nodes, process2);
            });
            if (format.links === true) {
              each$e(newWrappers, (node2) => {
                const process2 = (node3) => {
                  if (node3.nodeName === "A") {
                    setElementFormat(node3, format);
                  }
                  each$e(from(node3.childNodes), process2);
                };
                process2(node2);
              });
            }
            each$e(newWrappers, (node2) => {
              const getChildCount = (node3) => {
                let count2 = 0;
                each$e(node3.childNodes, (node4) => {
                  if (!isEmptyTextNode$1(node4) && !isBookmarkNode$1(node4)) {
                    count2++;
                  }
                });
                return count2;
              };
              const mergeStyles = (node3) => {
                const childElement = find$2(node3.childNodes, isElementNode$1).filter((child2) => dom3.getContentEditable(child2) !== "false" && matchName(dom3, child2, format));
                return childElement.map((child2) => {
                  const clone2 = dom3.clone(child2, false);
                  setElementFormat(clone2);
                  dom3.replace(clone2, node3, true);
                  dom3.remove(child2, true);
                  return clone2;
                }).getOr(node3);
              };
              const childCount = getChildCount(node2);
              if ((newWrappers.length > 1 || !dom3.isBlock(node2)) && childCount === 0) {
                dom3.remove(node2, true);
                return;
              }
              if (isInlineFormat(format) || isBlockFormat(format) && format.wrapper) {
                if (!format.exact && childCount === 1) {
                  node2 = mergeStyles(node2);
                }
                mergeWithChildren(ed, formatList, vars, node2);
                mergeWithParents(ed, format, name2, vars, node2);
                mergeBackgroundColorAndFontSize(dom3, format, vars, node2);
                mergeTextDecorationsAndColor(dom3, format, vars, node2);
                mergeSubSup(dom3, format, vars, node2);
                mergeSiblings(ed, format, vars, node2);
              }
            });
          };
          const targetNode = isNode(node) ? node : selection.getNode();
          if (dom2.getContentEditable(targetNode) === "false" && !isWrappableNoneditable(ed, targetNode)) {
            node = targetNode;
            applyNodeStyle(formatList, node);
            fireFormatApply(ed, name2, node, vars);
            return;
          }
          if (format) {
            if (node) {
              if (isNode(node)) {
                if (!applyNodeStyle(formatList, node)) {
                  const rng = dom2.createRng();
                  rng.setStartBefore(node);
                  rng.setEndAfter(node);
                  applyRngStyle(dom2, expandRng(dom2, rng, formatList), true);
                }
              } else {
                applyRngStyle(dom2, node, true);
              }
            } else {
              if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed).length) {
                selection.setRng(normalize(selection.getRng()));
                preserveSelection(ed, () => {
                  runOnRanges(ed, (selectionRng, fake) => {
                    const expandedRng = fake ? selectionRng : expandRng(dom2, selectionRng, formatList);
                    applyRngStyle(dom2, expandedRng, false);
                  });
                }, always);
                ed.nodeChanged();
              } else {
                applyCaretFormat(ed, name2, vars);
              }
              getExpandedListItemFormat(ed.formatter, name2).each((liFmt) => {
                each$e(getFullySelectedListItems(ed.selection), (li) => applyStyles2(dom2, li, liFmt, vars));
              });
            }
            postProcess$1(name2, ed);
          }
          fireFormatApply(ed, name2, node, vars);
        };
        const applyFormat$1 = (editor, name2, vars, node) => {
          if (node || editor.selection.isEditable()) {
            applyFormatAction(editor, name2, vars, node);
          }
        };
        const hasVars = (value2) => has$2(value2, "vars");
        const setup$t = (registeredFormatListeners, editor) => {
          registeredFormatListeners.set({});
          editor.on("NodeChange", (e2) => {
            updateAndFireChangeCallbacks(editor, e2.element, registeredFormatListeners.get());
          });
          editor.on("FormatApply FormatRemove", (e2) => {
            const element = Optional.from(e2.node).map((nodeOrRange) => isNode(nodeOrRange) ? nodeOrRange : nodeOrRange.startContainer).bind((node) => isElement$6(node) ? Optional.some(node) : Optional.from(node.parentElement)).getOrThunk(() => fallbackElement(editor));
            updateAndFireChangeCallbacks(editor, element, registeredFormatListeners.get());
          });
        };
        const fallbackElement = (editor) => editor.selection.getStart();
        const matchingNode = (editor, parents2, format, similar, vars) => {
          const isMatchingNode = (node) => {
            const matchingFormat = editor.formatter.matchNode(node, format, vars !== null && vars !== void 0 ? vars : {}, similar);
            return !isUndefined(matchingFormat);
          };
          const isUnableToMatch = (node) => {
            if (matchesUnInheritedFormatSelector(editor, node, format)) {
              return true;
            } else {
              if (!similar) {
                return isNonNullable(editor.formatter.matchNode(node, format, vars, true));
              } else {
                return false;
              }
            }
          };
          return findUntil$1(parents2, isMatchingNode, isUnableToMatch);
        };
        const getParents = (editor, elm) => {
          const element = elm !== null && elm !== void 0 ? elm : fallbackElement(editor);
          return filter$5(getParents$2(editor.dom, element), (node) => isElement$6(node) && !isBogus$2(node));
        };
        const updateAndFireChangeCallbacks = (editor, elm, registeredCallbacks) => {
          const parents2 = getParents(editor, elm);
          each$d(registeredCallbacks, (data2, format) => {
            const runIfChanged = (spec) => {
              const match2 = matchingNode(editor, parents2, format, spec.similar, hasVars(spec) ? spec.vars : void 0);
              const isSet = match2.isSome();
              if (spec.state.get() !== isSet) {
                spec.state.set(isSet);
                const node = match2.getOr(elm);
                if (hasVars(spec)) {
                  spec.callback(isSet, {
                    node,
                    format,
                    parents: parents2
                  });
                } else {
                  each$e(spec.callbacks, (callback) => callback(isSet, {
                    node,
                    format,
                    parents: parents2
                  }));
                }
              }
            };
            each$e([
              data2.withSimilar,
              data2.withoutSimilar
            ], runIfChanged);
            each$e(data2.withVars, runIfChanged);
          });
        };
        const addListeners = (editor, registeredFormatListeners, formats, callback, similar, vars) => {
          const formatChangeItems = registeredFormatListeners.get();
          each$e(formats.split(","), (format) => {
            const group = get$a(formatChangeItems, format).getOrThunk(() => {
              const base = {
                withSimilar: {
                  state: Cell(false),
                  similar: true,
                  callbacks: []
                },
                withoutSimilar: {
                  state: Cell(false),
                  similar: false,
                  callbacks: []
                },
                withVars: []
              };
              formatChangeItems[format] = base;
              return base;
            });
            const getCurrent = () => {
              const parents2 = getParents(editor);
              return matchingNode(editor, parents2, format, similar, vars).isSome();
            };
            if (isUndefined(vars)) {
              const toAppendTo = similar ? group.withSimilar : group.withoutSimilar;
              toAppendTo.callbacks.push(callback);
              if (toAppendTo.callbacks.length === 1) {
                toAppendTo.state.set(getCurrent());
              }
            } else {
              group.withVars.push({
                state: Cell(getCurrent()),
                similar,
                vars,
                callback
              });
            }
          });
          registeredFormatListeners.set(formatChangeItems);
        };
        const removeListeners = (registeredFormatListeners, formats, callback) => {
          const formatChangeItems = registeredFormatListeners.get();
          each$e(formats.split(","), (format) => get$a(formatChangeItems, format).each((group) => {
            formatChangeItems[format] = {
              withSimilar: {
                ...group.withSimilar,
                callbacks: filter$5(group.withSimilar.callbacks, (cb) => cb !== callback)
              },
              withoutSimilar: {
                ...group.withoutSimilar,
                callbacks: filter$5(group.withoutSimilar.callbacks, (cb) => cb !== callback)
              },
              withVars: filter$5(group.withVars, (item) => item.callback !== callback)
            };
          }));
          registeredFormatListeners.set(formatChangeItems);
        };
        const formatChangedInternal = (editor, registeredFormatListeners, formats, callback, similar, vars) => {
          addListeners(editor, registeredFormatListeners, formats, callback, similar, vars);
          return { unbind: () => removeListeners(registeredFormatListeners, formats, callback) };
        };
        const toggle = (editor, name2, vars, node) => {
          const fmt = editor.formatter.get(name2);
          if (fmt) {
            if (match$2(editor, name2, vars, node) && (!("toggle" in fmt[0]) || fmt[0].toggle)) {
              removeFormat$1(editor, name2, vars, node);
            } else {
              applyFormat$1(editor, name2, vars, node);
            }
          }
        };
        const explode$1 = Tools.explode;
        const create$8 = () => {
          const filters = {};
          const addFilter = (name2, callback) => {
            each$e(explode$1(name2), (name3) => {
              if (!has$2(filters, name3)) {
                filters[name3] = {
                  name: name3,
                  callbacks: []
                };
              }
              filters[name3].callbacks.push(callback);
            });
          };
          const getFilters = () => values(filters);
          const removeFilter = (name2, callback) => {
            each$e(explode$1(name2), (name3) => {
              if (has$2(filters, name3)) {
                if (isNonNullable(callback)) {
                  const filter2 = filters[name3];
                  const newCallbacks = filter$5(filter2.callbacks, (c2) => c2 !== callback);
                  if (newCallbacks.length > 0) {
                    filter2.callbacks = newCallbacks;
                  } else {
                    delete filters[name3];
                  }
                } else {
                  delete filters[name3];
                }
              }
            });
          };
          return {
            addFilter,
            getFilters,
            removeFilter
          };
        };
        const removeAttrs = (node, names) => {
          each$e(names, (name2) => {
            node.attr(name2, null);
          });
        };
        const addFontToSpansFilter = (domParser, styles, fontSizes) => {
          domParser.addNodeFilter("font", (nodes) => {
            each$e(nodes, (node) => {
              const props = styles.parse(node.attr("style"));
              const color = node.attr("color");
              const face = node.attr("face");
              const size = node.attr("size");
              if (color) {
                props.color = color;
              }
              if (face) {
                props["font-family"] = face;
              }
              if (size) {
                toInt(size).each((num) => {
                  props["font-size"] = fontSizes[num - 1];
                });
              }
              node.name = "span";
              node.attr("style", styles.serialize(props));
              removeAttrs(node, [
                "color",
                "face",
                "size"
              ]);
            });
          });
        };
        const addStrikeFilter = (domParser, schema, styles) => {
          domParser.addNodeFilter("strike", (nodes) => {
            const convertToSTag = schema.type !== "html4";
            each$e(nodes, (node) => {
              if (convertToSTag) {
                node.name = "s";
              } else {
                const props = styles.parse(node.attr("style"));
                props["text-decoration"] = "line-through";
                node.name = "span";
                node.attr("style", styles.serialize(props));
              }
            });
          });
        };
        const addFilters = (domParser, settings, schema) => {
          var _a;
          const styles = Styles();
          if (settings.convert_fonts_to_spans) {
            addFontToSpansFilter(domParser, styles, Tools.explode((_a = settings.font_size_legacy_values) !== null && _a !== void 0 ? _a : ""));
          }
          addStrikeFilter(domParser, schema, styles);
        };
        const register$5 = (domParser, settings, schema) => {
          if (settings.inline_styles) {
            addFilters(domParser, settings, schema);
          }
        };
        const addNodeFilter = (htmlParser, schema) => {
          htmlParser.addNodeFilter("br", (nodes, _2, args) => {
            const blockElements = Tools.extend({}, schema.getBlockElements());
            const nonEmptyElements = schema.getNonEmptyElements();
            const whitespaceElements = schema.getWhitespaceElements();
            blockElements.body = 1;
            const isBlock2 = (node) => node.name in blockElements && isTransparentAstInline(schema, node);
            for (let i2 = 0, l2 = nodes.length; i2 < l2; i2++) {
              let node = nodes[i2];
              let parent2 = node.parent;
              if (parent2 && blockElements[parent2.name] && node === parent2.lastChild) {
                let prev2 = node.prev;
                while (prev2) {
                  const prevName = prev2.name;
                  if (prevName !== "span" || prev2.attr("data-mce-type") !== "bookmark") {
                    if (prevName === "br") {
                      node = null;
                    }
                    break;
                  }
                  prev2 = prev2.prev;
                }
                if (node) {
                  node.remove();
                  if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent2)) {
                    const elementRule = schema.getElementRule(parent2.name);
                    if (elementRule) {
                      if (elementRule.removeEmpty) {
                        parent2.remove();
                      } else if (elementRule.paddEmpty) {
                        paddEmptyNode(args, isBlock2, parent2);
                      }
                    }
                  }
                }
              } else {
                let lastParent = node;
                while (parent2 && parent2.firstChild === lastParent && parent2.lastChild === lastParent) {
                  lastParent = parent2;
                  if (blockElements[parent2.name]) {
                    break;
                  }
                  parent2 = parent2.parent;
                }
                if (lastParent === parent2) {
                  const textNode = new AstNode("#text", 3);
                  textNode.value = nbsp;
                  node.replace(textNode);
                }
              }
            }
          });
        };
        const blobUriToBlob = (url) => fetch(url).then((res) => res.ok ? res.blob() : Promise.reject()).catch(() => Promise.reject({
          message: `Cannot convert ${url} to Blob. Resource might not exist or is inaccessible.`,
          uriType: "blob"
        }));
        const extractBase64Data = (data2) => {
          const matches = /([a-z0-9+\/=\s]+)/i.exec(data2);
          return matches ? matches[1] : "";
        };
        const parseDataUri = (uri) => {
          const [type2, ...rest] = uri.split(",");
          const data2 = rest.join(",");
          const matches = /data:([^/]+\/[^;]+)(;.+)?/.exec(type2);
          if (matches) {
            const base64Encoded = matches[2] === ";base64";
            const extractedData = base64Encoded ? extractBase64Data(data2) : decodeURIComponent(data2);
            return Optional.some({
              type: matches[1],
              data: extractedData,
              base64Encoded
            });
          } else {
            return Optional.none();
          }
        };
        const buildBlob = (type2, data2, base64Encoded = true) => {
          let str = data2;
          if (base64Encoded) {
            try {
              str = atob(data2);
            } catch (e2) {
              return Optional.none();
            }
          }
          const arr = new Uint8Array(str.length);
          for (let i2 = 0; i2 < arr.length; i2++) {
            arr[i2] = str.charCodeAt(i2);
          }
          return Optional.some(new Blob([arr], { type: type2 }));
        };
        const dataUriToBlob = (uri) => {
          return new Promise((resolve2, reject) => {
            parseDataUri(uri).bind(({ type: type2, data: data2, base64Encoded }) => buildBlob(type2, data2, base64Encoded)).fold(() => reject("Invalid data URI"), resolve2);
          });
        };
        const uriToBlob = (url) => {
          if (startsWith(url, "blob:")) {
            return blobUriToBlob(url);
          } else if (startsWith(url, "data:")) {
            return dataUriToBlob(url);
          } else {
            return Promise.reject("Unknown URI format");
          }
        };
        const blobToDataUri = (blob) => {
          return new Promise((resolve2, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
              resolve2(reader.result);
            };
            reader.onerror = () => {
              var _a;
              reject((_a = reader.error) === null || _a === void 0 ? void 0 : _a.message);
            };
            reader.readAsDataURL(blob);
          });
        };
        let count$1 = 0;
        const uniqueId$1 = (prefix) => {
          return (prefix || "blobid") + count$1++;
        };
        const processDataUri = (dataUri, base64Only, generateBlobInfo) => {
          return parseDataUri(dataUri).bind(({ data: data2, type: type2, base64Encoded }) => {
            if (base64Only && !base64Encoded) {
              return Optional.none();
            } else {
              const base64 = base64Encoded ? data2 : btoa(data2);
              return generateBlobInfo(base64, type2);
            }
          });
        };
        const createBlobInfo$1 = (blobCache, blob, base64) => {
          const blobInfo = blobCache.create(uniqueId$1(), blob, base64);
          blobCache.add(blobInfo);
          return blobInfo;
        };
        const dataUriToBlobInfo = (blobCache, dataUri, base64Only = false) => {
          return processDataUri(dataUri, base64Only, (base64, type2) => Optional.from(blobCache.getByData(base64, type2)).orThunk(() => buildBlob(type2, base64).map((blob) => createBlobInfo$1(blobCache, blob, base64))));
        };
        const imageToBlobInfo = (blobCache, imageSrc) => {
          const invalidDataUri = () => Promise.reject("Invalid data URI");
          if (startsWith(imageSrc, "blob:")) {
            const blobInfo = blobCache.getByUri(imageSrc);
            if (isNonNullable(blobInfo)) {
              return Promise.resolve(blobInfo);
            } else {
              return uriToBlob(imageSrc).then((blob) => {
                return blobToDataUri(blob).then((dataUri) => {
                  return processDataUri(dataUri, false, (base64) => {
                    return Optional.some(createBlobInfo$1(blobCache, blob, base64));
                  }).getOrThunk(invalidDataUri);
                });
              });
            }
          } else if (startsWith(imageSrc, "data:")) {
            return dataUriToBlobInfo(blobCache, imageSrc).fold(invalidDataUri, (blobInfo) => Promise.resolve(blobInfo));
          } else {
            return Promise.reject("Unknown image data format");
          }
        };
        const isBogusImage = (img) => isNonNullable(img.attr("data-mce-bogus"));
        const isInternalImageSource = (img) => img.attr("src") === Env.transparentSrc || isNonNullable(img.attr("data-mce-placeholder"));
        const registerBase64ImageFilter = (parser, settings) => {
          const { blob_cache: blobCache } = settings;
          if (blobCache) {
            const processImage = (img) => {
              const inputSrc = img.attr("src");
              if (isInternalImageSource(img) || isBogusImage(img) || isNullable(inputSrc)) {
                return;
              }
              dataUriToBlobInfo(blobCache, inputSrc, true).each((blobInfo) => {
                img.attr("src", blobInfo.blobUri());
              });
            };
            parser.addAttributeFilter("src", (nodes) => each$e(nodes, processImage));
          }
        };
        const register$4 = (parser, settings) => {
          const schema = parser.schema;
          if (settings.remove_trailing_brs) {
            addNodeFilter(parser, schema);
          }
          parser.addAttributeFilter("href", (nodes) => {
            let i2 = nodes.length;
            const appendRel = (rel) => {
              const parts = rel.split(" ").filter((p2) => p2.length > 0);
              return parts.concat(["noopener"]).sort().join(" ");
            };
            const addNoOpener = (rel) => {
              const newRel = rel ? Tools.trim(rel) : "";
              if (!/\b(noopener)\b/g.test(newRel)) {
                return appendRel(newRel);
              } else {
                return newRel;
              }
            };
            if (!settings.allow_unsafe_link_target) {
              while (i2--) {
                const node = nodes[i2];
                if (node.name === "a" && node.attr("target") === "_blank") {
                  node.attr("rel", addNoOpener(node.attr("rel")));
                }
              }
            }
          });
          if (!settings.allow_html_in_named_anchor) {
            parser.addAttributeFilter("id,name", (nodes) => {
              let i2 = nodes.length, sibling2, prevSibling2, parent2, node;
              while (i2--) {
                node = nodes[i2];
                if (node.name === "a" && node.firstChild && !node.attr("href")) {
                  parent2 = node.parent;
                  sibling2 = node.lastChild;
                  while (sibling2 && parent2) {
                    prevSibling2 = sibling2.prev;
                    parent2.insert(sibling2, node);
                    sibling2 = prevSibling2;
                  }
                }
              }
            });
          }
          if (settings.fix_list_elements) {
            parser.addNodeFilter("ul,ol", (nodes) => {
              let i2 = nodes.length, node, parentNode;
              while (i2--) {
                node = nodes[i2];
                parentNode = node.parent;
                if (parentNode && (parentNode.name === "ul" || parentNode.name === "ol")) {
                  if (node.prev && node.prev.name === "li") {
                    node.prev.append(node);
                  } else {
                    const li = new AstNode("li", 1);
                    li.attr("style", "list-style-type: none");
                    node.wrap(li);
                  }
                }
              }
            });
          }
          const validClasses = schema.getValidClasses();
          if (settings.validate && validClasses) {
            parser.addAttributeFilter("class", (nodes) => {
              var _a;
              let i2 = nodes.length;
              while (i2--) {
                const node = nodes[i2];
                const clazz = (_a = node.attr("class")) !== null && _a !== void 0 ? _a : "";
                const classList = Tools.explode(clazz, " ");
                let classValue = "";
                for (let ci = 0; ci < classList.length; ci++) {
                  const className = classList[ci];
                  let valid = false;
                  let validClassesMap = validClasses["*"];
                  if (validClassesMap && validClassesMap[className]) {
                    valid = true;
                  }
                  validClassesMap = validClasses[node.name];
                  if (!valid && validClassesMap && validClassesMap[className]) {
                    valid = true;
                  }
                  if (valid) {
                    if (classValue) {
                      classValue += " ";
                    }
                    classValue += className;
                  }
                }
                if (!classValue.length) {
                  classValue = null;
                }
                node.attr("class", classValue);
              }
            });
          }
          registerBase64ImageFilter(parser, settings);
        };
        function _typeof(obj) {
          "@babel/helpers - typeof";
          return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
            return typeof obj2;
          } : function(obj2) {
            return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          }, _typeof(obj);
        }
        function _setPrototypeOf(o2, p2) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
            o3.__proto__ = p3;
            return o3;
          };
          return _setPrototypeOf(o2, p2);
        }
        function _isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        function _construct(Parent, args, Class) {
          if (_isNativeReflectConstruct()) {
            _construct = Reflect.construct;
          } else {
            _construct = function _construct2(Parent2, args2, Class2) {
              var a2 = [null];
              a2.push.apply(a2, args2);
              var Constructor = Function.bind.apply(Parent2, a2);
              var instance2 = new Constructor();
              if (Class2)
                _setPrototypeOf(instance2, Class2.prototype);
              return instance2;
            };
          }
          return _construct.apply(null, arguments);
        }
        function _toConsumableArray(arr) {
          return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
        }
        function _arrayWithoutHoles(arr) {
          if (Array.isArray(arr))
            return _arrayLikeToArray(arr);
        }
        function _iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
            return Array.from(iter);
        }
        function _unsupportedIterableToArray(o2, minLen) {
          if (!o2)
            return;
          if (typeof o2 === "string")
            return _arrayLikeToArray(o2, minLen);
          var n2 = Object.prototype.toString.call(o2).slice(8, -1);
          if (n2 === "Object" && o2.constructor)
            n2 = o2.constructor.name;
          if (n2 === "Map" || n2 === "Set")
            return Array.from(o2);
          if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
            return _arrayLikeToArray(o2, minLen);
        }
        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
            arr2[i2] = arr[i2];
          return arr2;
        }
        function _nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var hasOwnProperty = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
        var freeze = Object.freeze, seal = Object.seal, create$7 = Object.create;
        var _ref = typeof Reflect !== "undefined" && Reflect, apply = _ref.apply, construct = _ref.construct;
        if (!apply) {
          apply = function apply2(fun, thisValue, args) {
            return fun.apply(thisValue, args);
          };
        }
        if (!freeze) {
          freeze = function freeze2(x2) {
            return x2;
          };
        }
        if (!seal) {
          seal = function seal2(x2) {
            return x2;
          };
        }
        if (!construct) {
          construct = function construct2(Func, args) {
            return _construct(Func, _toConsumableArray(args));
          };
        }
        var arrayForEach = unapply(Array.prototype.forEach);
        var arrayPop = unapply(Array.prototype.pop);
        var arrayPush = unapply(Array.prototype.push);
        var stringToLowerCase = unapply(String.prototype.toLowerCase);
        var stringMatch = unapply(String.prototype.match);
        var stringReplace = unapply(String.prototype.replace);
        var stringIndexOf = unapply(String.prototype.indexOf);
        var stringTrim = unapply(String.prototype.trim);
        var regExpTest = unapply(RegExp.prototype.test);
        var typeErrorCreate = unconstruct(TypeError);
        function unapply(func) {
          return function(thisArg) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return apply(func, thisArg, args);
          };
        }
        function unconstruct(func) {
          return function() {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }
            return construct(func, args);
          };
        }
        function addToSet(set2, array) {
          if (setPrototypeOf) {
            setPrototypeOf(set2, null);
          }
          var l2 = array.length;
          while (l2--) {
            var element = array[l2];
            if (typeof element === "string") {
              var lcElement = stringToLowerCase(element);
              if (lcElement !== element) {
                if (!isFrozen(array)) {
                  array[l2] = lcElement;
                }
                element = lcElement;
              }
            }
            set2[element] = true;
          }
          return set2;
        }
        function clone(object) {
          var newObject = create$7(null);
          var property;
          for (property in object) {
            if (apply(hasOwnProperty, object, [property])) {
              newObject[property] = object[property];
            }
          }
          return newObject;
        }
        function lookupGetter(object, prop) {
          while (object !== null) {
            var desc = getOwnPropertyDescriptor(object, prop);
            if (desc) {
              if (desc.get) {
                return unapply(desc.get);
              }
              if (typeof desc.value === "function") {
                return unapply(desc.value);
              }
            }
            object = getPrototypeOf(object);
          }
          function fallbackValue(element) {
            console.warn("fallback value for", element);
            return null;
          }
          return fallbackValue;
        }
        var html$1 = freeze([
          "a",
          "abbr",
          "acronym",
          "address",
          "area",
          "article",
          "aside",
          "audio",
          "b",
          "bdi",
          "bdo",
          "big",
          "blink",
          "blockquote",
          "body",
          "br",
          "button",
          "canvas",
          "caption",
          "center",
          "cite",
          "code",
          "col",
          "colgroup",
          "content",
          "data",
          "datalist",
          "dd",
          "decorator",
          "del",
          "details",
          "dfn",
          "dialog",
          "dir",
          "div",
          "dl",
          "dt",
          "element",
          "em",
          "fieldset",
          "figcaption",
          "figure",
          "font",
          "footer",
          "form",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "head",
          "header",
          "hgroup",
          "hr",
          "html",
          "i",
          "img",
          "input",
          "ins",
          "kbd",
          "label",
          "legend",
          "li",
          "main",
          "map",
          "mark",
          "marquee",
          "menu",
          "menuitem",
          "meter",
          "nav",
          "nobr",
          "ol",
          "optgroup",
          "option",
          "output",
          "p",
          "picture",
          "pre",
          "progress",
          "q",
          "rp",
          "rt",
          "ruby",
          "s",
          "samp",
          "section",
          "select",
          "shadow",
          "small",
          "source",
          "spacer",
          "span",
          "strike",
          "strong",
          "style",
          "sub",
          "summary",
          "sup",
          "table",
          "tbody",
          "td",
          "template",
          "textarea",
          "tfoot",
          "th",
          "thead",
          "time",
          "tr",
          "track",
          "tt",
          "u",
          "ul",
          "var",
          "video",
          "wbr"
        ]);
        var svg$1 = freeze([
          "svg",
          "a",
          "altglyph",
          "altglyphdef",
          "altglyphitem",
          "animatecolor",
          "animatemotion",
          "animatetransform",
          "circle",
          "clippath",
          "defs",
          "desc",
          "ellipse",
          "filter",
          "font",
          "g",
          "glyph",
          "glyphref",
          "hkern",
          "image",
          "line",
          "lineargradient",
          "marker",
          "mask",
          "metadata",
          "mpath",
          "path",
          "pattern",
          "polygon",
          "polyline",
          "radialgradient",
          "rect",
          "stop",
          "style",
          "switch",
          "symbol",
          "text",
          "textpath",
          "title",
          "tref",
          "tspan",
          "view",
          "vkern"
        ]);
        var svgFilters = freeze([
          "feBlend",
          "feColorMatrix",
          "feComponentTransfer",
          "feComposite",
          "feConvolveMatrix",
          "feDiffuseLighting",
          "feDisplacementMap",
          "feDistantLight",
          "feFlood",
          "feFuncA",
          "feFuncB",
          "feFuncG",
          "feFuncR",
          "feGaussianBlur",
          "feImage",
          "feMerge",
          "feMergeNode",
          "feMorphology",
          "feOffset",
          "fePointLight",
          "feSpecularLighting",
          "feSpotLight",
          "feTile",
          "feTurbulence"
        ]);
        var svgDisallowed = freeze([
          "animate",
          "color-profile",
          "cursor",
          "discard",
          "fedropshadow",
          "font-face",
          "font-face-format",
          "font-face-name",
          "font-face-src",
          "font-face-uri",
          "foreignobject",
          "hatch",
          "hatchpath",
          "mesh",
          "meshgradient",
          "meshpatch",
          "meshrow",
          "missing-glyph",
          "script",
          "set",
          "solidcolor",
          "unknown",
          "use"
        ]);
        var mathMl$1 = freeze([
          "math",
          "menclose",
          "merror",
          "mfenced",
          "mfrac",
          "mglyph",
          "mi",
          "mlabeledtr",
          "mmultiscripts",
          "mn",
          "mo",
          "mover",
          "mpadded",
          "mphantom",
          "mroot",
          "mrow",
          "ms",
          "mspace",
          "msqrt",
          "mstyle",
          "msub",
          "msup",
          "msubsup",
          "mtable",
          "mtd",
          "mtext",
          "mtr",
          "munder",
          "munderover"
        ]);
        var mathMlDisallowed = freeze([
          "maction",
          "maligngroup",
          "malignmark",
          "mlongdiv",
          "mscarries",
          "mscarry",
          "msgroup",
          "mstack",
          "msline",
          "msrow",
          "semantics",
          "annotation",
          "annotation-xml",
          "mprescripts",
          "none"
        ]);
        var text = freeze(["#text"]);
        var html = freeze([
          "accept",
          "action",
          "align",
          "alt",
          "autocapitalize",
          "autocomplete",
          "autopictureinpicture",
          "autoplay",
          "background",
          "bgcolor",
          "border",
          "capture",
          "cellpadding",
          "cellspacing",
          "checked",
          "cite",
          "class",
          "clear",
          "color",
          "cols",
          "colspan",
          "controls",
          "controlslist",
          "coords",
          "crossorigin",
          "datetime",
          "decoding",
          "default",
          "dir",
          "disabled",
          "disablepictureinpicture",
          "disableremoteplayback",
          "download",
          "draggable",
          "enctype",
          "enterkeyhint",
          "face",
          "for",
          "headers",
          "height",
          "hidden",
          "high",
          "href",
          "hreflang",
          "id",
          "inputmode",
          "integrity",
          "ismap",
          "kind",
          "label",
          "lang",
          "list",
          "loading",
          "loop",
          "low",
          "max",
          "maxlength",
          "media",
          "method",
          "min",
          "minlength",
          "multiple",
          "muted",
          "name",
          "nonce",
          "noshade",
          "novalidate",
          "nowrap",
          "open",
          "optimum",
          "pattern",
          "placeholder",
          "playsinline",
          "poster",
          "preload",
          "pubdate",
          "radiogroup",
          "readonly",
          "rel",
          "required",
          "rev",
          "reversed",
          "role",
          "rows",
          "rowspan",
          "spellcheck",
          "scope",
          "selected",
          "shape",
          "size",
          "sizes",
          "span",
          "srclang",
          "start",
          "src",
          "srcset",
          "step",
          "style",
          "summary",
          "tabindex",
          "title",
          "translate",
          "type",
          "usemap",
          "valign",
          "value",
          "width",
          "xmlns",
          "slot"
        ]);
        var svg = freeze([
          "accent-height",
          "accumulate",
          "additive",
          "alignment-baseline",
          "ascent",
          "attributename",
          "attributetype",
          "azimuth",
          "basefrequency",
          "baseline-shift",
          "begin",
          "bias",
          "by",
          "class",
          "clip",
          "clippathunits",
          "clip-path",
          "clip-rule",
          "color",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "cx",
          "cy",
          "d",
          "dx",
          "dy",
          "diffuseconstant",
          "direction",
          "display",
          "divisor",
          "dur",
          "edgemode",
          "elevation",
          "end",
          "fill",
          "fill-opacity",
          "fill-rule",
          "filter",
          "filterunits",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "fx",
          "fy",
          "g1",
          "g2",
          "glyph-name",
          "glyphref",
          "gradientunits",
          "gradienttransform",
          "height",
          "href",
          "id",
          "image-rendering",
          "in",
          "in2",
          "k",
          "k1",
          "k2",
          "k3",
          "k4",
          "kerning",
          "keypoints",
          "keysplines",
          "keytimes",
          "lang",
          "lengthadjust",
          "letter-spacing",
          "kernelmatrix",
          "kernelunitlength",
          "lighting-color",
          "local",
          "marker-end",
          "marker-mid",
          "marker-start",
          "markerheight",
          "markerunits",
          "markerwidth",
          "maskcontentunits",
          "maskunits",
          "max",
          "mask",
          "media",
          "method",
          "mode",
          "min",
          "name",
          "numoctaves",
          "offset",
          "operator",
          "opacity",
          "order",
          "orient",
          "orientation",
          "origin",
          "overflow",
          "paint-order",
          "path",
          "pathlength",
          "patterncontentunits",
          "patterntransform",
          "patternunits",
          "points",
          "preservealpha",
          "preserveaspectratio",
          "primitiveunits",
          "r",
          "rx",
          "ry",
          "radius",
          "refx",
          "refy",
          "repeatcount",
          "repeatdur",
          "restart",
          "result",
          "rotate",
          "scale",
          "seed",
          "shape-rendering",
          "specularconstant",
          "specularexponent",
          "spreadmethod",
          "startoffset",
          "stddeviation",
          "stitchtiles",
          "stop-color",
          "stop-opacity",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke",
          "stroke-width",
          "style",
          "surfacescale",
          "systemlanguage",
          "tabindex",
          "targetx",
          "targety",
          "transform",
          "transform-origin",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "textlength",
          "type",
          "u1",
          "u2",
          "unicode",
          "values",
          "viewbox",
          "visibility",
          "version",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "width",
          "word-spacing",
          "wrap",
          "writing-mode",
          "xchannelselector",
          "ychannelselector",
          "x",
          "x1",
          "x2",
          "xmlns",
          "y",
          "y1",
          "y2",
          "z",
          "zoomandpan"
        ]);
        var mathMl = freeze([
          "accent",
          "accentunder",
          "align",
          "bevelled",
          "close",
          "columnsalign",
          "columnlines",
          "columnspan",
          "denomalign",
          "depth",
          "dir",
          "display",
          "displaystyle",
          "encoding",
          "fence",
          "frame",
          "height",
          "href",
          "id",
          "largeop",
          "length",
          "linethickness",
          "lspace",
          "lquote",
          "mathbackground",
          "mathcolor",
          "mathsize",
          "mathvariant",
          "maxsize",
          "minsize",
          "movablelimits",
          "notation",
          "numalign",
          "open",
          "rowalign",
          "rowlines",
          "rowspacing",
          "rowspan",
          "rspace",
          "rquote",
          "scriptlevel",
          "scriptminsize",
          "scriptsizemultiplier",
          "selection",
          "separator",
          "separators",
          "stretchy",
          "subscriptshift",
          "supscriptshift",
          "symmetric",
          "voffset",
          "width",
          "xmlns"
        ]);
        var xml = freeze([
          "xlink:href",
          "xml:id",
          "xlink:title",
          "xml:space",
          "xmlns:xlink"
        ]);
        var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
        var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
        var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
        var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
        var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
        var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
        var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
        var DOCTYPE_NAME = seal(/^html$/i);
        var getGlobal = function getGlobal2() {
          return typeof window === "undefined" ? null : window;
        };
        var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
          if (_typeof(trustedTypes) !== "object" || typeof trustedTypes.createPolicy !== "function") {
            return null;
          }
          var suffix = null;
          var ATTR_NAME = "data-tt-policy-suffix";
          if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
            suffix = document2.currentScript.getAttribute(ATTR_NAME);
          }
          var policyName = "dompurify" + (suffix ? "#" + suffix : "");
          try {
            return trustedTypes.createPolicy(policyName, {
              createHTML: function createHTML(html2) {
                return html2;
              }
            });
          } catch (_2) {
            console.warn("TrustedTypes policy " + policyName + " could not be created.");
            return null;
          }
        };
        function createDOMPurify() {
          var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
          var DOMPurify = function DOMPurify2(root) {
            return createDOMPurify(root);
          };
          DOMPurify.version = "2.3.8";
          DOMPurify.removed = [];
          if (!window2 || !window2.document || window2.document.nodeType !== 9) {
            DOMPurify.isSupported = false;
            return DOMPurify;
          }
          var originalDocument = window2.document;
          var document2 = window2.document;
          var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement2 = window2.HTMLTemplateElement, Node2 = window2.Node, Element2 = window2.Element, NodeFilter2 = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement2 = window2.HTMLFormElement, DOMParser2 = window2.DOMParser, trustedTypes = window2.trustedTypes;
          var ElementPrototype = Element2.prototype;
          var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
          var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
          var getChildNodes2 = lookupGetter(ElementPrototype, "childNodes");
          var getParentNode2 = lookupGetter(ElementPrototype, "parentNode");
          if (typeof HTMLTemplateElement2 === "function") {
            var template = document2.createElement("template");
            if (template.content && template.content.ownerDocument) {
              document2 = template.content.ownerDocument;
            }
          }
          var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
          var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
          var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment2 = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
          var importNode2 = originalDocument.importNode;
          var documentMode = {};
          try {
            documentMode = clone(document2).documentMode ? document2.documentMode : {};
          } catch (_2) {
          }
          var hooks = {};
          DOMPurify.isSupported = typeof getParentNode2 === "function" && implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
          var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
          var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
          var ALLOWED_TAGS = null;
          var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
          var ALLOWED_ATTR = null;
          var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
          var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
            tagNameCheck: {
              writable: true,
              configurable: false,
              enumerable: true,
              value: null
            },
            attributeNameCheck: {
              writable: true,
              configurable: false,
              enumerable: true,
              value: null
            },
            allowCustomizedBuiltInElements: {
              writable: true,
              configurable: false,
              enumerable: true,
              value: false
            }
          }));
          var FORBID_TAGS = null;
          var FORBID_ATTR = null;
          var ALLOW_ARIA_ATTR = true;
          var ALLOW_DATA_ATTR = true;
          var ALLOW_UNKNOWN_PROTOCOLS = false;
          var SAFE_FOR_TEMPLATES = false;
          var WHOLE_DOCUMENT = false;
          var SET_CONFIG = false;
          var FORCE_BODY = false;
          var RETURN_DOM = false;
          var RETURN_DOM_FRAGMENT = false;
          var RETURN_TRUSTED_TYPE = false;
          var SANITIZE_DOM = true;
          var KEEP_CONTENT = true;
          var IN_PLACE = false;
          var USE_PROFILES = {};
          var FORBID_CONTENTS = null;
          var DEFAULT_FORBID_CONTENTS = addToSet({}, [
            "annotation-xml",
            "audio",
            "colgroup",
            "desc",
            "foreignobject",
            "head",
            "iframe",
            "math",
            "mi",
            "mn",
            "mo",
            "ms",
            "mtext",
            "noembed",
            "noframes",
            "noscript",
            "plaintext",
            "script",
            "style",
            "svg",
            "template",
            "thead",
            "title",
            "video",
            "xmp"
          ]);
          var DATA_URI_TAGS = null;
          var DEFAULT_DATA_URI_TAGS = addToSet({}, [
            "audio",
            "video",
            "img",
            "source",
            "image",
            "track"
          ]);
          var URI_SAFE_ATTRIBUTES = null;
          var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [
            "alt",
            "class",
            "for",
            "id",
            "label",
            "name",
            "pattern",
            "placeholder",
            "role",
            "summary",
            "title",
            "value",
            "style",
            "xmlns"
          ]);
          var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
          var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
          var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
          var NAMESPACE = HTML_NAMESPACE;
          var IS_EMPTY_INPUT = false;
          var PARSER_MEDIA_TYPE;
          var SUPPORTED_PARSER_MEDIA_TYPES = [
            "application/xhtml+xml",
            "text/html"
          ];
          var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
          var transformCaseFunc;
          var CONFIG = null;
          var formElement = document2.createElement("form");
          var isRegexOrFunction = function isRegexOrFunction2(testValue) {
            return testValue instanceof RegExp || testValue instanceof Function;
          };
          var _parseConfig = function _parseConfig2(cfg) {
            if (CONFIG && CONFIG === cfg) {
              return;
            }
            if (!cfg || _typeof(cfg) !== "object") {
              cfg = {};
            }
            cfg = clone(cfg);
            ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
            ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
            URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
            DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
            FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
            FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
            FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
            USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
            ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
            ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
            ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
            SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
            WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
            RETURN_DOM = cfg.RETURN_DOM || false;
            RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
            RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
            FORCE_BODY = cfg.FORCE_BODY || false;
            SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
            KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
            IN_PLACE = cfg.IN_PLACE || false;
            IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
            NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
            if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
              CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
            }
            if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
              CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
            }
            if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
              CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
            }
            PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
            transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? function(x2) {
              return x2;
            } : stringToLowerCase;
            if (SAFE_FOR_TEMPLATES) {
              ALLOW_DATA_ATTR = false;
            }
            if (RETURN_DOM_FRAGMENT) {
              RETURN_DOM = true;
            }
            if (USE_PROFILES) {
              ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
              ALLOWED_ATTR = [];
              if (USE_PROFILES.html === true) {
                addToSet(ALLOWED_TAGS, html$1);
                addToSet(ALLOWED_ATTR, html);
              }
              if (USE_PROFILES.svg === true) {
                addToSet(ALLOWED_TAGS, svg$1);
                addToSet(ALLOWED_ATTR, svg);
                addToSet(ALLOWED_ATTR, xml);
              }
              if (USE_PROFILES.svgFilters === true) {
                addToSet(ALLOWED_TAGS, svgFilters);
                addToSet(ALLOWED_ATTR, svg);
                addToSet(ALLOWED_ATTR, xml);
              }
              if (USE_PROFILES.mathMl === true) {
                addToSet(ALLOWED_TAGS, mathMl$1);
                addToSet(ALLOWED_ATTR, mathMl);
                addToSet(ALLOWED_ATTR, xml);
              }
            }
            if (cfg.ADD_TAGS) {
              if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
                ALLOWED_TAGS = clone(ALLOWED_TAGS);
              }
              addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
            }
            if (cfg.ADD_ATTR) {
              if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
                ALLOWED_ATTR = clone(ALLOWED_ATTR);
              }
              addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
            }
            if (cfg.ADD_URI_SAFE_ATTR) {
              addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
            }
            if (cfg.FORBID_CONTENTS) {
              if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
                FORBID_CONTENTS = clone(FORBID_CONTENTS);
              }
              addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
            }
            if (KEEP_CONTENT) {
              ALLOWED_TAGS["#text"] = true;
            }
            if (WHOLE_DOCUMENT) {
              addToSet(ALLOWED_TAGS, [
                "html",
                "head",
                "body"
              ]);
            }
            if (ALLOWED_TAGS.table) {
              addToSet(ALLOWED_TAGS, ["tbody"]);
              delete FORBID_TAGS.tbody;
            }
            if (freeze) {
              freeze(cfg);
            }
            CONFIG = cfg;
          };
          var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [
            "mi",
            "mo",
            "mn",
            "ms",
            "mtext"
          ]);
          var HTML_INTEGRATION_POINTS = addToSet({}, [
            "foreignobject",
            "desc",
            "title",
            "annotation-xml"
          ]);
          var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [
            "title",
            "style",
            "font",
            "a",
            "script"
          ]);
          var ALL_SVG_TAGS = addToSet({}, svg$1);
          addToSet(ALL_SVG_TAGS, svgFilters);
          addToSet(ALL_SVG_TAGS, svgDisallowed);
          var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
          addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
          var _checkValidNamespace = function _checkValidNamespace2(element) {
            var parent2 = getParentNode2(element);
            if (!parent2 || !parent2.tagName) {
              parent2 = {
                namespaceURI: HTML_NAMESPACE,
                tagName: "template"
              };
            }
            var tagName = stringToLowerCase(element.tagName);
            var parentTagName = stringToLowerCase(parent2.tagName);
            if (element.namespaceURI === SVG_NAMESPACE) {
              if (parent2.namespaceURI === HTML_NAMESPACE) {
                return tagName === "svg";
              }
              if (parent2.namespaceURI === MATHML_NAMESPACE) {
                return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
              }
              return Boolean(ALL_SVG_TAGS[tagName]);
            }
            if (element.namespaceURI === MATHML_NAMESPACE) {
              if (parent2.namespaceURI === HTML_NAMESPACE) {
                return tagName === "math";
              }
              if (parent2.namespaceURI === SVG_NAMESPACE) {
                return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
              }
              return Boolean(ALL_MATHML_TAGS[tagName]);
            }
            if (element.namespaceURI === HTML_NAMESPACE) {
              if (parent2.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
                return false;
              }
              if (parent2.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
                return false;
              }
              return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
            }
            return false;
          };
          var _forceRemove = function _forceRemove2(node) {
            arrayPush(DOMPurify.removed, { element: node });
            try {
              node.parentNode.removeChild(node);
            } catch (_2) {
              try {
                node.outerHTML = emptyHTML;
              } catch (_3) {
                node.remove();
              }
            }
          };
          var _removeAttribute = function _removeAttribute2(name2, node) {
            try {
              arrayPush(DOMPurify.removed, {
                attribute: node.getAttributeNode(name2),
                from: node
              });
            } catch (_2) {
              arrayPush(DOMPurify.removed, {
                attribute: null,
                from: node
              });
            }
            node.removeAttribute(name2);
            if (name2 === "is" && !ALLOWED_ATTR[name2]) {
              if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
                try {
                  _forceRemove(node);
                } catch (_2) {
                }
              } else {
                try {
                  node.setAttribute(name2, "");
                } catch (_2) {
                }
              }
            }
          };
          var _initDocument = function _initDocument2(dirty) {
            var doc;
            var leadingWhitespace;
            if (FORCE_BODY) {
              dirty = "<remove></remove>" + dirty;
            } else {
              var matches = stringMatch(dirty, /^[\r\n\t ]+/);
              leadingWhitespace = matches && matches[0];
            }
            if (PARSER_MEDIA_TYPE === "application/xhtml+xml") {
              dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
            }
            var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
            if (NAMESPACE === HTML_NAMESPACE) {
              try {
                doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
              } catch (_2) {
              }
            }
            if (!doc || !doc.documentElement) {
              doc = implementation.createDocument(NAMESPACE, "template", null);
              try {
                doc.documentElement.innerHTML = IS_EMPTY_INPUT ? "" : dirtyPayload;
              } catch (_2) {
              }
            }
            var body = doc.body || doc.documentElement;
            if (dirty && leadingWhitespace) {
              body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
            }
            if (NAMESPACE === HTML_NAMESPACE) {
              return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
            }
            return WHOLE_DOCUMENT ? doc.documentElement : body;
          };
          var _createIterator = function _createIterator2(root) {
            return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter2.SHOW_ELEMENT | NodeFilter2.SHOW_COMMENT | NodeFilter2.SHOW_TEXT, null, false);
          };
          var _isClobbered = function _isClobbered2(elm) {
            return elm instanceof HTMLFormElement2 && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function");
          };
          var _isNode = function _isNode2(object) {
            return _typeof(Node2) === "object" ? object instanceof Node2 : object && _typeof(object) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
          };
          var _executeHook = function _executeHook2(entryPoint, currentNode, data2) {
            if (!hooks[entryPoint]) {
              return;
            }
            arrayForEach(hooks[entryPoint], function(hook) {
              hook.call(DOMPurify, currentNode, data2, CONFIG);
            });
          };
          var _sanitizeElements = function _sanitizeElements2(currentNode) {
            var content;
            _executeHook("beforeSanitizeElements", currentNode, null);
            if (_isClobbered(currentNode)) {
              _forceRemove(currentNode);
              return true;
            }
            if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
              _forceRemove(currentNode);
              return true;
            }
            var tagName = transformCaseFunc(currentNode.nodeName);
            _executeHook("uponSanitizeElement", currentNode, {
              tagName,
              allowedTags: ALLOWED_TAGS
            });
            if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
              _forceRemove(currentNode);
              return true;
            }
            if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
              _forceRemove(currentNode);
              return true;
            }
            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
              if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
                  return false;
                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
                  return false;
              }
              if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
                var parentNode = getParentNode2(currentNode) || currentNode.parentNode;
                var childNodes = getChildNodes2(currentNode) || currentNode.childNodes;
                if (childNodes && parentNode) {
                  var childCount = childNodes.length;
                  for (var i2 = childCount - 1; i2 >= 0; --i2) {
                    parentNode.insertBefore(cloneNode(childNodes[i2], true), getNextSibling(currentNode));
                  }
                }
              }
              _forceRemove(currentNode);
              return true;
            }
            if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
              _forceRemove(currentNode);
              return true;
            }
            if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
              _forceRemove(currentNode);
              return true;
            }
            if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
              content = currentNode.textContent;
              content = stringReplace(content, MUSTACHE_EXPR$1, " ");
              content = stringReplace(content, ERB_EXPR$1, " ");
              if (currentNode.textContent !== content) {
                arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
                currentNode.textContent = content;
              }
            }
            _executeHook("afterSanitizeElements", currentNode, null);
            return false;
          };
          var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value2) {
            if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value2 in document2 || value2 in formElement)) {
              return false;
            }
            if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName))
              ;
            else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName))
              ;
            else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
              if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value2) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value2)))
                ;
              else {
                return false;
              }
            } else if (URI_SAFE_ATTRIBUTES[lcName])
              ;
            else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value2, ATTR_WHITESPACE$1, "")))
              ;
            else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value2, "data:") === 0 && DATA_URI_TAGS[lcTag])
              ;
            else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value2, ATTR_WHITESPACE$1, "")))
              ;
            else if (!value2)
              ;
            else {
              return false;
            }
            return true;
          };
          var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
            return tagName.indexOf("-") > 0;
          };
          var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
            var attr;
            var value2;
            var lcName;
            var l2;
            _executeHook("beforeSanitizeAttributes", currentNode, null);
            var attributes = currentNode.attributes;
            if (!attributes) {
              return;
            }
            var hookEvent = {
              attrName: "",
              attrValue: "",
              keepAttr: true,
              allowedAttributes: ALLOWED_ATTR
            };
            l2 = attributes.length;
            while (l2--) {
              attr = attributes[l2];
              var _attr = attr, name2 = _attr.name, namespaceURI = _attr.namespaceURI;
              value2 = name2 === "value" ? attr.value : stringTrim(attr.value);
              lcName = transformCaseFunc(name2);
              var initValue = value2;
              hookEvent.attrName = lcName;
              hookEvent.attrValue = value2;
              hookEvent.keepAttr = true;
              hookEvent.forceKeepAttr = void 0;
              _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
              value2 = hookEvent.attrValue;
              if (hookEvent.forceKeepAttr) {
                continue;
              }
              if (!hookEvent.keepAttr) {
                _removeAttribute(name2, currentNode);
                continue;
              }
              if (regExpTest(/\/>/i, value2)) {
                _removeAttribute(name2, currentNode);
                continue;
              }
              if (SAFE_FOR_TEMPLATES) {
                value2 = stringReplace(value2, MUSTACHE_EXPR$1, " ");
                value2 = stringReplace(value2, ERB_EXPR$1, " ");
              }
              var lcTag = transformCaseFunc(currentNode.nodeName);
              if (!_isValidAttribute(lcTag, lcName, value2)) {
                _removeAttribute(name2, currentNode);
                continue;
              }
              if (value2 !== initValue) {
                try {
                  if (namespaceURI) {
                    currentNode.setAttributeNS(namespaceURI, name2, value2);
                  } else {
                    currentNode.setAttribute(name2, value2);
                  }
                } catch (_2) {
                  _removeAttribute(name2, currentNode);
                }
              }
            }
            _executeHook("afterSanitizeAttributes", currentNode, null);
          };
          var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
            var shadowNode;
            var shadowIterator = _createIterator(fragment);
            _executeHook("beforeSanitizeShadowDOM", fragment, null);
            while (shadowNode = shadowIterator.nextNode()) {
              _executeHook("uponSanitizeShadowNode", shadowNode, null);
              if (_sanitizeElements(shadowNode)) {
                continue;
              }
              if (shadowNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM2(shadowNode.content);
              }
              _sanitizeAttributes(shadowNode);
            }
            _executeHook("afterSanitizeShadowDOM", fragment, null);
          };
          DOMPurify.sanitize = function(dirty, cfg) {
            var body;
            var importedNode;
            var currentNode;
            var oldNode;
            var returnNode;
            IS_EMPTY_INPUT = !dirty;
            if (IS_EMPTY_INPUT) {
              dirty = "<!-->";
            }
            if (typeof dirty !== "string" && !_isNode(dirty)) {
              if (typeof dirty.toString !== "function") {
                throw typeErrorCreate("toString is not a function");
              } else {
                dirty = dirty.toString();
                if (typeof dirty !== "string") {
                  throw typeErrorCreate("dirty is not a string, aborting");
                }
              }
            }
            if (!DOMPurify.isSupported) {
              if (_typeof(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
                if (typeof dirty === "string") {
                  return window2.toStaticHTML(dirty);
                }
                if (_isNode(dirty)) {
                  return window2.toStaticHTML(dirty.outerHTML);
                }
              }
              return dirty;
            }
            if (!SET_CONFIG) {
              _parseConfig(cfg);
            }
            DOMPurify.removed = [];
            if (typeof dirty === "string") {
              IN_PLACE = false;
            }
            if (IN_PLACE) {
              if (dirty.nodeName) {
                var tagName = transformCaseFunc(dirty.nodeName);
                if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
                  throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
                }
              }
            } else if (dirty instanceof Node2) {
              body = _initDocument("<!---->");
              importedNode = body.ownerDocument.importNode(dirty, true);
              if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
                body = importedNode;
              } else if (importedNode.nodeName === "HTML") {
                body = importedNode;
              } else {
                body.appendChild(importedNode);
              }
            } else {
              if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf("<") === -1) {
                return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
              }
              body = _initDocument(dirty);
              if (!body) {
                return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
              }
            }
            if (body && FORCE_BODY) {
              _forceRemove(body.firstChild);
            }
            var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
            while (currentNode = nodeIterator.nextNode()) {
              if (currentNode.nodeType === 3 && currentNode === oldNode) {
                continue;
              }
              if (_sanitizeElements(currentNode)) {
                continue;
              }
              if (currentNode.content instanceof DocumentFragment) {
                _sanitizeShadowDOM(currentNode.content);
              }
              _sanitizeAttributes(currentNode);
              oldNode = currentNode;
            }
            oldNode = null;
            if (IN_PLACE) {
              return dirty;
            }
            if (RETURN_DOM) {
              if (RETURN_DOM_FRAGMENT) {
                returnNode = createDocumentFragment2.call(body.ownerDocument);
                while (body.firstChild) {
                  returnNode.appendChild(body.firstChild);
                }
              } else {
                returnNode = body;
              }
              if (ALLOWED_ATTR.shadowroot) {
                returnNode = importNode2.call(originalDocument, returnNode, true);
              }
              return returnNode;
            }
            var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
            if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
              serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
            }
            if (SAFE_FOR_TEMPLATES) {
              serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, " ");
              serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, " ");
            }
            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
          };
          DOMPurify.setConfig = function(cfg) {
            _parseConfig(cfg);
            SET_CONFIG = true;
          };
          DOMPurify.clearConfig = function() {
            CONFIG = null;
            SET_CONFIG = false;
          };
          DOMPurify.isValidAttribute = function(tag, attr, value2) {
            if (!CONFIG) {
              _parseConfig({});
            }
            var lcTag = transformCaseFunc(tag);
            var lcName = transformCaseFunc(attr);
            return _isValidAttribute(lcTag, lcName, value2);
          };
          DOMPurify.addHook = function(entryPoint, hookFunction) {
            if (typeof hookFunction !== "function") {
              return;
            }
            hooks[entryPoint] = hooks[entryPoint] || [];
            arrayPush(hooks[entryPoint], hookFunction);
          };
          DOMPurify.removeHook = function(entryPoint) {
            if (hooks[entryPoint]) {
              return arrayPop(hooks[entryPoint]);
            }
          };
          DOMPurify.removeHooks = function(entryPoint) {
            if (hooks[entryPoint]) {
              hooks[entryPoint] = [];
            }
          };
          DOMPurify.removeAllHooks = function() {
            hooks = {};
          };
          return DOMPurify;
        }
        var purify = createDOMPurify();
        const each$4 = Tools.each, trim = Tools.trim;
        const queryParts = [
          "source",
          "protocol",
          "authority",
          "userInfo",
          "user",
          "password",
          "host",
          "port",
          "relative",
          "path",
          "directory",
          "file",
          "query",
          "anchor"
        ];
        const DEFAULT_PORTS = {
          ftp: 21,
          http: 80,
          https: 443,
          mailto: 25
        };
        const safeSvgDataUrlElements = [
          "img",
          "video"
        ];
        const blockSvgDataUris = (allowSvgDataUrls, tagName) => {
          if (isNonNullable(allowSvgDataUrls)) {
            return !allowSvgDataUrls;
          } else {
            return isNonNullable(tagName) ? !contains$2(safeSvgDataUrlElements, tagName) : true;
          }
        };
        const decodeUri = (encodedUri) => {
          try {
            return decodeURIComponent(encodedUri);
          } catch (ex) {
            return unescape(encodedUri);
          }
        };
        const isInvalidUri = (settings, uri, tagName) => {
          const decodedUri = decodeUri(uri).replace(/\s/g, "");
          if (settings.allow_script_urls) {
            return false;
          } else if (/((java|vb)script|mhtml):/i.test(decodedUri)) {
            return true;
          } else if (settings.allow_html_data_urls) {
            return false;
          } else if (/^data:image\//i.test(decodedUri)) {
            return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\/svg\+xml/i.test(decodedUri);
          } else {
            return /^data:/i.test(decodedUri);
          }
        };
        class URI {
          static parseDataUri(uri) {
            let type2;
            const uriComponents = decodeURIComponent(uri).split(",");
            const matches = /data:([^;]+)/.exec(uriComponents[0]);
            if (matches) {
              type2 = matches[1];
            }
            return {
              type: type2,
              data: uriComponents[1]
            };
          }
          static isDomSafe(uri, context2, options = {}) {
            if (options.allow_script_urls) {
              return true;
            } else {
              const decodedUri = Entities.decode(uri).replace(/[\s\u0000-\u001F]+/g, "");
              return !isInvalidUri(options, decodedUri, context2);
            }
          }
          static getDocumentBaseUrl(loc) {
            var _a;
            let baseUrl;
            if (loc.protocol.indexOf("http") !== 0 && loc.protocol !== "file:") {
              baseUrl = (_a = loc.href) !== null && _a !== void 0 ? _a : "";
            } else {
              baseUrl = loc.protocol + "//" + loc.host + loc.pathname;
            }
            if (/^[^:]+:\/\/\/?[^\/]+\//.test(baseUrl)) {
              baseUrl = baseUrl.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, "");
              if (!/[\/\\]$/.test(baseUrl)) {
                baseUrl += "/";
              }
            }
            return baseUrl;
          }
          constructor(url, settings = {}) {
            this.path = "";
            this.directory = "";
            url = trim(url);
            this.settings = settings;
            const baseUri = settings.base_uri;
            const self2 = this;
            if (/^([\w\-]+):([^\/]{2})/i.test(url) || /^\s*#/.test(url)) {
              self2.source = url;
              return;
            }
            const isProtocolRelative = url.indexOf("//") === 0;
            if (url.indexOf("/") === 0 && !isProtocolRelative) {
              url = (baseUri ? baseUri.protocol || "http" : "http") + "://mce_host" + url;
            }
            if (!/^[\w\-]*:?\/\//.test(url)) {
              const baseUrl = baseUri ? baseUri.path : new URI(document.location.href).directory;
              if ((baseUri === null || baseUri === void 0 ? void 0 : baseUri.protocol) === "") {
                url = "//mce_host" + self2.toAbsPath(baseUrl, url);
              } else {
                const match2 = /([^#?]*)([#?]?.*)/.exec(url);
                if (match2) {
                  url = (baseUri && baseUri.protocol || "http") + "://mce_host" + self2.toAbsPath(baseUrl, match2[1]) + match2[2];
                }
              }
            }
            url = url.replace(/@@/g, "(mce_at)");
            const urlMatch = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(url);
            if (urlMatch) {
              each$4(queryParts, (v2, i2) => {
                let part = urlMatch[i2];
                if (part) {
                  part = part.replace(/\(mce_at\)/g, "@@");
                }
                self2[v2] = part;
              });
            }
            if (baseUri) {
              if (!self2.protocol) {
                self2.protocol = baseUri.protocol;
              }
              if (!self2.userInfo) {
                self2.userInfo = baseUri.userInfo;
              }
              if (!self2.port && self2.host === "mce_host") {
                self2.port = baseUri.port;
              }
              if (!self2.host || self2.host === "mce_host") {
                self2.host = baseUri.host;
              }
              self2.source = "";
            }
            if (isProtocolRelative) {
              self2.protocol = "";
            }
          }
          setPath(path2) {
            const pathMatch = /^(.*?)\/?(\w+)?$/.exec(path2);
            if (pathMatch) {
              this.path = pathMatch[0];
              this.directory = pathMatch[1];
              this.file = pathMatch[2];
            }
            this.source = "";
            this.getURI();
          }
          toRelative(uri) {
            if (uri === "./") {
              return uri;
            }
            const relativeUri = new URI(uri, { base_uri: this });
            if (relativeUri.host !== "mce_host" && this.host !== relativeUri.host && relativeUri.host || this.port !== relativeUri.port || this.protocol !== relativeUri.protocol && relativeUri.protocol !== "") {
              return relativeUri.getURI();
            }
            const tu = this.getURI(), uu = relativeUri.getURI();
            if (tu === uu || tu.charAt(tu.length - 1) === "/" && tu.substr(0, tu.length - 1) === uu) {
              return tu;
            }
            let output = this.toRelPath(this.path, relativeUri.path);
            if (relativeUri.query) {
              output += "?" + relativeUri.query;
            }
            if (relativeUri.anchor) {
              output += "#" + relativeUri.anchor;
            }
            return output;
          }
          toAbsolute(uri, noHost) {
            const absoluteUri = new URI(uri, { base_uri: this });
            return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));
          }
          isSameOrigin(uri) {
            if (this.host == uri.host && this.protocol == uri.protocol) {
              if (this.port == uri.port) {
                return true;
              }
              const defaultPort = this.protocol ? DEFAULT_PORTS[this.protocol] : null;
              if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {
                return true;
              }
            }
            return false;
          }
          toRelPath(base, path2) {
            let breakPoint = 0, out = "", i2, l2;
            const normalizedBase = base.substring(0, base.lastIndexOf("/")).split("/");
            const items = path2.split("/");
            if (normalizedBase.length >= items.length) {
              for (i2 = 0, l2 = normalizedBase.length; i2 < l2; i2++) {
                if (i2 >= items.length || normalizedBase[i2] !== items[i2]) {
                  breakPoint = i2 + 1;
                  break;
                }
              }
            }
            if (normalizedBase.length < items.length) {
              for (i2 = 0, l2 = items.length; i2 < l2; i2++) {
                if (i2 >= normalizedBase.length || normalizedBase[i2] !== items[i2]) {
                  breakPoint = i2 + 1;
                  break;
                }
              }
            }
            if (breakPoint === 1) {
              return path2;
            }
            for (i2 = 0, l2 = normalizedBase.length - (breakPoint - 1); i2 < l2; i2++) {
              out += "../";
            }
            for (i2 = breakPoint - 1, l2 = items.length; i2 < l2; i2++) {
              if (i2 !== breakPoint - 1) {
                out += "/" + items[i2];
              } else {
                out += items[i2];
              }
            }
            return out;
          }
          toAbsPath(base, path2) {
            let nb = 0;
            const tr = /\/$/.test(path2) ? "/" : "";
            const normalizedBase = base.split("/");
            const normalizedPath = path2.split("/");
            const baseParts = [];
            each$4(normalizedBase, (k2) => {
              if (k2) {
                baseParts.push(k2);
              }
            });
            const pathParts = [];
            for (let i3 = normalizedPath.length - 1; i3 >= 0; i3--) {
              if (normalizedPath[i3].length === 0 || normalizedPath[i3] === ".") {
                continue;
              }
              if (normalizedPath[i3] === "..") {
                nb++;
                continue;
              }
              if (nb > 0) {
                nb--;
                continue;
              }
              pathParts.push(normalizedPath[i3]);
            }
            const i2 = baseParts.length - nb;
            let outPath;
            if (i2 <= 0) {
              outPath = reverse(pathParts).join("/");
            } else {
              outPath = baseParts.slice(0, i2).join("/") + "/" + reverse(pathParts).join("/");
            }
            if (outPath.indexOf("/") !== 0) {
              outPath = "/" + outPath;
            }
            if (tr && outPath.lastIndexOf("/") !== outPath.length - 1) {
              outPath += tr;
            }
            return outPath;
          }
          getURI(noProtoHost = false) {
            let s2;
            if (!this.source || noProtoHost) {
              s2 = "";
              if (!noProtoHost) {
                if (this.protocol) {
                  s2 += this.protocol + "://";
                } else {
                  s2 += "//";
                }
                if (this.userInfo) {
                  s2 += this.userInfo + "@";
                }
                if (this.host) {
                  s2 += this.host;
                }
                if (this.port) {
                  s2 += ":" + this.port;
                }
              }
              if (this.path) {
                s2 += this.path;
              }
              if (this.query) {
                s2 += "?" + this.query;
              }
              if (this.anchor) {
                s2 += "#" + this.anchor;
              }
              this.source = s2;
            }
            return this.source;
          }
        }
        const filteredUrlAttrs = Tools.makeMap("src,href,data,background,action,formaction,poster,xlink:href");
        const internalElementAttr = "data-mce-type";
        let uid = 0;
        const processNode = (node, settings, schema, evt) => {
          var _a, _b, _c, _d;
          const validate2 = settings.validate;
          const specialElements = schema.getSpecialElements();
          if (node.nodeType === COMMENT && !settings.allow_conditional_comments && /^\[if/i.test((_a = node.nodeValue) !== null && _a !== void 0 ? _a : "")) {
            node.nodeValue = " " + node.nodeValue;
          }
          const lcTagName = (_b = evt === null || evt === void 0 ? void 0 : evt.tagName) !== null && _b !== void 0 ? _b : node.nodeName.toLowerCase();
          if (node.nodeType !== ELEMENT || lcTagName === "body") {
            return;
          }
          const element = SugarElement.fromDom(node);
          const isInternalElement = has$1(element, internalElementAttr);
          const bogus = get$9(element, "data-mce-bogus");
          if (!isInternalElement && isString(bogus)) {
            if (bogus === "all") {
              remove$5(element);
            } else {
              unwrap(element);
            }
            return;
          }
          const rule = schema.getElementRule(lcTagName);
          if (validate2 && !rule) {
            if (has$2(specialElements, lcTagName)) {
              remove$5(element);
            } else {
              unwrap(element);
            }
            return;
          } else {
            if (isNonNullable(evt)) {
              evt.allowedTags[lcTagName] = true;
            }
          }
          if (validate2 && rule && !isInternalElement) {
            each$e((_c = rule.attributesForced) !== null && _c !== void 0 ? _c : [], (attr) => {
              set$3(element, attr.name, attr.value === "{$uid}" ? `mce_${uid++}` : attr.value);
            });
            each$e((_d = rule.attributesDefault) !== null && _d !== void 0 ? _d : [], (attr) => {
              if (!has$1(element, attr.name)) {
                set$3(element, attr.name, attr.value === "{$uid}" ? `mce_${uid++}` : attr.value);
              }
            });
            if (rule.attributesRequired && !exists(rule.attributesRequired, (attr) => has$1(element, attr))) {
              unwrap(element);
              return;
            }
            if (rule.removeEmptyAttrs && hasNone(element)) {
              unwrap(element);
              return;
            }
            if (rule.outputName && rule.outputName !== lcTagName) {
              mutate(element, rule.outputName);
            }
          }
        };
        const shouldKeepAttribute = (settings, schema, tagName, attrName, attrValue) => !(attrName in filteredUrlAttrs && isInvalidUri(settings, attrValue, tagName)) && (!settings.validate || schema.isValid(tagName, attrName) || startsWith(attrName, "data-") || startsWith(attrName, "aria-"));
        const isRequiredAttributeOfInternalElement = (ele, attrName) => ele.hasAttribute(internalElementAttr) && (attrName === "id" || attrName === "class" || attrName === "style");
        const isBooleanAttribute = (attrName, schema) => attrName in schema.getBoolAttrs();
        const filterAttributes = (ele, settings, schema) => {
          const { attributes } = ele;
          for (let i2 = attributes.length - 1; i2 >= 0; i2--) {
            const attr = attributes[i2];
            const attrName = attr.name;
            const attrValue = attr.value;
            if (!shouldKeepAttribute(settings, schema, ele.tagName.toLowerCase(), attrName, attrValue) && !isRequiredAttributeOfInternalElement(ele, attrName)) {
              ele.removeAttribute(attrName);
            } else if (isBooleanAttribute(attrName, schema)) {
              ele.setAttribute(attrName, attrName);
            }
          }
        };
        const setupPurify = (settings, schema) => {
          const purify$1 = purify();
          purify$1.addHook("uponSanitizeElement", (ele, evt) => {
            processNode(ele, settings, schema, evt);
          });
          purify$1.addHook("uponSanitizeAttribute", (ele, evt) => {
            const tagName = ele.tagName.toLowerCase();
            const { attrName, attrValue } = evt;
            evt.keepAttr = shouldKeepAttribute(settings, schema, tagName, attrName, attrValue);
            if (evt.keepAttr) {
              evt.allowedAttributes[attrName] = true;
              if (isBooleanAttribute(attrName, schema)) {
                evt.attrValue = attrName;
              }
              if (settings.allow_svg_data_urls && startsWith(attrValue, "data:image/svg+xml")) {
                evt.forceKeepAttr = true;
              }
            } else if (isRequiredAttributeOfInternalElement(ele, attrName)) {
              evt.forceKeepAttr = true;
            }
          });
          return purify$1;
        };
        const getPurifyConfig = (settings, mimeType) => {
          const basePurifyConfig = {
            IN_PLACE: true,
            ALLOW_UNKNOWN_PROTOCOLS: true,
            ALLOWED_TAGS: [
              "#comment",
              "#cdata-section",
              "body"
            ],
            ALLOWED_ATTR: []
          };
          const config = { ...basePurifyConfig };
          config.PARSER_MEDIA_TYPE = mimeType;
          if (settings.allow_script_urls) {
            config.ALLOWED_URI_REGEXP = /.*/;
          } else if (settings.allow_html_data_urls) {
            config.ALLOWED_URI_REGEXP = /^(?!(\w+script|mhtml):)/i;
          }
          return config;
        };
        const getSanitizer = (settings, schema) => {
          if (settings.sanitize) {
            const purify2 = setupPurify(settings, schema);
            return (body, mimeType) => {
              purify2.sanitize(body, getPurifyConfig(settings, mimeType));
              purify2.removed = [];
            };
          } else {
            return (body, _2) => {
              const nodeIterator = document.createNodeIterator(body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);
              let node;
              while (node = nodeIterator.nextNode()) {
                processNode(node, settings, schema);
                if (isElement$6(node)) {
                  filterAttributes(node, settings, schema);
                }
              }
            };
          }
        };
        const makeMap = Tools.makeMap, extend$1 = Tools.extend;
        const transferChildren = (parent2, nativeParent, specialElements) => {
          const parentName = parent2.name;
          const isSpecial = parentName in specialElements && parentName !== "title" && parentName !== "textarea";
          const childNodes = nativeParent.childNodes;
          for (let ni = 0, nl = childNodes.length; ni < nl; ni++) {
            const nativeChild = childNodes[ni];
            const child2 = new AstNode(nativeChild.nodeName.toLowerCase(), nativeChild.nodeType);
            if (isElement$6(nativeChild)) {
              const attributes = nativeChild.attributes;
              for (let ai = 0, al = attributes.length; ai < al; ai++) {
                const attr = attributes[ai];
                child2.attr(attr.name, attr.value);
              }
            } else if (isText$a(nativeChild)) {
              child2.value = nativeChild.data;
              if (isSpecial) {
                child2.raw = true;
              }
            } else if (isComment(nativeChild) || isCData(nativeChild) || isPi(nativeChild)) {
              child2.value = nativeChild.data;
            }
            transferChildren(child2, nativeChild, specialElements);
            parent2.append(child2);
          }
        };
        const walkTree = (root, preprocessors, postprocessors) => {
          const traverseOrder = [];
          for (let node = root, lastNode = node; node; lastNode = node, node = node.walk()) {
            const tempNode = node;
            each$e(preprocessors, (preprocess2) => preprocess2(tempNode));
            if (isNullable(tempNode.parent) && tempNode !== root) {
              node = lastNode;
            } else {
              traverseOrder.push(tempNode);
            }
          }
          for (let i2 = traverseOrder.length - 1; i2 >= 0; i2--) {
            const node = traverseOrder[i2];
            each$e(postprocessors, (postprocess) => postprocess(node));
          }
        };
        const whitespaceCleaner = (root, schema, settings, args) => {
          const validate2 = settings.validate;
          const nonEmptyElements = schema.getNonEmptyElements();
          const whitespaceElements = schema.getWhitespaceElements();
          const blockElements = extend$1(makeMap("script,style,head,html,body,title,meta,param"), schema.getBlockElements());
          const textRootBlockElements = getTextRootBlockElements(schema);
          const allWhiteSpaceRegExp = /[ \t\r\n]+/g;
          const startWhiteSpaceRegExp = /^[ \t\r\n]+/;
          const endWhiteSpaceRegExp = /[ \t\r\n]+$/;
          const hasWhitespaceParent = (node) => {
            let tempNode = node.parent;
            while (isNonNullable(tempNode)) {
              if (tempNode.name in whitespaceElements) {
                return true;
              } else {
                tempNode = tempNode.parent;
              }
            }
            return false;
          };
          const isTextRootBlockEmpty = (node) => {
            let tempNode = node;
            while (isNonNullable(tempNode)) {
              if (tempNode.name in textRootBlockElements) {
                return isEmpty(schema, nonEmptyElements, whitespaceElements, tempNode);
              } else {
                tempNode = tempNode.parent;
              }
            }
            return false;
          };
          const isBlock2 = (node) => node.name in blockElements || isTransparentAstBlock(schema, node);
          const isAtEdgeOfBlock = (node, start4) => {
            const neighbour = start4 ? node.prev : node.next;
            if (isNonNullable(neighbour) || isNullable(node.parent)) {
              return false;
            }
            return isBlock2(node.parent) && (node.parent !== root || args.isRootContent === true);
          };
          const preprocess2 = (node) => {
            var _a;
            if (node.type === 3) {
              if (!hasWhitespaceParent(node)) {
                let text2 = (_a = node.value) !== null && _a !== void 0 ? _a : "";
                text2 = text2.replace(allWhiteSpaceRegExp, " ");
                if (isLineBreakNode(node.prev, isBlock2) || isAtEdgeOfBlock(node, true)) {
                  text2 = text2.replace(startWhiteSpaceRegExp, "");
                }
                if (text2.length === 0) {
                  node.remove();
                } else {
                  node.value = text2;
                }
              }
            }
          };
          const postprocess = (node) => {
            var _a;
            if (node.type === 1) {
              const elementRule = schema.getElementRule(node.name);
              if (validate2 && elementRule) {
                const isNodeEmpty = isEmpty(schema, nonEmptyElements, whitespaceElements, node);
                if (elementRule.paddInEmptyBlock && isNodeEmpty && isTextRootBlockEmpty(node)) {
                  paddEmptyNode(args, isBlock2, node);
                } else if (elementRule.removeEmpty && isNodeEmpty) {
                  if (isBlock2(node)) {
                    node.remove();
                  } else {
                    node.unwrap();
                  }
                } else if (elementRule.paddEmpty && (isNodeEmpty || isPaddedWithNbsp(node))) {
                  paddEmptyNode(args, isBlock2, node);
                }
              }
            } else if (node.type === 3) {
              if (!hasWhitespaceParent(node)) {
                let text2 = (_a = node.value) !== null && _a !== void 0 ? _a : "";
                if (node.next && isBlock2(node.next) || isAtEdgeOfBlock(node, false)) {
                  text2 = text2.replace(endWhiteSpaceRegExp, "");
                }
                if (text2.length === 0) {
                  node.remove();
                } else {
                  node.value = text2;
                }
              }
            }
          };
          return [
            preprocess2,
            postprocess
          ];
        };
        const getRootBlockName = (settings, args) => {
          var _a;
          const name2 = (_a = args.forced_root_block) !== null && _a !== void 0 ? _a : settings.forced_root_block;
          if (name2 === false) {
            return "";
          } else if (name2 === true) {
            return "p";
          } else {
            return name2;
          }
        };
        const DomParser = (settings = {}, schema = Schema()) => {
          const nodeFilterRegistry = create$8();
          const attributeFilterRegistry = create$8();
          const defaultedSettings = {
            validate: true,
            root_name: "body",
            sanitize: true,
            ...settings
          };
          const parser = new DOMParser();
          const sanitize = getSanitizer(defaultedSettings, schema);
          const parseAndSanitizeWithContext = (html2, rootName, format = "html") => {
            const mimeType = format === "xhtml" ? "application/xhtml+xml" : "text/html";
            const isSpecialRoot = has$2(schema.getSpecialElements(), rootName.toLowerCase());
            const content = isSpecialRoot ? `<${rootName}>${html2}</${rootName}>` : html2;
            const wrappedHtml = format === "xhtml" ? `<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>${content}</body></html>` : `<body>${content}</body>`;
            const body = parser.parseFromString(wrappedHtml, mimeType).body;
            sanitize(body, mimeType);
            return isSpecialRoot ? body.firstChild : body;
          };
          const addNodeFilter2 = nodeFilterRegistry.addFilter;
          const getNodeFilters = nodeFilterRegistry.getFilters;
          const removeNodeFilter = nodeFilterRegistry.removeFilter;
          const addAttributeFilter = attributeFilterRegistry.addFilter;
          const getAttributeFilters = attributeFilterRegistry.getFilters;
          const removeAttributeFilter = attributeFilterRegistry.removeFilter;
          const findInvalidChildren = (node, invalidChildren) => {
            if (isInvalid(schema, node)) {
              invalidChildren.push(node);
            }
          };
          const isWrappableNode = (blockElements, node) => {
            const isInternalElement = isString(node.attr(internalElementAttr));
            const isInlineElement2 = node.type === 1 && (!has$2(blockElements, node.name) && !isTransparentAstBlock(schema, node));
            return node.type === 3 || isInlineElement2 && !isInternalElement;
          };
          const addRootBlocks2 = (rootNode, rootBlockName) => {
            const blockElements = extend$1(makeMap("script,style,head,html,body,title,meta,param"), schema.getBlockElements());
            const startWhiteSpaceRegExp = /^[ \t\r\n]+/;
            const endWhiteSpaceRegExp = /[ \t\r\n]+$/;
            let node = rootNode.firstChild, rootBlockNode = null;
            const trim2 = (rootBlock) => {
              var _a, _b;
              if (rootBlock) {
                node = rootBlock.firstChild;
                if (node && node.type === 3) {
                  node.value = (_a = node.value) === null || _a === void 0 ? void 0 : _a.replace(startWhiteSpaceRegExp, "");
                }
                node = rootBlock.lastChild;
                if (node && node.type === 3) {
                  node.value = (_b = node.value) === null || _b === void 0 ? void 0 : _b.replace(endWhiteSpaceRegExp, "");
                }
              }
            };
            if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {
              return;
            }
            while (node) {
              const next2 = node.next;
              if (isWrappableNode(blockElements, node)) {
                if (!rootBlockNode) {
                  rootBlockNode = new AstNode(rootBlockName, 1);
                  rootBlockNode.attr(defaultedSettings.forced_root_block_attrs);
                  rootNode.insert(rootBlockNode, node);
                  rootBlockNode.append(node);
                } else {
                  rootBlockNode.append(node);
                }
              } else {
                trim2(rootBlockNode);
                rootBlockNode = null;
              }
              node = next2;
            }
            trim2(rootBlockNode);
          };
          const parse = (html2, args = {}) => {
            var _a;
            const validate2 = defaultedSettings.validate;
            const rootName = (_a = args.context) !== null && _a !== void 0 ? _a : defaultedSettings.root_name;
            const element = parseAndSanitizeWithContext(html2, rootName, args.format);
            updateChildren(schema, element);
            const rootNode = new AstNode(rootName, 11);
            transferChildren(rootNode, element, schema.getSpecialElements());
            element.innerHTML = "";
            const [whitespacePre, whitespacePost] = whitespaceCleaner(rootNode, schema, defaultedSettings, args);
            const invalidChildren = [];
            const invalidFinder = validate2 ? (node) => findInvalidChildren(node, invalidChildren) : noop2;
            const matches = {
              nodes: {},
              attributes: {}
            };
            const matchFinder = (node) => matchNode$1(getNodeFilters(), getAttributeFilters(), node, matches);
            walkTree(rootNode, [
              whitespacePre,
              matchFinder
            ], [
              whitespacePost,
              invalidFinder
            ]);
            invalidChildren.reverse();
            if (validate2 && invalidChildren.length > 0) {
              if (args.context) {
                const {
                  pass: topLevelChildren,
                  fail: otherChildren
                } = partition$2(invalidChildren, (child2) => child2.parent === rootNode);
                cleanInvalidNodes(otherChildren, schema, rootNode, matchFinder);
                args.invalid = topLevelChildren.length > 0;
              } else {
                cleanInvalidNodes(invalidChildren, schema, rootNode, matchFinder);
              }
            }
            const rootBlockName = getRootBlockName(defaultedSettings, args);
            if (rootBlockName && (rootNode.name === "body" || args.isRootContent)) {
              addRootBlocks2(rootNode, rootBlockName);
            }
            if (!args.invalid) {
              runFilters(matches, args);
            }
            return rootNode;
          };
          const exports2 = {
            schema,
            addAttributeFilter,
            getAttributeFilters,
            removeAttributeFilter,
            addNodeFilter: addNodeFilter2,
            getNodeFilters,
            removeNodeFilter,
            parse
          };
          register$4(exports2, defaultedSettings);
          register$5(exports2, defaultedSettings, schema);
          return exports2;
        };
        const serializeContent = (content) => isTreeNode(content) ? HtmlSerializer({ validate: false }).serialize(content) : content;
        const withSerializedContent = (content, fireEvent2, sanitize) => {
          const serializedContent = serializeContent(content);
          const eventArgs = fireEvent2(serializedContent);
          if (eventArgs.isDefaultPrevented()) {
            return eventArgs;
          } else if (isTreeNode(content)) {
            if (eventArgs.content !== serializedContent) {
              const rootNode = DomParser({
                validate: false,
                forced_root_block: false,
                sanitize
              }).parse(eventArgs.content, { context: content.name });
              return {
                ...eventArgs,
                content: rootNode
              };
            } else {
              return {
                ...eventArgs,
                content
              };
            }
          } else {
            return eventArgs;
          }
        };
        const preProcessGetContent = (editor, args) => {
          if (args.no_events) {
            return Result.value(args);
          } else {
            const eventArgs = fireBeforeGetContent(editor, args);
            if (eventArgs.isDefaultPrevented()) {
              return Result.error(fireGetContent(editor, {
                content: "",
                ...eventArgs
              }).content);
            } else {
              return Result.value(eventArgs);
            }
          }
        };
        const postProcessGetContent = (editor, content, args) => {
          if (args.no_events) {
            return content;
          } else {
            const processedEventArgs = withSerializedContent(content, (content2) => fireGetContent(editor, {
              ...args,
              content: content2
            }), shouldSanitizeXss(editor));
            return processedEventArgs.content;
          }
        };
        const preProcessSetContent = (editor, args) => {
          if (args.no_events) {
            return Result.value(args);
          } else {
            const processedEventArgs = withSerializedContent(args.content, (content) => fireBeforeSetContent(editor, {
              ...args,
              content
            }), shouldSanitizeXss(editor));
            if (processedEventArgs.isDefaultPrevented()) {
              fireSetContent(editor, processedEventArgs);
              return Result.error(void 0);
            } else {
              return Result.value(processedEventArgs);
            }
          }
        };
        const postProcessSetContent = (editor, content, args) => {
          if (!args.no_events) {
            fireSetContent(editor, {
              ...args,
              content
            });
          }
        };
        const tableModel = (element, width, rows) => ({
          element,
          width,
          rows
        });
        const tableRow = (element, cells2) => ({
          element,
          cells: cells2
        });
        const cellPosition = (x2, y2) => ({
          x: x2,
          y: y2
        });
        const getSpan = (td, key) => {
          return getOpt(td, key).bind(toInt).getOr(1);
        };
        const fillout = (table2, x2, y2, tr, td) => {
          const rowspan = getSpan(td, "rowspan");
          const colspan = getSpan(td, "colspan");
          const rows = table2.rows;
          for (let y22 = y2; y22 < y2 + rowspan; y22++) {
            if (!rows[y22]) {
              rows[y22] = tableRow(deep$1(tr), []);
            }
            for (let x22 = x2; x22 < x2 + colspan; x22++) {
              const cells2 = rows[y22].cells;
              cells2[x22] = y22 === y2 && x22 === x2 ? td : shallow$1(td);
            }
          }
        };
        const cellExists = (table2, x2, y2) => {
          const rows = table2.rows;
          const cells2 = rows[y2] ? rows[y2].cells : [];
          return !!cells2[x2];
        };
        const skipCellsX = (table2, x2, y2) => {
          while (cellExists(table2, x2, y2)) {
            x2++;
          }
          return x2;
        };
        const getWidth = (rows) => {
          return foldl(rows, (acc, row) => {
            return row.cells.length > acc ? row.cells.length : acc;
          }, 0);
        };
        const findElementPos = (table2, element) => {
          const rows = table2.rows;
          for (let y2 = 0; y2 < rows.length; y2++) {
            const cells2 = rows[y2].cells;
            for (let x2 = 0; x2 < cells2.length; x2++) {
              if (eq(cells2[x2], element)) {
                return Optional.some(cellPosition(x2, y2));
              }
            }
          }
          return Optional.none();
        };
        const extractRows = (table2, sx, sy, ex, ey) => {
          const newRows = [];
          const rows = table2.rows;
          for (let y2 = sy; y2 <= ey; y2++) {
            const cells2 = rows[y2].cells;
            const slice = sx < ex ? cells2.slice(sx, ex + 1) : cells2.slice(ex, sx + 1);
            newRows.push(tableRow(rows[y2].element, slice));
          }
          return newRows;
        };
        const subTable = (table2, startPos, endPos) => {
          const sx = startPos.x, sy = startPos.y;
          const ex = endPos.x, ey = endPos.y;
          const newRows = sy < ey ? extractRows(table2, sx, sy, ex, ey) : extractRows(table2, sx, ey, ex, sy);
          return tableModel(table2.element, getWidth(newRows), newRows);
        };
        const createDomTable = (table2, rows) => {
          const tableElement = shallow$1(table2.element);
          const tableBody = SugarElement.fromTag("tbody");
          append(tableBody, rows);
          append$1(tableElement, tableBody);
          return tableElement;
        };
        const modelRowsToDomRows = (table2) => {
          return map$3(table2.rows, (row) => {
            const cells2 = map$3(row.cells, (cell2) => {
              const td = deep$1(cell2);
              remove$a(td, "colspan");
              remove$a(td, "rowspan");
              return td;
            });
            const tr = shallow$1(row.element);
            append(tr, cells2);
            return tr;
          });
        };
        const fromDom = (tableElm) => {
          const table2 = tableModel(shallow$1(tableElm), 0, []);
          each$e(descendants(tableElm, "tr"), (tr, y2) => {
            each$e(descendants(tr, "td,th"), (td, x2) => {
              fillout(table2, skipCellsX(table2, x2, y2), y2, tr, td);
            });
          });
          return tableModel(table2.element, getWidth(table2.rows), table2.rows);
        };
        const toDom = (table2) => {
          return createDomTable(table2, modelRowsToDomRows(table2));
        };
        const subsection = (table2, startElement, endElement) => {
          return findElementPos(table2, startElement).bind((startPos) => {
            return findElementPos(table2, endElement).map((endPos) => {
              return subTable(table2, startPos, endPos);
            });
          });
        };
        const findParentListContainer = (parents2) => find$2(parents2, (elm) => name(elm) === "ul" || name(elm) === "ol");
        const getFullySelectedListWrappers = (parents2, rng) => find$2(parents2, (elm) => name(elm) === "li" && hasAllContentsSelected(elm, rng)).fold(constant([]), (_li) => findParentListContainer(parents2).map((listCont) => {
          const listElm = SugarElement.fromTag(name(listCont));
          const listStyles = filter$4(getAllRaw(listCont), (_style, name2) => startsWith(name2, "list-style"));
          setAll(listElm, listStyles);
          return [
            SugarElement.fromTag("li"),
            listElm
          ];
        }).getOr([]));
        const wrap = (innerElm, elms) => {
          const wrapped = foldl(elms, (acc, elm) => {
            append$1(elm, acc);
            return elm;
          }, innerElm);
          return elms.length > 0 ? fromElements([wrapped]) : wrapped;
        };
        const directListWrappers = (commonAnchorContainer) => {
          if (isListItem$1(commonAnchorContainer)) {
            return parent(commonAnchorContainer).filter(isList).fold(constant([]), (listElm) => [
              commonAnchorContainer,
              listElm
            ]);
          } else {
            return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];
          }
        };
        const getWrapElements = (rootNode, rng) => {
          const commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);
          const parents2 = parentsAndSelf(commonAnchorContainer, rootNode);
          const wrapElements = filter$5(parents2, isWrapElement);
          const listWrappers = getFullySelectedListWrappers(parents2, rng);
          const allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));
          return map$3(allWrappers, shallow$1);
        };
        const emptyFragment = () => fromElements([]);
        const getFragmentFromRange = (rootNode, rng) => wrap(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng));
        const getParentTable = (rootElm, cell2) => ancestor$3(cell2, "table", curry(eq, rootElm));
        const getTableFragment = (rootNode, selectedTableCells) => getParentTable(rootNode, selectedTableCells[0]).bind((tableElm) => {
          const firstCell = selectedTableCells[0];
          const lastCell = selectedTableCells[selectedTableCells.length - 1];
          const fullTableModel = fromDom(tableElm);
          return subsection(fullTableModel, firstCell, lastCell).map((sectionedTableModel) => fromElements([toDom(sectionedTableModel)]));
        }).getOrThunk(emptyFragment);
        const getSelectionFragment = (rootNode, ranges) => ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0]);
        const read$3 = (rootNode, ranges) => {
          const selectedCells = getCellsFromElementOrRanges(ranges, rootNode);
          return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges);
        };
        const isCollapsibleWhitespace = (text2, index) => index >= 0 && index < text2.length && isWhiteSpace(text2.charAt(index));
        const getInnerText = (bin) => {
          return trim$1(bin.innerText);
        };
        const getContextNodeName = (parentBlockOpt) => parentBlockOpt.map((block) => block.nodeName).getOr("div").toLowerCase();
        const getTextContent = (editor) => Optional.from(editor.selection.getRng()).map((rng) => {
          var _a;
          const parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));
          const body = editor.getBody();
          const contextNodeName = getContextNodeName(parentBlockOpt);
          const rangeContentClone = SugarElement.fromDom(rng.cloneContents());
          cleanupBogusElements(rangeContentClone);
          cleanupInputNames(rangeContentClone);
          const bin = editor.dom.add(body, contextNodeName, {
            "data-mce-bogus": "all",
            "style": "overflow: hidden; opacity: 0;"
          }, rangeContentClone.dom);
          const text2 = getInnerText(bin);
          const nonRenderedText = trim$1((_a = bin.textContent) !== null && _a !== void 0 ? _a : "");
          editor.dom.remove(bin);
          if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {
            const parentBlock = parentBlockOpt.getOr(body);
            const parentBlockText = getInnerText(parentBlock);
            const textIndex = parentBlockText.indexOf(text2);
            if (textIndex === -1) {
              return text2;
            } else {
              const hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);
              const hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text2.length);
              return (hasProceedingSpace ? " " : "") + text2 + (hasTrailingSpace ? " " : "");
            }
          } else {
            return text2;
          }
        }).getOr("");
        const getSerializedContent = (editor, args) => {
          const rng = editor.selection.getRng(), tmpElm = editor.dom.create("body");
          const sel = editor.selection.getSel();
          const ranges = processRanges(editor, getRanges$1(sel));
          const fragment = args.contextual ? read$3(SugarElement.fromDom(editor.getBody()), ranges).dom : rng.cloneContents();
          if (fragment) {
            tmpElm.appendChild(fragment);
          }
          return editor.selection.serializer.serialize(tmpElm, args);
        };
        const extractSelectedContent = (editor, args) => {
          if (args.format === "text") {
            return getTextContent(editor);
          } else {
            const content = getSerializedContent(editor, args);
            if (args.format === "tree") {
              return content;
            } else {
              return editor.selection.isCollapsed() ? "" : content;
            }
          }
        };
        const setupArgs$3 = (args, format) => ({
          ...args,
          format,
          get: true,
          selection: true,
          getInner: true
        });
        const getSelectedContentInternal = (editor, format, args = {}) => {
          const defaultedArgs = setupArgs$3(args, format);
          return preProcessGetContent(editor, defaultedArgs).fold(identity, (updatedArgs) => {
            const content = extractSelectedContent(editor, updatedArgs);
            return postProcessGetContent(editor, content, updatedArgs);
          });
        };
        const KEEP = 0, INSERT = 1, DELETE = 2;
        const diff = (left2, right2) => {
          const size = left2.length + right2.length + 2;
          const vDown = new Array(size);
          const vUp = new Array(size);
          const snake = (start4, end3, diag) => {
            return {
              start: start4,
              end: end3,
              diag
            };
          };
          const buildScript = (start1, end1, start22, end22, script2) => {
            const middle = getMiddleSnake(start1, end1, start22, end22);
            if (middle === null || middle.start === end1 && middle.diag === end1 - end22 || middle.end === start1 && middle.diag === start1 - start22) {
              let i2 = start1;
              let j2 = start22;
              while (i2 < end1 || j2 < end22) {
                if (i2 < end1 && j2 < end22 && left2[i2] === right2[j2]) {
                  script2.push([
                    KEEP,
                    left2[i2]
                  ]);
                  ++i2;
                  ++j2;
                } else {
                  if (end1 - start1 > end22 - start22) {
                    script2.push([
                      DELETE,
                      left2[i2]
                    ]);
                    ++i2;
                  } else {
                    script2.push([
                      INSERT,
                      right2[j2]
                    ]);
                    ++j2;
                  }
                }
              }
            } else {
              buildScript(start1, middle.start, start22, middle.start - middle.diag, script2);
              for (let i2 = middle.start; i2 < middle.end; ++i2) {
                script2.push([
                  KEEP,
                  left2[i2]
                ]);
              }
              buildScript(middle.end, end1, middle.end - middle.diag, end22, script2);
            }
          };
          const buildSnake = (start4, diag, end1, end22) => {
            let end3 = start4;
            while (end3 - diag < end22 && end3 < end1 && left2[end3] === right2[end3 - diag]) {
              ++end3;
            }
            return snake(start4, end3, diag);
          };
          const getMiddleSnake = (start1, end1, start22, end22) => {
            const m2 = end1 - start1;
            const n2 = end22 - start22;
            if (m2 === 0 || n2 === 0) {
              return null;
            }
            const delta = m2 - n2;
            const sum = n2 + m2;
            const offset2 = (sum % 2 === 0 ? sum : sum + 1) / 2;
            vDown[1 + offset2] = start1;
            vUp[1 + offset2] = end1 + 1;
            let d2, k2, i2, x2, y2;
            for (d2 = 0; d2 <= offset2; ++d2) {
              for (k2 = -d2; k2 <= d2; k2 += 2) {
                i2 = k2 + offset2;
                if (k2 === -d2 || k2 !== d2 && vDown[i2 - 1] < vDown[i2 + 1]) {
                  vDown[i2] = vDown[i2 + 1];
                } else {
                  vDown[i2] = vDown[i2 - 1] + 1;
                }
                x2 = vDown[i2];
                y2 = x2 - start1 + start22 - k2;
                while (x2 < end1 && y2 < end22 && left2[x2] === right2[y2]) {
                  vDown[i2] = ++x2;
                  ++y2;
                }
                if (delta % 2 !== 0 && delta - d2 <= k2 && k2 <= delta + d2) {
                  if (vUp[i2 - delta] <= vDown[i2]) {
                    return buildSnake(vUp[i2 - delta], k2 + start1 - start22, end1, end22);
                  }
                }
              }
              for (k2 = delta - d2; k2 <= delta + d2; k2 += 2) {
                i2 = k2 + offset2 - delta;
                if (k2 === delta - d2 || k2 !== delta + d2 && vUp[i2 + 1] <= vUp[i2 - 1]) {
                  vUp[i2] = vUp[i2 + 1] - 1;
                } else {
                  vUp[i2] = vUp[i2 - 1];
                }
                x2 = vUp[i2] - 1;
                y2 = x2 - start1 + start22 - k2;
                while (x2 >= start1 && y2 >= start22 && left2[x2] === right2[y2]) {
                  vUp[i2] = x2--;
                  y2--;
                }
                if (delta % 2 === 0 && -d2 <= k2 && k2 <= d2) {
                  if (vUp[i2] <= vDown[i2 + delta]) {
                    return buildSnake(vUp[i2], k2 + start1 - start22, end1, end22);
                  }
                }
              }
            }
            return null;
          };
          const script = [];
          buildScript(0, left2.length, 0, right2.length, script);
          return script;
        };
        const getOuterHtml = (elm) => {
          if (isElement$6(elm)) {
            return elm.outerHTML;
          } else if (isText$a(elm)) {
            return Entities.encodeRaw(elm.data, false);
          } else if (isComment(elm)) {
            return "<!--" + elm.data + "-->";
          }
          return "";
        };
        const createFragment = (html2) => {
          let node;
          const container = document.createElement("div");
          const frag = document.createDocumentFragment();
          if (html2) {
            container.innerHTML = html2;
          }
          while (node = container.firstChild) {
            frag.appendChild(node);
          }
          return frag;
        };
        const insertAt = (elm, html2, index) => {
          const fragment = createFragment(html2);
          if (elm.hasChildNodes() && index < elm.childNodes.length) {
            const target = elm.childNodes[index];
            elm.insertBefore(fragment, target);
          } else {
            elm.appendChild(fragment);
          }
        };
        const removeAt = (elm, index) => {
          if (elm.hasChildNodes() && index < elm.childNodes.length) {
            const target = elm.childNodes[index];
            elm.removeChild(target);
          }
        };
        const applyDiff = (diff2, elm) => {
          let index = 0;
          each$e(diff2, (action2) => {
            if (action2[0] === KEEP) {
              index++;
            } else if (action2[0] === INSERT) {
              insertAt(elm, action2[1], index);
              index++;
            } else if (action2[0] === DELETE) {
              removeAt(elm, index);
            }
          });
        };
        const read$2 = (elm) => {
          return filter$5(map$3(from(elm.childNodes), getOuterHtml), (item) => {
            return item.length > 0;
          });
        };
        const write2 = (fragments, elm) => {
          const currentFragments = map$3(from(elm.childNodes), getOuterHtml);
          applyDiff(diff(currentFragments, fragments), elm);
          return elm;
        };
        const lazyTempDocument = cached(() => document.implementation.createHTMLDocument("undo"));
        const hasIframes = (html2) => {
          return html2.indexOf("</iframe>") !== -1;
        };
        const createFragmentedLevel = (fragments) => {
          return {
            type: "fragmented",
            fragments,
            content: "",
            bookmark: null,
            beforeBookmark: null
          };
        };
        const createCompleteLevel = (content) => {
          return {
            type: "complete",
            fragments: null,
            content,
            bookmark: null,
            beforeBookmark: null
          };
        };
        const createFromEditor = (editor) => {
          const fragments = read$2(editor.getBody());
          const trimmedFragments = bind$3(fragments, (html2) => {
            const trimmed = trimInternal(editor.serializer, html2);
            return trimmed.length > 0 ? [trimmed] : [];
          });
          const content = trimmedFragments.join("");
          return hasIframes(content) ? createFragmentedLevel(trimmedFragments) : createCompleteLevel(content);
        };
        const applyToEditor = (editor, level, before2) => {
          const bookmark = before2 ? level.beforeBookmark : level.bookmark;
          if (level.type === "fragmented") {
            write2(level.fragments, editor.getBody());
          } else {
            editor.setContent(level.content, {
              format: "raw",
              no_selection: isNonNullable(bookmark) && isPathBookmark(bookmark) ? !bookmark.isFakeCaret : true
            });
          }
          if (bookmark) {
            editor.selection.moveToBookmark(bookmark);
            editor.selection.scrollIntoView();
          }
        };
        const getLevelContent = (level) => {
          return level.type === "fragmented" ? level.fragments.join("") : level.content;
        };
        const getCleanLevelContent = (level) => {
          const elm = SugarElement.fromTag("body", lazyTempDocument());
          set$1(elm, getLevelContent(level));
          each$e(descendants(elm, "*[data-mce-bogus]"), unwrap);
          return get$6(elm);
        };
        const hasEqualContent = (level1, level2) => getLevelContent(level1) === getLevelContent(level2);
        const hasEqualCleanedContent = (level1, level2) => getCleanLevelContent(level1) === getCleanLevelContent(level2);
        const isEq$1 = (level1, level2) => {
          if (!level1 || !level2) {
            return false;
          } else if (hasEqualContent(level1, level2)) {
            return true;
          } else {
            return hasEqualCleanedContent(level1, level2);
          }
        };
        const isUnlocked = (locks) => locks.get() === 0;
        const setTyping = (undoManager, typing, locks) => {
          if (isUnlocked(locks)) {
            undoManager.typing = typing;
          }
        };
        const endTyping = (undoManager, locks) => {
          if (undoManager.typing) {
            setTyping(undoManager, false, locks);
            undoManager.add();
          }
        };
        const endTypingLevelIgnoreLocks = (undoManager) => {
          if (undoManager.typing) {
            undoManager.typing = false;
            undoManager.add();
          }
        };
        const beforeChange$1 = (editor, locks, beforeBookmark) => {
          if (isUnlocked(locks)) {
            beforeBookmark.set(getUndoBookmark(editor.selection));
          }
        };
        const addUndoLevel$1 = (editor, undoManager, index, locks, beforeBookmark, level, event) => {
          const currentLevel = createFromEditor(editor);
          const newLevel = Tools.extend(level || {}, currentLevel);
          if (!isUnlocked(locks) || editor.removed) {
            return null;
          }
          const lastLevel = undoManager.data[index.get()];
          if (editor.dispatch("BeforeAddUndo", {
            level: newLevel,
            lastLevel,
            originalEvent: event
          }).isDefaultPrevented()) {
            return null;
          }
          if (lastLevel && isEq$1(lastLevel, newLevel)) {
            return null;
          }
          if (undoManager.data[index.get()]) {
            beforeBookmark.get().each((bm) => {
              undoManager.data[index.get()].beforeBookmark = bm;
            });
          }
          const customUndoRedoLevels = getCustomUndoRedoLevels(editor);
          if (customUndoRedoLevels) {
            if (undoManager.data.length > customUndoRedoLevels) {
              for (let i2 = 0; i2 < undoManager.data.length - 1; i2++) {
                undoManager.data[i2] = undoManager.data[i2 + 1];
              }
              undoManager.data.length--;
              index.set(undoManager.data.length);
            }
          }
          newLevel.bookmark = getUndoBookmark(editor.selection);
          if (index.get() < undoManager.data.length - 1) {
            undoManager.data.length = index.get() + 1;
          }
          undoManager.data.push(newLevel);
          index.set(undoManager.data.length - 1);
          const args = {
            level: newLevel,
            lastLevel,
            originalEvent: event
          };
          if (index.get() > 0) {
            editor.setDirty(true);
            editor.dispatch("AddUndo", args);
            editor.dispatch("change", args);
          } else {
            editor.dispatch("AddUndo", args);
          }
          return newLevel;
        };
        const clear$1 = (editor, undoManager, index) => {
          undoManager.data = [];
          index.set(0);
          undoManager.typing = false;
          editor.dispatch("ClearUndos");
        };
        const extra$1 = (editor, undoManager, index, callback1, callback2) => {
          if (undoManager.transact(callback1)) {
            const bookmark = undoManager.data[index.get()].bookmark;
            const lastLevel = undoManager.data[index.get() - 1];
            applyToEditor(editor, lastLevel, true);
            if (undoManager.transact(callback2)) {
              undoManager.data[index.get() - 1].beforeBookmark = bookmark;
            }
          }
        };
        const redo$1 = (editor, index, data2) => {
          let level;
          if (index.get() < data2.length - 1) {
            index.set(index.get() + 1);
            level = data2[index.get()];
            applyToEditor(editor, level, false);
            editor.setDirty(true);
            editor.dispatch("Redo", { level });
          }
          return level;
        };
        const undo$1 = (editor, undoManager, locks, index) => {
          let level;
          if (undoManager.typing) {
            undoManager.add();
            undoManager.typing = false;
            setTyping(undoManager, false, locks);
          }
          if (index.get() > 0) {
            index.set(index.get() - 1);
            level = undoManager.data[index.get()];
            applyToEditor(editor, level, true);
            editor.setDirty(true);
            editor.dispatch("Undo", { level });
          }
          return level;
        };
        const reset$1 = (undoManager) => {
          undoManager.clear();
          undoManager.add();
        };
        const hasUndo$1 = (editor, undoManager, index) => index.get() > 0 || undoManager.typing && undoManager.data[0] && !isEq$1(createFromEditor(editor), undoManager.data[0]);
        const hasRedo$1 = (undoManager, index) => index.get() < undoManager.data.length - 1 && !undoManager.typing;
        const transact$1 = (undoManager, locks, callback) => {
          endTyping(undoManager, locks);
          undoManager.beforeChange();
          undoManager.ignore(callback);
          return undoManager.add();
        };
        const ignore$1 = (locks, callback) => {
          try {
            locks.set(locks.get() + 1);
            callback();
          } finally {
            locks.set(locks.get() - 1);
          }
        };
        const addVisualInternal = (editor, elm) => {
          const dom2 = editor.dom;
          const scope = isNonNullable(elm) ? elm : editor.getBody();
          each$e(dom2.select("table,a", scope), (matchedElm) => {
            switch (matchedElm.nodeName) {
              case "TABLE":
                const cls = getVisualAidsTableClass(editor);
                const value2 = dom2.getAttrib(matchedElm, "border");
                if ((!value2 || value2 === "0") && editor.hasVisual) {
                  dom2.addClass(matchedElm, cls);
                } else {
                  dom2.removeClass(matchedElm, cls);
                }
                break;
              case "A":
                if (!dom2.getAttrib(matchedElm, "href")) {
                  const value3 = dom2.getAttrib(matchedElm, "name") || matchedElm.id;
                  const cls2 = getVisualAidsAnchorClass(editor);
                  if (value3 && editor.hasVisual) {
                    dom2.addClass(matchedElm, cls2);
                  } else {
                    dom2.removeClass(matchedElm, cls2);
                  }
                }
                break;
            }
          });
          editor.dispatch("VisualAid", {
            element: elm,
            hasVisual: editor.hasVisual
          });
        };
        const makePlainAdaptor = (editor) => ({
          init: { bindEvents: noop2 },
          undoManager: {
            beforeChange: (locks, beforeBookmark) => beforeChange$1(editor, locks, beforeBookmark),
            add: (undoManager, index, locks, beforeBookmark, level, event) => addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event),
            undo: (undoManager, locks, index) => undo$1(editor, undoManager, locks, index),
            redo: (index, data2) => redo$1(editor, index, data2),
            clear: (undoManager, index) => clear$1(editor, undoManager, index),
            reset: (undoManager) => reset$1(undoManager),
            hasUndo: (undoManager, index) => hasUndo$1(editor, undoManager, index),
            hasRedo: (undoManager, index) => hasRedo$1(undoManager, index),
            transact: (undoManager, locks, callback) => transact$1(undoManager, locks, callback),
            ignore: (locks, callback) => ignore$1(locks, callback),
            extra: (undoManager, index, callback1, callback2) => extra$1(editor, undoManager, index, callback1, callback2)
          },
          formatter: {
            match: (name2, vars, node, similar) => match$2(editor, name2, vars, node, similar),
            matchAll: (names, vars) => matchAll(editor, names, vars),
            matchNode: (node, name2, vars, similar) => matchNode(editor, node, name2, vars, similar),
            canApply: (name2) => canApply(editor, name2),
            closest: (names) => closest(editor, names),
            apply: (name2, vars, node) => applyFormat$1(editor, name2, vars, node),
            remove: (name2, vars, node, similar) => removeFormat$1(editor, name2, vars, node, similar),
            toggle: (name2, vars, node) => toggle(editor, name2, vars, node),
            formatChanged: (registeredFormatListeners, formats, callback, similar, vars) => formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar, vars)
          },
          editor: {
            getContent: (args) => getContentInternal(editor, args),
            setContent: (content, args) => setContentInternal(editor, content, args),
            insertContent: (value2, details) => insertHtmlAtCaret(editor, value2, details),
            addVisual: (elm) => addVisualInternal(editor, elm)
          },
          selection: { getContent: (format, args) => getSelectedContentInternal(editor, format, args) },
          autocompleter: {
            addDecoration: (range2) => create$9(editor, range2),
            removeDecoration: () => remove$2(editor, SugarElement.fromDom(editor.getBody()))
          },
          raw: { getModel: () => Optional.none() }
        });
        const makeRtcAdaptor = (rtcEditor) => {
          const defaultVars = (vars) => isObject(vars) ? vars : {};
          const { init: init2, undoManager, formatter, editor, selection, autocompleter, raw } = rtcEditor;
          return {
            init: { bindEvents: init2.bindEvents },
            undoManager: {
              beforeChange: undoManager.beforeChange,
              add: undoManager.add,
              undo: undoManager.undo,
              redo: undoManager.redo,
              clear: undoManager.clear,
              reset: undoManager.reset,
              hasUndo: undoManager.hasUndo,
              hasRedo: undoManager.hasRedo,
              transact: (_undoManager, _locks, fn2) => undoManager.transact(fn2),
              ignore: (_locks, callback) => undoManager.ignore(callback),
              extra: (_undoManager, _index, callback1, callback2) => undoManager.extra(callback1, callback2)
            },
            formatter: {
              match: (name2, vars, _node, similar) => formatter.match(name2, defaultVars(vars), similar),
              matchAll: formatter.matchAll,
              matchNode: formatter.matchNode,
              canApply: (name2) => formatter.canApply(name2),
              closest: (names) => formatter.closest(names),
              apply: (name2, vars, _node) => formatter.apply(name2, defaultVars(vars)),
              remove: (name2, vars, _node, _similar) => formatter.remove(name2, defaultVars(vars)),
              toggle: (name2, vars, _node) => formatter.toggle(name2, defaultVars(vars)),
              formatChanged: (_rfl, formats, callback, similar, vars) => formatter.formatChanged(formats, callback, similar, vars)
            },
            editor: {
              getContent: (args) => editor.getContent(args),
              setContent: (content, args) => {
                return {
                  content: editor.setContent(content, args),
                  html: ""
                };
              },
              insertContent: (content, _details) => {
                editor.insertContent(content);
                return "";
              },
              addVisual: editor.addVisual
            },
            selection: { getContent: (_format, args) => selection.getContent(args) },
            autocompleter: {
              addDecoration: autocompleter.addDecoration,
              removeDecoration: autocompleter.removeDecoration
            },
            raw: { getModel: () => Optional.some(raw.getRawModel()) }
          };
        };
        const makeNoopAdaptor = () => {
          const nul = constant(null);
          const empty2 = constant("");
          return {
            init: { bindEvents: noop2 },
            undoManager: {
              beforeChange: noop2,
              add: nul,
              undo: nul,
              redo: nul,
              clear: noop2,
              reset: noop2,
              hasUndo: never,
              hasRedo: never,
              transact: nul,
              ignore: noop2,
              extra: noop2
            },
            formatter: {
              match: never,
              matchAll: constant([]),
              matchNode: constant(void 0),
              canApply: never,
              closest: empty2,
              apply: noop2,
              remove: noop2,
              toggle: noop2,
              formatChanged: constant({ unbind: noop2 })
            },
            editor: {
              getContent: empty2,
              setContent: constant({
                content: "",
                html: ""
              }),
              insertContent: constant(""),
              addVisual: noop2
            },
            selection: { getContent: empty2 },
            autocompleter: {
              addDecoration: noop2,
              removeDecoration: noop2
            },
            raw: { getModel: constant(Optional.none()) }
          };
        };
        const isRtc = (editor) => has$2(editor.plugins, "rtc");
        const getRtcSetup = (editor) => get$a(editor.plugins, "rtc").bind((rtcPlugin) => Optional.from(rtcPlugin.setup));
        const setup$s = (editor) => {
          const editorCast = editor;
          return getRtcSetup(editor).fold(() => {
            editorCast.rtcInstance = makePlainAdaptor(editor);
            return Optional.none();
          }, (setup2) => {
            editorCast.rtcInstance = makeNoopAdaptor();
            return Optional.some(() => setup2().then((rtcEditor) => {
              editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);
              return rtcEditor.rtc.isRemote;
            }));
          });
        };
        const getRtcInstanceWithFallback = (editor) => editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);
        const getRtcInstanceWithError = (editor) => {
          const rtcInstance = editor.rtcInstance;
          if (!rtcInstance) {
            throw new Error("Failed to get RTC instance not yet initialized.");
          } else {
            return rtcInstance;
          }
        };
        const beforeChange = (editor, locks, beforeBookmark) => {
          getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);
        };
        const addUndoLevel = (editor, undoManager, index, locks, beforeBookmark, level, event) => getRtcInstanceWithError(editor).undoManager.add(undoManager, index, locks, beforeBookmark, level, event);
        const undo = (editor, undoManager, locks, index) => getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);
        const redo = (editor, index, data2) => getRtcInstanceWithError(editor).undoManager.redo(index, data2);
        const clear = (editor, undoManager, index) => {
          getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);
        };
        const reset = (editor, undoManager) => {
          getRtcInstanceWithError(editor).undoManager.reset(undoManager);
        };
        const hasUndo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);
        const hasRedo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);
        const transact = (editor, undoManager, locks, callback) => getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);
        const ignore = (editor, locks, callback) => {
          getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);
        };
        const extra = (editor, undoManager, index, callback1, callback2) => {
          getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);
        };
        const matchFormat = (editor, name2, vars, node, similar) => getRtcInstanceWithError(editor).formatter.match(name2, vars, node, similar);
        const matchAllFormats = (editor, names, vars) => getRtcInstanceWithError(editor).formatter.matchAll(names, vars);
        const matchNodeFormat = (editor, node, name2, vars, similar) => getRtcInstanceWithError(editor).formatter.matchNode(node, name2, vars, similar);
        const canApplyFormat = (editor, name2) => getRtcInstanceWithError(editor).formatter.canApply(name2);
        const closestFormat = (editor, names) => getRtcInstanceWithError(editor).formatter.closest(names);
        const applyFormat = (editor, name2, vars, node) => {
          getRtcInstanceWithError(editor).formatter.apply(name2, vars, node);
        };
        const removeFormat = (editor, name2, vars, node, similar) => {
          getRtcInstanceWithError(editor).formatter.remove(name2, vars, node, similar);
        };
        const toggleFormat = (editor, name2, vars, node) => {
          getRtcInstanceWithError(editor).formatter.toggle(name2, vars, node);
        };
        const formatChanged = (editor, registeredFormatListeners, formats, callback, similar, vars) => getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar, vars);
        const getContent$2 = (editor, args) => getRtcInstanceWithFallback(editor).editor.getContent(args);
        const setContent$2 = (editor, content, args) => getRtcInstanceWithFallback(editor).editor.setContent(content, args);
        const insertContent$1 = (editor, value2, details) => getRtcInstanceWithFallback(editor).editor.insertContent(value2, details);
        const getSelectedContent = (editor, format, args) => getRtcInstanceWithError(editor).selection.getContent(format, args);
        const addVisual$1 = (editor, elm) => getRtcInstanceWithError(editor).editor.addVisual(elm);
        const bindEvents = (editor) => getRtcInstanceWithError(editor).init.bindEvents();
        const addAutocompleterDecoration = (editor, range2) => getRtcInstanceWithError(editor).autocompleter.addDecoration(range2);
        const removeAutocompleterDecoration = (editor) => getRtcInstanceWithError(editor).autocompleter.removeDecoration();
        const getContent$1 = (editor, args = {}) => {
          const format = args.format ? args.format : "html";
          return getSelectedContent(editor, format, args);
        };
        const removeEmpty = (text2) => {
          if (text2.dom.length === 0) {
            remove$5(text2);
            return Optional.none();
          } else {
            return Optional.some(text2);
          }
        };
        const walkPastBookmark = (node, start4) => node.filter((elm) => BookmarkManager.isBookmarkNode(elm.dom)).bind(start4 ? nextSibling : prevSibling);
        const merge$1 = (outer, inner, rng, start4) => {
          const outerElm = outer.dom;
          const innerElm = inner.dom;
          const oldLength = start4 ? outerElm.length : innerElm.length;
          if (start4) {
            mergeTextNodes(outerElm, innerElm, false, !start4);
            rng.setStart(innerElm, oldLength);
          } else {
            mergeTextNodes(innerElm, outerElm, false, !start4);
            rng.setEnd(innerElm, oldLength);
          }
        };
        const normalizeTextIfRequired = (inner, start4) => {
          parent(inner).each((root) => {
            const text2 = inner.dom;
            if (start4 && needsToBeNbspLeft(root, CaretPosition(text2, 0))) {
              normalizeWhitespaceAfter(text2, 0);
            } else if (!start4 && needsToBeNbspRight(root, CaretPosition(text2, text2.length))) {
              normalizeWhitespaceBefore(text2, text2.length);
            }
          });
        };
        const mergeAndNormalizeText = (outerNode, innerNode, rng, start4) => {
          outerNode.bind((outer) => {
            const normalizer = start4 ? normalizeWhitespaceBefore : normalizeWhitespaceAfter;
            normalizer(outer.dom, start4 ? outer.dom.length : 0);
            return innerNode.filter(isText$b).map((inner) => merge$1(outer, inner, rng, start4));
          }).orThunk(() => {
            const innerTextNode = walkPastBookmark(innerNode, start4).or(innerNode).filter(isText$b);
            return innerTextNode.map((inner) => normalizeTextIfRequired(inner, start4));
          });
        };
        const rngSetContent = (rng, fragment) => {
          const firstChild2 = Optional.from(fragment.firstChild).map(SugarElement.fromDom);
          const lastChild2 = Optional.from(fragment.lastChild).map(SugarElement.fromDom);
          rng.deleteContents();
          rng.insertNode(fragment);
          const prevText = firstChild2.bind(prevSibling).filter(isText$b).bind(removeEmpty);
          const nextText = lastChild2.bind(nextSibling).filter(isText$b).bind(removeEmpty);
          mergeAndNormalizeText(prevText, firstChild2, rng, true);
          mergeAndNormalizeText(nextText, lastChild2, rng, false);
          rng.collapse(false);
        };
        const setupArgs$2 = (args, content) => ({
          format: "html",
          ...args,
          set: true,
          selection: true,
          content
        });
        const cleanContent = (editor, args) => {
          if (args.format !== "raw") {
            const rng = editor.selection.getRng();
            const contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);
            const contextArgs = contextBlock ? { context: contextBlock.nodeName.toLowerCase() } : {};
            const node = editor.parser.parse(args.content, {
              forced_root_block: false,
              ...contextArgs,
              ...args
            });
            return HtmlSerializer({ validate: false }, editor.schema).serialize(node);
          } else {
            return args.content;
          }
        };
        const setContent$1 = (editor, content, args = {}) => {
          const defaultedArgs = setupArgs$2(args, content);
          preProcessSetContent(editor, defaultedArgs).each((updatedArgs) => {
            const cleanedContent = cleanContent(editor, updatedArgs);
            const rng = editor.selection.getRng();
            rngSetContent(rng, rng.createContextualFragment(cleanedContent));
            editor.selection.setRng(rng);
            scrollRangeIntoView(editor, rng);
            postProcessSetContent(editor, cleanedContent, updatedArgs);
          });
        };
        const deleteFromCallbackMap = (callbackMap, selector, callback) => {
          if (has$2(callbackMap, selector)) {
            const newCallbacks = filter$5(callbackMap[selector], (cb) => cb !== callback);
            if (newCallbacks.length === 0) {
              delete callbackMap[selector];
            } else {
              callbackMap[selector] = newCallbacks;
            }
          }
        };
        var SelectorChanged = (dom2, editor) => {
          let selectorChangedData;
          let currentSelectors;
          const findMatchingNode = (selector, nodes) => find$2(nodes, (node) => dom2.is(node, selector));
          const getParents2 = (elem) => dom2.getParents(elem, void 0, dom2.getRoot());
          const setup2 = () => {
            selectorChangedData = {};
            currentSelectors = {};
            editor.on("NodeChange", (e2) => {
              const node = e2.element;
              const parents2 = getParents2(node);
              const matchedSelectors = {};
              each$d(selectorChangedData, (callbacks, selector) => {
                findMatchingNode(selector, parents2).each((node2) => {
                  if (!currentSelectors[selector]) {
                    each$e(callbacks, (callback) => {
                      callback(true, {
                        node: node2,
                        selector,
                        parents: parents2
                      });
                    });
                    currentSelectors[selector] = callbacks;
                  }
                  matchedSelectors[selector] = callbacks;
                });
              });
              each$d(currentSelectors, (callbacks, selector) => {
                if (!matchedSelectors[selector]) {
                  delete currentSelectors[selector];
                  each$e(callbacks, (callback) => {
                    callback(false, {
                      node,
                      selector,
                      parents: parents2
                    });
                  });
                }
              });
            });
          };
          return {
            selectorChangedWithUnbind: (selector, callback) => {
              if (!selectorChangedData) {
                setup2();
              }
              if (!selectorChangedData[selector]) {
                selectorChangedData[selector] = [];
              }
              selectorChangedData[selector].push(callback);
              findMatchingNode(selector, getParents2(editor.selection.getStart())).each(() => {
                currentSelectors[selector] = selectorChangedData[selector];
              });
              return {
                unbind: () => {
                  deleteFromCallbackMap(selectorChangedData, selector, callback);
                  deleteFromCallbackMap(currentSelectors, selector, callback);
                }
              };
            }
          };
        };
        const isAttachedToDom = (node) => {
          return !!(node && node.ownerDocument) && contains2(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));
        };
        const isValidRange = (rng) => {
          if (!rng) {
            return false;
          } else {
            return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);
          }
        };
        const EditorSelection = (dom2, win, serializer, editor) => {
          let selectedRange;
          let explicitRange;
          const { selectorChangedWithUnbind } = SelectorChanged(dom2, editor);
          const setCursorLocation = (node, offset2) => {
            const rng = dom2.createRng();
            if (isNonNullable(node) && isNonNullable(offset2)) {
              rng.setStart(node, offset2);
              rng.setEnd(node, offset2);
              setRng(rng);
              collapse2(false);
            } else {
              moveEndPoint(dom2, rng, editor.getBody(), true);
              setRng(rng);
            }
          };
          const getContent2 = (args) => getContent$1(editor, args);
          const setContent2 = (content, args) => setContent$1(editor, content, args);
          const getStart$12 = (real) => getStart(editor.getBody(), getRng$1(), real);
          const getEnd2 = (real) => getEnd$1(editor.getBody(), getRng$1(), real);
          const getBookmark2 = (type2, normalized) => bookmarkManager.getBookmark(type2, normalized);
          const moveToBookmark2 = (bookmark) => bookmarkManager.moveToBookmark(bookmark);
          const select$1 = (node, content) => {
            select(dom2, node, content).each(setRng);
            return node;
          };
          const isCollapsed = () => {
            const rng = getRng$1(), sel = getSel();
            if (!rng || rng.item) {
              return false;
            }
            if (rng.compareEndPoints) {
              return rng.compareEndPoints("StartToEnd", rng) === 0;
            }
            return !sel || rng.collapsed;
          };
          const isEditable2 = () => {
            const rng = getRng$1();
            const fakeSelectedElements = editor.getBody().querySelectorAll('[data-mce-selected="1"]');
            if (fakeSelectedElements.length > 0) {
              return forall(fakeSelectedElements, (el) => dom2.isEditable(el.parentElement));
            } else if (rng.startContainer === rng.endContainer) {
              return dom2.isEditable(rng.startContainer);
            } else {
              return dom2.isEditable(rng.startContainer) && dom2.isEditable(rng.endContainer);
            }
          };
          const collapse2 = (toStart) => {
            const rng = getRng$1();
            rng.collapse(!!toStart);
            setRng(rng);
          };
          const getSel = () => win.getSelection ? win.getSelection() : win.document.selection;
          const getRng$1 = () => {
            let rng;
            const tryCompareBoundaryPoints = (how, sourceRange, destinationRange) => {
              try {
                return sourceRange.compareBoundaryPoints(how, destinationRange);
              } catch (ex) {
                return -1;
              }
            };
            const doc = win.document;
            if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {
              const bookmark = getRng(editor);
              if (bookmark.isSome()) {
                return bookmark.map((r3) => processRanges(editor, [r3])[0]).getOr(doc.createRange());
              }
            }
            try {
              const selection = getSel();
              if (selection && !isRestrictedNode(selection.anchorNode)) {
                if (selection.rangeCount > 0) {
                  rng = selection.getRangeAt(0);
                } else {
                  rng = doc.createRange();
                }
                rng = processRanges(editor, [rng])[0];
              }
            } catch (ex) {
            }
            if (!rng) {
              rng = doc.createRange();
            }
            if (isDocument$1(rng.startContainer) && rng.collapsed) {
              const elm = dom2.getRoot();
              rng.setStart(elm, 0);
              rng.setEnd(elm, 0);
            }
            if (selectedRange && explicitRange) {
              if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {
                rng = explicitRange;
              } else {
                selectedRange = null;
                explicitRange = null;
              }
            }
            return rng;
          };
          const setRng = (rng, forward) => {
            if (!isValidRange(rng)) {
              return;
            }
            const sel = getSel();
            const evt = editor.dispatch("SetSelectionRange", {
              range: rng,
              forward
            });
            rng = evt.range;
            if (sel) {
              explicitRange = rng;
              try {
                sel.removeAllRanges();
                sel.addRange(rng);
              } catch (ex) {
              }
              if (forward === false && sel.extend) {
                sel.collapse(rng.endContainer, rng.endOffset);
                sel.extend(rng.startContainer, rng.startOffset);
              }
              selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
            }
            if (!rng.collapsed && rng.startContainer === rng.endContainer && (sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent)) {
              if (rng.endOffset - rng.startOffset < 2) {
                if (rng.startContainer.hasChildNodes()) {
                  const node = rng.startContainer.childNodes[rng.startOffset];
                  if (node && node.nodeName === "IMG") {
                    sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);
                    if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {
                      sel.setBaseAndExtent(node, 0, node, 1);
                    }
                  }
                }
              }
            }
            editor.dispatch("AfterSetSelectionRange", {
              range: rng,
              forward
            });
          };
          const setNode = (elm) => {
            setContent2(dom2.getOuterHTML(elm));
            return elm;
          };
          const getNode$12 = () => getNode(editor.getBody(), getRng$1());
          const getSelectedBlocks$1 = (startElm, endElm) => getSelectedBlocks(dom2, getRng$1(), startElm, endElm);
          const isForward = () => {
            const sel = getSel();
            const anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;
            const focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;
            if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) {
              return true;
            }
            const anchorRange = dom2.createRng();
            const focusRange = dom2.createRng();
            try {
              anchorRange.setStart(anchorNode, sel.anchorOffset);
              anchorRange.collapse(true);
              focusRange.setStart(focusNode, sel.focusOffset);
              focusRange.collapse(true);
            } catch (e2) {
              return true;
            }
            return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;
          };
          const normalize2 = () => {
            const rng = getRng$1();
            const sel = getSel();
            if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {
              const normRng = normalize$2(dom2, rng);
              normRng.each((normRng2) => {
                setRng(normRng2, isForward());
              });
              return normRng.getOr(rng);
            }
            return rng;
          };
          const selectorChanged = (selector, callback) => {
            selectorChangedWithUnbind(selector, callback);
            return exports2;
          };
          const getScrollContainer = () => {
            let scrollContainer;
            let node = dom2.getRoot();
            while (node && node.nodeName !== "BODY") {
              if (node.scrollHeight > node.clientHeight) {
                scrollContainer = node;
                break;
              }
              node = node.parentNode;
            }
            return scrollContainer;
          };
          const scrollIntoView = (elm, alignToTop) => {
            if (isNonNullable(elm)) {
              scrollElementIntoView(editor, elm, alignToTop);
            } else {
              scrollRangeIntoView(editor, getRng$1(), alignToTop);
            }
          };
          const placeCaretAt2 = (clientX, clientY) => setRng(fromPoint(clientX, clientY, editor.getDoc()));
          const getBoundingClientRect3 = () => {
            const rng = getRng$1();
            return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();
          };
          const destroy2 = () => {
            win = selectedRange = explicitRange = null;
            controlSelection.destroy();
          };
          const expand = (options = { type: "word" }) => setRng(RangeUtils(dom2).expand(getRng$1(), options));
          const exports2 = {
            dom: dom2,
            win,
            serializer,
            editor,
            expand,
            collapse: collapse2,
            setCursorLocation,
            getContent: getContent2,
            setContent: setContent2,
            getBookmark: getBookmark2,
            moveToBookmark: moveToBookmark2,
            select: select$1,
            isCollapsed,
            isEditable: isEditable2,
            isForward,
            setNode,
            getNode: getNode$12,
            getSel,
            setRng,
            getRng: getRng$1,
            getStart: getStart$12,
            getEnd: getEnd2,
            getSelectedBlocks: getSelectedBlocks$1,
            normalize: normalize2,
            selectorChanged,
            selectorChangedWithUnbind,
            getScrollContainer,
            scrollIntoView,
            placeCaretAt: placeCaretAt2,
            getBoundingClientRect: getBoundingClientRect3,
            destroy: destroy2
          };
          const bookmarkManager = BookmarkManager(exports2);
          const controlSelection = ControlSelection(exports2, editor);
          exports2.bookmarkManager = bookmarkManager;
          exports2.controlSelection = controlSelection;
          return exports2;
        };
        const register$3 = (htmlParser, settings, dom2) => {
          htmlParser.addAttributeFilter("data-mce-tabindex", (nodes, name2) => {
            let i2 = nodes.length;
            while (i2--) {
              const node = nodes[i2];
              node.attr("tabindex", node.attr("data-mce-tabindex"));
              node.attr(name2, null);
            }
          });
          htmlParser.addAttributeFilter("src,href,style", (nodes, name2) => {
            const internalName = "data-mce-" + name2;
            const urlConverter = settings.url_converter;
            const urlConverterScope = settings.url_converter_scope;
            let i2 = nodes.length;
            while (i2--) {
              const node = nodes[i2];
              let value2 = node.attr(internalName);
              if (value2 !== void 0) {
                node.attr(name2, value2.length > 0 ? value2 : null);
                node.attr(internalName, null);
              } else {
                value2 = node.attr(name2);
                if (name2 === "style") {
                  value2 = dom2.serializeStyle(dom2.parseStyle(value2), node.name);
                } else if (urlConverter) {
                  value2 = urlConverter.call(urlConverterScope, value2, name2, node.name);
                }
                node.attr(name2, value2.length > 0 ? value2 : null);
              }
            }
          });
          htmlParser.addAttributeFilter("class", (nodes) => {
            let i2 = nodes.length;
            while (i2--) {
              const node = nodes[i2];
              let value2 = node.attr("class");
              if (value2) {
                value2 = value2.replace(/(?:^|\s)mce-item-\w+(?!\S)/g, "");
                node.attr("class", value2.length > 0 ? value2 : null);
              }
            }
          });
          htmlParser.addAttributeFilter("data-mce-type", (nodes, name2, args) => {
            let i2 = nodes.length;
            while (i2--) {
              const node = nodes[i2];
              if (node.attr("data-mce-type") === "bookmark" && !args.cleanup) {
                const hasChildren = Optional.from(node.firstChild).exists((firstChild2) => {
                  var _a;
                  return !isZwsp$1((_a = firstChild2.value) !== null && _a !== void 0 ? _a : "");
                });
                if (hasChildren) {
                  node.unwrap();
                } else {
                  node.remove();
                }
              }
            }
          });
          htmlParser.addNodeFilter("noscript", (nodes) => {
            var _a;
            let i2 = nodes.length;
            while (i2--) {
              const node = nodes[i2].firstChild;
              if (node) {
                node.value = Entities.decode((_a = node.value) !== null && _a !== void 0 ? _a : "");
              }
            }
          });
          htmlParser.addNodeFilter("script,style", (nodes, name2) => {
            var _a;
            const trim2 = (value2) => {
              return value2.replace(/(<!--\[CDATA\[|\]\]-->)/g, "\n").replace(/^[\r\n]*|[\r\n]*$/g, "").replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, "").replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, "");
            };
            let i2 = nodes.length;
            while (i2--) {
              const node = nodes[i2];
              const firstChild2 = node.firstChild;
              const value2 = (_a = firstChild2 === null || firstChild2 === void 0 ? void 0 : firstChild2.value) !== null && _a !== void 0 ? _a : "";
              if (name2 === "script") {
                const type2 = node.attr("type");
                if (type2) {
                  node.attr("type", type2 === "mce-no/type" ? null : type2.replace(/^mce\-/, ""));
                }
                if (settings.element_format === "xhtml" && firstChild2 && value2.length > 0) {
                  firstChild2.value = "// <![CDATA[\n" + trim2(value2) + "\n// ]]>";
                }
              } else {
                if (settings.element_format === "xhtml" && firstChild2 && value2.length > 0) {
                  firstChild2.value = "<!--\n" + trim2(value2) + "\n-->";
                }
              }
            }
          });
          htmlParser.addNodeFilter("#comment", (nodes) => {
            let i2 = nodes.length;
            while (i2--) {
              const node = nodes[i2];
              const value2 = node.value;
              if (settings.preserve_cdata && (value2 === null || value2 === void 0 ? void 0 : value2.indexOf("[CDATA[")) === 0) {
                node.name = "#cdata";
                node.type = 4;
                node.value = dom2.decode(value2.replace(/^\[CDATA\[|\]\]$/g, ""));
              } else if ((value2 === null || value2 === void 0 ? void 0 : value2.indexOf("mce:protected ")) === 0) {
                node.name = "#text";
                node.type = 3;
                node.raw = true;
                node.value = unescape(value2).substr(14);
              }
            }
          });
          htmlParser.addNodeFilter("xml:namespace,input", (nodes, name2) => {
            let i2 = nodes.length;
            while (i2--) {
              const node = nodes[i2];
              if (node.type === 7) {
                node.remove();
              } else if (node.type === 1) {
                if (name2 === "input" && !node.attr("type")) {
                  node.attr("type", "text");
                }
              }
            }
          });
          htmlParser.addAttributeFilter("data-mce-type", (nodes) => {
            each$e(nodes, (node) => {
              if (node.attr("data-mce-type") === "format-caret") {
                if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {
                  node.remove();
                } else {
                  node.unwrap();
                }
              }
            });
          });
          htmlParser.addAttributeFilter("data-mce-src,data-mce-href,data-mce-style,data-mce-selected,data-mce-expando,data-mce-block,data-mce-type,data-mce-resize,data-mce-placeholder", (nodes, name2) => {
            let i2 = nodes.length;
            while (i2--) {
              nodes[i2].attr(name2, null);
            }
          });
          if (settings.remove_trailing_brs) {
            addNodeFilter(htmlParser, htmlParser.schema);
          }
        };
        const trimTrailingBr = (rootNode) => {
          const isBr2 = (node) => {
            return (node === null || node === void 0 ? void 0 : node.name) === "br";
          };
          const brNode1 = rootNode.lastChild;
          if (isBr2(brNode1)) {
            const brNode2 = brNode1.prev;
            if (isBr2(brNode2)) {
              brNode1.remove();
              brNode2.remove();
            }
          }
        };
        const preProcess$1 = (editor, node, args) => {
          let oldDoc;
          const dom2 = editor.dom;
          let clonedNode = node.cloneNode(true);
          const impl = document.implementation;
          if (impl.createHTMLDocument) {
            const doc = impl.createHTMLDocument("");
            Tools.each(clonedNode.nodeName === "BODY" ? clonedNode.childNodes : [clonedNode], (node2) => {
              doc.body.appendChild(doc.importNode(node2, true));
            });
            if (clonedNode.nodeName !== "BODY") {
              clonedNode = doc.body.firstChild;
            } else {
              clonedNode = doc.body;
            }
            oldDoc = dom2.doc;
            dom2.doc = doc;
          }
          firePreProcess(editor, {
            ...args,
            node: clonedNode
          });
          if (oldDoc) {
            dom2.doc = oldDoc;
          }
          return clonedNode;
        };
        const shouldFireEvent = (editor, args) => {
          return isNonNullable(editor) && editor.hasEventListeners("PreProcess") && !args.no_events;
        };
        const process$1 = (editor, node, args) => {
          return shouldFireEvent(editor, args) ? preProcess$1(editor, node, args) : node;
        };
        const addTempAttr = (htmlParser, tempAttrs, name2) => {
          if (Tools.inArray(tempAttrs, name2) === -1) {
            htmlParser.addAttributeFilter(name2, (nodes, name3) => {
              let i2 = nodes.length;
              while (i2--) {
                nodes[i2].attr(name3, null);
              }
            });
            tempAttrs.push(name2);
          }
        };
        const postProcess = (editor, args, content) => {
          if (!args.no_events && editor) {
            const outArgs = firePostProcess(editor, {
              ...args,
              content
            });
            return outArgs.content;
          } else {
            return content;
          }
        };
        const getHtmlFromNode = (dom2, node, args) => {
          const html2 = trim$1(args.getInner ? node.innerHTML : dom2.getOuterHTML(node));
          return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html2 : Tools.trim(html2);
        };
        const parseHtml = (htmlParser, html2, args) => {
          const parserArgs = args.selection ? {
            forced_root_block: false,
            ...args
          } : args;
          const rootNode = htmlParser.parse(html2, parserArgs);
          trimTrailingBr(rootNode);
          return rootNode;
        };
        const serializeNode = (settings, schema, node) => {
          const htmlSerializer = HtmlSerializer(settings, schema);
          return htmlSerializer.serialize(node);
        };
        const toHtml = (editor, settings, schema, rootNode, args) => {
          const content = serializeNode(settings, schema, rootNode);
          return postProcess(editor, args, content);
        };
        const DomSerializerImpl = (settings, editor) => {
          const tempAttrs = ["data-mce-selected"];
          const defaultedSettings = {
            entity_encoding: "named",
            remove_trailing_brs: true,
            ...settings
          };
          const dom2 = editor && editor.dom ? editor.dom : DOMUtils.DOM;
          const schema = editor && editor.schema ? editor.schema : Schema(defaultedSettings);
          const htmlParser = DomParser(defaultedSettings, schema);
          register$3(htmlParser, defaultedSettings, dom2);
          const serialize = (node, parserArgs = {}) => {
            const args = {
              format: "html",
              ...parserArgs
            };
            const targetNode = process$1(editor, node, args);
            const html2 = getHtmlFromNode(dom2, targetNode, args);
            const rootNode = parseHtml(htmlParser, html2, args);
            return args.format === "tree" ? rootNode : toHtml(editor, defaultedSettings, schema, rootNode, args);
          };
          return {
            schema,
            addNodeFilter: htmlParser.addNodeFilter,
            addAttributeFilter: htmlParser.addAttributeFilter,
            serialize,
            addRules: schema.addValidElements,
            setRules: schema.setValidElements,
            addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),
            getTempAttrs: constant(tempAttrs),
            getNodeFilters: htmlParser.getNodeFilters,
            getAttributeFilters: htmlParser.getAttributeFilters,
            removeNodeFilter: htmlParser.removeNodeFilter,
            removeAttributeFilter: htmlParser.removeAttributeFilter
          };
        };
        const DomSerializer = (settings, editor) => {
          const domSerializer = DomSerializerImpl(settings, editor);
          return {
            schema: domSerializer.schema,
            addNodeFilter: domSerializer.addNodeFilter,
            addAttributeFilter: domSerializer.addAttributeFilter,
            serialize: domSerializer.serialize,
            addRules: domSerializer.addRules,
            setRules: domSerializer.setRules,
            addTempAttr: domSerializer.addTempAttr,
            getTempAttrs: domSerializer.getTempAttrs,
            getNodeFilters: domSerializer.getNodeFilters,
            getAttributeFilters: domSerializer.getAttributeFilters,
            removeNodeFilter: domSerializer.removeNodeFilter,
            removeAttributeFilter: domSerializer.removeAttributeFilter
          };
        };
        const defaultFormat$1 = "html";
        const setupArgs$1 = (args, format) => ({
          ...args,
          format,
          get: true,
          getInner: true
        });
        const getContent = (editor, args = {}) => {
          const format = args.format ? args.format : defaultFormat$1;
          const defaultedArgs = setupArgs$1(args, format);
          return preProcessGetContent(editor, defaultedArgs).fold(identity, (updatedArgs) => {
            const content = getContent$2(editor, updatedArgs);
            return postProcessGetContent(editor, content, updatedArgs);
          });
        };
        const defaultFormat = "html";
        const setupArgs = (args, content) => ({
          format: defaultFormat,
          ...args,
          set: true,
          content
        });
        const setContent = (editor, content, args = {}) => {
          const defaultedArgs = setupArgs(args, content);
          return preProcessSetContent(editor, defaultedArgs).map((updatedArgs) => {
            const result = setContent$2(editor, updatedArgs.content, updatedArgs);
            postProcessSetContent(editor, result.html, updatedArgs);
            return result.content;
          }).getOr(content);
        };
        const removedOptions = "autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists".split(",");
        const deprecatedOptions = "template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format".split(",");
        const removedPlugins = "bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor".split(",");
        const deprecatedPlugins = [
          {
            name: "template",
            replacedWith: "Advanced Template"
          },
          { name: "rtc" }
        ];
        const getMatchingOptions = (options, searchingFor) => {
          const settingNames = filter$5(searchingFor, (setting) => has$2(options, setting));
          return sort(settingNames);
        };
        const getRemovedOptions = (options) => {
          const settingNames = getMatchingOptions(options, removedOptions);
          const forcedRootBlock = options.forced_root_block;
          if (forcedRootBlock === false || forcedRootBlock === "") {
            settingNames.push("forced_root_block (false only)");
          }
          return sort(settingNames);
        };
        const getDeprecatedOptions = (options) => getMatchingOptions(options, deprecatedOptions);
        const getMatchingPlugins = (options, searchingFor) => {
          const plugins = Tools.makeMap(options.plugins, " ");
          const hasPlugin = (plugin) => has$2(plugins, plugin);
          const pluginNames = filter$5(searchingFor, hasPlugin);
          return sort(pluginNames);
        };
        const getRemovedPlugins = (options) => getMatchingPlugins(options, removedPlugins);
        const getDeprecatedPlugins = (options) => getMatchingPlugins(options, deprecatedPlugins.map((entry) => entry.name));
        const logRemovedWarnings = (rawOptions, normalizedOptions) => {
          const removedOptions2 = getRemovedOptions(rawOptions);
          const removedPlugins2 = getRemovedPlugins(normalizedOptions);
          const hasRemovedPlugins = removedPlugins2.length > 0;
          const hasRemovedOptions = removedOptions2.length > 0;
          const isLegacyMobileTheme = normalizedOptions.theme === "mobile";
          if (hasRemovedPlugins || hasRemovedOptions || isLegacyMobileTheme) {
            const listJoiner = "\n- ";
            const themesMessage = isLegacyMobileTheme ? `

Themes:${listJoiner}mobile` : "";
            const pluginsMessage = hasRemovedPlugins ? `

Plugins:${listJoiner}${removedPlugins2.join(listJoiner)}` : "";
            const optionsMessage = hasRemovedOptions ? `

Options:${listJoiner}${removedOptions2.join(listJoiner)}` : "";
            console.warn("The following deprecated features are currently enabled and have been removed in TinyMCE 6.0. These features will no longer work and should be removed from the TinyMCE configuration. See https://www.tiny.cloud/docs/tinymce/6/migration-from-5x/ for more information." + themesMessage + pluginsMessage + optionsMessage);
          }
        };
        const getPluginDescription = (name2) => find$2(deprecatedPlugins, (entry) => entry.name === name2).fold(() => name2, (entry) => {
          if (entry.replacedWith) {
            return `${name2}, replaced by ${entry.replacedWith}`;
          } else {
            return name2;
          }
        });
        const logDeprecatedWarnings = (rawOptions, normalizedOptions) => {
          const deprecatedOptions2 = getDeprecatedOptions(rawOptions);
          const deprecatedPlugins2 = getDeprecatedPlugins(normalizedOptions);
          const hasDeprecatedPlugins = deprecatedPlugins2.length > 0;
          const hasDeprecatedOptions = deprecatedOptions2.length > 0;
          if (hasDeprecatedPlugins || hasDeprecatedOptions) {
            const listJoiner = "\n- ";
            const pluginsMessage = hasDeprecatedPlugins ? `

Plugins:${listJoiner}${deprecatedPlugins2.map(getPluginDescription).join(listJoiner)}` : "";
            const optionsMessage = hasDeprecatedOptions ? `

Options:${listJoiner}${deprecatedOptions2.join(listJoiner)}` : "";
            console.warn("The following deprecated features are currently enabled but will be removed soon." + pluginsMessage + optionsMessage);
          }
        };
        const logWarnings = (rawOptions, normalizedOptions) => {
          logRemovedWarnings(rawOptions, normalizedOptions);
          logDeprecatedWarnings(rawOptions, normalizedOptions);
        };
        const DOM$8 = DOMUtils.DOM;
        const restoreOriginalStyles = (editor) => {
          DOM$8.setStyle(editor.id, "display", editor.orgDisplay);
        };
        const safeDestroy = (x2) => Optional.from(x2).each((x3) => x3.destroy());
        const clearDomReferences = (editor) => {
          const ed = editor;
          ed.contentAreaContainer = ed.formElement = ed.container = ed.editorContainer = null;
          ed.bodyElement = ed.contentDocument = ed.contentWindow = null;
          ed.iframeElement = ed.targetElm = null;
          const selection = editor.selection;
          if (selection) {
            const dom2 = selection.dom;
            ed.selection = selection.win = selection.dom = dom2.doc = null;
          }
        };
        const restoreForm = (editor) => {
          const form = editor.formElement;
          if (form) {
            if (form._mceOldSubmit) {
              form.submit = form._mceOldSubmit;
              delete form._mceOldSubmit;
            }
            DOM$8.unbind(form, "submit reset", editor.formEventDelegate);
          }
        };
        const remove$1 = (editor) => {
          if (!editor.removed) {
            const { _selectionOverrides, editorUpload } = editor;
            const body = editor.getBody();
            const element = editor.getElement();
            if (body) {
              editor.save({ is_removing: true });
            }
            editor.removed = true;
            editor.unbindAllNativeEvents();
            if (editor.hasHiddenInput && isNonNullable(element === null || element === void 0 ? void 0 : element.nextSibling)) {
              DOM$8.remove(element.nextSibling);
            }
            fireRemove(editor);
            editor.editorManager.remove(editor);
            if (!editor.inline && body) {
              restoreOriginalStyles(editor);
            }
            fireDetach(editor);
            DOM$8.remove(editor.getContainer());
            safeDestroy(_selectionOverrides);
            safeDestroy(editorUpload);
            editor.destroy();
          }
        };
        const destroy = (editor, automatic) => {
          const { selection, dom: dom2 } = editor;
          if (editor.destroyed) {
            return;
          }
          if (!automatic && !editor.removed) {
            editor.remove();
            return;
          }
          if (!automatic) {
            editor.editorManager.off("beforeunload", editor._beforeUnload);
            if (editor.theme && editor.theme.destroy) {
              editor.theme.destroy();
            }
            safeDestroy(selection);
            safeDestroy(dom2);
          }
          restoreForm(editor);
          clearDomReferences(editor);
          editor.destroyed = true;
        };
        const CreateIconManager = () => {
          const lookup2 = {};
          const add3 = (id, iconPack) => {
            lookup2[id] = iconPack;
          };
          const get2 = (id) => {
            if (lookup2[id]) {
              return lookup2[id];
            } else {
              return { icons: {} };
            }
          };
          const has2 = (id) => has$2(lookup2, id);
          return {
            add: add3,
            get: get2,
            has: has2
          };
        };
        const IconManager = CreateIconManager();
        const ModelManager = AddOnManager.ModelManager;
        const getProp = (propName, elm) => {
          const rawElm = elm.dom;
          return rawElm[propName];
        };
        const getComputedSizeProp = (propName, elm) => parseInt(get$7(elm, propName), 10);
        const getClientWidth = curry(getProp, "clientWidth");
        const getClientHeight = curry(getProp, "clientHeight");
        const getMarginTop = curry(getComputedSizeProp, "margin-top");
        const getMarginLeft = curry(getComputedSizeProp, "margin-left");
        const getBoundingClientRect2 = (elm) => elm.dom.getBoundingClientRect();
        const isInsideElementContentArea = (bodyElm, clientX, clientY) => {
          const clientWidth = getClientWidth(bodyElm);
          const clientHeight = getClientHeight(bodyElm);
          return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;
        };
        const transpose = (inline, elm, clientX, clientY) => {
          const clientRect = getBoundingClientRect2(elm);
          const deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;
          const deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;
          const x2 = clientX - deltaX;
          const y2 = clientY - deltaY;
          return {
            x: x2,
            y: y2
          };
        };
        const isXYInContentArea = (editor, clientX, clientY) => {
          const bodyElm = SugarElement.fromDom(editor.getBody());
          const targetElm = editor.inline ? bodyElm : documentElement(bodyElm);
          const transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);
          return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);
        };
        const fromDomSafe = (node) => Optional.from(node).map(SugarElement.fromDom);
        const isEditorAttachedToDom = (editor) => {
          const rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();
          return fromDomSafe(rawContainer).map(inBody).getOr(false);
        };
        var NotificationManagerImpl = () => {
          const unimplemented = () => {
            throw new Error("Theme did not provide a NotificationManager implementation.");
          };
          return {
            open: unimplemented,
            close: unimplemented,
            getArgs: unimplemented
          };
        };
        const NotificationManager = (editor) => {
          const notifications = [];
          const getImplementation = () => {
            const theme = editor.theme;
            return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();
          };
          const getTopNotification = () => {
            return Optional.from(notifications[0]);
          };
          const isEqual2 = (a2, b2) => {
            return a2.type === b2.type && a2.text === b2.text && !a2.progressBar && !a2.timeout && !b2.progressBar && !b2.timeout;
          };
          const reposition2 = () => {
            each$e(notifications, (notification) => {
              notification.reposition();
            });
          };
          const addNotification = (notification) => {
            notifications.push(notification);
          };
          const closeNotification = (notification) => {
            findIndex$2(notifications, (otherNotification) => {
              return otherNotification === notification;
            }).each((index) => {
              notifications.splice(index, 1);
            });
          };
          const open = (spec, fireEvent2 = true) => {
            if (editor.removed || !isEditorAttachedToDom(editor)) {
              return {};
            }
            if (fireEvent2) {
              editor.dispatch("BeforeOpenNotification", { notification: spec });
            }
            return find$2(notifications, (notification) => {
              return isEqual2(getImplementation().getArgs(notification), spec);
            }).getOrThunk(() => {
              editor.editorManager.setActive(editor);
              const notification = getImplementation().open(spec, () => {
                closeNotification(notification);
                reposition2();
                getTopNotification().fold(() => editor.focus(), (top2) => focus$1(SugarElement.fromDom(top2.getEl())));
              });
              addNotification(notification);
              reposition2();
              editor.dispatch("OpenNotification", { notification: { ...notification } });
              return notification;
            });
          };
          const close = () => {
            getTopNotification().each((notification) => {
              getImplementation().close(notification);
              closeNotification(notification);
              reposition2();
            });
          };
          const getNotifications = constant(notifications);
          const registerEvents2 = (editor2) => {
            editor2.on("SkinLoaded", () => {
              const serviceMessage = getServiceMessage(editor2);
              if (serviceMessage) {
                open({
                  text: serviceMessage,
                  type: "warning",
                  timeout: 0
                }, false);
              }
              reposition2();
            });
            editor2.on("show ResizeEditor ResizeWindow NodeChange", () => {
              requestAnimationFrame(reposition2);
            });
            editor2.on("remove", () => {
              each$e(notifications.slice(), (notification) => {
                getImplementation().close(notification);
              });
            });
          };
          registerEvents2(editor);
          return {
            open,
            close,
            getNotifications
          };
        };
        const PluginManager = AddOnManager.PluginManager;
        const ThemeManager = AddOnManager.ThemeManager;
        var WindowManagerImpl = () => {
          const unimplemented = () => {
            throw new Error("Theme did not provide a WindowManager implementation.");
          };
          return {
            open: unimplemented,
            openUrl: unimplemented,
            alert: unimplemented,
            confirm: unimplemented,
            close: unimplemented
          };
        };
        const WindowManager = (editor) => {
          let dialogs = [];
          const getImplementation = () => {
            const theme = editor.theme;
            return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();
          };
          const funcBind = (scope, f2) => {
            return (...args) => {
              return f2 ? f2.apply(scope, args) : void 0;
            };
          };
          const fireOpenEvent = (dialog) => {
            editor.dispatch("OpenWindow", { dialog });
          };
          const fireCloseEvent = (dialog) => {
            editor.dispatch("CloseWindow", { dialog });
          };
          const addDialog = (dialog) => {
            dialogs.push(dialog);
            fireOpenEvent(dialog);
          };
          const closeDialog = (dialog) => {
            fireCloseEvent(dialog);
            dialogs = filter$5(dialogs, (otherDialog) => {
              return otherDialog !== dialog;
            });
            if (dialogs.length === 0) {
              editor.focus();
            }
          };
          const getTopDialog = () => {
            return Optional.from(dialogs[dialogs.length - 1]);
          };
          const storeSelectionAndOpenDialog = (openDialog) => {
            editor.editorManager.setActive(editor);
            store(editor);
            editor.ui.show();
            const dialog = openDialog();
            addDialog(dialog);
            return dialog;
          };
          const open = (args, params) => {
            return storeSelectionAndOpenDialog(() => getImplementation().open(args, params, closeDialog));
          };
          const openUrl = (args) => {
            return storeSelectionAndOpenDialog(() => getImplementation().openUrl(args, closeDialog));
          };
          const alert2 = (message, callback, scope) => {
            const windowManagerImpl = getImplementation();
            windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, callback));
          };
          const confirm2 = (message, callback, scope) => {
            const windowManagerImpl = getImplementation();
            windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, callback));
          };
          const close = () => {
            getTopDialog().each((dialog) => {
              getImplementation().close(dialog);
              closeDialog(dialog);
            });
          };
          editor.on("remove", () => {
            each$e(dialogs, (dialog) => {
              getImplementation().close(dialog);
            });
          });
          return {
            open,
            openUrl,
            alert: alert2,
            confirm: confirm2,
            close
          };
        };
        const displayNotification = (editor, message) => {
          editor.notificationManager.open({
            type: "error",
            text: message
          });
        };
        const displayError = (editor, message) => {
          if (editor._skinLoaded) {
            displayNotification(editor, message);
          } else {
            editor.on("SkinLoaded", () => {
              displayNotification(editor, message);
            });
          }
        };
        const uploadError = (editor, message) => {
          displayError(editor, I18n.translate([
            "Failed to upload image: {0}",
            message
          ]));
        };
        const logError = (editor, errorType, msg) => {
          fireError(editor, errorType, { message: msg });
          console.error(msg);
        };
        const createLoadError = (type2, url, name2) => name2 ? `Failed to load ${type2}: ${name2} from url ${url}` : `Failed to load ${type2} url: ${url}`;
        const pluginLoadError = (editor, url, name2) => {
          logError(editor, "PluginLoadError", createLoadError("plugin", url, name2));
        };
        const iconsLoadError = (editor, url, name2) => {
          logError(editor, "IconsLoadError", createLoadError("icons", url, name2));
        };
        const languageLoadError = (editor, url, name2) => {
          logError(editor, "LanguageLoadError", createLoadError("language", url, name2));
        };
        const themeLoadError = (editor, url, name2) => {
          logError(editor, "ThemeLoadError", createLoadError("theme", url, name2));
        };
        const modelLoadError = (editor, url, name2) => {
          logError(editor, "ModelLoadError", createLoadError("model", url, name2));
        };
        const pluginInitError = (editor, name2, err) => {
          const message = I18n.translate([
            "Failed to initialize plugin: {0}",
            name2
          ]);
          fireError(editor, "PluginLoadError", { message });
          initError(message, err);
          displayError(editor, message);
        };
        const initError = (message, ...x2) => {
          const console2 = window.console;
          if (console2) {
            if (console2.error) {
              console2.error(message, ...x2);
            } else {
              console2.log(message, ...x2);
            }
          }
        };
        const isContentCssSkinName = (url) => /^[a-z0-9\-]+$/i.test(url);
        const getContentCssUrls = (editor) => {
          return transformToUrls(editor, getContentCss(editor));
        };
        const getFontCssUrls = (editor) => {
          return transformToUrls(editor, getFontCss(editor));
        };
        const transformToUrls = (editor, cssLinks) => {
          const skinUrl = editor.editorManager.baseURL + "/skins/content";
          const suffix = editor.editorManager.suffix;
          const contentCssFile = `content${suffix}.css`;
          return map$3(cssLinks, (url) => {
            if (isContentCssSkinName(url) && !editor.inline) {
              return `${skinUrl}/${url}/${contentCssFile}`;
            } else {
              return editor.documentBaseURI.toAbsolute(url);
            }
          });
        };
        const appendContentCssFromSettings = (editor) => {
          editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));
        };
        const getAllImages = (elm) => {
          return elm ? from(elm.getElementsByTagName("img")) : [];
        };
        const ImageScanner = (uploadStatus, blobCache) => {
          const cachedPromises = {};
          const findAll2 = (elm, predicate = always) => {
            const images = filter$5(getAllImages(elm), (img) => {
              const src = img.src;
              if (img.hasAttribute("data-mce-bogus")) {
                return false;
              }
              if (img.hasAttribute("data-mce-placeholder")) {
                return false;
              }
              if (!src || src === Env.transparentSrc) {
                return false;
              }
              if (startsWith(src, "blob:")) {
                return !uploadStatus.isUploaded(src) && predicate(img);
              }
              if (startsWith(src, "data:")) {
                return predicate(img);
              }
              return false;
            });
            const promises = map$3(images, (img) => {
              const imageSrc = img.src;
              if (has$2(cachedPromises, imageSrc)) {
                return cachedPromises[imageSrc].then((imageInfo) => {
                  if (isString(imageInfo)) {
                    return imageInfo;
                  } else {
                    return {
                      image: img,
                      blobInfo: imageInfo.blobInfo
                    };
                  }
                });
              } else {
                const newPromise = imageToBlobInfo(blobCache, imageSrc).then((blobInfo) => {
                  delete cachedPromises[imageSrc];
                  return {
                    image: img,
                    blobInfo
                  };
                }).catch((error3) => {
                  delete cachedPromises[imageSrc];
                  return error3;
                });
                cachedPromises[imageSrc] = newPromise;
                return newPromise;
              }
            });
            return Promise.all(promises);
          };
          return { findAll: findAll2 };
        };
        const UploadStatus = () => {
          const PENDING = 1, UPLOADED = 2;
          let blobUriStatuses = {};
          const createStatus = (status, resultUri) => {
            return {
              status,
              resultUri
            };
          };
          const hasBlobUri = (blobUri) => {
            return blobUri in blobUriStatuses;
          };
          const getResultUri = (blobUri) => {
            const result = blobUriStatuses[blobUri];
            return result ? result.resultUri : null;
          };
          const isPending = (blobUri) => {
            return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;
          };
          const isUploaded = (blobUri) => {
            return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;
          };
          const markPending = (blobUri) => {
            blobUriStatuses[blobUri] = createStatus(PENDING, null);
          };
          const markUploaded = (blobUri, resultUri) => {
            blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);
          };
          const removeFailed = (blobUri) => {
            delete blobUriStatuses[blobUri];
          };
          const destroy2 = () => {
            blobUriStatuses = {};
          };
          return {
            hasBlobUri,
            getResultUri,
            isPending,
            isUploaded,
            markPending,
            markUploaded,
            removeFailed,
            destroy: destroy2
          };
        };
        let count = 0;
        const seed = () => {
          const rnd = () => {
            return Math.round(Math.random() * 4294967295).toString(36);
          };
          const now2 = (/* @__PURE__ */ new Date()).getTime();
          return "s" + now2.toString(36) + rnd() + rnd() + rnd();
        };
        const uuid2 = (prefix) => {
          return prefix + count++ + seed();
        };
        const BlobCache = () => {
          let cache2 = [];
          const mimeToExt = (mime) => {
            const mimes = {
              "image/jpeg": "jpg",
              "image/jpg": "jpg",
              "image/gif": "gif",
              "image/png": "png",
              "image/apng": "apng",
              "image/avif": "avif",
              "image/svg+xml": "svg",
              "image/webp": "webp",
              "image/bmp": "bmp",
              "image/tiff": "tiff"
            };
            return mimes[mime.toLowerCase()] || "dat";
          };
          const create2 = (o2, blob, base64, name2, filename) => {
            if (isString(o2)) {
              const id = o2;
              return toBlobInfo({
                id,
                name: name2,
                filename,
                blob,
                base64
              });
            } else if (isObject(o2)) {
              return toBlobInfo(o2);
            } else {
              throw new Error("Unknown input type");
            }
          };
          const toBlobInfo = (o2) => {
            if (!o2.blob || !o2.base64) {
              throw new Error("blob and base64 representations of the image are required for BlobInfo to be created");
            }
            const id = o2.id || uuid2("blobid");
            const name2 = o2.name || id;
            const blob = o2.blob;
            return {
              id: constant(id),
              name: constant(name2),
              filename: constant(o2.filename || name2 + "." + mimeToExt(blob.type)),
              blob: constant(blob),
              base64: constant(o2.base64),
              blobUri: constant(o2.blobUri || URL.createObjectURL(blob)),
              uri: constant(o2.uri)
            };
          };
          const add3 = (blobInfo) => {
            if (!get2(blobInfo.id())) {
              cache2.push(blobInfo);
            }
          };
          const findFirst = (predicate) => find$2(cache2, predicate).getOrUndefined();
          const get2 = (id) => findFirst((cachedBlobInfo) => cachedBlobInfo.id() === id);
          const getByUri = (blobUri) => findFirst((blobInfo) => blobInfo.blobUri() === blobUri);
          const getByData = (base64, type2) => findFirst((blobInfo) => blobInfo.base64() === base64 && blobInfo.blob().type === type2);
          const removeByUri = (blobUri) => {
            cache2 = filter$5(cache2, (blobInfo) => {
              if (blobInfo.blobUri() === blobUri) {
                URL.revokeObjectURL(blobInfo.blobUri());
                return false;
              }
              return true;
            });
          };
          const destroy2 = () => {
            each$e(cache2, (cachedBlobInfo) => {
              URL.revokeObjectURL(cachedBlobInfo.blobUri());
            });
            cache2 = [];
          };
          return {
            create: create2,
            add: add3,
            get: get2,
            getByUri,
            getByData,
            findFirst,
            removeByUri,
            destroy: destroy2
          };
        };
        const Uploader = (uploadStatus, settings) => {
          const pendingPromises = {};
          const pathJoin = (path1, path2) => {
            if (path1) {
              return path1.replace(/\/$/, "") + "/" + path2.replace(/^\//, "");
            }
            return path2;
          };
          const defaultHandler = (blobInfo, progress) => new Promise((success, failure) => {
            const xhr = new XMLHttpRequest();
            xhr.open("POST", settings.url);
            xhr.withCredentials = settings.credentials;
            xhr.upload.onprogress = (e2) => {
              progress(e2.loaded / e2.total * 100);
            };
            xhr.onerror = () => {
              failure("Image upload failed due to a XHR Transport error. Code: " + xhr.status);
            };
            xhr.onload = () => {
              if (xhr.status < 200 || xhr.status >= 300) {
                failure("HTTP Error: " + xhr.status);
                return;
              }
              const json = JSON.parse(xhr.responseText);
              if (!json || !isString(json.location)) {
                failure("Invalid JSON: " + xhr.responseText);
                return;
              }
              success(pathJoin(settings.basePath, json.location));
            };
            const formData = new FormData();
            formData.append("file", blobInfo.blob(), blobInfo.filename());
            xhr.send(formData);
          });
          const uploadHandler = isFunction(settings.handler) ? settings.handler : defaultHandler;
          const noUpload = () => new Promise((resolve2) => {
            resolve2([]);
          });
          const handlerSuccess = (blobInfo, url) => ({
            url,
            blobInfo,
            status: true
          });
          const handlerFailure = (blobInfo, error3) => ({
            url: "",
            blobInfo,
            status: false,
            error: error3
          });
          const resolvePending = (blobUri, result) => {
            Tools.each(pendingPromises[blobUri], (resolve2) => {
              resolve2(result);
            });
            delete pendingPromises[blobUri];
          };
          const uploadBlobInfo = (blobInfo, handler, openNotification2) => {
            uploadStatus.markPending(blobInfo.blobUri());
            return new Promise((resolve2) => {
              let notification;
              let progress;
              try {
                const closeNotification = () => {
                  if (notification) {
                    notification.close();
                    progress = noop2;
                  }
                };
                const success = (url) => {
                  closeNotification();
                  uploadStatus.markUploaded(blobInfo.blobUri(), url);
                  resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));
                  resolve2(handlerSuccess(blobInfo, url));
                };
                const failure = (error3) => {
                  closeNotification();
                  uploadStatus.removeFailed(blobInfo.blobUri());
                  resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error3));
                  resolve2(handlerFailure(blobInfo, error3));
                };
                progress = (percent) => {
                  if (percent < 0 || percent > 100) {
                    return;
                  }
                  Optional.from(notification).orThunk(() => Optional.from(openNotification2).map(apply$1)).each((n2) => {
                    notification = n2;
                    n2.progressBar.value(percent);
                  });
                };
                handler(blobInfo, progress).then(success, (err) => {
                  failure(isString(err) ? { message: err } : err);
                });
              } catch (ex) {
                resolve2(handlerFailure(blobInfo, ex));
              }
            });
          };
          const isDefaultHandler = (handler) => handler === defaultHandler;
          const pendingUploadBlobInfo = (blobInfo) => {
            const blobUri = blobInfo.blobUri();
            return new Promise((resolve2) => {
              pendingPromises[blobUri] = pendingPromises[blobUri] || [];
              pendingPromises[blobUri].push(resolve2);
            });
          };
          const uploadBlobs = (blobInfos, openNotification2) => {
            blobInfos = Tools.grep(blobInfos, (blobInfo) => !uploadStatus.isUploaded(blobInfo.blobUri()));
            return Promise.all(Tools.map(blobInfos, (blobInfo) => uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, uploadHandler, openNotification2)));
          };
          const upload = (blobInfos, openNotification2) => !settings.url && isDefaultHandler(uploadHandler) ? noUpload() : uploadBlobs(blobInfos, openNotification2);
          return { upload };
        };
        const openNotification = (editor) => () => editor.notificationManager.open({
          text: editor.translate("Image uploading..."),
          type: "info",
          timeout: -1,
          progressBar: true
        });
        const createUploader = (editor, uploadStatus) => Uploader(uploadStatus, {
          url: getImageUploadUrl(editor),
          basePath: getImageUploadBasePath(editor),
          credentials: getImagesUploadCredentials(editor),
          handler: getImagesUploadHandler(editor)
        });
        const ImageUploader = (editor) => {
          const uploadStatus = UploadStatus();
          const uploader = createUploader(editor, uploadStatus);
          return { upload: (blobInfos, showNotification = true) => uploader.upload(blobInfos, showNotification ? openNotification(editor) : void 0) };
        };
        const isEmptyForPadding = (editor, element) => editor.dom.isEmpty(element.dom) && isNonNullable(editor.schema.getTextBlockElements()[name(element)]);
        const addPaddingToEmpty = (editor) => (element) => {
          if (isEmptyForPadding(editor, element)) {
            append$1(element, SugarElement.fromHtml('<br data-mce-bogus="1" />'));
          }
        };
        const EditorUpload = (editor) => {
          const blobCache = BlobCache();
          let uploader, imageScanner;
          const uploadStatus = UploadStatus();
          const urlFilters = [];
          const aliveGuard = (callback) => {
            return (result) => {
              if (editor.selection) {
                return callback(result);
              }
              return [];
            };
          };
          const cacheInvalidator = (url) => url + (url.indexOf("?") === -1 ? "?" : "&") + (/* @__PURE__ */ new Date()).getTime();
          const replaceString = (content, search2, replace) => {
            let index = 0;
            do {
              index = content.indexOf(search2, index);
              if (index !== -1) {
                content = content.substring(0, index) + replace + content.substr(index + search2.length);
                index += replace.length - search2.length + 1;
              }
            } while (index !== -1);
            return content;
          };
          const replaceImageUrl = (content, targetUrl, replacementUrl) => {
            const replacementString = `src="${replacementUrl}"${replacementUrl === Env.transparentSrc ? ' data-mce-placeholder="1"' : ""}`;
            content = replaceString(content, `src="${targetUrl}"`, replacementString);
            content = replaceString(content, 'data-mce-src="' + targetUrl + '"', 'data-mce-src="' + replacementUrl + '"');
            return content;
          };
          const replaceUrlInUndoStack = (targetUrl, replacementUrl) => {
            each$e(editor.undoManager.data, (level) => {
              if (level.type === "fragmented") {
                level.fragments = map$3(level.fragments, (fragment) => replaceImageUrl(fragment, targetUrl, replacementUrl));
              } else {
                level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);
              }
            });
          };
          const replaceImageUriInView = (image, resultUri) => {
            const src = editor.convertURL(resultUri, "src");
            replaceUrlInUndoStack(image.src, resultUri);
            setAll$1(SugarElement.fromDom(image), {
              "src": shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,
              "data-mce-src": src
            });
          };
          const uploadImages = () => {
            if (!uploader) {
              uploader = createUploader(editor, uploadStatus);
            }
            return scanForImages().then(aliveGuard((imageInfos) => {
              const blobInfos = map$3(imageInfos, (imageInfo) => imageInfo.blobInfo);
              return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard((result) => {
                const imagesToRemove = [];
                let shouldDispatchChange = false;
                const filteredResult = map$3(result, (uploadInfo, index) => {
                  const { blobInfo, image } = imageInfos[index];
                  let removed = false;
                  if (uploadInfo.status && shouldReplaceBlobUris(editor)) {
                    if (uploadInfo.url && !contains$1(image.src, uploadInfo.url)) {
                      shouldDispatchChange = true;
                    }
                    blobCache.removeByUri(image.src);
                    if (isRtc(editor))
                      ;
                    else {
                      replaceImageUriInView(image, uploadInfo.url);
                    }
                  } else if (uploadInfo.error) {
                    if (uploadInfo.error.remove) {
                      replaceUrlInUndoStack(image.src, Env.transparentSrc);
                      imagesToRemove.push(image);
                      removed = true;
                    }
                    uploadError(editor, uploadInfo.error.message);
                  }
                  return {
                    element: image,
                    status: uploadInfo.status,
                    uploadUri: uploadInfo.url,
                    blobInfo,
                    removed
                  };
                });
                if (imagesToRemove.length > 0 && !isRtc(editor)) {
                  editor.undoManager.transact(() => {
                    each$e(fromDom$1(imagesToRemove), (sugarElement) => {
                      const parentOpt = parent(sugarElement);
                      remove$5(sugarElement);
                      parentOpt.each(addPaddingToEmpty(editor));
                      blobCache.removeByUri(sugarElement.dom.src);
                    });
                  });
                } else if (shouldDispatchChange) {
                  editor.undoManager.dispatchChange();
                }
                return filteredResult;
              }));
            }));
          };
          const uploadImagesAuto = () => isAutomaticUploadsEnabled(editor) ? uploadImages() : Promise.resolve([]);
          const isValidDataUriImage = (imgElm) => forall(urlFilters, (filter2) => filter2(imgElm));
          const addFilter = (filter2) => {
            urlFilters.push(filter2);
          };
          const scanForImages = () => {
            if (!imageScanner) {
              imageScanner = ImageScanner(uploadStatus, blobCache);
            }
            return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard((result) => {
              const filteredResult = filter$5(result, (resultItem) => {
                if (isString(resultItem)) {
                  displayError(editor, resultItem);
                  return false;
                } else if (resultItem.uriType === "blob") {
                  return false;
                } else {
                  return true;
                }
              });
              if (isRtc(editor))
                ;
              else {
                each$e(filteredResult, (resultItem) => {
                  replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());
                  resultItem.image.src = resultItem.blobInfo.blobUri();
                  resultItem.image.removeAttribute("data-mce-src");
                });
              }
              return filteredResult;
            }));
          };
          const destroy2 = () => {
            blobCache.destroy();
            uploadStatus.destroy();
            imageScanner = uploader = null;
          };
          const replaceBlobUris = (content) => {
            return content.replace(/src="(blob:[^"]+)"/g, (match2, blobUri) => {
              const resultUri = uploadStatus.getResultUri(blobUri);
              if (resultUri) {
                return 'src="' + resultUri + '"';
              }
              let blobInfo = blobCache.getByUri(blobUri);
              if (!blobInfo) {
                blobInfo = foldl(editor.editorManager.get(), (result, editor2) => {
                  return result || editor2.editorUpload && editor2.editorUpload.blobCache.getByUri(blobUri);
                }, void 0);
              }
              if (blobInfo) {
                const blob = blobInfo.blob();
                return 'src="data:' + blob.type + ";base64," + blobInfo.base64() + '"';
              }
              return match2;
            });
          };
          editor.on("SetContent", () => {
            if (isAutomaticUploadsEnabled(editor)) {
              uploadImagesAuto();
            } else {
              scanForImages();
            }
          });
          editor.on("RawSaveContent", (e2) => {
            e2.content = replaceBlobUris(e2.content);
          });
          editor.on("GetContent", (e2) => {
            if (e2.source_view || e2.format === "raw" || e2.format === "tree") {
              return;
            }
            e2.content = replaceBlobUris(e2.content);
          });
          editor.on("PostRender", () => {
            editor.parser.addNodeFilter("img", (images) => {
              each$e(images, (img) => {
                const src = img.attr("src");
                if (!src || blobCache.getByUri(src)) {
                  return;
                }
                const resultUri = uploadStatus.getResultUri(src);
                if (resultUri) {
                  img.attr("src", resultUri);
                }
              });
            });
          });
          return {
            blobCache,
            addFilter,
            uploadImages,
            uploadImagesAuto,
            scanForImages,
            destroy: destroy2
          };
        };
        const get$1 = (editor) => {
          const dom2 = editor.dom;
          const schemaType = editor.schema.type;
          const formats = {
            valigntop: [{
              selector: "td,th",
              styles: { verticalAlign: "top" }
            }],
            valignmiddle: [{
              selector: "td,th",
              styles: { verticalAlign: "middle" }
            }],
            valignbottom: [{
              selector: "td,th",
              styles: { verticalAlign: "bottom" }
            }],
            alignleft: [
              {
                selector: "figure.image",
                collapsed: false,
                classes: "align-left",
                ceFalseOverride: true,
                preview: "font-family font-size"
              },
              {
                selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
                styles: { textAlign: "left" },
                inherit: false,
                preview: false
              },
              {
                selector: "img,audio,video",
                collapsed: false,
                styles: { float: "left" },
                preview: "font-family font-size"
              },
              {
                selector: "table",
                collapsed: false,
                styles: {
                  marginLeft: "0px",
                  marginRight: "auto"
                },
                onformat: (table2) => {
                  dom2.setStyle(table2, "float", null);
                },
                preview: "font-family font-size"
              },
              {
                selector: ".mce-preview-object,[data-ephox-embed-iri]",
                ceFalseOverride: true,
                styles: { float: "left" }
              }
            ],
            aligncenter: [
              {
                selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
                styles: { textAlign: "center" },
                inherit: false,
                preview: "font-family font-size"
              },
              {
                selector: "figure.image",
                collapsed: false,
                classes: "align-center",
                ceFalseOverride: true,
                preview: "font-family font-size"
              },
              {
                selector: "img,audio,video",
                collapsed: false,
                styles: {
                  display: "block",
                  marginLeft: "auto",
                  marginRight: "auto"
                },
                preview: false
              },
              {
                selector: "table",
                collapsed: false,
                styles: {
                  marginLeft: "auto",
                  marginRight: "auto"
                },
                preview: "font-family font-size"
              },
              {
                selector: ".mce-preview-object",
                ceFalseOverride: true,
                styles: {
                  display: "table",
                  marginLeft: "auto",
                  marginRight: "auto"
                },
                preview: false
              },
              {
                selector: "[data-ephox-embed-iri]",
                ceFalseOverride: true,
                styles: {
                  marginLeft: "auto",
                  marginRight: "auto"
                },
                preview: false
              }
            ],
            alignright: [
              {
                selector: "figure.image",
                collapsed: false,
                classes: "align-right",
                ceFalseOverride: true,
                preview: "font-family font-size"
              },
              {
                selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
                styles: { textAlign: "right" },
                inherit: false,
                preview: "font-family font-size"
              },
              {
                selector: "img,audio,video",
                collapsed: false,
                styles: { float: "right" },
                preview: "font-family font-size"
              },
              {
                selector: "table",
                collapsed: false,
                styles: {
                  marginRight: "0px",
                  marginLeft: "auto"
                },
                onformat: (table2) => {
                  dom2.setStyle(table2, "float", null);
                },
                preview: "font-family font-size"
              },
              {
                selector: ".mce-preview-object,[data-ephox-embed-iri]",
                ceFalseOverride: true,
                styles: { float: "right" },
                preview: false
              }
            ],
            alignjustify: [{
              selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
              styles: { textAlign: "justify" },
              inherit: false,
              preview: "font-family font-size"
            }],
            bold: [
              {
                inline: "strong",
                remove: "all",
                preserve_attributes: [
                  "class",
                  "style"
                ]
              },
              {
                inline: "span",
                styles: { fontWeight: "bold" }
              },
              {
                inline: "b",
                remove: "all",
                preserve_attributes: [
                  "class",
                  "style"
                ]
              }
            ],
            italic: [
              {
                inline: "em",
                remove: "all",
                preserve_attributes: [
                  "class",
                  "style"
                ]
              },
              {
                inline: "span",
                styles: { fontStyle: "italic" }
              },
              {
                inline: "i",
                remove: "all",
                preserve_attributes: [
                  "class",
                  "style"
                ]
              }
            ],
            underline: [
              {
                inline: "span",
                styles: { textDecoration: "underline" },
                exact: true
              },
              {
                inline: "u",
                remove: "all",
                preserve_attributes: [
                  "class",
                  "style"
                ]
              }
            ],
            strikethrough: (() => {
              const span = {
                inline: "span",
                styles: { textDecoration: "line-through" },
                exact: true
              };
              const strike = {
                inline: "strike",
                remove: "all",
                preserve_attributes: [
                  "class",
                  "style"
                ]
              };
              const s2 = {
                inline: "s",
                remove: "all",
                preserve_attributes: [
                  "class",
                  "style"
                ]
              };
              return schemaType !== "html4" ? [
                s2,
                span,
                strike
              ] : [
                span,
                s2,
                strike
              ];
            })(),
            forecolor: {
              inline: "span",
              styles: { color: "%value" },
              links: true,
              remove_similar: true,
              clear_child_styles: true
            },
            hilitecolor: {
              inline: "span",
              styles: { backgroundColor: "%value" },
              links: true,
              remove_similar: true,
              clear_child_styles: true
            },
            fontname: {
              inline: "span",
              toggle: false,
              styles: { fontFamily: "%value" },
              clear_child_styles: true
            },
            fontsize: {
              inline: "span",
              toggle: false,
              styles: { fontSize: "%value" },
              clear_child_styles: true
            },
            lineheight: {
              selector: "h1,h2,h3,h4,h5,h6,p,li,td,th,div",
              styles: { lineHeight: "%value" }
            },
            fontsize_class: {
              inline: "span",
              attributes: { class: "%value" }
            },
            blockquote: {
              block: "blockquote",
              wrapper: true,
              remove: "all"
            },
            subscript: { inline: "sub" },
            superscript: { inline: "sup" },
            code: { inline: "code" },
            link: {
              inline: "a",
              selector: "a",
              remove: "all",
              split: true,
              deep: true,
              onmatch: (node, _fmt, _itemName) => {
                return isElement$6(node) && node.hasAttribute("href");
              },
              onformat: (elm, _fmt, vars) => {
                Tools.each(vars, (value2, key) => {
                  dom2.setAttrib(elm, key, value2);
                });
              }
            },
            lang: {
              inline: "span",
              clear_child_styles: true,
              remove_similar: true,
              attributes: {
                "lang": "%value",
                "data-mce-lang": (vars) => {
                  var _a;
                  return (_a = vars === null || vars === void 0 ? void 0 : vars.customValue) !== null && _a !== void 0 ? _a : null;
                }
              }
            },
            removeformat: [
              {
                selector: "b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small",
                remove: "all",
                split: true,
                expand: false,
                block_expand: true,
                deep: true
              },
              {
                selector: "span",
                attributes: [
                  "style",
                  "class"
                ],
                remove: "empty",
                split: true,
                expand: false,
                deep: true
              },
              {
                selector: "*",
                attributes: [
                  "style",
                  "class"
                ],
                split: false,
                expand: false,
                deep: true
              }
            ]
          };
          Tools.each("p h1 h2 h3 h4 h5 h6 div address pre dt dd samp".split(/\s/), (name2) => {
            formats[name2] = {
              block: name2,
              remove: "all"
            };
          });
          return formats;
        };
        const genericBase = {
          remove_similar: true,
          inherit: false
        };
        const cellBase = {
          selector: "td,th",
          ...genericBase
        };
        const cellFormats = {
          tablecellbackgroundcolor: {
            styles: { backgroundColor: "%value" },
            ...cellBase
          },
          tablecellverticalalign: {
            styles: { "vertical-align": "%value" },
            ...cellBase
          },
          tablecellbordercolor: {
            styles: { borderColor: "%value" },
            ...cellBase
          },
          tablecellclass: {
            classes: ["%value"],
            ...cellBase
          },
          tableclass: {
            selector: "table",
            classes: ["%value"],
            ...genericBase
          },
          tablecellborderstyle: {
            styles: { borderStyle: "%value" },
            ...cellBase
          },
          tablecellborderwidth: {
            styles: { borderWidth: "%value" },
            ...cellBase
          }
        };
        const get = constant(cellFormats);
        const FormatRegistry = (editor) => {
          const formats = {};
          const get$22 = (name2) => isNonNullable(name2) ? formats[name2] : formats;
          const has2 = (name2) => has$2(formats, name2);
          const register2 = (name2, format) => {
            if (name2) {
              if (!isString(name2)) {
                each$d(name2, (format2, name3) => {
                  register2(name3, format2);
                });
              } else {
                if (!isArray$1(format)) {
                  format = [format];
                }
                each$e(format, (format2) => {
                  if (isUndefined(format2.deep)) {
                    format2.deep = !isSelectorFormat(format2);
                  }
                  if (isUndefined(format2.split)) {
                    format2.split = !isSelectorFormat(format2) || isInlineFormat(format2);
                  }
                  if (isUndefined(format2.remove) && isSelectorFormat(format2) && !isInlineFormat(format2)) {
                    format2.remove = "none";
                  }
                  if (isSelectorFormat(format2) && isInlineFormat(format2)) {
                    format2.mixed = true;
                    format2.block_expand = true;
                  }
                  if (isString(format2.classes)) {
                    format2.classes = format2.classes.split(/\s+/);
                  }
                });
                formats[name2] = format;
              }
            }
          };
          const unregister = (name2) => {
            if (name2 && formats[name2]) {
              delete formats[name2];
            }
            return formats;
          };
          register2(get$1(editor));
          register2(get());
          register2(getFormats(editor));
          return {
            get: get$22,
            has: has2,
            register: register2,
            unregister
          };
        };
        const each$3 = Tools.each;
        const dom = DOMUtils.DOM;
        const isPreviewItem = (item) => isNonNullable(item) && isObject(item);
        const parsedSelectorToHtml = (ancestry, editor) => {
          const schema = editor && editor.schema || Schema({});
          const decorate = (elm, item) => {
            if (item.classes.length > 0) {
              dom.addClass(elm, item.classes.join(" "));
            }
            dom.setAttribs(elm, item.attrs);
          };
          const createElement = (sItem) => {
            const item = isString(sItem) ? {
              name: sItem,
              classes: [],
              attrs: {}
            } : sItem;
            const elm = dom.create(item.name);
            decorate(elm, item);
            return elm;
          };
          const getRequiredParent = (elm, candidate) => {
            const elmRule = schema.getElementRule(elm.nodeName.toLowerCase());
            const parentsRequired = elmRule === null || elmRule === void 0 ? void 0 : elmRule.parentsRequired;
            if (parentsRequired && parentsRequired.length) {
              return candidate && contains$2(parentsRequired, candidate) ? candidate : parentsRequired[0];
            } else {
              return false;
            }
          };
          const wrapInHtml = (elm, ancestors, siblings2) => {
            let parentCandidate;
            const ancestor2 = ancestors[0];
            const ancestorName = isPreviewItem(ancestor2) ? ancestor2.name : void 0;
            const parentRequired = getRequiredParent(elm, ancestorName);
            if (parentRequired) {
              if (ancestorName === parentRequired) {
                parentCandidate = ancestor2;
                ancestors = ancestors.slice(1);
              } else {
                parentCandidate = parentRequired;
              }
            } else if (ancestor2) {
              parentCandidate = ancestor2;
              ancestors = ancestors.slice(1);
            } else if (!siblings2) {
              return elm;
            }
            const parent2 = parentCandidate ? createElement(parentCandidate) : dom.create("div");
            parent2.appendChild(elm);
            if (siblings2) {
              Tools.each(siblings2, (sibling2) => {
                const siblingElm = createElement(sibling2);
                parent2.insertBefore(siblingElm, elm);
              });
            }
            const parentSiblings = isPreviewItem(parentCandidate) ? parentCandidate.siblings : void 0;
            return wrapInHtml(parent2, ancestors, parentSiblings);
          };
          const fragment = dom.create("div");
          if (ancestry.length > 0) {
            const item = ancestry[0];
            const elm = createElement(item);
            const siblings2 = isPreviewItem(item) ? item.siblings : void 0;
            fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), siblings2));
          }
          return fragment;
        };
        const parseSelectorItem = (item) => {
          item = Tools.trim(item);
          let tagName = "div";
          const obj = {
            name: tagName,
            classes: [],
            attrs: {},
            selector: item
          };
          if (item !== "*") {
            tagName = item.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, ($0, $1, $22, $32, $42) => {
              switch ($1) {
                case "#":
                  obj.attrs.id = $22;
                  break;
                case ".":
                  obj.classes.push($22);
                  break;
                case ":":
                  if (Tools.inArray("checked disabled enabled read-only required".split(" "), $22) !== -1) {
                    obj.attrs[$22] = $22;
                  }
                  break;
              }
              if ($32 === "[") {
                const m2 = $42.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
                if (m2) {
                  obj.attrs[m2[1]] = m2[2];
                }
              }
              return "";
            });
          }
          obj.name = tagName || "div";
          return obj;
        };
        const parseSelector2 = (selector) => {
          if (!isString(selector)) {
            return [];
          }
          selector = selector.split(/\s*,\s*/)[0];
          selector = selector.replace(/\s*(~\+|~|\+|>)\s*/g, "$1");
          return Tools.map(selector.split(/(?:>|\s+(?![^\[\]]+\]))/), (item) => {
            const siblings2 = Tools.map(item.split(/(?:~\+|~|\+)/), parseSelectorItem);
            const obj = siblings2.pop();
            if (siblings2.length) {
              obj.siblings = siblings2;
            }
            return obj;
          }).reverse();
        };
        const getCssText = (editor, format) => {
          let previewCss = "";
          let previewStyles = getPreviewStyles(editor);
          if (previewStyles === "") {
            return "";
          }
          const removeVars = (val) => {
            return isString(val) ? val.replace(/%(\w+)/g, "") : "";
          };
          const getComputedStyle3 = (name3, elm) => {
            return dom.getStyle(elm !== null && elm !== void 0 ? elm : editor.getBody(), name3, true);
          };
          if (isString(format)) {
            const formats = editor.formatter.get(format);
            if (!formats) {
              return "";
            }
            format = formats[0];
          }
          if ("preview" in format) {
            const preview = format.preview;
            if (preview === false) {
              return "";
            } else {
              previewStyles = preview || previewStyles;
            }
          }
          let name2 = format.block || format.inline || "span";
          let previewFrag;
          const items = parseSelector2(format.selector);
          if (items.length > 0) {
            if (!items[0].name) {
              items[0].name = name2;
            }
            name2 = format.selector;
            previewFrag = parsedSelectorToHtml(items, editor);
          } else {
            previewFrag = parsedSelectorToHtml([name2], editor);
          }
          const previewElm = dom.select(name2, previewFrag)[0] || previewFrag.firstChild;
          each$3(format.styles, (value2, name3) => {
            const newValue = removeVars(value2);
            if (newValue) {
              dom.setStyle(previewElm, name3, newValue);
            }
          });
          each$3(format.attributes, (value2, name3) => {
            const newValue = removeVars(value2);
            if (newValue) {
              dom.setAttrib(previewElm, name3, newValue);
            }
          });
          each$3(format.classes, (value2) => {
            const newValue = removeVars(value2);
            if (!dom.hasClass(previewElm, newValue)) {
              dom.addClass(previewElm, newValue);
            }
          });
          editor.dispatch("PreviewFormats");
          dom.setStyles(previewFrag, {
            position: "absolute",
            left: -65535
          });
          editor.getBody().appendChild(previewFrag);
          const rawParentFontSize = getComputedStyle3("fontSize");
          const parentFontSize = /px$/.test(rawParentFontSize) ? parseInt(rawParentFontSize, 10) : 0;
          each$3(previewStyles.split(" "), (name3) => {
            let value2 = getComputedStyle3(name3, previewElm);
            if (name3 === "background-color" && /transparent|rgba\s*\([^)]+,\s*0\)/.test(value2)) {
              value2 = getComputedStyle3(name3);
              if (rgbaToHexString(value2).toLowerCase() === "#ffffff") {
                return;
              }
            }
            if (name3 === "color") {
              if (rgbaToHexString(value2).toLowerCase() === "#000000") {
                return;
              }
            }
            if (name3 === "font-size") {
              if (/em|%$/.test(value2)) {
                if (parentFontSize === 0) {
                  return;
                }
                const numValue = parseFloat(value2) / (/%$/.test(value2) ? 100 : 1);
                value2 = numValue * parentFontSize + "px";
              }
            }
            if (name3 === "border" && value2) {
              previewCss += "padding:0 2px;";
            }
            previewCss += name3 + ":" + value2 + ";";
          });
          editor.dispatch("AfterPreviewFormats");
          dom.remove(previewFrag);
          return previewCss;
        };
        const setup$r = (editor) => {
          editor.addShortcut("meta+b", "", "Bold");
          editor.addShortcut("meta+i", "", "Italic");
          editor.addShortcut("meta+u", "", "Underline");
          for (let i2 = 1; i2 <= 6; i2++) {
            editor.addShortcut("access+" + i2, "", [
              "FormatBlock",
              false,
              "h" + i2
            ]);
          }
          editor.addShortcut("access+7", "", [
            "FormatBlock",
            false,
            "p"
          ]);
          editor.addShortcut("access+8", "", [
            "FormatBlock",
            false,
            "div"
          ]);
          editor.addShortcut("access+9", "", [
            "FormatBlock",
            false,
            "address"
          ]);
        };
        const Formatter = (editor) => {
          const formats = FormatRegistry(editor);
          const formatChangeState = Cell({});
          setup$r(editor);
          setup$u(editor);
          if (!isRtc(editor)) {
            setup$t(formatChangeState, editor);
          }
          return {
            get: formats.get,
            has: formats.has,
            register: formats.register,
            unregister: formats.unregister,
            apply: (name2, vars, node) => {
              applyFormat(editor, name2, vars, node);
            },
            remove: (name2, vars, node, similar) => {
              removeFormat(editor, name2, vars, node, similar);
            },
            toggle: (name2, vars, node) => {
              toggleFormat(editor, name2, vars, node);
            },
            match: (name2, vars, node, similar) => matchFormat(editor, name2, vars, node, similar),
            closest: (names) => closestFormat(editor, names),
            matchAll: (names, vars) => matchAllFormats(editor, names, vars),
            matchNode: (node, name2, vars, similar) => matchNodeFormat(editor, node, name2, vars, similar),
            canApply: (name2) => canApplyFormat(editor, name2),
            formatChanged: (formats2, callback, similar, vars) => formatChanged(editor, formatChangeState, formats2, callback, similar, vars),
            getCssText: curry(getCssText, editor)
          };
        };
        const shouldIgnoreCommand = (cmd) => {
          switch (cmd.toLowerCase()) {
            case "undo":
            case "redo":
            case "mcefocus":
              return true;
            default:
              return false;
          }
        };
        const registerEvents = (editor, undoManager, locks) => {
          const isFirstTypedCharacter = Cell(false);
          const addNonTypingUndoLevel = (e2) => {
            setTyping(undoManager, false, locks);
            undoManager.add({}, e2);
          };
          editor.on("init", () => {
            undoManager.add();
          });
          editor.on("BeforeExecCommand", (e2) => {
            const cmd = e2.command;
            if (!shouldIgnoreCommand(cmd)) {
              endTyping(undoManager, locks);
              undoManager.beforeChange();
            }
          });
          editor.on("ExecCommand", (e2) => {
            const cmd = e2.command;
            if (!shouldIgnoreCommand(cmd)) {
              addNonTypingUndoLevel(e2);
            }
          });
          editor.on("ObjectResizeStart cut", () => {
            undoManager.beforeChange();
          });
          editor.on("SaveContent ObjectResized blur", addNonTypingUndoLevel);
          editor.on("dragend", addNonTypingUndoLevel);
          editor.on("keyup", (e2) => {
            const keyCode = e2.keyCode;
            if (e2.isDefaultPrevented()) {
              return;
            }
            const isMeta = Env.os.isMacOS() && e2.key === "Meta";
            if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e2.ctrlKey || isMeta) {
              addNonTypingUndoLevel();
              editor.nodeChanged();
            }
            if (keyCode === 46 || keyCode === 8) {
              editor.nodeChanged();
            }
            if (isFirstTypedCharacter.get() && undoManager.typing && !isEq$1(createFromEditor(editor), undoManager.data[0])) {
              if (!editor.isDirty()) {
                editor.setDirty(true);
              }
              editor.dispatch("TypingUndo");
              isFirstTypedCharacter.set(false);
              editor.nodeChanged();
            }
          });
          editor.on("keydown", (e2) => {
            const keyCode = e2.keyCode;
            if (e2.isDefaultPrevented()) {
              return;
            }
            if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {
              if (undoManager.typing) {
                addNonTypingUndoLevel(e2);
              }
              return;
            }
            const modKey = e2.ctrlKey && !e2.altKey || e2.metaKey;
            if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {
              undoManager.beforeChange();
              setTyping(undoManager, true, locks);
              undoManager.add({}, e2);
              isFirstTypedCharacter.set(true);
              return;
            }
            const hasOnlyMetaOrCtrlModifier = Env.os.isMacOS() ? e2.metaKey : e2.ctrlKey && !e2.altKey;
            if (hasOnlyMetaOrCtrlModifier) {
              undoManager.beforeChange();
            }
          });
          editor.on("mousedown", (e2) => {
            if (undoManager.typing) {
              addNonTypingUndoLevel(e2);
            }
          });
          const isInsertReplacementText = (event) => event.inputType === "insertReplacementText";
          const isInsertTextDataNull = (event) => event.inputType === "insertText" && event.data === null;
          const isInsertFromPasteOrDrop = (event) => event.inputType === "insertFromPaste" || event.inputType === "insertFromDrop";
          editor.on("input", (e2) => {
            if (e2.inputType && (isInsertReplacementText(e2) || isInsertTextDataNull(e2) || isInsertFromPasteOrDrop(e2))) {
              addNonTypingUndoLevel(e2);
            }
          });
          editor.on("AddUndo Undo Redo ClearUndos", (e2) => {
            if (!e2.isDefaultPrevented()) {
              editor.nodeChanged();
            }
          });
        };
        const addKeyboardShortcuts = (editor) => {
          editor.addShortcut("meta+z", "", "Undo");
          editor.addShortcut("meta+y,meta+shift+z", "", "Redo");
        };
        const UndoManager = (editor) => {
          const beforeBookmark = value$2();
          const locks = Cell(0);
          const index = Cell(0);
          const undoManager = {
            data: [],
            typing: false,
            beforeChange: () => {
              beforeChange(editor, locks, beforeBookmark);
            },
            add: (level, event) => {
              return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);
            },
            dispatchChange: () => {
              editor.setDirty(true);
              const level = createFromEditor(editor);
              level.bookmark = getUndoBookmark(editor.selection);
              editor.dispatch("change", {
                level,
                lastLevel: get$b(undoManager.data, index.get()).getOrUndefined()
              });
            },
            undo: () => {
              return undo(editor, undoManager, locks, index);
            },
            redo: () => {
              return redo(editor, index, undoManager.data);
            },
            clear: () => {
              clear(editor, undoManager, index);
            },
            reset: () => {
              reset(editor, undoManager);
            },
            hasUndo: () => {
              return hasUndo(editor, undoManager, index);
            },
            hasRedo: () => {
              return hasRedo(editor, undoManager, index);
            },
            transact: (callback) => {
              return transact(editor, undoManager, locks, callback);
            },
            ignore: (callback) => {
              ignore(editor, locks, callback);
            },
            extra: (callback1, callback2) => {
              extra(editor, undoManager, index, callback1, callback2);
            }
          };
          if (!isRtc(editor)) {
            registerEvents(editor, undoManager, locks);
          }
          addKeyboardShortcuts(editor);
          return undoManager;
        };
        const nonTypingKeycodes = [
          9,
          27,
          VK.HOME,
          VK.END,
          19,
          20,
          44,
          144,
          145,
          33,
          34,
          45,
          16,
          17,
          18,
          91,
          92,
          93,
          VK.DOWN,
          VK.UP,
          VK.LEFT,
          VK.RIGHT
        ].concat(Env.browser.isFirefox() ? [224] : []);
        const placeholderAttr = "data-mce-placeholder";
        const isKeyboardEvent = (e2) => e2.type === "keydown" || e2.type === "keyup";
        const isDeleteEvent = (e2) => {
          const keyCode = e2.keyCode;
          return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;
        };
        const isNonTypingKeyboardEvent = (e2) => {
          if (isKeyboardEvent(e2)) {
            const keyCode = e2.keyCode;
            return !isDeleteEvent(e2) && (VK.metaKeyPressed(e2) || e2.altKey || keyCode >= 112 && keyCode <= 123 || contains$2(nonTypingKeycodes, keyCode));
          } else {
            return false;
          }
        };
        const isTypingKeyboardEvent = (e2) => isKeyboardEvent(e2) && !(isDeleteEvent(e2) || e2.type === "keyup" && e2.keyCode === 229);
        const isVisuallyEmpty = (dom2, rootElm, forcedRootBlock) => {
          if (isEmpty$2(SugarElement.fromDom(rootElm), false)) {
            const firstElement2 = rootElm.firstElementChild;
            if (!firstElement2) {
              return true;
            } else if (dom2.getStyle(rootElm.firstElementChild, "padding-left") || dom2.getStyle(rootElm.firstElementChild, "padding-right")) {
              return false;
            } else {
              return forcedRootBlock === firstElement2.nodeName.toLowerCase();
            }
          } else {
            return false;
          }
        };
        const setup$q = (editor) => {
          var _a;
          const dom2 = editor.dom;
          const rootBlock = getForcedRootBlock(editor);
          const placeholder = (_a = getPlaceholder(editor)) !== null && _a !== void 0 ? _a : "";
          const updatePlaceholder = (e2, initial) => {
            if (isNonTypingKeyboardEvent(e2)) {
              return;
            }
            const body = editor.getBody();
            const showPlaceholder = isTypingKeyboardEvent(e2) ? false : isVisuallyEmpty(dom2, body, rootBlock);
            const isPlaceholderShown = dom2.getAttrib(body, placeholderAttr) !== "";
            if (isPlaceholderShown !== showPlaceholder || initial) {
              dom2.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);
              dom2.setAttrib(body, "aria-placeholder", showPlaceholder ? placeholder : null);
              firePlaceholderToggle(editor, showPlaceholder);
              editor.on(showPlaceholder ? "keydown" : "keyup", updatePlaceholder);
              editor.off(showPlaceholder ? "keyup" : "keydown", updatePlaceholder);
            }
          };
          if (isNotEmpty(placeholder)) {
            editor.on("init", (e2) => {
              updatePlaceholder(e2, true);
              editor.on("change SetContent ExecCommand", updatePlaceholder);
              editor.on("paste", (e3) => Delay.setEditorTimeout(editor, () => updatePlaceholder(e3)));
            });
          }
        };
        const blockPosition = (block, position) => ({
          block,
          position
        });
        const blockBoundary = (from2, to) => ({
          from: from2,
          to
        });
        const getBlockPosition = (rootNode, pos) => {
          const rootElm = SugarElement.fromDom(rootNode);
          const containerElm = SugarElement.fromDom(pos.container());
          return getParentBlock$2(rootElm, containerElm).map((block) => blockPosition(block, pos));
        };
        const isDifferentBlocks = (blockBoundary2) => !eq(blockBoundary2.from.block, blockBoundary2.to.block);
        const getClosestHost = (root, scope) => {
          const isRoot2 = (node) => eq(node, root);
          const isHost = (node) => isTableCell$2(node) || isContentEditableTrue$3(node.dom);
          return closest$4(scope, isHost, isRoot2).filter(isElement$7).getOr(root);
        };
        const hasSameHost = (rootNode, blockBoundary2) => {
          const root = SugarElement.fromDom(rootNode);
          return eq(getClosestHost(root, blockBoundary2.from.block), getClosestHost(root, blockBoundary2.to.block));
        };
        const isEditable$1 = (blockBoundary2) => isContentEditableFalse$b(blockBoundary2.from.block.dom) === false && isContentEditableFalse$b(blockBoundary2.to.block.dom) === false;
        const hasValidBlocks = (blockBoundary2) => {
          const isValidBlock = (block) => isTextBlock$2(block) || hasBlockAttr(block.dom);
          return isValidBlock(blockBoundary2.from.block) && isValidBlock(blockBoundary2.to.block);
        };
        const skipLastBr = (rootNode, forward, blockPosition2) => {
          if (isBr$6(blockPosition2.position.getNode()) && !isEmpty$2(blockPosition2.block)) {
            return positionIn(false, blockPosition2.block.dom).bind((lastPositionInBlock) => {
              if (lastPositionInBlock.isEqual(blockPosition2.position)) {
                return fromPosition(forward, rootNode, lastPositionInBlock).bind((to) => getBlockPosition(rootNode, to));
              } else {
                return Optional.some(blockPosition2);
              }
            }).getOr(blockPosition2);
          } else {
            return blockPosition2;
          }
        };
        const readFromRange = (rootNode, forward, rng) => {
          const fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));
          const toBlockPos = fromBlockPos.bind((blockPos) => fromPosition(forward, rootNode, blockPos.position).bind((to) => getBlockPosition(rootNode, to).map((blockPos2) => skipLastBr(rootNode, forward, blockPos2))));
          return lift2(fromBlockPos, toBlockPos, blockBoundary).filter((blockBoundary2) => isDifferentBlocks(blockBoundary2) && hasSameHost(rootNode, blockBoundary2) && isEditable$1(blockBoundary2) && hasValidBlocks(blockBoundary2));
        };
        const read$1 = (rootNode, forward, rng) => rng.collapsed ? readFromRange(rootNode, forward, rng) : Optional.none();
        const getChildrenUntilBlockBoundary = (block) => {
          const children2 = children$1(block);
          return findIndex$2(children2, isBlock$2).fold(constant(children2), (index) => children2.slice(0, index));
        };
        const extractChildren = (block) => {
          const children2 = getChildrenUntilBlockBoundary(block);
          each$e(children2, remove$5);
          return children2;
        };
        const removeEmptyRoot = (rootNode, block) => {
          const parents2 = parentsAndSelf(block, rootNode);
          return find$2(parents2.reverse(), (element) => isEmpty$2(element)).each(remove$5);
        };
        const isEmptyBefore = (el) => filter$5(prevSiblings(el), (el2) => !isEmpty$2(el2)).length === 0;
        const nestedBlockMerge = (rootNode, fromBlock, toBlock, insertionPoint) => {
          if (isEmpty$2(toBlock)) {
            fillWithPaddingBr(toBlock);
            return firstPositionIn(toBlock.dom);
          }
          if (isEmptyBefore(insertionPoint) && isEmpty$2(fromBlock)) {
            before$3(insertionPoint, SugarElement.fromTag("br"));
          }
          const position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));
          each$e(extractChildren(fromBlock), (child2) => {
            before$3(insertionPoint, child2);
          });
          removeEmptyRoot(rootNode, fromBlock);
          return position;
        };
        const sidelongBlockMerge = (rootNode, fromBlock, toBlock) => {
          if (isEmpty$2(toBlock)) {
            if (isEmpty$2(fromBlock)) {
              const getInlineToBlockDescendants = (el) => {
                const helper = (node, elements) => firstChild(node).fold(() => elements, (child2) => isInline$1(child2) ? helper(child2, elements.concat(shallow$1(child2))) : elements);
                return helper(el, []);
              };
              const newFromBlockDescendants = foldr(getInlineToBlockDescendants(toBlock), (element, descendant2) => {
                wrap$2(element, descendant2);
                return descendant2;
              }, createPaddingBr());
              empty(fromBlock);
              append$1(fromBlock, newFromBlockDescendants);
            }
            remove$5(toBlock);
            return firstPositionIn(fromBlock.dom);
          }
          const position = lastPositionIn(toBlock.dom);
          each$e(extractChildren(fromBlock), (child2) => {
            append$1(toBlock, child2);
          });
          removeEmptyRoot(rootNode, fromBlock);
          return position;
        };
        const findInsertionPoint = (toBlock, block) => {
          const parentsAndSelf$1 = parentsAndSelf(block, toBlock);
          return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);
        };
        const getInsertionPoint = (fromBlock, toBlock) => contains2(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();
        const trimBr = (first2, block) => {
          positionIn(first2, block.dom).bind((position) => Optional.from(position.getNode())).map(SugarElement.fromDom).filter(isBr$5).each(remove$5);
        };
        const mergeBlockInto = (rootNode, fromBlock, toBlock) => {
          trimBr(true, fromBlock);
          trimBr(false, toBlock);
          return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock), curry(nestedBlockMerge, rootNode, fromBlock, toBlock));
        };
        const mergeBlocks = (rootNode, forward, block1, block2) => forward ? mergeBlockInto(rootNode, block2, block1) : mergeBlockInto(rootNode, block1, block2);
        const backspaceDelete$8 = (editor, forward) => {
          const rootNode = SugarElement.fromDom(editor.getBody());
          const position = read$1(rootNode.dom, forward, editor.selection.getRng()).map((blockBoundary2) => () => {
            mergeBlocks(rootNode, forward, blockBoundary2.from.block, blockBoundary2.to.block).each((pos) => {
              editor.selection.setRng(pos.toRange());
            });
          });
          return position;
        };
        const deleteRangeMergeBlocks = (rootNode, selection) => {
          const rng = selection.getRng();
          return lift2(getParentBlock$2(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$2(rootNode, SugarElement.fromDom(rng.endContainer)), (block1, block2) => {
            if (!eq(block1, block2)) {
              return Optional.some(() => {
                rng.deleteContents();
                mergeBlocks(rootNode, true, block1, block2).each((pos) => {
                  selection.setRng(pos.toRange());
                });
              });
            } else {
              return Optional.none();
            }
          }).getOr(Optional.none());
        };
        const isRawNodeInTable = (root, rawNode) => {
          const node = SugarElement.fromDom(rawNode);
          const isRoot2 = curry(eq, root);
          return ancestor$4(node, isTableCell$2, isRoot2).isSome();
        };
        const isSelectionInTable = (root, rng) => isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);
        const isEverythingSelected = (root, rng) => {
          const noPrevious = prevPosition(root.dom, CaretPosition.fromRangeStart(rng)).isNone();
          const noNext = nextPosition(root.dom, CaretPosition.fromRangeEnd(rng)).isNone();
          return !isSelectionInTable(root, rng) && noPrevious && noNext;
        };
        const emptyEditor = (editor) => {
          return Optional.some(() => {
            editor.setContent("");
            editor.selection.setCursorLocation();
          });
        };
        const deleteRange$2 = (editor) => {
          const rootNode = SugarElement.fromDom(editor.getBody());
          const rng = editor.selection.getRng();
          return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection);
        };
        const backspaceDelete$7 = (editor, _forward) => editor.selection.isCollapsed() ? Optional.none() : deleteRange$2(editor);
        const showCaret = (direction, editor, node, before2, scrollIntoView) => Optional.from(editor._selectionOverrides.showCaret(direction, node, before2, scrollIntoView));
        const getNodeRange = (node) => {
          const rng = node.ownerDocument.createRange();
          rng.selectNode(node);
          return rng;
        };
        const selectNode = (editor, node) => {
          const e2 = editor.dispatch("BeforeObjectSelected", { target: node });
          if (e2.isDefaultPrevented()) {
            return Optional.none();
          }
          return Optional.some(getNodeRange(node));
        };
        const renderCaretAtRange = (editor, range2, scrollIntoView) => {
          const normalizedRange = normalizeRange(1, editor.getBody(), range2);
          const caretPosition = CaretPosition.fromRangeStart(normalizedRange);
          const caretPositionNode = caretPosition.getNode();
          if (isInlineFakeCaretTarget(caretPositionNode)) {
            return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);
          }
          const caretPositionBeforeNode = caretPosition.getNode(true);
          if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {
            return showCaret(1, editor, caretPositionBeforeNode, false, false);
          }
          const ceRoot = getContentEditableRoot$1(editor.dom.getRoot(), caretPosition.getNode());
          if (isInlineFakeCaretTarget(ceRoot)) {
            return showCaret(1, editor, ceRoot, false, scrollIntoView);
          }
          return Optional.none();
        };
        const renderRangeCaret = (editor, range2, scrollIntoView) => range2.collapsed ? renderCaretAtRange(editor, range2, scrollIntoView).getOr(range2) : range2;
        const isBeforeBoundary = (pos) => isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);
        const isAfterBoundary = (pos) => isAfterContentEditableFalse(pos) || isAfterMedia(pos);
        const trimEmptyTextNode = (dom2, node) => {
          if (isText$a(node) && node.data.length === 0) {
            dom2.remove(node);
          }
        };
        const deleteContentAndShowCaret = (editor, range2, node, direction, forward, peekCaretPosition) => {
          showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each((caretRange) => {
            if (range2.collapsed) {
              const deleteRange2 = range2.cloneRange();
              if (forward) {
                deleteRange2.setEnd(caretRange.startContainer, caretRange.startOffset);
              } else {
                deleteRange2.setStart(caretRange.endContainer, caretRange.endOffset);
              }
              deleteRange2.deleteContents();
            } else {
              range2.deleteContents();
            }
            editor.selection.setRng(caretRange);
          });
          trimEmptyTextNode(editor.dom, node);
        };
        const deleteBoundaryText = (editor, forward) => {
          const range2 = editor.selection.getRng();
          if (!isText$a(range2.commonAncestorContainer)) {
            return Optional.none();
          }
          const direction = forward ? HDirection.Forwards : HDirection.Backwards;
          const caretWalker = CaretWalker(editor.getBody());
          const getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);
          const isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;
          const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range2);
          const nextCaretPosition = getNextPosFn(caretPosition);
          const normalizedNextCaretPosition = nextCaretPosition ? normalizePosition(forward, nextCaretPosition) : nextCaretPosition;
          if (!normalizedNextCaretPosition || !isMoveInsideSameBlock(caretPosition, normalizedNextCaretPosition)) {
            return Optional.none();
          } else if (isBeforeFn(normalizedNextCaretPosition)) {
            return Optional.some(() => deleteContentAndShowCaret(editor, range2, caretPosition.getNode(), direction, forward, normalizedNextCaretPosition));
          }
          const peekCaretPosition = getNextPosFn(normalizedNextCaretPosition);
          if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
            if (isMoveInsideSameBlock(normalizedNextCaretPosition, peekCaretPosition)) {
              return Optional.some(() => deleteContentAndShowCaret(editor, range2, caretPosition.getNode(), direction, forward, peekCaretPosition));
            }
          }
          return Optional.none();
        };
        const backspaceDelete$6 = (editor, forward) => deleteBoundaryText(editor, forward);
        const getEdgeCefPosition = (editor, atStart) => {
          const root = editor.getBody();
          return atStart ? firstPositionIn(root).filter(isBeforeContentEditableFalse) : lastPositionIn(root).filter(isAfterContentEditableFalse);
        };
        const isCefAtEdgeSelected = (editor) => {
          const rng = editor.selection.getRng();
          return !rng.collapsed && (getEdgeCefPosition(editor, true).exists((pos) => pos.isEqual(CaretPosition.fromRangeStart(rng))) || getEdgeCefPosition(editor, false).exists((pos) => pos.isEqual(CaretPosition.fromRangeEnd(rng))));
        };
        const isCompoundElement = (node) => isNonNullable(node) && (isTableCell$2(SugarElement.fromDom(node)) || isListItem$1(SugarElement.fromDom(node)));
        const DeleteAction = Adt.generate([
          { remove: ["element"] },
          { moveToElement: ["element"] },
          { moveToPosition: ["position"] }
        ]);
        const isAtContentEditableBlockCaret = (forward, from2) => {
          const elm = from2.getNode(!forward);
          const caretLocation = forward ? "after" : "before";
          return isElement$6(elm) && elm.getAttribute("data-mce-caret") === caretLocation;
        };
        const isDeleteFromCefDifferentBlocks = (root, forward, from2, to) => {
          const inSameBlock = (elm) => isInline$1(SugarElement.fromDom(elm)) && !isInSameBlock(from2, to, root);
          return getRelativeCefElm(!forward, from2).fold(() => getRelativeCefElm(forward, to).fold(never, inSameBlock), inSameBlock);
        };
        const deleteEmptyBlockOrMoveToCef = (root, forward, from2, to) => {
          const toCefElm = to.getNode(!forward);
          return getParentBlock$2(SugarElement.fromDom(root), SugarElement.fromDom(from2.getNode())).map((blockElm) => isEmpty$2(blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm)).orThunk(() => Optional.some(DeleteAction.moveToElement(toCefElm)));
        };
        const findCefPosition = (root, forward, from2) => fromPosition(forward, root, from2).bind((to) => {
          if (isCompoundElement(to.getNode())) {
            return Optional.none();
          } else if (isDeleteFromCefDifferentBlocks(root, forward, from2, to)) {
            return Optional.none();
          } else if (forward && isContentEditableFalse$b(to.getNode())) {
            return deleteEmptyBlockOrMoveToCef(root, forward, from2, to);
          } else if (!forward && isContentEditableFalse$b(to.getNode(true))) {
            return deleteEmptyBlockOrMoveToCef(root, forward, from2, to);
          } else if (forward && isAfterContentEditableFalse(from2)) {
            return Optional.some(DeleteAction.moveToPosition(to));
          } else if (!forward && isBeforeContentEditableFalse(from2)) {
            return Optional.some(DeleteAction.moveToPosition(to));
          } else {
            return Optional.none();
          }
        });
        const getContentEditableBlockAction = (forward, elm) => {
          if (isNullable(elm)) {
            return Optional.none();
          } else if (forward && isContentEditableFalse$b(elm.nextSibling)) {
            return Optional.some(DeleteAction.moveToElement(elm.nextSibling));
          } else if (!forward && isContentEditableFalse$b(elm.previousSibling)) {
            return Optional.some(DeleteAction.moveToElement(elm.previousSibling));
          } else {
            return Optional.none();
          }
        };
        const skipMoveToActionFromInlineCefToContent = (root, from2, deleteAction2) => deleteAction2.fold((elm) => Optional.some(DeleteAction.remove(elm)), (elm) => Optional.some(DeleteAction.moveToElement(elm)), (to) => {
          if (isInSameBlock(from2, to, root)) {
            return Optional.none();
          } else {
            return Optional.some(DeleteAction.moveToPosition(to));
          }
        });
        const getContentEditableAction = (root, forward, from2) => {
          if (isAtContentEditableBlockCaret(forward, from2)) {
            return getContentEditableBlockAction(forward, from2.getNode(!forward)).orThunk(() => findCefPosition(root, forward, from2));
          } else {
            return findCefPosition(root, forward, from2).bind((deleteAction2) => skipMoveToActionFromInlineCefToContent(root, from2, deleteAction2));
          }
        };
        const read2 = (root, forward, rng) => {
          const normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);
          const from2 = CaretPosition.fromRangeStart(normalizedRange);
          const rootElement = SugarElement.fromDom(root);
          if (!forward && isAfterContentEditableFalse(from2)) {
            return Optional.some(DeleteAction.remove(from2.getNode(true)));
          } else if (forward && isBeforeContentEditableFalse(from2)) {
            return Optional.some(DeleteAction.remove(from2.getNode()));
          } else if (!forward && isBeforeContentEditableFalse(from2) && isAfterBr(rootElement, from2)) {
            return findPreviousBr(rootElement, from2).map((br) => DeleteAction.remove(br.getNode()));
          } else if (forward && isAfterContentEditableFalse(from2) && isBeforeBr$1(rootElement, from2)) {
            return findNextBr(rootElement, from2).map((br) => DeleteAction.remove(br.getNode()));
          } else {
            return getContentEditableAction(root, forward, from2);
          }
        };
        const deleteElement$1 = (editor, forward) => (element) => {
          editor._selectionOverrides.hideFakeCaret();
          deleteElement$2(editor, forward, SugarElement.fromDom(element));
          return true;
        };
        const moveToElement = (editor, forward) => (element) => {
          const pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);
          editor.selection.setRng(pos.toRange());
          return true;
        };
        const moveToPosition = (editor) => (pos) => {
          editor.selection.setRng(pos.toRange());
          return true;
        };
        const getAncestorCe = (editor, node) => Optional.from(getContentEditableRoot$1(editor.getBody(), node));
        const backspaceDeleteCaret = (editor, forward) => {
          const selectedNode = editor.selection.getNode();
          return getAncestorCe(editor, selectedNode).filter(isContentEditableFalse$b).fold(() => read2(editor.getBody(), forward, editor.selection.getRng()).map((deleteAction2) => () => deleteAction2.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor))), () => Optional.some(noop2));
        };
        const deleteOffscreenSelection = (rootElement) => {
          each$e(descendants(rootElement, ".mce-offscreen-selection"), remove$5);
        };
        const backspaceDeleteRange = (editor, forward) => {
          const selectedNode = editor.selection.getNode();
          if (isContentEditableFalse$b(selectedNode) && !isTableCell$3(selectedNode)) {
            const hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse$b);
            return hasCefAncestor.fold(() => Optional.some(() => {
              deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));
              deleteElement$2(editor, forward, SugarElement.fromDom(editor.selection.getNode()));
              paddEmptyBody(editor);
            }), () => Optional.some(noop2));
          }
          if (isCefAtEdgeSelected(editor)) {
            return Optional.some(() => {
              deleteRangeContents(editor, editor.selection.getRng(), SugarElement.fromDom(editor.getBody()));
            });
          }
          return Optional.none();
        };
        const paddEmptyElement = (editor) => {
          const dom2 = editor.dom, selection = editor.selection;
          const ceRoot = getContentEditableRoot$1(editor.getBody(), selection.getNode());
          if (isContentEditableTrue$3(ceRoot) && dom2.isBlock(ceRoot) && dom2.isEmpty(ceRoot)) {
            const br = dom2.create("br", { "data-mce-bogus": "1" });
            dom2.setHTML(ceRoot, "");
            ceRoot.appendChild(br);
            selection.setRng(CaretPosition.before(br).toRange());
          }
          return true;
        };
        const backspaceDelete$5 = (editor, forward) => {
          if (editor.selection.isCollapsed()) {
            return backspaceDeleteCaret(editor, forward);
          } else {
            return backspaceDeleteRange(editor, forward);
          }
        };
        const deleteCaret$2 = (editor, forward) => {
          const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
          return fromPosition(forward, editor.getBody(), fromPos).filter((pos) => forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos)).bind((pos) => getChildNodeAtRelativeOffset(forward ? 0 : -1, pos)).map((elm) => () => editor.selection.select(elm));
        };
        const backspaceDelete$4 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : Optional.none();
        const isText$2 = isText$a;
        const startsWithCaretContainer = (node) => isText$2(node) && node.data[0] === ZWSP$1;
        const endsWithCaretContainer = (node) => isText$2(node) && node.data[node.data.length - 1] === ZWSP$1;
        const createZwsp = (node) => {
          var _a;
          const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
          return doc.createTextNode(ZWSP$1);
        };
        const insertBefore = (node) => {
          var _a;
          if (isText$2(node.previousSibling)) {
            if (endsWithCaretContainer(node.previousSibling)) {
              return node.previousSibling;
            } else {
              node.previousSibling.appendData(ZWSP$1);
              return node.previousSibling;
            }
          } else if (isText$2(node)) {
            if (startsWithCaretContainer(node)) {
              return node;
            } else {
              node.insertData(0, ZWSP$1);
              return node;
            }
          } else {
            const newNode = createZwsp(node);
            (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node);
            return newNode;
          }
        };
        const insertAfter = (node) => {
          var _a, _b;
          if (isText$2(node.nextSibling)) {
            if (startsWithCaretContainer(node.nextSibling)) {
              return node.nextSibling;
            } else {
              node.nextSibling.insertData(0, ZWSP$1);
              return node.nextSibling;
            }
          } else if (isText$2(node)) {
            if (endsWithCaretContainer(node)) {
              return node;
            } else {
              node.appendData(ZWSP$1);
              return node;
            }
          } else {
            const newNode = createZwsp(node);
            if (node.nextSibling) {
              (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node.nextSibling);
            } else {
              (_b = node.parentNode) === null || _b === void 0 ? void 0 : _b.appendChild(newNode);
            }
            return newNode;
          }
        };
        const insertInline = (before2, node) => before2 ? insertBefore(node) : insertAfter(node);
        const insertInlineBefore = curry(insertInline, true);
        const insertInlineAfter = curry(insertInline, false);
        const insertInlinePos = (pos, before2) => {
          if (isText$a(pos.container())) {
            return insertInline(before2, pos.container());
          } else {
            return insertInline(before2, pos.getNode());
          }
        };
        const isPosCaretContainer = (pos, caret) => {
          const caretNode = caret.get();
          return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);
        };
        const renderCaret = (caret, location2) => location2.fold((element) => {
          remove$3(caret.get());
          const text2 = insertInlineBefore(element);
          caret.set(text2);
          return Optional.some(CaretPosition(text2, text2.length - 1));
        }, (element) => firstPositionIn(element).map((pos) => {
          if (!isPosCaretContainer(pos, caret)) {
            remove$3(caret.get());
            const text2 = insertInlinePos(pos, true);
            caret.set(text2);
            return CaretPosition(text2, 1);
          } else {
            const node = caret.get();
            return CaretPosition(node, 1);
          }
        }), (element) => lastPositionIn(element).map((pos) => {
          if (!isPosCaretContainer(pos, caret)) {
            remove$3(caret.get());
            const text2 = insertInlinePos(pos, false);
            caret.set(text2);
            return CaretPosition(text2, text2.length - 1);
          } else {
            const node = caret.get();
            return CaretPosition(node, node.length - 1);
          }
        }), (element) => {
          remove$3(caret.get());
          const text2 = insertInlineAfter(element);
          caret.set(text2);
          return Optional.some(CaretPosition(text2, 1));
        });
        const evaluateUntil = (fns, args) => {
          for (let i2 = 0; i2 < fns.length; i2++) {
            const result = fns[i2].apply(null, args);
            if (result.isSome()) {
              return result;
            }
          }
          return Optional.none();
        };
        const Location = Adt.generate([
          { before: ["element"] },
          { start: ["element"] },
          { end: ["element"] },
          { after: ["element"] }
        ]);
        const rescope$1 = (rootNode, node) => {
          const parentBlock = getParentBlock$3(node, rootNode);
          return parentBlock ? parentBlock : rootNode;
        };
        const before = (isInlineTarget2, rootNode, pos) => {
          const nPos = normalizeForwards(pos);
          const scope = rescope$1(rootNode, nPos.container());
          return findRootInline(isInlineTarget2, scope, nPos).fold(() => nextPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget2, scope)).map((inline) => Location.before(inline)), Optional.none);
        };
        const isNotInsideFormatCaretContainer = (rootNode, elm) => getParentCaretContainer(rootNode, elm) === null;
        const findInsideRootInline = (isInlineTarget2, rootNode, pos) => findRootInline(isInlineTarget2, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));
        const start$1 = (isInlineTarget2, rootNode, pos) => {
          const nPos = normalizeBackwards(pos);
          return findInsideRootInline(isInlineTarget2, rootNode, nPos).bind((inline) => {
            const prevPos = prevPosition(inline, nPos);
            return prevPos.isNone() ? Optional.some(Location.start(inline)) : Optional.none();
          });
        };
        const end2 = (isInlineTarget2, rootNode, pos) => {
          const nPos = normalizeForwards(pos);
          return findInsideRootInline(isInlineTarget2, rootNode, nPos).bind((inline) => {
            const nextPos = nextPosition(inline, nPos);
            return nextPos.isNone() ? Optional.some(Location.end(inline)) : Optional.none();
          });
        };
        const after = (isInlineTarget2, rootNode, pos) => {
          const nPos = normalizeBackwards(pos);
          const scope = rescope$1(rootNode, nPos.container());
          return findRootInline(isInlineTarget2, scope, nPos).fold(() => prevPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget2, scope)).map((inline) => Location.after(inline)), Optional.none);
        };
        const isValidLocation = (location2) => !isRtl(getElement2(location2));
        const readLocation = (isInlineTarget2, rootNode, pos) => {
          const location2 = evaluateUntil([
            before,
            start$1,
            end2,
            after
          ], [
            isInlineTarget2,
            rootNode,
            pos
          ]);
          return location2.filter(isValidLocation);
        };
        const getElement2 = (location2) => location2.fold(identity, identity, identity, identity);
        const getName = (location2) => location2.fold(constant("before"), constant("start"), constant("end"), constant("after"));
        const outside = (location2) => location2.fold(Location.before, Location.before, Location.after, Location.after);
        const inside = (location2) => location2.fold(Location.start, Location.start, Location.end, Location.end);
        const isEq = (location1, location2) => getName(location1) === getName(location2) && getElement2(location1) === getElement2(location2);
        const betweenInlines = (forward, isInlineTarget2, rootNode, from2, to, location2) => lift2(findRootInline(isInlineTarget2, rootNode, from2), findRootInline(isInlineTarget2, rootNode, to), (fromInline, toInline) => {
          if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) {
            return Location.after(forward ? fromInline : toInline);
          } else {
            return location2;
          }
        }).getOr(location2);
        const skipNoMovement = (fromLocation, toLocation) => fromLocation.fold(always, (fromLocation2) => !isEq(fromLocation2, toLocation));
        const findLocationTraverse = (forward, isInlineTarget2, rootNode, fromLocation, pos) => {
          const from2 = normalizePosition(forward, pos);
          const to = fromPosition(forward, rootNode, from2).map(curry(normalizePosition, forward));
          const location2 = to.fold(() => fromLocation.map(outside), (to2) => readLocation(isInlineTarget2, rootNode, to2).map(curry(betweenInlines, forward, isInlineTarget2, rootNode, from2, to2)).filter(curry(skipNoMovement, fromLocation)));
          return location2.filter(isValidLocation);
        };
        const findLocationSimple = (forward, location2) => {
          if (forward) {
            return location2.fold(compose(Optional.some, Location.start), Optional.none, compose(Optional.some, Location.after), Optional.none);
          } else {
            return location2.fold(Optional.none, compose(Optional.some, Location.before), Optional.none, compose(Optional.some, Location.end));
          }
        };
        const findLocation$1 = (forward, isInlineTarget2, rootNode, pos) => {
          const from2 = normalizePosition(forward, pos);
          const fromLocation = readLocation(isInlineTarget2, rootNode, from2);
          return readLocation(isInlineTarget2, rootNode, from2).bind(curry(findLocationSimple, forward)).orThunk(() => findLocationTraverse(forward, isInlineTarget2, rootNode, fromLocation, pos));
        };
        const hasSelectionModifyApi = (editor) => {
          return isFunction(editor.selection.getSel().modify);
        };
        const moveRel = (forward, selection, pos) => {
          const delta = forward ? 1 : -1;
          selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());
          selection.getSel().modify("move", forward ? "forward" : "backward", "word");
          return true;
        };
        const moveByWord = (forward, editor) => {
          const rng = editor.selection.getRng();
          const pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
          if (!hasSelectionModifyApi(editor)) {
            return false;
          } else if (forward && isBeforeInline(pos)) {
            return moveRel(true, editor.selection, pos);
          } else if (!forward && isAfterInline(pos)) {
            return moveRel(false, editor.selection, pos);
          } else {
            return false;
          }
        };
        var BreakType;
        (function(BreakType2) {
          BreakType2[BreakType2["Br"] = 0] = "Br";
          BreakType2[BreakType2["Block"] = 1] = "Block";
          BreakType2[BreakType2["Wrap"] = 2] = "Wrap";
          BreakType2[BreakType2["Eol"] = 3] = "Eol";
        })(BreakType || (BreakType = {}));
        const flip2 = (direction, positions) => direction === HDirection.Backwards ? reverse(positions) : positions;
        const walk$1 = (direction, caretWalker, pos) => direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);
        const getBreakType = (scope, direction, currentPos, nextPos) => {
          if (isBr$6(nextPos.getNode(direction === HDirection.Forwards))) {
            return BreakType.Br;
          } else if (isInSameBlock(currentPos, nextPos) === false) {
            return BreakType.Block;
          } else {
            return BreakType.Wrap;
          }
        };
        const getPositionsUntil = (predicate, direction, scope, start4) => {
          const caretWalker = CaretWalker(scope);
          let currentPos = start4;
          const positions = [];
          while (currentPos) {
            const nextPos = walk$1(direction, caretWalker, currentPos);
            if (!nextPos) {
              break;
            }
            if (isBr$6(nextPos.getNode(false))) {
              if (direction === HDirection.Forwards) {
                return {
                  positions: flip2(direction, positions).concat([nextPos]),
                  breakType: BreakType.Br,
                  breakAt: Optional.some(nextPos)
                };
              } else {
                return {
                  positions: flip2(direction, positions),
                  breakType: BreakType.Br,
                  breakAt: Optional.some(nextPos)
                };
              }
            }
            if (!nextPos.isVisible()) {
              currentPos = nextPos;
              continue;
            }
            if (predicate(currentPos, nextPos)) {
              const breakType = getBreakType(scope, direction, currentPos, nextPos);
              return {
                positions: flip2(direction, positions),
                breakType,
                breakAt: Optional.some(nextPos)
              };
            }
            positions.push(nextPos);
            currentPos = nextPos;
          }
          return {
            positions: flip2(direction, positions),
            breakType: BreakType.Eol,
            breakAt: Optional.none()
          };
        };
        const getAdjacentLinePositions = (direction, getPositionsUntilBreak, scope, start4) => getPositionsUntilBreak(scope, start4).breakAt.map((pos) => {
          const positions = getPositionsUntilBreak(scope, pos).positions;
          return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);
        }).getOr([]);
        const findClosestHorizontalPositionFromPoint = (positions, x2) => foldl(positions, (acc, newPos) => acc.fold(() => Optional.some(newPos), (lastPos) => lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), (lastRect, newRect) => {
          const lastDist = Math.abs(x2 - lastRect.left);
          const newDist = Math.abs(x2 - newRect.left);
          return newDist <= lastDist ? newPos : lastPos;
        }).or(acc)), Optional.none());
        const findClosestHorizontalPosition = (positions, pos) => head(pos.getClientRects()).bind((targetRect) => findClosestHorizontalPositionFromPoint(positions, targetRect.left));
        const getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);
        const getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);
        const getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);
        const getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);
        const isAtFirstLine = (scope, pos) => getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();
        const isAtLastLine = (scope, pos) => getPositionsUntilNextLine(scope, pos).breakAt.isNone();
        const getFirstLinePositions = (scope) => firstPositionIn(scope).map((pos) => [pos].concat(getPositionsUntilNextLine(scope, pos).positions)).getOr([]);
        const getLastLinePositions = (scope) => lastPositionIn(scope).map((pos) => getPositionsUntilPreviousLine(scope, pos).positions.concat(pos)).getOr([]);
        const getClosestPositionAbove = (scope, pos) => findClosestHorizontalPosition(getPositionsAbove(scope, pos), pos);
        const getClosestPositionBelow = (scope, pos) => findClosestHorizontalPosition(getPositionsBelow(scope, pos), pos);
        const isContentEditableFalse$4 = isContentEditableFalse$b;
        const distanceToRectLeft$1 = (clientRect, clientX) => Math.abs(clientRect.left - clientX);
        const distanceToRectRight$1 = (clientRect, clientX) => Math.abs(clientRect.right - clientX);
        const isNodeClientRect = (rect) => hasNonNullableKey(rect, "node");
        const findClosestClientRect = (clientRects, clientX) => reduce(clientRects, (oldClientRect, clientRect) => {
          const oldDistance = Math.min(distanceToRectLeft$1(oldClientRect, clientX), distanceToRectRight$1(oldClientRect, clientX));
          const newDistance = Math.min(distanceToRectLeft$1(clientRect, clientX), distanceToRectRight$1(clientRect, clientX));
          if (newDistance === oldDistance && isNodeClientRect(clientRect) && isContentEditableFalse$4(clientRect.node)) {
            return clientRect;
          }
          if (newDistance < oldDistance) {
            return clientRect;
          }
          return oldClientRect;
        });
        const getNodeClientRects = (node) => {
          const toArrayWithNode = (clientRects) => {
            return map$3(clientRects, (rect) => {
              const clientRect = clone$1(rect);
              clientRect.node = node;
              return clientRect;
            });
          };
          if (isElement$6(node)) {
            return toArrayWithNode(node.getClientRects());
          } else if (isText$a(node)) {
            const rng = node.ownerDocument.createRange();
            rng.setStart(node, 0);
            rng.setEnd(node, node.data.length);
            return toArrayWithNode(rng.getClientRects());
          } else {
            return [];
          }
        };
        const getClientRects = (nodes) => bind$3(nodes, getNodeClientRects);
        var VDirection;
        (function(VDirection2) {
          VDirection2[VDirection2["Up"] = -1] = "Up";
          VDirection2[VDirection2["Down"] = 1] = "Down";
        })(VDirection || (VDirection = {}));
        const findUntil = (direction, root, predicateFn, node) => {
          let currentNode = node;
          while (currentNode = findNode(currentNode, direction, isEditableCaretCandidate$1, root)) {
            if (predicateFn(currentNode)) {
              return;
            }
          }
        };
        const walkUntil = (direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) => {
          let line = 0;
          const result = [];
          const add3 = (node2) => {
            let clientRects = getClientRects([node2]);
            if (direction === -1) {
              clientRects = clientRects.reverse();
            }
            for (let i2 = 0; i2 < clientRects.length; i2++) {
              const clientRect = clientRects[i2];
              if (isBeflowFn(clientRect, targetClientRect)) {
                continue;
              }
              if (result.length > 0 && isAboveFn(clientRect, last$2(result))) {
                line++;
              }
              clientRect.line = line;
              if (predicateFn(clientRect)) {
                return true;
              }
              result.push(clientRect);
            }
            return false;
          };
          const targetClientRect = last$2(caretPosition.getClientRects());
          if (!targetClientRect) {
            return result;
          }
          const node = caretPosition.getNode();
          if (node) {
            add3(node);
            findUntil(direction, root, add3, node);
          }
          return result;
        };
        const aboveLineNumber = (lineNumber, clientRect) => clientRect.line > lineNumber;
        const isLineNumber = (lineNumber, clientRect) => clientRect.line === lineNumber;
        const upUntil = curry(walkUntil, VDirection.Up, isAbove$1, isBelow$1);
        const downUntil = curry(walkUntil, VDirection.Down, isBelow$1, isAbove$1);
        const getLastClientRect = (caretPosition) => {
          return last$2(caretPosition.getClientRects());
        };
        const positionsUntil = (direction, root, predicateFn, node) => {
          const caretWalker = CaretWalker(root);
          let walkFn;
          let isBelowFn;
          let isAboveFn;
          let caretPosition;
          const result = [];
          let line = 0;
          if (direction === 1) {
            walkFn = caretWalker.next;
            isBelowFn = isBelow$1;
            isAboveFn = isAbove$1;
            caretPosition = CaretPosition.after(node);
          } else {
            walkFn = caretWalker.prev;
            isBelowFn = isAbove$1;
            isAboveFn = isBelow$1;
            caretPosition = CaretPosition.before(node);
          }
          const targetClientRect = getLastClientRect(caretPosition);
          do {
            if (!caretPosition.isVisible()) {
              continue;
            }
            const rect = getLastClientRect(caretPosition);
            if (isAboveFn(rect, targetClientRect)) {
              continue;
            }
            if (result.length > 0 && isBelowFn(rect, last$2(result))) {
              line++;
            }
            const clientRect = clone$1(rect);
            clientRect.position = caretPosition;
            clientRect.line = line;
            if (predicateFn(clientRect)) {
              return result;
            }
            result.push(clientRect);
          } while (caretPosition = walkFn(caretPosition));
          return result;
        };
        const isAboveLine = (lineNumber) => (clientRect) => aboveLineNumber(lineNumber, clientRect);
        const isLine = (lineNumber) => (clientRect) => isLineNumber(lineNumber, clientRect);
        const moveToRange = (editor, rng) => {
          editor.selection.setRng(rng);
          scrollRangeIntoView(editor, editor.selection.getRng());
        };
        const renderRangeCaretOpt = (editor, range2, scrollIntoView) => Optional.some(renderRangeCaret(editor, range2, scrollIntoView));
        const moveHorizontally = (editor, direction, range2, isBefore, isAfter, isElement4) => {
          const forwards = direction === HDirection.Forwards;
          const caretWalker = CaretWalker(editor.getBody());
          const getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);
          const isBeforeFn = forwards ? isBefore : isAfter;
          if (!range2.collapsed) {
            const node = getSelectedNode(range2);
            if (isElement4(node)) {
              return showCaret(direction, editor, node, direction === HDirection.Backwards, false);
            } else if (isCefAtEdgeSelected(editor)) {
              const newRange = range2.cloneRange();
              newRange.collapse(direction === HDirection.Backwards);
              return Optional.from(newRange);
            }
          }
          const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range2);
          if (isBeforeFn(caretPosition)) {
            return selectNode(editor, caretPosition.getNode(!forwards));
          }
          let nextCaretPosition = getNextPosFn(caretPosition);
          const rangeIsInContainerBlock = isRangeInCaretContainerBlock(range2);
          if (!nextCaretPosition) {
            return rangeIsInContainerBlock ? Optional.some(range2) : Optional.none();
          } else {
            nextCaretPosition = normalizePosition(forwards, nextCaretPosition);
          }
          if (isBeforeFn(nextCaretPosition)) {
            return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);
          }
          const peekCaretPosition = getNextPosFn(nextCaretPosition);
          if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
            if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {
              return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);
            }
          }
          if (rangeIsInContainerBlock) {
            return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);
          }
          return Optional.none();
        };
        const moveVertically = (editor, direction, range2, isBefore, isAfter, isElement4) => {
          const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range2);
          const caretClientRect = last$2(caretPosition.getClientRects());
          const forwards = direction === VDirection.Down;
          const root = editor.getBody();
          if (!caretClientRect) {
            return Optional.none();
          }
          if (isCefAtEdgeSelected(editor)) {
            const caretPosition2 = forwards ? CaretPosition.fromRangeEnd(range2) : CaretPosition.fromRangeStart(range2);
            const getClosestFn = !forwards ? getClosestPositionAbove : getClosestPositionBelow;
            return getClosestFn(root, caretPosition2).orThunk(() => Optional.from(caretPosition2)).map((pos) => pos.toRange());
          }
          const walkerFn = forwards ? downUntil : upUntil;
          const linePositions = walkerFn(root, isAboveLine(1), caretPosition);
          const nextLinePositions = filter$5(linePositions, isLine(1));
          const clientX = caretClientRect.left;
          const nextLineRect = findClosestClientRect(nextLinePositions, clientX);
          if (nextLineRect && isElement4(nextLineRect.node)) {
            const dist1 = Math.abs(clientX - nextLineRect.left);
            const dist2 = Math.abs(clientX - nextLineRect.right);
            return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);
          }
          let currentNode;
          if (isBefore(caretPosition)) {
            currentNode = caretPosition.getNode();
          } else if (isAfter(caretPosition)) {
            currentNode = caretPosition.getNode(true);
          } else {
            currentNode = getSelectedNode(range2);
          }
          if (currentNode) {
            const caretPositions = positionsUntil(direction, root, isAboveLine(1), currentNode);
            let closestNextLineRect = findClosestClientRect(filter$5(caretPositions, isLine(1)), clientX);
            if (closestNextLineRect) {
              return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);
            }
            closestNextLineRect = last$2(filter$5(caretPositions, isLine(0)));
            if (closestNextLineRect) {
              return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);
            }
          }
          if (nextLinePositions.length === 0) {
            return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore).map((pos) => renderRangeCaret(editor, pos.toRange(), false));
          }
          return Optional.none();
        };
        const getLineEndPoint = (editor, forward) => {
          const rng = editor.selection.getRng();
          const from2 = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
          const host = getEditingHost(from2.container(), editor.getBody());
          if (forward) {
            const lineInfo = getPositionsUntilNextLine(host, from2);
            return last$3(lineInfo.positions);
          } else {
            const lineInfo = getPositionsUntilPreviousLine(host, from2);
            return head(lineInfo.positions);
          }
        };
        const moveToLineEndPoint$3 = (editor, forward, isElementPosition) => getLineEndPoint(editor, forward).filter(isElementPosition).exists((pos) => {
          editor.selection.setRng(pos.toRange());
          return true;
        });
        const setCaretPosition = (editor, pos) => {
          const rng = editor.dom.createRng();
          rng.setStart(pos.container(), pos.offset());
          rng.setEnd(pos.container(), pos.offset());
          editor.selection.setRng(rng);
        };
        const setSelected = (state, elm) => {
          if (state) {
            elm.setAttribute("data-mce-selected", "inline-boundary");
          } else {
            elm.removeAttribute("data-mce-selected");
          }
        };
        const renderCaretLocation = (editor, caret, location2) => renderCaret(caret, location2).map((pos) => {
          setCaretPosition(editor, pos);
          return location2;
        });
        const getPositionFromRange = (range2, root, forward) => {
          const start4 = CaretPosition.fromRangeStart(range2);
          if (range2.collapsed) {
            return start4;
          } else {
            const end3 = CaretPosition.fromRangeEnd(range2);
            return forward ? prevPosition(root, end3).getOr(end3) : nextPosition(root, start4).getOr(start4);
          }
        };
        const findLocation = (editor, caret, forward) => {
          const rootNode = editor.getBody();
          const from2 = getPositionFromRange(editor.selection.getRng(), rootNode, forward);
          const isInlineTarget$1 = curry(isInlineTarget, editor);
          const location2 = findLocation$1(forward, isInlineTarget$1, rootNode, from2);
          return location2.bind((location3) => renderCaretLocation(editor, caret, location3));
        };
        const toggleInlines = (isInlineTarget2, dom2, elms) => {
          const inlineBoundaries = map$3(descendants(SugarElement.fromDom(dom2.getRoot()), '*[data-mce-selected="inline-boundary"]'), (e2) => e2.dom);
          const selectedInlines = filter$5(inlineBoundaries, isInlineTarget2);
          const targetInlines = filter$5(elms, isInlineTarget2);
          each$e(difference(selectedInlines, targetInlines), curry(setSelected, false));
          each$e(difference(targetInlines, selectedInlines), curry(setSelected, true));
        };
        const safeRemoveCaretContainer = (editor, caret) => {
          const caretValue = caret.get();
          if (editor.selection.isCollapsed() && !editor.composing && caretValue) {
            const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
            if (CaretPosition.isTextPosition(pos) && !isAtZwsp(pos)) {
              setCaretPosition(editor, removeAndReposition(caretValue, pos));
              caret.set(null);
            }
          }
        };
        const renderInsideInlineCaret = (isInlineTarget2, editor, caret, elms) => {
          if (editor.selection.isCollapsed()) {
            const inlines = filter$5(elms, isInlineTarget2);
            each$e(inlines, (_inline) => {
              const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
              readLocation(isInlineTarget2, editor.getBody(), pos).bind((location2) => renderCaretLocation(editor, caret, location2));
            });
          }
        };
        const move$2 = (editor, caret, forward) => isInlineBoundariesEnabled(editor) ? findLocation(editor, caret, forward).isSome() : false;
        const moveWord = (forward, editor, _caret) => isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;
        const setupSelectedState = (editor) => {
          const caret = Cell(null);
          const isInlineTarget$1 = curry(isInlineTarget, editor);
          editor.on("NodeChange", (e2) => {
            if (isInlineBoundariesEnabled(editor)) {
              toggleInlines(isInlineTarget$1, editor.dom, e2.parents);
              safeRemoveCaretContainer(editor, caret);
              renderInsideInlineCaret(isInlineTarget$1, editor, caret, e2.parents);
            }
          });
          return caret;
        };
        const moveNextWord = curry(moveWord, true);
        const movePrevWord = curry(moveWord, false);
        const moveToLineEndPoint$2 = (editor, forward, caret) => {
          if (isInlineBoundariesEnabled(editor)) {
            const linePoint = getLineEndPoint(editor, forward).getOrThunk(() => {
              const rng = editor.selection.getRng();
              return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
            });
            return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists((loc) => {
              const outsideLoc = outside(loc);
              return renderCaret(caret, outsideLoc).exists((pos) => {
                setCaretPosition(editor, pos);
                return true;
              });
            });
          } else {
            return false;
          }
        };
        const rangeFromPositions = (from2, to) => {
          const range2 = document.createRange();
          range2.setStart(from2.container(), from2.offset());
          range2.setEnd(to.container(), to.offset());
          return range2;
        };
        const hasOnlyTwoOrLessPositionsLeft = (elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {
          const normalizedFirstPos = normalizePosition(true, firstPos);
          const normalizedLastPos = normalizePosition(false, lastPos);
          return nextPosition(elm, normalizedFirstPos).forall((pos) => pos.isEqual(normalizedLastPos));
        }).getOr(true);
        const setCaretLocation = (editor, caret) => (location2) => renderCaret(caret, location2).map((pos) => () => setCaretPosition(editor, pos));
        const deleteFromTo = (editor, caret, from2, to) => {
          const rootNode = editor.getBody();
          const isInlineTarget$1 = curry(isInlineTarget, editor);
          editor.undoManager.ignore(() => {
            editor.selection.setRng(rangeFromPositions(from2, to));
            execNativeDeleteCommand(editor);
            readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng())).map(inside).bind(setCaretLocation(editor, caret)).each(call);
          });
          editor.nodeChanged();
        };
        const rescope = (rootNode, node) => {
          const parentBlock = getParentBlock$3(node, rootNode);
          return parentBlock ? parentBlock : rootNode;
        };
        const backspaceDeleteCollapsed = (editor, caret, forward, from2) => {
          const rootNode = rescope(editor.getBody(), from2.container());
          const isInlineTarget$1 = curry(isInlineTarget, editor);
          const fromLocation = readLocation(isInlineTarget$1, rootNode, from2);
          const location2 = fromLocation.bind((location3) => {
            if (forward) {
              return location3.fold(constant(Optional.some(inside(location3))), Optional.none, constant(Optional.some(outside(location3))), Optional.none);
            } else {
              return location3.fold(Optional.none, constant(Optional.some(outside(location3))), Optional.none, constant(Optional.some(inside(location3))));
            }
          });
          return location2.map(setCaretLocation(editor, caret)).getOrThunk(() => {
            const toPosition = navigate(forward, rootNode, from2);
            const toLocation = toPosition.bind((pos) => readLocation(isInlineTarget$1, rootNode, pos));
            return lift2(fromLocation, toLocation, () => findRootInline(isInlineTarget$1, rootNode, from2).bind((elm) => {
              if (hasOnlyTwoOrLessPositionsLeft(elm)) {
                return Optional.some(() => {
                  deleteElement$2(editor, forward, SugarElement.fromDom(elm));
                });
              } else {
                return Optional.none();
              }
            })).getOrThunk(() => toLocation.bind(() => toPosition.map((to) => {
              return () => {
                if (forward) {
                  deleteFromTo(editor, caret, from2, to);
                } else {
                  deleteFromTo(editor, caret, to, from2);
                }
              };
            })));
          });
        };
        const backspaceDelete$3 = (editor, caret, forward) => {
          if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {
            const from2 = CaretPosition.fromRangeStart(editor.selection.getRng());
            return backspaceDeleteCollapsed(editor, caret, forward, from2);
          }
          return Optional.none();
        };
        const hasMultipleChildren = (elm) => childNodesCount(elm) > 1;
        const getParentsUntil = (editor, pred) => {
          const rootElm = SugarElement.fromDom(editor.getBody());
          const startElm = SugarElement.fromDom(editor.selection.getStart());
          const parents2 = parentsAndSelf(startElm, rootElm);
          return findIndex$2(parents2, pred).fold(constant(parents2), (index) => parents2.slice(0, index));
        };
        const hasOnlyOneChild = (elm) => childNodesCount(elm) === 1;
        const getParentInlinesUntilMultichildInline = (editor) => getParentsUntil(editor, (elm) => isBlock$2(elm) || hasMultipleChildren(elm));
        const getParentInlines = (editor) => getParentsUntil(editor, isBlock$2);
        const getFormatNodes = (editor, parentInlines) => {
          const isFormatElement$1 = curry(isFormatElement, editor);
          return bind$3(parentInlines, (elm) => isFormatElement$1(elm) ? [elm.dom] : []);
        };
        const getFormatNodesAtStart = (editor) => {
          const parentInlines = getParentInlines(editor);
          return getFormatNodes(editor, parentInlines);
        };
        const deleteLastPosition = (forward, editor, target, parentInlines) => {
          const formatNodes = getFormatNodes(editor, parentInlines);
          if (formatNodes.length === 0) {
            deleteElement$2(editor, forward, target);
          } else {
            const pos = replaceWithCaretFormat(target.dom, formatNodes);
            editor.selection.setRng(pos.toRange());
          }
        };
        const deleteCaret$1 = (editor, forward) => {
          const parentInlines = filter$5(getParentInlinesUntilMultichildInline(editor), hasOnlyOneChild);
          return last$3(parentInlines).bind((target) => {
            const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
            if (willDeleteLastPositionInElement(forward, fromPos, target.dom) && !isEmptyCaretFormatElement(target)) {
              return Optional.some(() => deleteLastPosition(forward, editor, target, parentInlines));
            } else {
              return Optional.none();
            }
          });
        };
        const isBrInEmptyElement = (editor, elm) => {
          const parentElm = elm.parentElement;
          return isBr$6(elm) && !isNull(parentElm) && editor.dom.isEmpty(parentElm);
        };
        const isEmptyCaret = (elm) => isEmptyCaretFormatElement(SugarElement.fromDom(elm));
        const createCaretFormatAtStart = (editor, formatNodes) => {
          const startElm = editor.selection.getStart();
          const pos = isBrInEmptyElement(editor, startElm) || isEmptyCaret(startElm) ? replaceWithCaretFormat(startElm, formatNodes) : createCaretFormatAtStart$1(editor.selection.getRng(), formatNodes);
          editor.selection.setRng(pos.toRange());
        };
        const updateCaretFormat = (editor, updateFormats) => {
          const missingFormats = difference(updateFormats, getFormatNodesAtStart(editor));
          if (missingFormats.length > 0) {
            createCaretFormatAtStart(editor, missingFormats);
          }
        };
        const rangeStartsAtTextContainer = (rng) => isText$a(rng.startContainer);
        const rangeStartsAtStartOfTextContainer = (rng) => rng.startOffset === 0 && rangeStartsAtTextContainer(rng);
        const rangeStartParentIsFormatElement = (editor, rng) => {
          const startParent = rng.startContainer.parentElement;
          return !isNull(startParent) && isFormatElement(editor, SugarElement.fromDom(startParent));
        };
        const rangeStartAndEndHaveSameParent = (rng) => {
          const startParent = rng.startContainer.parentNode;
          const endParent = rng.endContainer.parentNode;
          return !isNull(startParent) && !isNull(endParent) && startParent.isEqualNode(endParent);
        };
        const rangeEndsAtEndOfEndContainer = (rng) => {
          const endContainer = rng.endContainer;
          return rng.endOffset === (isText$a(endContainer) ? endContainer.length : endContainer.childNodes.length);
        };
        const rangeEndsAtEndOfStartContainer = (rng) => rangeStartAndEndHaveSameParent(rng) && rangeEndsAtEndOfEndContainer(rng);
        const rangeEndsAfterEndOfStartContainer = (rng) => !rng.endContainer.isEqualNode(rng.commonAncestorContainer);
        const rangeEndsAtOrAfterEndOfStartContainer = (rng) => rangeEndsAtEndOfStartContainer(rng) || rangeEndsAfterEndOfStartContainer(rng);
        const requiresDeleteRangeOverride = (editor) => {
          const rng = editor.selection.getRng();
          return rangeStartsAtStartOfTextContainer(rng) && rangeStartParentIsFormatElement(editor, rng) && rangeEndsAtOrAfterEndOfStartContainer(rng);
        };
        const deleteRange$1 = (editor) => {
          if (requiresDeleteRangeOverride(editor)) {
            const formatNodes = getFormatNodesAtStart(editor);
            return Optional.some(() => {
              execNativeDeleteCommand(editor);
              updateCaretFormat(editor, formatNodes);
            });
          } else {
            return Optional.none();
          }
        };
        const backspaceDelete$2 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : deleteRange$1(editor);
        const hasAncestorInlineCaret = (elm) => ancestor$1(elm, (node) => isCaretNode(node.dom), isBlock$2);
        const hasAncestorInlineCaretAtStart = (editor) => hasAncestorInlineCaret(SugarElement.fromDom(editor.selection.getStart()));
        const requiresRefreshCaretOverride = (editor) => {
          const rng = editor.selection.getRng();
          return rng.collapsed && (rangeStartsAtTextContainer(rng) || editor.dom.isEmpty(rng.startContainer)) && !hasAncestorInlineCaretAtStart(editor);
        };
        const refreshCaret = (editor) => {
          if (requiresRefreshCaretOverride(editor)) {
            createCaretFormatAtStart(editor, []);
          }
          return true;
        };
        const deleteElement = (editor, forward, element) => {
          if (isNonNullable(element)) {
            return Optional.some(() => {
              editor._selectionOverrides.hideFakeCaret();
              deleteElement$2(editor, forward, SugarElement.fromDom(element));
            });
          } else {
            return Optional.none();
          }
        };
        const deleteCaret = (editor, forward) => {
          const isNearMedia = forward ? isBeforeMedia : isAfterMedia;
          const direction = forward ? HDirection.Forwards : HDirection.Backwards;
          const fromPos = getNormalizedRangeEndPoint(direction, editor.getBody(), editor.selection.getRng());
          if (isNearMedia(fromPos)) {
            return deleteElement(editor, forward, fromPos.getNode(!forward));
          } else {
            return Optional.from(normalizePosition(forward, fromPos)).filter((pos) => isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos)).bind((pos) => deleteElement(editor, forward, pos.getNode(!forward)));
          }
        };
        const deleteRange = (editor, forward) => {
          const selectedNode = editor.selection.getNode();
          return isMedia$2(selectedNode) ? deleteElement(editor, forward, selectedNode) : Optional.none();
        };
        const backspaceDelete$1 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret(editor, forward) : deleteRange(editor, forward);
        const isEditable = (target) => closest$4(target, (elm) => isContentEditableTrue$3(elm.dom) || isContentEditableFalse$b(elm.dom)).exists((elm) => isContentEditableTrue$3(elm.dom));
        const parseIndentValue = (value2) => toInt(value2 !== null && value2 !== void 0 ? value2 : "").getOr(0);
        const getIndentStyleName = (useMargin, element) => {
          const indentStyleName = useMargin || isTable$1(element) ? "margin" : "padding";
          const suffix = get$7(element, "direction") === "rtl" ? "-right" : "-left";
          return indentStyleName + suffix;
        };
        const indentElement = (dom2, command, useMargin, value2, unit, element) => {
          const indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));
          const parsedValue = parseIndentValue(dom2.getStyle(element, indentStyleName));
          if (command === "outdent") {
            const styleValue = Math.max(0, parsedValue - value2);
            dom2.setStyle(element, indentStyleName, styleValue ? styleValue + unit : "");
          } else {
            const styleValue = parsedValue + value2 + unit;
            dom2.setStyle(element, indentStyleName, styleValue);
          }
        };
        const validateBlocks = (editor, blocks2) => forall(blocks2, (block) => {
          const indentStyleName = getIndentStyleName(shouldIndentUseMargin(editor), block);
          const intentValue = getRaw(block, indentStyleName).map(parseIndentValue).getOr(0);
          const contentEditable = editor.dom.getContentEditable(block.dom);
          return contentEditable !== "false" && intentValue > 0;
        });
        const canOutdent = (editor) => {
          const blocks2 = getBlocksToIndent(editor);
          return !editor.mode.isReadOnly() && (blocks2.length > 1 || validateBlocks(editor, blocks2));
        };
        const isListComponent = (el) => isList(el) || isListItem$1(el);
        const parentIsListComponent = (el) => parent(el).exists(isListComponent);
        const getBlocksToIndent = (editor) => filter$5(fromDom$1(editor.selection.getSelectedBlocks()), (el) => !isListComponent(el) && !parentIsListComponent(el) && isEditable(el));
        const handle = (editor, command) => {
          var _a, _b;
          const { dom: dom2 } = editor;
          const indentation = getIndentation(editor);
          const indentUnit = (_b = (_a = /[a-z%]+$/i.exec(indentation)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : "px";
          const indentValue = parseIndentValue(indentation);
          const useMargin = shouldIndentUseMargin(editor);
          each$e(getBlocksToIndent(editor), (block) => {
            indentElement(dom2, command, useMargin, indentValue, indentUnit, block.dom);
          });
        };
        const indent = (editor) => handle(editor, "indent");
        const outdent = (editor) => handle(editor, "outdent");
        const backspaceDelete = (editor) => {
          if (editor.selection.isCollapsed() && canOutdent(editor)) {
            const dom2 = editor.dom;
            const rng = editor.selection.getRng();
            const pos = CaretPosition.fromRangeStart(rng);
            const block = dom2.getParent(rng.startContainer, dom2.isBlock);
            if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos)) {
              return Optional.some(() => outdent(editor));
            }
          }
          return Optional.none();
        };
        const findAction = (editor, caret, forward) => findMap([
          backspaceDelete,
          backspaceDelete$5,
          backspaceDelete$6,
          (editor2, forward2) => backspaceDelete$3(editor2, caret, forward2),
          backspaceDelete$8,
          backspaceDelete$9,
          backspaceDelete$4,
          backspaceDelete$1,
          backspaceDelete$7,
          backspaceDelete$2
        ], (item) => item(editor, forward)).filter((_2) => editor.selection.isEditable());
        const deleteCommand = (editor, caret) => {
          const result = findAction(editor, caret, false);
          result.fold(() => {
            execNativeDeleteCommand(editor);
            paddEmptyBody(editor);
          }, call);
        };
        const forwardDeleteCommand = (editor, caret) => {
          const result = findAction(editor, caret, true);
          result.fold(() => execNativeForwardDeleteCommand(editor), call);
        };
        const setup$p = (editor, caret) => {
          editor.addCommand("delete", () => {
            deleteCommand(editor, caret);
          });
          editor.addCommand("forwardDelete", () => {
            forwardDeleteCommand(editor, caret);
          });
        };
        const SIGNIFICANT_MOVE = 5;
        const LONGPRESS_DELAY = 400;
        const getTouch = (event) => {
          if (event.touches === void 0 || event.touches.length !== 1) {
            return Optional.none();
          }
          return Optional.some(event.touches[0]);
        };
        const isFarEnough = (touch, data2) => {
          const distX = Math.abs(touch.clientX - data2.x);
          const distY = Math.abs(touch.clientY - data2.y);
          return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;
        };
        const setup$o = (editor) => {
          const startData = value$2();
          const longpressFired = Cell(false);
          const debounceLongpress = last$1((e2) => {
            editor.dispatch("longpress", {
              ...e2,
              type: "longpress"
            });
            longpressFired.set(true);
          }, LONGPRESS_DELAY);
          editor.on("touchstart", (e2) => {
            getTouch(e2).each((touch) => {
              debounceLongpress.cancel();
              const data2 = {
                x: touch.clientX,
                y: touch.clientY,
                target: e2.target
              };
              debounceLongpress.throttle(e2);
              longpressFired.set(false);
              startData.set(data2);
            });
          }, true);
          editor.on("touchmove", (e2) => {
            debounceLongpress.cancel();
            getTouch(e2).each((touch) => {
              startData.on((data2) => {
                if (isFarEnough(touch, data2)) {
                  startData.clear();
                  longpressFired.set(false);
                  editor.dispatch("longpresscancel");
                }
              });
            });
          }, true);
          editor.on("touchend touchcancel", (e2) => {
            debounceLongpress.cancel();
            if (e2.type === "touchcancel") {
              return;
            }
            startData.get().filter((data2) => data2.target.isEqualNode(e2.target)).each(() => {
              if (longpressFired.get()) {
                e2.preventDefault();
              } else {
                editor.dispatch("tap", {
                  ...e2,
                  type: "tap"
                });
              }
            });
          }, true);
        };
        const isBlockElement = (blockElements, node) => has$2(blockElements, node.nodeName);
        const isValidTarget = (schema, node) => {
          if (isText$a(node)) {
            return true;
          } else if (isElement$6(node)) {
            return !isBlockElement(schema.getBlockElements(), node) && !isBookmarkNode$1(node) && !isTransparentBlock(schema, node);
          } else {
            return false;
          }
        };
        const hasBlockParent = (blockElements, root, node) => {
          return exists(parents(SugarElement.fromDom(node), SugarElement.fromDom(root)), (elm) => {
            return isBlockElement(blockElements, elm.dom);
          });
        };
        const shouldRemoveTextNode = (blockElements, node) => {
          if (isText$a(node)) {
            if (node.data.length === 0) {
              return true;
            } else if (/^\s+$/.test(node.data) && (!node.nextSibling || isBlockElement(blockElements, node.nextSibling))) {
              return true;
            }
          }
          return false;
        };
        const createRootBlock = (editor) => editor.dom.create(getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));
        const addRootBlocks = (editor) => {
          const dom2 = editor.dom, selection = editor.selection;
          const schema = editor.schema;
          const blockElements = schema.getBlockElements();
          const startNode = selection.getStart();
          const rootNode = editor.getBody();
          let rootBlockNode;
          let tempNode;
          let wrapped = false;
          const forcedRootBlock = getForcedRootBlock(editor);
          if (!startNode || !isElement$6(startNode)) {
            return;
          }
          const rootNodeName = rootNode.nodeName.toLowerCase();
          if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, startNode)) {
            return;
          }
          const rng = selection.getRng();
          const { startContainer, startOffset, endContainer, endOffset } = rng;
          const restoreSelection = hasFocus(editor);
          let node = rootNode.firstChild;
          while (node) {
            if (isElement$6(node)) {
              updateElement(schema, node);
            }
            if (isValidTarget(schema, node)) {
              if (shouldRemoveTextNode(blockElements, node)) {
                tempNode = node;
                node = node.nextSibling;
                dom2.remove(tempNode);
                continue;
              }
              if (!rootBlockNode) {
                rootBlockNode = createRootBlock(editor);
                rootNode.insertBefore(rootBlockNode, node);
                wrapped = true;
              }
              tempNode = node;
              node = node.nextSibling;
              rootBlockNode.appendChild(tempNode);
            } else {
              rootBlockNode = null;
              node = node.nextSibling;
            }
          }
          if (wrapped && restoreSelection) {
            rng.setStart(startContainer, startOffset);
            rng.setEnd(endContainer, endOffset);
            selection.setRng(rng);
            editor.nodeChanged();
          }
        };
        const insertEmptyLine = (editor, root, insertBlock2) => {
          const block = SugarElement.fromDom(createRootBlock(editor));
          const br = createPaddingBr();
          append$1(block, br);
          insertBlock2(root, block);
          const rng = document.createRange();
          rng.setStartBefore(br.dom);
          rng.setEndBefore(br.dom);
          return rng;
        };
        const setup$n = (editor) => {
          editor.on("NodeChange", curry(addRootBlocks, editor));
        };
        const hasClass = (checkClassName) => (node) => (" " + node.attr("class") + " ").indexOf(checkClassName) !== -1;
        const replaceMatchWithSpan = (editor, content, cls) => {
          return function(match2) {
            const args = arguments, index = args[args.length - 2];
            const prevChar = index > 0 ? content.charAt(index - 1) : "";
            if (prevChar === '"') {
              return match2;
            }
            if (prevChar === ">") {
              const findStartTagIndex = content.lastIndexOf("<", index);
              if (findStartTagIndex !== -1) {
                const tagHtml = content.substring(findStartTagIndex, index);
                if (tagHtml.indexOf('contenteditable="false"') !== -1) {
                  return match2;
                }
              }
            }
            return '<span class="' + cls + '" data-mce-content="' + editor.dom.encode(args[0]) + '">' + editor.dom.encode(typeof args[1] === "string" ? args[1] : args[0]) + "</span>";
          };
        };
        const convertRegExpsToNonEditable = (editor, nonEditableRegExps, e2) => {
          let i2 = nonEditableRegExps.length, content = e2.content;
          if (e2.format === "raw") {
            return;
          }
          while (i2--) {
            content = content.replace(nonEditableRegExps[i2], replaceMatchWithSpan(editor, content, getNonEditableClass(editor)));
          }
          e2.content = content;
        };
        const setup$m = (editor) => {
          const contentEditableAttrName = "contenteditable";
          const editClass = " " + Tools.trim(getEditableClass(editor)) + " ";
          const nonEditClass = " " + Tools.trim(getNonEditableClass(editor)) + " ";
          const hasEditClass = hasClass(editClass);
          const hasNonEditClass = hasClass(nonEditClass);
          const nonEditableRegExps = getNonEditableRegExps(editor);
          if (nonEditableRegExps.length > 0) {
            editor.on("BeforeSetContent", (e2) => {
              convertRegExpsToNonEditable(editor, nonEditableRegExps, e2);
            });
          }
          editor.parser.addAttributeFilter("class", (nodes) => {
            let i2 = nodes.length;
            while (i2--) {
              const node = nodes[i2];
              if (hasEditClass(node)) {
                node.attr(contentEditableAttrName, "true");
              } else if (hasNonEditClass(node)) {
                node.attr(contentEditableAttrName, "false");
              }
            }
          });
          editor.serializer.addAttributeFilter(contentEditableAttrName, (nodes) => {
            let i2 = nodes.length;
            while (i2--) {
              const node = nodes[i2];
              if (!hasEditClass(node) && !hasNonEditClass(node)) {
                continue;
              }
              if (nonEditableRegExps.length > 0 && node.attr("data-mce-content")) {
                node.name = "#text";
                node.type = 3;
                node.raw = true;
                node.value = node.attr("data-mce-content");
              } else {
                node.attr(contentEditableAttrName, null);
              }
            }
          });
        };
        const findBlockCaretContainer = (editor) => descendant(SugarElement.fromDom(editor.getBody()), "*[data-mce-caret]").map((elm) => elm.dom).getOrNull();
        const showBlockCaretContainer = (editor, blockCaretContainer) => {
          if (blockCaretContainer.hasAttribute("data-mce-caret")) {
            showCaretContainerBlock(blockCaretContainer);
            editor.selection.setRng(editor.selection.getRng());
            editor.selection.scrollIntoView(blockCaretContainer);
          }
        };
        const handleBlockContainer = (editor, e2) => {
          const blockCaretContainer = findBlockCaretContainer(editor);
          if (!blockCaretContainer) {
            return;
          }
          if (e2.type === "compositionstart") {
            e2.preventDefault();
            e2.stopPropagation();
            showBlockCaretContainer(editor, blockCaretContainer);
            return;
          }
          if (hasContent(blockCaretContainer)) {
            showBlockCaretContainer(editor, blockCaretContainer);
            editor.undoManager.add();
          }
        };
        const setup$l = (editor) => {
          editor.on("keyup compositionstart", curry(handleBlockContainer, editor));
        };
        const isContentEditableFalse$3 = isContentEditableFalse$b;
        const moveToCeFalseHorizontally = (direction, editor, range2) => moveHorizontally(editor, direction, range2, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$3);
        const moveToCeFalseVertically = (direction, editor, range2) => {
          const isBefore = (caretPosition) => isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);
          const isAfter = (caretPosition) => isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);
          return moveVertically(editor, direction, range2, isBefore, isAfter, isContentEditableFalse$3);
        };
        const createTextBlock = (editor) => {
          const textBlock = editor.dom.create(getForcedRootBlock(editor));
          textBlock.innerHTML = '<br data-mce-bogus="1">';
          return textBlock;
        };
        const exitPreBlock = (editor, direction, range2) => {
          const caretWalker = CaretWalker(editor.getBody());
          const getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 ? caretWalker.next : caretWalker.prev);
          if (range2.collapsed) {
            const pre = editor.dom.getParent(range2.startContainer, "PRE");
            if (!pre) {
              return;
            }
            const caretPos = getVisualCaretPosition$1(CaretPosition.fromRangeStart(range2));
            if (!caretPos) {
              const newBlock = SugarElement.fromDom(createTextBlock(editor));
              if (direction === 1) {
                after$4(SugarElement.fromDom(pre), newBlock);
              } else {
                before$3(SugarElement.fromDom(pre), newBlock);
              }
              editor.selection.select(newBlock.dom, true);
              editor.selection.collapse();
            }
          }
        };
        const getHorizontalRange = (editor, forward) => {
          const direction = forward ? HDirection.Forwards : HDirection.Backwards;
          const range2 = editor.selection.getRng();
          return moveToCeFalseHorizontally(direction, editor, range2).orThunk(() => {
            exitPreBlock(editor, direction, range2);
            return Optional.none();
          });
        };
        const getVerticalRange = (editor, down) => {
          const direction = down ? 1 : -1;
          const range2 = editor.selection.getRng();
          return moveToCeFalseVertically(direction, editor, range2).orThunk(() => {
            exitPreBlock(editor, direction, range2);
            return Optional.none();
          });
        };
        const flipDirection = (selection, forward) => {
          const elm = forward ? selection.getEnd(true) : selection.getStart(true);
          return isRtl(elm) ? !forward : forward;
        };
        const moveH$2 = (editor, forward) => getHorizontalRange(editor, flipDirection(editor.selection, forward)).exists((newRange) => {
          moveToRange(editor, newRange);
          return true;
        });
        const moveV$3 = (editor, down) => getVerticalRange(editor, down).exists((newRange) => {
          moveToRange(editor, newRange);
          return true;
        });
        const moveToLineEndPoint$1 = (editor, forward) => {
          const isCefPosition = forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse;
          return moveToLineEndPoint$3(editor, forward, isCefPosition);
        };
        const selectToEndPoint = (editor, forward) => getEdgeCefPosition(editor, !forward).map((pos) => {
          const rng = pos.toRange();
          const curRng = editor.selection.getRng();
          if (forward) {
            rng.setStart(curRng.startContainer, curRng.startOffset);
          } else {
            rng.setEnd(curRng.endContainer, curRng.endOffset);
          }
          return rng;
        }).exists((rng) => {
          moveToRange(editor, rng);
          return true;
        });
        const isTarget = (node) => contains$2(["figcaption"], name(node));
        const getClosestTargetBlock = (pos, root) => {
          const isRoot2 = curry(eq, root);
          return closest$4(SugarElement.fromDom(pos.container()), isBlock$2, isRoot2).filter(isTarget);
        };
        const isAtFirstOrLastLine = (root, forward, pos) => forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);
        const moveCaretToNewEmptyLine = (editor, forward) => {
          const root = SugarElement.fromDom(editor.getBody());
          const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
          return getClosestTargetBlock(pos, root).exists(() => {
            if (isAtFirstOrLastLine(root, forward, pos)) {
              const insertFn = forward ? append$1 : prepend;
              const rng = insertEmptyLine(editor, root, insertFn);
              editor.selection.setRng(rng);
              return true;
            } else {
              return false;
            }
          });
        };
        const moveV$2 = (editor, forward) => {
          if (editor.selection.isCollapsed()) {
            return moveCaretToNewEmptyLine(editor, forward);
          } else {
            return false;
          }
        };
        const baseKeyPattern = {
          shiftKey: false,
          altKey: false,
          ctrlKey: false,
          metaKey: false,
          keyCode: 0
        };
        const defaultPatterns = (patterns) => map$3(patterns, (pattern) => ({
          ...baseKeyPattern,
          ...pattern
        }));
        const defaultDelayedPatterns = (patterns) => map$3(patterns, (pattern) => ({
          ...baseKeyPattern,
          ...pattern
        }));
        const matchesEvent = (pattern, evt) => evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;
        const match$1 = (patterns, evt) => bind$3(defaultPatterns(patterns), (pattern) => matchesEvent(pattern, evt) ? [pattern] : []);
        const matchDelayed = (patterns, evt) => bind$3(defaultDelayedPatterns(patterns), (pattern) => matchesEvent(pattern, evt) ? [pattern] : []);
        const action = (f2, ...x2) => () => f2.apply(null, x2);
        const execute2 = (patterns, evt) => find$2(match$1(patterns, evt), (pattern) => pattern.action());
        const executeWithDelayedAction = (patterns, evt) => findMap(matchDelayed(patterns, evt), (pattern) => pattern.action());
        const moveH$1 = (editor, forward) => {
          const direction = forward ? HDirection.Forwards : HDirection.Backwards;
          const range2 = editor.selection.getRng();
          return moveHorizontally(editor, direction, range2, isBeforeMedia, isAfterMedia, isMedia$2).exists((newRange) => {
            moveToRange(editor, newRange);
            return true;
          });
        };
        const moveV$1 = (editor, down) => {
          const direction = down ? 1 : -1;
          const range2 = editor.selection.getRng();
          return moveVertically(editor, direction, range2, isBeforeMedia, isAfterMedia, isMedia$2).exists((newRange) => {
            moveToRange(editor, newRange);
            return true;
          });
        };
        const moveToLineEndPoint = (editor, forward) => {
          const isNearMedia = forward ? isAfterMedia : isBeforeMedia;
          return moveToLineEndPoint$3(editor, forward, isNearMedia);
        };
        const adt = Adt.generate([
          { none: ["current"] },
          { first: ["current"] },
          {
            middle: [
              "current",
              "target"
            ]
          },
          { last: ["current"] }
        ]);
        const none = (current) => adt.none(current);
        const CellLocation = {
          ...adt,
          none
        };
        const firstLayer = (scope, selector) => {
          return filterFirstLayer(scope, selector, always);
        };
        const filterFirstLayer = (scope, selector, predicate) => {
          return bind$3(children$1(scope), (x2) => {
            if (is$1(x2, selector)) {
              return predicate(x2) ? [x2] : [];
            } else {
              return filterFirstLayer(x2, selector, predicate);
            }
          });
        };
        const lookup$1 = (tags, element, isRoot2 = never) => {
          if (isRoot2(element)) {
            return Optional.none();
          }
          if (contains$2(tags, name(element))) {
            return Optional.some(element);
          }
          const isRootOrUpperTable = (elm) => is$1(elm, "table") || isRoot2(elm);
          return ancestor$3(element, tags.join(","), isRootOrUpperTable);
        };
        const cell = (element, isRoot2) => lookup$1([
          "td",
          "th"
        ], element, isRoot2);
        const cells = (ancestor2) => firstLayer(ancestor2, "th,td");
        const table = (element, isRoot2) => closest$3(element, "table", isRoot2);
        const walk2 = (all2, current, index, direction, isEligible = always) => {
          const forwards = direction === 1;
          if (!forwards && index <= 0) {
            return CellLocation.first(all2[0]);
          } else if (forwards && index >= all2.length - 1) {
            return CellLocation.last(all2[all2.length - 1]);
          } else {
            const newIndex = index + direction;
            const elem = all2[newIndex];
            return isEligible(elem) ? CellLocation.middle(current, elem) : walk2(all2, current, newIndex, direction, isEligible);
          }
        };
        const detect = (current, isRoot2) => {
          return table(current, isRoot2).bind((table2) => {
            const all2 = cells(table2);
            const index = findIndex$2(all2, (x2) => eq(current, x2));
            return index.map((index2) => ({
              index: index2,
              all: all2
            }));
          });
        };
        const next = (current, isEligible, isRoot2) => {
          const detection = detect(current, isRoot2);
          return detection.fold(() => {
            return CellLocation.none(current);
          }, (info) => {
            return walk2(info.all, current, info.index, 1, isEligible);
          });
        };
        const prev = (current, isEligible, isRoot2) => {
          const detection = detect(current, isRoot2);
          return detection.fold(() => {
            return CellLocation.none();
          }, (info) => {
            return walk2(info.all, current, info.index, -1, isEligible);
          });
        };
        const deflate = (rect, delta) => ({
          left: rect.left - delta,
          top: rect.top - delta,
          right: rect.right + delta * 2,
          bottom: rect.bottom + delta * 2,
          width: rect.width + delta,
          height: rect.height + delta
        });
        const getCorners = (getYAxisValue, tds) => bind$3(tds, (td) => {
          const rect = deflate(clone$1(td.getBoundingClientRect()), -1);
          return [
            {
              x: rect.left,
              y: getYAxisValue(rect),
              cell: td
            },
            {
              x: rect.right,
              y: getYAxisValue(rect),
              cell: td
            }
          ];
        });
        const findClosestCorner = (corners, x2, y2) => foldl(corners, (acc, newCorner) => acc.fold(() => Optional.some(newCorner), (oldCorner) => {
          const oldDist = Math.sqrt(Math.abs(oldCorner.x - x2) + Math.abs(oldCorner.y - y2));
          const newDist = Math.sqrt(Math.abs(newCorner.x - x2) + Math.abs(newCorner.y - y2));
          return Optional.some(newDist < oldDist ? newCorner : oldCorner);
        }), Optional.none());
        const getClosestCell = (getYAxisValue, isTargetCorner, table2, x2, y2) => {
          const cells2 = descendants(SugarElement.fromDom(table2), "td,th,caption").map((e2) => e2.dom);
          const corners = filter$5(getCorners(getYAxisValue, cells2), (corner) => isTargetCorner(corner, y2));
          return findClosestCorner(corners, x2, y2).map((corner) => corner.cell);
        };
        const getBottomValue = (rect) => rect.bottom;
        const getTopValue = (rect) => rect.top;
        const isAbove = (corner, y2) => corner.y < y2;
        const isBelow = (corner, y2) => corner.y > y2;
        const getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove);
        const getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow);
        const findClosestPositionInAboveCell = (table2, pos) => head(pos.getClientRects()).bind((rect) => getClosestCellAbove(table2, rect.left, rect.top)).bind((cell2) => findClosestHorizontalPosition(getLastLinePositions(cell2), pos));
        const findClosestPositionInBelowCell = (table2, pos) => last$3(pos.getClientRects()).bind((rect) => getClosestCellBelow(table2, rect.left, rect.top)).bind((cell2) => findClosestHorizontalPosition(getFirstLinePositions(cell2), pos));
        const hasNextBreak = (getPositionsUntil2, scope, lineInfo) => lineInfo.breakAt.exists((breakPos) => getPositionsUntil2(scope, breakPos).breakAt.isSome());
        const startsWithWrapBreak = (lineInfo) => lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;
        const startsWithBrBreak = (lineInfo) => lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;
        const isAtTableCellLine = (getPositionsUntil2, scope, pos) => {
          const lineInfo = getPositionsUntil2(scope, pos);
          if (startsWithWrapBreak(lineInfo) || !isBr$6(pos.getNode()) && startsWithBrBreak(lineInfo)) {
            return !hasNextBreak(getPositionsUntil2, scope, lineInfo);
          } else {
            return lineInfo.breakAt.isNone();
          }
        };
        const isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);
        const isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);
        const isCaretAtStartOrEndOfTable = (forward, rng, table2) => {
          const caretPos = CaretPosition.fromRangeStart(rng);
          return positionIn(!forward, table2).exists((pos) => pos.isEqual(caretPos));
        };
        const navigateHorizontally = (editor, forward, table2, _td) => {
          const rng = editor.selection.getRng();
          const direction = forward ? 1 : -1;
          if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table2)) {
            showCaret(direction, editor, table2, !forward, false).each((newRng) => {
              moveToRange(editor, newRng);
            });
            return true;
          }
          return false;
        };
        const getClosestAbovePosition = (root, table2, start4) => findClosestPositionInAboveCell(table2, start4).orThunk(() => head(start4.getClientRects()).bind((rect) => findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition.before(table2)), rect.left))).getOr(CaretPosition.before(table2));
        const getClosestBelowPosition = (root, table2, start4) => findClosestPositionInBelowCell(table2, start4).orThunk(() => head(start4.getClientRects()).bind((rect) => findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition.after(table2)), rect.left))).getOr(CaretPosition.after(table2));
        const getTable = (previous, pos) => {
          const node = pos.getNode(previous);
          return isTable$2(node) ? Optional.some(node) : Optional.none();
        };
        const renderBlock = (down, editor, table2) => {
          editor.undoManager.transact(() => {
            const insertFn = down ? after$4 : before$3;
            const rng = insertEmptyLine(editor, SugarElement.fromDom(table2), insertFn);
            moveToRange(editor, rng);
          });
        };
        const moveCaret = (editor, down, pos) => {
          const table2 = down ? getTable(true, pos) : getTable(false, pos);
          const last2 = down === false;
          table2.fold(() => moveToRange(editor, pos.toRange()), (table3) => positionIn(last2, editor.getBody()).filter((lastPos) => lastPos.isEqual(pos)).fold(() => moveToRange(editor, pos.toRange()), (_2) => renderBlock(down, editor, table3)));
        };
        const navigateVertically = (editor, down, table2, td) => {
          const rng = editor.selection.getRng();
          const pos = CaretPosition.fromRangeStart(rng);
          const root = editor.getBody();
          if (!down && isAtFirstTableCellLine(td, pos)) {
            const newPos = getClosestAbovePosition(root, table2, pos);
            moveCaret(editor, down, newPos);
            return true;
          } else if (down && isAtLastTableCellLine(td, pos)) {
            const newPos = getClosestBelowPosition(root, table2, pos);
            moveCaret(editor, down, newPos);
            return true;
          } else {
            return false;
          }
        };
        const move$1 = (editor, forward, mover) => Optional.from(editor.dom.getParent(editor.selection.getNode(), "td,th")).bind((td) => Optional.from(editor.dom.getParent(td, "table")).map((table2) => mover(editor, forward, table2, td))).getOr(false);
        const moveH = (editor, forward) => move$1(editor, forward, navigateHorizontally);
        const moveV = (editor, forward) => move$1(editor, forward, navigateVertically);
        const getCellFirstCursorPosition = (cell2) => {
          const selection = SimSelection.exact(cell2, 0, cell2, 0);
          return toNative(selection);
        };
        const tabGo = (editor, isRoot2, cell2) => {
          return cell2.fold(Optional.none, Optional.none, (_current, next2) => {
            return first(next2).map((cell3) => {
              return getCellFirstCursorPosition(cell3);
            });
          }, (current) => {
            editor.execCommand("mceTableInsertRowAfter");
            return tabForward(editor, isRoot2, current);
          });
        };
        const tabForward = (editor, isRoot2, cell2) => tabGo(editor, isRoot2, next(cell2, isEditable$3));
        const tabBackward = (editor, isRoot2, cell2) => tabGo(editor, isRoot2, prev(cell2, isEditable$3));
        const handleTab = (editor, forward) => {
          const rootElements = [
            "table",
            "li",
            "dl"
          ];
          const body = SugarElement.fromDom(editor.getBody());
          const isRoot2 = (element) => {
            const name$1 = name(element);
            return eq(element, body) || contains$2(rootElements, name$1);
          };
          const rng = editor.selection.getRng();
          const container = SugarElement.fromDom(!forward ? rng.startContainer : rng.endContainer);
          return cell(container, isRoot2).map((cell2) => {
            table(cell2, isRoot2).each((table2) => {
              editor.model.table.clearSelectedCells(table2.dom);
            });
            editor.selection.collapse(!forward);
            const navigation = !forward ? tabBackward : tabForward;
            const rng2 = navigation(editor, isRoot2, cell2);
            rng2.each((range2) => {
              editor.selection.setRng(range2);
            });
            return true;
          }).getOr(false);
        };
        const executeKeydownOverride$4 = (editor, caret, evt) => {
          const isMac = Env.os.isMacOS() || Env.os.isiOS();
          execute2([
            {
              keyCode: VK.RIGHT,
              action: action(moveH$2, editor, true)
            },
            {
              keyCode: VK.LEFT,
              action: action(moveH$2, editor, false)
            },
            {
              keyCode: VK.UP,
              action: action(moveV$3, editor, false)
            },
            {
              keyCode: VK.DOWN,
              action: action(moveV$3, editor, true)
            },
            ...isMac ? [
              {
                keyCode: VK.UP,
                action: action(selectToEndPoint, editor, false),
                metaKey: true,
                shiftKey: true
              },
              {
                keyCode: VK.DOWN,
                action: action(selectToEndPoint, editor, true),
                metaKey: true,
                shiftKey: true
              }
            ] : [],
            {
              keyCode: VK.RIGHT,
              action: action(moveH, editor, true)
            },
            {
              keyCode: VK.LEFT,
              action: action(moveH, editor, false)
            },
            {
              keyCode: VK.UP,
              action: action(moveV, editor, false)
            },
            {
              keyCode: VK.DOWN,
              action: action(moveV, editor, true)
            },
            {
              keyCode: VK.RIGHT,
              action: action(moveH$1, editor, true)
            },
            {
              keyCode: VK.LEFT,
              action: action(moveH$1, editor, false)
            },
            {
              keyCode: VK.UP,
              action: action(moveV$1, editor, false)
            },
            {
              keyCode: VK.DOWN,
              action: action(moveV$1, editor, true)
            },
            {
              keyCode: VK.RIGHT,
              action: action(move$2, editor, caret, true)
            },
            {
              keyCode: VK.LEFT,
              action: action(move$2, editor, caret, false)
            },
            {
              keyCode: VK.RIGHT,
              ctrlKey: !isMac,
              altKey: isMac,
              action: action(moveNextWord, editor, caret)
            },
            {
              keyCode: VK.LEFT,
              ctrlKey: !isMac,
              altKey: isMac,
              action: action(movePrevWord, editor, caret)
            },
            {
              keyCode: VK.UP,
              action: action(moveV$2, editor, false)
            },
            {
              keyCode: VK.DOWN,
              action: action(moveV$2, editor, true)
            }
          ], evt).each((_2) => {
            evt.preventDefault();
          });
        };
        const setup$k = (editor, caret) => {
          editor.on("keydown", (evt) => {
            if (!evt.isDefaultPrevented()) {
              executeKeydownOverride$4(editor, caret, evt);
            }
          });
        };
        const point = (container, offset2) => ({
          container,
          offset: offset2
        });
        const DOM$7 = DOMUtils.DOM;
        const alwaysNext = (startNode) => (node) => startNode === node ? -1 : 0;
        const isBoundary = (dom2) => (node) => dom2.isBlock(node) || contains$2([
          "BR",
          "IMG",
          "HR",
          "INPUT"
        ], node.nodeName) || dom2.getContentEditable(node) === "false";
        const textBefore = (node, offset2, rootNode) => {
          if (isText$a(node) && offset2 >= 0) {
            return Optional.some(point(node, offset2));
          } else {
            const textSeeker = TextSeeker(DOM$7);
            return Optional.from(textSeeker.backwards(node, offset2, alwaysNext(node), rootNode)).map((prev2) => point(prev2.container, prev2.container.data.length));
          }
        };
        const textAfter = (node, offset2, rootNode) => {
          if (isText$a(node) && offset2 >= node.length) {
            return Optional.some(point(node, offset2));
          } else {
            const textSeeker = TextSeeker(DOM$7);
            return Optional.from(textSeeker.forwards(node, offset2, alwaysNext(node), rootNode)).map((prev2) => point(prev2.container, 0));
          }
        };
        const scanLeft = (node, offset2, rootNode) => {
          if (!isText$a(node)) {
            return Optional.none();
          }
          const text2 = node.data;
          if (offset2 >= 0 && offset2 <= text2.length) {
            return Optional.some(point(node, offset2));
          } else {
            const textSeeker = TextSeeker(DOM$7);
            return Optional.from(textSeeker.backwards(node, offset2, alwaysNext(node), rootNode)).bind((prev2) => {
              const prevText = prev2.container.data;
              return scanLeft(prev2.container, offset2 + prevText.length, rootNode);
            });
          }
        };
        const scanRight = (node, offset2, rootNode) => {
          if (!isText$a(node)) {
            return Optional.none();
          }
          const text2 = node.data;
          if (offset2 <= text2.length) {
            return Optional.some(point(node, offset2));
          } else {
            const textSeeker = TextSeeker(DOM$7);
            return Optional.from(textSeeker.forwards(node, offset2, alwaysNext(node), rootNode)).bind((next2) => scanRight(next2.container, offset2 - text2.length, rootNode));
          }
        };
        const repeatLeft = (dom2, node, offset2, process2, rootNode) => {
          const search2 = TextSeeker(dom2, isBoundary(dom2));
          return Optional.from(search2.backwards(node, offset2, process2, rootNode));
        };
        const isValidTextRange = (rng) => rng.collapsed && isText$a(rng.startContainer);
        const getText = (rng) => trim$1(rng.toString().replace(/\u00A0/g, " "));
        const isWhitespace = (chr) => chr !== "" && " \xA0\f\n\r	\v".indexOf(chr) !== -1;
        const stripTrigger = (text2, trigger) => text2.substring(trigger.length);
        const findTrigger = (text2, index, trigger) => {
          let i2;
          const firstChar = trigger.charAt(0);
          for (i2 = index - 1; i2 >= 0; i2--) {
            const char = text2.charAt(i2);
            if (isWhitespace(char)) {
              return Optional.none();
            }
            if (firstChar === char && contains$1(text2, trigger, i2, index)) {
              break;
            }
          }
          return Optional.some(i2);
        };
        const findStart = (dom2, initRange, trigger, minChars = 0) => {
          if (!isValidTextRange(initRange)) {
            return Optional.none();
          }
          const buffer = {
            text: "",
            offset: 0
          };
          const findTriggerIndex = (element, offset2, text2) => {
            buffer.text = text2 + buffer.text;
            buffer.offset += offset2;
            return findTrigger(buffer.text, buffer.offset, trigger).getOr(offset2);
          };
          const root = dom2.getParent(initRange.startContainer, dom2.isBlock) || dom2.getRoot();
          return repeatLeft(dom2, initRange.startContainer, initRange.startOffset, findTriggerIndex, root).bind((spot) => {
            const range2 = initRange.cloneRange();
            range2.setStart(spot.container, spot.offset);
            range2.setEnd(initRange.endContainer, initRange.endOffset);
            if (range2.collapsed) {
              return Optional.none();
            }
            const text2 = getText(range2);
            const triggerIndex = text2.lastIndexOf(trigger);
            if (triggerIndex !== 0 || stripTrigger(text2, trigger).length < minChars) {
              return Optional.none();
            } else {
              return Optional.some({
                text: stripTrigger(text2, trigger),
                range: range2,
                trigger
              });
            }
          });
        };
        const getContext = (dom2, initRange, trigger, minChars = 0) => detect$1(SugarElement.fromDom(initRange.startContainer)).fold(() => findStart(dom2, initRange, trigger, minChars), (elm) => {
          const range2 = dom2.createRng();
          range2.selectNode(elm.dom);
          const text2 = getText(range2);
          return Optional.some({
            range: range2,
            text: stripTrigger(text2, trigger),
            trigger
          });
        });
        const isText$1 = (node) => node.nodeType === TEXT;
        const isElement3 = (node) => node.nodeType === ELEMENT;
        const toLast = (node) => {
          if (isText$1(node)) {
            return point(node, node.data.length);
          } else {
            const children2 = node.childNodes;
            return children2.length > 0 ? toLast(children2[children2.length - 1]) : point(node, children2.length);
          }
        };
        const toLeaf = (node, offset2) => {
          const children2 = node.childNodes;
          if (children2.length > 0 && offset2 < children2.length) {
            return toLeaf(children2[offset2], 0);
          } else if (children2.length > 0 && isElement3(node) && children2.length === offset2) {
            return toLast(children2[children2.length - 1]);
          } else {
            return point(node, offset2);
          }
        };
        const isPreviousCharContent = (dom2, leaf) => {
          var _a;
          const root = (_a = dom2.getParent(leaf.container, dom2.isBlock)) !== null && _a !== void 0 ? _a : dom2.getRoot();
          return repeatLeft(dom2, leaf.container, leaf.offset, (_element, offset2) => offset2 === 0 ? -1 : offset2, root).filter((spot) => {
            const char = spot.container.data.charAt(spot.offset - 1);
            return !isWhitespace(char);
          }).isSome();
        };
        const isStartOfWord = (dom2) => (rng) => {
          const leaf = toLeaf(rng.startContainer, rng.startOffset);
          return !isPreviousCharContent(dom2, leaf);
        };
        const getTriggerContext = (dom2, initRange, database) => findMap(database.triggers, (trigger) => getContext(dom2, initRange, trigger));
        const lookup = (editor, getDatabase) => {
          const database = getDatabase();
          const rng = editor.selection.getRng();
          return getTriggerContext(editor.dom, rng, database).bind((context2) => lookupWithContext(editor, getDatabase, context2));
        };
        const lookupWithContext = (editor, getDatabase, context2, fetchOptions = {}) => {
          var _a;
          const database = getDatabase();
          const rng = editor.selection.getRng();
          const startText = (_a = rng.startContainer.nodeValue) !== null && _a !== void 0 ? _a : "";
          const autocompleters = filter$5(database.lookupByTrigger(context2.trigger), (autocompleter) => context2.text.length >= autocompleter.minChars && autocompleter.matches.getOrThunk(() => isStartOfWord(editor.dom))(context2.range, startText, context2.text));
          if (autocompleters.length === 0) {
            return Optional.none();
          }
          const lookupData = Promise.all(map$3(autocompleters, (ac) => {
            const fetchResult = ac.fetch(context2.text, ac.maxResults, fetchOptions);
            return fetchResult.then((results) => ({
              matchText: context2.text,
              items: results,
              columns: ac.columns,
              onAction: ac.onAction,
              highlightOn: ac.highlightOn
            }));
          }));
          return Optional.some({
            lookupData,
            context: context2
          });
        };
        var SimpleResultType;
        (function(SimpleResultType2) {
          SimpleResultType2[SimpleResultType2["Error"] = 0] = "Error";
          SimpleResultType2[SimpleResultType2["Value"] = 1] = "Value";
        })(SimpleResultType || (SimpleResultType = {}));
        const fold$1 = (res, onError, onValue) => res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);
        const partition = (results) => {
          const values2 = [];
          const errors = [];
          each$e(results, (obj) => {
            fold$1(obj, (err) => errors.push(err), (val) => values2.push(val));
          });
          return {
            values: values2,
            errors
          };
        };
        const mapError = (res, f2) => {
          if (res.stype === SimpleResultType.Error) {
            return {
              stype: SimpleResultType.Error,
              serror: f2(res.serror)
            };
          } else {
            return res;
          }
        };
        const map = (res, f2) => {
          if (res.stype === SimpleResultType.Value) {
            return {
              stype: SimpleResultType.Value,
              svalue: f2(res.svalue)
            };
          } else {
            return res;
          }
        };
        const bind$1 = (res, f2) => {
          if (res.stype === SimpleResultType.Value) {
            return f2(res.svalue);
          } else {
            return res;
          }
        };
        const bindError = (res, f2) => {
          if (res.stype === SimpleResultType.Error) {
            return f2(res.serror);
          } else {
            return res;
          }
        };
        const svalue = (v2) => ({
          stype: SimpleResultType.Value,
          svalue: v2
        });
        const serror = (e2) => ({
          stype: SimpleResultType.Error,
          serror: e2
        });
        const toResult = (res) => fold$1(res, Result.error, Result.value);
        const fromResult = (res) => res.fold(serror, svalue);
        const SimpleResult = {
          fromResult,
          toResult,
          svalue,
          partition,
          serror,
          bind: bind$1,
          bindError,
          map,
          mapError,
          fold: fold$1
        };
        const formatObj = (input) => {
          return isObject(input) && keys(input).length > 100 ? " removed due to size" : JSON.stringify(input, null, 2);
        };
        const formatErrors = (errors) => {
          const es = errors.length > 10 ? errors.slice(0, 10).concat([{
            path: [],
            getErrorInfo: constant("... (only showing first ten failures)")
          }]) : errors;
          return map$3(es, (e2) => {
            return "Failed path: (" + e2.path.join(" > ") + ")\n" + e2.getErrorInfo();
          });
        };
        const nu = (path2, getErrorInfo) => {
          return SimpleResult.serror([{
            path: path2,
            getErrorInfo
          }]);
        };
        const missingRequired = (path2, key, obj) => nu(path2, () => 'Could not find valid *required* value for "' + key + '" in ' + formatObj(obj));
        const missingKey = (path2, key) => nu(path2, () => 'Choice schema did not contain choice key: "' + key + '"');
        const missingBranch = (path2, branches, branch) => nu(path2, () => 'The chosen schema: "' + branch + '" did not exist in branches: ' + formatObj(branches));
        const custom = (path2, err) => nu(path2, constant(err));
        const chooseFrom = (path2, input, branches, ch) => {
          const fields = get$a(branches, ch);
          return fields.fold(() => missingBranch(path2, branches, ch), (vp) => vp.extract(path2.concat(["branch: " + ch]), input));
        };
        const choose$1 = (key, branches) => {
          const extract = (path2, input) => {
            const choice = get$a(input, key);
            return choice.fold(() => missingKey(path2, key), (chosen) => chooseFrom(path2, input, branches, chosen));
          };
          const toString = () => "chooseOn(" + key + "). Possible values: " + keys(branches);
          return {
            extract,
            toString
          };
        };
        const shallow = (old, nu2) => {
          return nu2;
        };
        const deep = (old, nu2) => {
          const bothObjects = isPlainObject(old) && isPlainObject(nu2);
          return bothObjects ? deepMerge(old, nu2) : nu2;
        };
        const baseMerge = (merger) => {
          return (...objects) => {
            if (objects.length === 0) {
              throw new Error(`Can't merge zero objects`);
            }
            const ret = {};
            for (let j2 = 0; j2 < objects.length; j2++) {
              const curObject = objects[j2];
              for (const key in curObject) {
                if (has$2(curObject, key)) {
                  ret[key] = merger(ret[key], curObject[key]);
                }
              }
            }
            return ret;
          };
        };
        const deepMerge = baseMerge(deep);
        const merge = baseMerge(shallow);
        const required = () => ({
          tag: "required",
          process: {}
        });
        const defaultedThunk = (fallbackThunk) => ({
          tag: "defaultedThunk",
          process: fallbackThunk
        });
        const defaulted$1 = (fallback2) => defaultedThunk(constant(fallback2));
        const asOption = () => ({
          tag: "option",
          process: {}
        });
        const mergeValues = (values2, base) => values2.length > 0 ? SimpleResult.svalue(deepMerge(base, merge.apply(void 0, values2))) : SimpleResult.svalue(base);
        const mergeErrors = (errors) => compose(SimpleResult.serror, flatten)(errors);
        const consolidateObj = (objects, base) => {
          const partition2 = SimpleResult.partition(objects);
          return partition2.errors.length > 0 ? mergeErrors(partition2.errors) : mergeValues(partition2.values, base);
        };
        const consolidateArr = (objects) => {
          const partitions = SimpleResult.partition(objects);
          return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : SimpleResult.svalue(partitions.values);
        };
        const ResultCombine = {
          consolidateObj,
          consolidateArr
        };
        const field$1 = (key, newKey, presence, prop) => ({
          tag: "field",
          key,
          newKey,
          presence,
          prop
        });
        const customField$1 = (newKey, instantiator) => ({
          tag: "custom",
          newKey,
          instantiator
        });
        const fold = (value2, ifField, ifCustom) => {
          switch (value2.tag) {
            case "field":
              return ifField(value2.key, value2.newKey, value2.presence, value2.prop);
            case "custom":
              return ifCustom(value2.newKey, value2.instantiator);
          }
        };
        const value = (validator) => {
          const extract = (path2, val) => {
            return SimpleResult.bindError(validator(val), (err) => custom(path2, err));
          };
          const toString = constant("val");
          return {
            extract,
            toString
          };
        };
        const anyValue$1 = value(SimpleResult.svalue);
        const requiredAccess = (path2, obj, key, bundle) => get$a(obj, key).fold(() => missingRequired(path2, key, obj), bundle);
        const fallbackAccess = (obj, key, fallback2, bundle) => {
          const v2 = get$a(obj, key).getOrThunk(() => fallback2(obj));
          return bundle(v2);
        };
        const optionAccess = (obj, key, bundle) => bundle(get$a(obj, key));
        const optionDefaultedAccess = (obj, key, fallback2, bundle) => {
          const opt = get$a(obj, key).map((val) => val === true ? fallback2(obj) : val);
          return bundle(opt);
        };
        const extractField = (field2, path2, obj, key, prop) => {
          const bundle = (av) => prop.extract(path2.concat([key]), av);
          const bundleAsOption = (optValue) => optValue.fold(() => SimpleResult.svalue(Optional.none()), (ov) => {
            const result = prop.extract(path2.concat([key]), ov);
            return SimpleResult.map(result, Optional.some);
          });
          switch (field2.tag) {
            case "required":
              return requiredAccess(path2, obj, key, bundle);
            case "defaultedThunk":
              return fallbackAccess(obj, key, field2.process, bundle);
            case "option":
              return optionAccess(obj, key, bundleAsOption);
            case "defaultedOptionThunk":
              return optionDefaultedAccess(obj, key, field2.process, bundleAsOption);
            case "mergeWithThunk": {
              return fallbackAccess(obj, key, constant({}), (v2) => {
                const result = deepMerge(field2.process(obj), v2);
                return bundle(result);
              });
            }
          }
        };
        const extractFields = (path2, obj, fields) => {
          const success = {};
          const errors = [];
          for (const field2 of fields) {
            fold(field2, (key, newKey, presence, prop) => {
              const result = extractField(presence, path2, obj, key, prop);
              SimpleResult.fold(result, (err) => {
                errors.push(...err);
              }, (res) => {
                success[newKey] = res;
              });
            }, (newKey, instantiator) => {
              success[newKey] = instantiator(obj);
            });
          }
          return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);
        };
        const objOf = (values2) => {
          const extract = (path2, o2) => extractFields(path2, o2, values2);
          const toString = () => {
            const fieldStrings = map$3(values2, (value2) => fold(value2, (key, _okey, _presence, prop) => key + " -> " + prop.toString(), (newKey, _instantiator) => "state(" + newKey + ")"));
            return "obj{\n" + fieldStrings.join("\n") + "}";
          };
          return {
            extract,
            toString
          };
        };
        const arrOf = (prop) => {
          const extract = (path2, array) => {
            const results = map$3(array, (a2, i2) => prop.extract(path2.concat(["[" + i2 + "]"]), a2));
            return ResultCombine.consolidateArr(results);
          };
          const toString = () => "array(" + prop.toString() + ")";
          return {
            extract,
            toString
          };
        };
        const valueOf = (validator) => value((v2) => validator(v2).fold(SimpleResult.serror, SimpleResult.svalue));
        const extractValue = (label, prop, obj) => {
          const res = prop.extract([label], obj);
          return SimpleResult.mapError(res, (errs) => ({
            input: obj,
            errors: errs
          }));
        };
        const asRaw = (label, prop, obj) => SimpleResult.toResult(extractValue(label, prop, obj));
        const formatError = (errInfo) => {
          return "Errors: \n" + formatErrors(errInfo.errors).join("\n") + "\n\nInput object: " + formatObj(errInfo.input);
        };
        const choose = (key, branches) => choose$1(key, map$2(branches, objOf));
        const anyValue = constant(anyValue$1);
        const typedValue = (validator, expectedType) => value((a2) => {
          const actualType = typeof a2;
          return validator(a2) ? SimpleResult.svalue(a2) : SimpleResult.serror(`Expected type: ${expectedType} but got: ${actualType}`);
        });
        const number = typedValue(isNumber, "number");
        const string = typedValue(isString, "string");
        const boolean = typedValue(isBoolean, "boolean");
        const functionProcessor = typedValue(isFunction, "function");
        const field = field$1;
        const customField = customField$1;
        const validateEnum = (values2) => valueOf((value2) => contains$2(values2, value2) ? Result.value(value2) : Result.error(`Unsupported value: "${value2}", choose one of "${values2.join(", ")}".`));
        const requiredOf = (key, schema) => field(key, key, required(), schema);
        const requiredString = (key) => requiredOf(key, string);
        const requiredFunction = (key) => requiredOf(key, functionProcessor);
        const requiredArrayOf = (key, schema) => field(key, key, required(), arrOf(schema));
        const optionOf = (key, schema) => field(key, key, asOption(), schema);
        const optionString = (key) => optionOf(key, string);
        const optionFunction = (key) => optionOf(key, functionProcessor);
        const defaulted = (key, fallback2) => field(key, key, defaulted$1(fallback2), anyValue());
        const defaultedOf = (key, fallback2, schema) => field(key, key, defaulted$1(fallback2), schema);
        const defaultedNumber = (key, fallback2) => defaultedOf(key, fallback2, number);
        const defaultedString = (key, fallback2) => defaultedOf(key, fallback2, string);
        const defaultedStringEnum = (key, fallback2, values2) => defaultedOf(key, fallback2, validateEnum(values2));
        const defaultedBoolean = (key, fallback2) => defaultedOf(key, fallback2, boolean);
        const defaultedFunction = (key, fallback2) => defaultedOf(key, fallback2, functionProcessor);
        const defaultedArrayOf = (key, fallback2, schema) => defaultedOf(key, fallback2, arrOf(schema));
        const type = requiredString("type");
        const fetch$1 = requiredFunction("fetch");
        const onAction = requiredFunction("onAction");
        const onSetup = defaultedFunction("onSetup", () => noop2);
        const optionalText = optionString("text");
        const optionalIcon = optionString("icon");
        const optionalTooltip = optionString("tooltip");
        const optionalLabel = optionString("label");
        const active = defaultedBoolean("active", false);
        const enabled = defaultedBoolean("enabled", true);
        const primary = defaultedBoolean("primary", false);
        const defaultedColumns = (num) => defaulted("columns", num);
        const defaultedType = (type2) => defaultedString("type", type2);
        const autocompleterSchema = objOf([
          type,
          requiredString("trigger"),
          defaultedNumber("minChars", 1),
          defaultedColumns(1),
          defaultedNumber("maxResults", 10),
          optionFunction("matches"),
          fetch$1,
          onAction,
          defaultedArrayOf("highlightOn", [], string)
        ]);
        const createAutocompleter = (spec) => asRaw("Autocompleter", autocompleterSchema, {
          trigger: spec.ch,
          ...spec
        });
        const baseToolbarButtonFields = [
          enabled,
          optionalTooltip,
          optionalIcon,
          optionalText,
          onSetup
        ];
        const baseToolbarToggleButtonFields = [active].concat(baseToolbarButtonFields);
        const contextBarFields = [
          defaultedFunction("predicate", never),
          defaultedStringEnum("scope", "node", [
            "node",
            "editor"
          ]),
          defaultedStringEnum("position", "selection", [
            "node",
            "selection",
            "line"
          ])
        ];
        const contextButtonFields = baseToolbarButtonFields.concat([
          defaultedType("contextformbutton"),
          primary,
          onAction,
          customField("original", identity)
        ]);
        const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([
          defaultedType("contextformbutton"),
          primary,
          onAction,
          customField("original", identity)
        ]);
        const launchButtonFields = baseToolbarButtonFields.concat([defaultedType("contextformbutton")]);
        const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType("contextformtogglebutton")]);
        const toggleOrNormal = choose("type", {
          contextformbutton: contextButtonFields,
          contextformtogglebutton: contextToggleButtonFields
        });
        objOf([
          defaultedType("contextform"),
          defaultedFunction("initValue", constant("")),
          optionalLabel,
          requiredArrayOf("commands", toggleOrNormal),
          optionOf("launch", choose("type", {
            contextformbutton: launchButtonFields,
            contextformtogglebutton: launchToggleButtonFields
          }))
        ].concat(contextBarFields));
        const register$2 = (editor) => {
          const popups = editor.ui.registry.getAll().popups;
          const dataset = map$2(popups, (popup) => createAutocompleter(popup).fold((err) => {
            throw new Error(formatError(err));
          }, identity));
          const triggers = stringArray(mapToArray(dataset, (v2) => v2.trigger));
          const datasetValues = values(dataset);
          const lookupByTrigger = (trigger) => filter$5(datasetValues, (dv) => dv.trigger === trigger);
          return {
            dataset,
            triggers,
            lookupByTrigger
          };
        };
        const setupEditorInput = (editor, api2) => {
          const update = last$1(api2.load, 50);
          editor.on("keypress compositionend", (e2) => {
            if (e2.which === 27) {
              return;
            }
            update.throttle();
          });
          editor.on("keydown", (e2) => {
            const keyCode = e2.which;
            if (keyCode === 8) {
              update.throttle();
            } else if (keyCode === 27) {
              api2.cancelIfNecessary();
            }
          });
          editor.on("remove", update.cancel);
        };
        const setup$j = (editor) => {
          const activeAutocompleter = value$2();
          const uiActive = Cell(false);
          const isActive = activeAutocompleter.isSet;
          const cancelIfNecessary = () => {
            if (isActive()) {
              removeAutocompleterDecoration(editor);
              fireAutocompleterEnd(editor);
              uiActive.set(false);
              activeAutocompleter.clear();
            }
          };
          const commenceIfNecessary = (context2) => {
            if (!isActive()) {
              addAutocompleterDecoration(editor, context2.range);
              activeAutocompleter.set({
                trigger: context2.trigger,
                matchLength: context2.text.length
              });
            }
          };
          const getAutocompleters = cached(() => register$2(editor));
          const doLookup = (fetchOptions) => activeAutocompleter.get().map((ac) => getContext(editor.dom, editor.selection.getRng(), ac.trigger).bind((newContext) => lookupWithContext(editor, getAutocompleters, newContext, fetchOptions))).getOrThunk(() => lookup(editor, getAutocompleters));
          const load = (fetchOptions) => {
            doLookup(fetchOptions).fold(cancelIfNecessary, (lookupInfo) => {
              commenceIfNecessary(lookupInfo.context);
              lookupInfo.lookupData.then((lookupData) => {
                activeAutocompleter.get().map((ac) => {
                  const context2 = lookupInfo.context;
                  if (ac.trigger === context2.trigger) {
                    if (context2.text.length - ac.matchLength >= 10) {
                      cancelIfNecessary();
                    } else {
                      activeAutocompleter.set({
                        ...ac,
                        matchLength: context2.text.length
                      });
                      if (uiActive.get()) {
                        fireAutocompleterUpdate(editor, { lookupData });
                      } else {
                        uiActive.set(true);
                        fireAutocompleterStart(editor, { lookupData });
                      }
                    }
                  }
                });
              });
            });
          };
          editor.addCommand("mceAutocompleterReload", (_ui, value2) => {
            const fetchOptions = isObject(value2) ? value2.fetchOptions : {};
            load(fetchOptions);
          });
          editor.addCommand("mceAutocompleterClose", cancelIfNecessary);
          setupEditorInput(editor, {
            cancelIfNecessary,
            load
          });
        };
        const createAndFireInputEvent = (eventType) => (editor, inputType, specifics = {}) => {
          const target = editor.getBody();
          const overrides = {
            bubbles: true,
            composed: true,
            data: null,
            isComposing: false,
            detail: 0,
            view: null,
            target,
            currentTarget: target,
            eventPhase: Event.AT_TARGET,
            originalTarget: target,
            explicitOriginalTarget: target,
            isTrusted: false,
            srcElement: target,
            cancelable: false,
            preventDefault: noop2,
            inputType
          };
          const input = clone$3(new InputEvent(eventType));
          return editor.dispatch(eventType, {
            ...input,
            ...overrides,
            ...specifics
          });
        };
        const fireInputEvent = createAndFireInputEvent("input");
        const fireBeforeInputEvent = createAndFireInputEvent("beforeinput");
        const executeKeydownOverride$3 = (editor, caret, evt) => {
          const inputType = evt.keyCode === VK.BACKSPACE ? "deleteContentBackward" : "deleteContentForward";
          executeWithDelayedAction([
            {
              keyCode: VK.BACKSPACE,
              action: action(backspaceDelete, editor)
            },
            {
              keyCode: VK.BACKSPACE,
              action: action(backspaceDelete$5, editor, false)
            },
            {
              keyCode: VK.DELETE,
              action: action(backspaceDelete$5, editor, true)
            },
            {
              keyCode: VK.BACKSPACE,
              action: action(backspaceDelete$6, editor, false)
            },
            {
              keyCode: VK.DELETE,
              action: action(backspaceDelete$6, editor, true)
            },
            {
              keyCode: VK.BACKSPACE,
              action: action(backspaceDelete$3, editor, caret, false)
            },
            {
              keyCode: VK.DELETE,
              action: action(backspaceDelete$3, editor, caret, true)
            },
            {
              keyCode: VK.BACKSPACE,
              action: action(backspaceDelete$9, editor, false)
            },
            {
              keyCode: VK.DELETE,
              action: action(backspaceDelete$9, editor, true)
            },
            {
              keyCode: VK.BACKSPACE,
              action: action(backspaceDelete$4, editor, false)
            },
            {
              keyCode: VK.DELETE,
              action: action(backspaceDelete$4, editor, true)
            },
            {
              keyCode: VK.BACKSPACE,
              action: action(backspaceDelete$1, editor, false)
            },
            {
              keyCode: VK.DELETE,
              action: action(backspaceDelete$1, editor, true)
            },
            {
              keyCode: VK.BACKSPACE,
              action: action(backspaceDelete$7, editor, false)
            },
            {
              keyCode: VK.DELETE,
              action: action(backspaceDelete$7, editor, true)
            },
            {
              keyCode: VK.BACKSPACE,
              action: action(backspaceDelete$8, editor, false)
            },
            {
              keyCode: VK.DELETE,
              action: action(backspaceDelete$8, editor, true)
            },
            {
              keyCode: VK.BACKSPACE,
              action: action(backspaceDelete$2, editor, false)
            },
            {
              keyCode: VK.DELETE,
              action: action(backspaceDelete$2, editor, true)
            }
          ], evt).filter((_2) => editor.selection.isEditable()).each((applyAction) => {
            evt.preventDefault();
            const beforeInput = fireBeforeInputEvent(editor, inputType);
            if (!beforeInput.isDefaultPrevented()) {
              applyAction();
              fireInputEvent(editor, inputType);
            }
          });
        };
        const executeKeyupOverride = (editor, evt, isBackspaceKeydown) => {
          const platform2 = detect$2();
          const os2 = platform2.os;
          const browser2 = platform2.browser;
          const multiDeleteKeyPatterns = os2.isMacOS() ? [
            {
              keyCode: VK.BACKSPACE,
              altKey: true,
              action: action(refreshCaret, editor)
            },
            {
              keyCode: VK.DELETE,
              altKey: true,
              action: action(refreshCaret, editor)
            }
          ] : [
            {
              keyCode: VK.BACKSPACE,
              ctrlKey: true,
              action: action(refreshCaret, editor)
            },
            {
              keyCode: VK.DELETE,
              ctrlKey: true,
              action: action(refreshCaret, editor)
            }
          ];
          if (os2.isMacOS() && isBackspaceKeydown) {
            multiDeleteKeyPatterns.push({
              keyCode: browser2.isFirefox() ? 224 : 91,
              action: action(refreshCaret, editor)
            });
          }
          execute2([
            {
              keyCode: VK.BACKSPACE,
              action: action(paddEmptyElement, editor)
            },
            {
              keyCode: VK.DELETE,
              action: action(paddEmptyElement, editor)
            },
            ...multiDeleteKeyPatterns
          ], evt);
        };
        const setup$i = (editor, caret) => {
          let isBackspaceKeydown = false;
          editor.on("keydown", (evt) => {
            isBackspaceKeydown = evt.keyCode === VK.BACKSPACE;
            if (!evt.isDefaultPrevented()) {
              executeKeydownOverride$3(editor, caret, evt);
            }
          });
          editor.on("keyup", (evt) => {
            if (!evt.isDefaultPrevented()) {
              executeKeyupOverride(editor, evt, isBackspaceKeydown);
            }
            isBackspaceKeydown = false;
          });
        };
        const firstNonWhiteSpaceNodeSibling = (node) => {
          while (node) {
            if (isElement$6(node) || isText$a(node) && node.data && /[\r\n\s]/.test(node.data)) {
              return node;
            }
            node = node.nextSibling;
          }
          return null;
        };
        const moveToCaretPosition = (editor, root) => {
          const dom2 = editor.dom;
          const moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();
          if (!root) {
            return;
          }
          if (/^(LI|DT|DD)$/.test(root.nodeName)) {
            const firstChild2 = firstNonWhiteSpaceNodeSibling(root.firstChild);
            if (firstChild2 && /^(UL|OL|DL)$/.test(firstChild2.nodeName)) {
              root.insertBefore(dom2.doc.createTextNode(nbsp), root.firstChild);
            }
          }
          const rng = dom2.createRng();
          root.normalize();
          if (root.hasChildNodes()) {
            const walker = new DomTreeWalker(root, root);
            let lastNode = root;
            let node;
            while (node = walker.current()) {
              if (isText$a(node)) {
                rng.setStart(node, 0);
                rng.setEnd(node, 0);
                break;
              }
              if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {
                rng.setStartBefore(node);
                rng.setEndBefore(node);
                break;
              }
              lastNode = node;
              node = walker.next();
            }
            if (!node) {
              rng.setStart(lastNode, 0);
              rng.setEnd(lastNode, 0);
            }
          } else {
            if (isBr$6(root)) {
              if (root.nextSibling && dom2.isBlock(root.nextSibling)) {
                rng.setStartBefore(root);
                rng.setEndBefore(root);
              } else {
                rng.setStartAfter(root);
                rng.setEndAfter(root);
              }
            } else {
              rng.setStart(root, 0);
              rng.setEnd(root, 0);
            }
          }
          editor.selection.setRng(rng);
          scrollRangeIntoView(editor, rng);
        };
        const getEditableRoot = (dom2, node) => {
          const root = dom2.getRoot();
          let editableRoot;
          let parent2 = node;
          while (parent2 !== root && parent2 && dom2.getContentEditable(parent2) !== "false") {
            if (dom2.getContentEditable(parent2) === "true") {
              editableRoot = parent2;
            }
            parent2 = parent2.parentNode;
          }
          return parent2 !== root ? editableRoot : root;
        };
        const getParentBlock$1 = (editor) => {
          return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));
        };
        const getParentBlockName = (editor) => {
          return getParentBlock$1(editor).fold(constant(""), (parentBlock) => {
            return parentBlock.nodeName.toUpperCase();
          });
        };
        const isListItemParentBlock = (editor) => {
          return getParentBlock$1(editor).filter((elm) => {
            return isListItem$1(SugarElement.fromDom(elm));
          }).isSome();
        };
        const getDetailsRoot = (editor, element) => editor.dom.getParent(element, isDetails);
        const isAtDetailsEdge = (root, element, isTextBlock2) => {
          let node = element;
          while (node && node !== root && isNull(node.nextSibling)) {
            const parent2 = node.parentElement;
            if (!parent2 || !isTextBlock2(parent2)) {
              return isDetails(parent2);
            }
            node = parent2;
          }
          return false;
        };
        const isLastEmptyBlockInDetails = (editor, shiftKey, element) => !shiftKey && element.nodeName.toLowerCase() === getForcedRootBlock(editor) && editor.dom.isEmpty(element) && isAtDetailsEdge(editor.getBody(), element, (el) => has$2(editor.schema.getTextBlockElements(), el.nodeName.toLowerCase()));
        const insertNewLine = (editor, createNewBlock, parentBlock) => {
          var _a, _b, _c;
          const newBlock = createNewBlock(getForcedRootBlock(editor));
          const root = getDetailsRoot(editor, parentBlock);
          if (!root) {
            return;
          }
          editor.dom.insertAfter(newBlock, root);
          moveToCaretPosition(editor, newBlock);
          if (((_c = (_b = (_a = parentBlock.parentElement) === null || _a === void 0 ? void 0 : _a.childNodes) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0) > 1) {
            editor.dom.remove(parentBlock);
          }
        };
        const hasFirstChild = (elm, name2) => {
          return elm.firstChild && elm.firstChild.nodeName === name2;
        };
        const isFirstChild = (elm) => {
          var _a;
          return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;
        };
        const hasParent = (elm, parentName) => {
          const parentNode = elm === null || elm === void 0 ? void 0 : elm.parentNode;
          return isNonNullable(parentNode) && parentNode.nodeName === parentName;
        };
        const isListBlock = (elm) => {
          return isNonNullable(elm) && /^(OL|UL|LI)$/.test(elm.nodeName);
        };
        const isListItem = (elm) => {
          return isNonNullable(elm) && /^(LI|DT|DD)$/.test(elm.nodeName);
        };
        const isNestedList = (elm) => {
          return isListBlock(elm) && isListBlock(elm.parentNode);
        };
        const getContainerBlock = (containerBlock) => {
          const containerBlockParent = containerBlock.parentNode;
          return isListItem(containerBlockParent) ? containerBlockParent : containerBlock;
        };
        const isFirstOrLastLi = (containerBlock, parentBlock, first2) => {
          let node = containerBlock[first2 ? "firstChild" : "lastChild"];
          while (node) {
            if (isElement$6(node)) {
              break;
            }
            node = node[first2 ? "nextSibling" : "previousSibling"];
          }
          return node === parentBlock;
        };
        const insert$3 = (editor, createNewBlock, containerBlock, parentBlock, newBlockName) => {
          const dom2 = editor.dom;
          const rng = editor.selection.getRng();
          const containerParent = containerBlock.parentNode;
          if (containerBlock === editor.getBody() || !containerParent) {
            return;
          }
          if (isNestedList(containerBlock)) {
            newBlockName = "LI";
          }
          let newBlock = createNewBlock(newBlockName);
          if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {
            if (hasParent(containerBlock, "LI")) {
              const containerBlockParent = getContainerBlock(containerBlock);
              dom2.insertAfter(newBlock, containerBlockParent);
              if (isFirstChild(containerBlock)) {
                dom2.remove(containerBlockParent);
              } else {
                dom2.remove(containerBlock);
              }
            } else {
              dom2.replace(newBlock, containerBlock);
            }
          } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {
            if (hasParent(containerBlock, "LI")) {
              dom2.insertAfter(newBlock, getContainerBlock(containerBlock));
              newBlock.appendChild(dom2.doc.createTextNode(" "));
              newBlock.appendChild(containerBlock);
            } else {
              containerParent.insertBefore(newBlock, containerBlock);
            }
            dom2.remove(parentBlock);
          } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {
            dom2.insertAfter(newBlock, getContainerBlock(containerBlock));
            dom2.remove(parentBlock);
          } else {
            containerBlock = getContainerBlock(containerBlock);
            const tmpRng = rng.cloneRange();
            tmpRng.setStartAfter(parentBlock);
            tmpRng.setEndAfter(containerBlock);
            const fragment = tmpRng.extractContents();
            if (newBlockName === "LI" && hasFirstChild(fragment, "LI")) {
              newBlock = fragment.firstChild;
              dom2.insertAfter(fragment, containerBlock);
            } else {
              dom2.insertAfter(fragment, containerBlock);
              dom2.insertAfter(newBlock, containerBlock);
            }
            dom2.remove(parentBlock);
          }
          moveToCaretPosition(editor, newBlock);
        };
        const trimZwsp = (fragment) => {
          each$e(descendants$1(SugarElement.fromDom(fragment), isText$b), (text2) => {
            const rawNode = text2.dom;
            rawNode.nodeValue = trim$1(rawNode.data);
          });
        };
        const isWithinNonEditableList = (editor, node) => {
          const parentList = editor.dom.getParent(node, "ol,ul,dl");
          return parentList !== null && editor.dom.getContentEditableParent(parentList) === "false";
        };
        const isEmptyAnchor = (dom2, elm) => {
          return elm && elm.nodeName === "A" && dom2.isEmpty(elm);
        };
        const emptyBlock = (elm) => {
          elm.innerHTML = '<br data-mce-bogus="1">';
        };
        const containerAndSiblingName = (container, nodeName) => {
          return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;
        };
        const canSplitBlock = (dom2, node) => {
          return isNonNullable(node) && dom2.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && dom2.isEditable(node.parentNode) && dom2.getContentEditable(node) !== "false";
        };
        const trimInlineElementsOnLeftSideOfBlock = (dom2, nonEmptyElementsMap, block) => {
          var _a;
          const firstChilds = [];
          if (!block) {
            return;
          }
          let currentNode = block;
          while (currentNode = currentNode.firstChild) {
            if (dom2.isBlock(currentNode)) {
              return;
            }
            if (isElement$6(currentNode) && !nonEmptyElementsMap[currentNode.nodeName.toLowerCase()]) {
              firstChilds.push(currentNode);
            }
          }
          let i2 = firstChilds.length;
          while (i2--) {
            currentNode = firstChilds[i2];
            if (!currentNode.hasChildNodes() || currentNode.firstChild === currentNode.lastChild && ((_a = currentNode.firstChild) === null || _a === void 0 ? void 0 : _a.nodeValue) === "") {
              dom2.remove(currentNode);
            } else {
              if (isEmptyAnchor(dom2, currentNode)) {
                dom2.remove(currentNode);
              }
            }
          }
        };
        const normalizeZwspOffset = (start4, container, offset2) => {
          if (!isText$a(container)) {
            return offset2;
          } else if (start4) {
            return offset2 === 1 && container.data.charAt(offset2 - 1) === ZWSP$1 ? 0 : offset2;
          } else {
            return offset2 === container.data.length - 1 && container.data.charAt(offset2) === ZWSP$1 ? container.data.length : offset2;
          }
        };
        const includeZwspInRange = (rng) => {
          const newRng = rng.cloneRange();
          newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));
          newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));
          return newRng;
        };
        const trimLeadingLineBreaks = (node) => {
          let currentNode = node;
          do {
            if (isText$a(currentNode)) {
              currentNode.data = currentNode.data.replace(/^[\r\n]+/, "");
            }
            currentNode = currentNode.firstChild;
          } while (currentNode);
        };
        const applyAttributes = (editor, node, forcedRootBlockAttrs) => {
          const dom2 = editor.dom;
          Optional.from(forcedRootBlockAttrs.style).map(dom2.parseStyle).each((attrStyles) => {
            const currentStyles = getAllRaw(SugarElement.fromDom(node));
            const newStyles = {
              ...currentStyles,
              ...attrStyles
            };
            dom2.setStyles(node, newStyles);
          });
          const attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map((attrClasses) => attrClasses.split(/\s+/));
          const currentClassesOpt = Optional.from(node.className).map((currentClasses) => filter$5(currentClasses.split(/\s+/), (clazz) => clazz !== ""));
          lift2(attrClassesOpt, currentClassesOpt, (attrClasses, currentClasses) => {
            const filteredClasses = filter$5(currentClasses, (clazz) => !contains$2(attrClasses, clazz));
            const newClasses = [
              ...attrClasses,
              ...filteredClasses
            ];
            dom2.setAttrib(node, "class", newClasses.join(" "));
          });
          const appliedAttrs = [
            "style",
            "class"
          ];
          const remainingAttrs = filter$4(forcedRootBlockAttrs, (_2, attrs) => !contains$2(appliedAttrs, attrs));
          dom2.setAttribs(node, remainingAttrs);
        };
        const setForcedBlockAttrs = (editor, node) => {
          const forcedRootBlockName = getForcedRootBlock(editor);
          if (forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {
            const forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);
            applyAttributes(editor, node, forcedRootBlockAttrs);
          }
        };
        const wrapSelfAndSiblingsInDefaultBlock = (editor, newBlockName, rng, container, offset2) => {
          var _a, _b;
          const dom2 = editor.dom;
          const editableRoot = (_a = getEditableRoot(dom2, container)) !== null && _a !== void 0 ? _a : dom2.getRoot();
          let parentBlock = dom2.getParent(container, dom2.isBlock);
          if (!parentBlock || !canSplitBlock(dom2, parentBlock)) {
            parentBlock = parentBlock || editableRoot;
            if (!parentBlock.hasChildNodes()) {
              const newBlock = dom2.create(newBlockName);
              setForcedBlockAttrs(editor, newBlock);
              parentBlock.appendChild(newBlock);
              rng.setStart(newBlock, 0);
              rng.setEnd(newBlock, 0);
              return newBlock;
            }
            let node = container;
            while (node && node.parentNode !== parentBlock) {
              node = node.parentNode;
            }
            let startNode;
            while (node && !dom2.isBlock(node)) {
              startNode = node;
              node = node.previousSibling;
            }
            const startNodeName = (_b = startNode === null || startNode === void 0 ? void 0 : startNode.parentElement) === null || _b === void 0 ? void 0 : _b.nodeName;
            if (startNode && startNodeName && editor.schema.isValidChild(startNodeName, newBlockName.toLowerCase())) {
              const startNodeParent = startNode.parentNode;
              const newBlock = dom2.create(newBlockName);
              setForcedBlockAttrs(editor, newBlock);
              startNodeParent.insertBefore(newBlock, startNode);
              node = startNode;
              while (node && !dom2.isBlock(node)) {
                const next2 = node.nextSibling;
                newBlock.appendChild(node);
                node = next2;
              }
              rng.setStart(container, offset2);
              rng.setEnd(container, offset2);
            }
          }
          return container;
        };
        const addBrToBlockIfNeeded = (dom2, block) => {
          block.normalize();
          const lastChild2 = block.lastChild;
          if (!lastChild2 || isElement$6(lastChild2) && /^(left|right)$/gi.test(dom2.getStyle(lastChild2, "float", true))) {
            dom2.add(block, "br");
          }
        };
        const shouldEndContainer = (editor, container) => {
          const optionValue = shouldEndContainerOnEmptyBlock(editor);
          if (isNullable(container)) {
            return false;
          } else if (isString(optionValue)) {
            return contains$2(Tools.explode(optionValue), container.nodeName.toLowerCase());
          } else {
            return optionValue;
          }
        };
        const insert$2 = (editor, evt) => {
          let container;
          let offset2;
          let parentBlockName;
          let containerBlock;
          let isAfterLastNodeInContainer = false;
          const dom2 = editor.dom;
          const schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();
          const rng = editor.selection.getRng();
          const newBlockName = getForcedRootBlock(editor);
          const isInRoot = rng.collapsed && rng.startContainer === editor.dom.getRoot();
          const start4 = SugarElement.fromDom(rng.startContainer);
          const child2 = child$1(start4, rng.startOffset);
          const isCef = child2.exists((element) => isHTMLElement2(element) && !isEditable$3(element));
          const inRootAndLastOrCef = isInRoot && isCef;
          const createNewBlock = (name2) => {
            let node = container;
            const textInlineElements = schema.getTextInlineElements();
            let block;
            if (name2 || parentBlockName === "TABLE" || parentBlockName === "HR") {
              block = dom2.create(name2 || newBlockName);
            } else {
              block = parentBlock.cloneNode(false);
            }
            let caretNode = block;
            if (shouldKeepStyles(editor) === false) {
              dom2.setAttrib(block, "style", null);
              dom2.setAttrib(block, "class", null);
            } else {
              do {
                if (textInlineElements[node.nodeName]) {
                  if (isCaretNode(node) || isBookmarkNode$1(node)) {
                    continue;
                  }
                  const clonedNode = node.cloneNode(false);
                  dom2.setAttrib(clonedNode, "id", "");
                  if (block.hasChildNodes()) {
                    clonedNode.appendChild(block.firstChild);
                    block.appendChild(clonedNode);
                  } else {
                    caretNode = clonedNode;
                    block.appendChild(clonedNode);
                  }
                }
              } while ((node = node.parentNode) && node !== editableRoot);
            }
            setForcedBlockAttrs(editor, block);
            emptyBlock(caretNode);
            return block;
          };
          const isCaretAtStartOrEndOfBlock = (start5) => {
            const normalizedOffset = normalizeZwspOffset(start5, container, offset2);
            if (isText$a(container) && (start5 ? normalizedOffset > 0 : normalizedOffset < container.data.length)) {
              return false;
            }
            if (container.parentNode === parentBlock && isAfterLastNodeInContainer && !start5) {
              return true;
            }
            if (start5 && isElement$6(container) && container === parentBlock.firstChild) {
              return true;
            }
            if (containerAndSiblingName(container, "TABLE") || containerAndSiblingName(container, "HR")) {
              return isAfterLastNodeInContainer && !start5 || !isAfterLastNodeInContainer && start5;
            }
            const walker = new DomTreeWalker(container, parentBlock);
            if (isText$a(container)) {
              if (start5 && normalizedOffset === 0) {
                walker.prev();
              } else if (!start5 && normalizedOffset === container.data.length) {
                walker.next();
              }
            }
            let node;
            while (node = walker.current()) {
              if (isElement$6(node)) {
                if (!node.getAttribute("data-mce-bogus")) {
                  const name2 = node.nodeName.toLowerCase();
                  if (nonEmptyElementsMap[name2] && name2 !== "br") {
                    return false;
                  }
                }
              } else if (isText$a(node) && !isWhitespaceText(node.data)) {
                return false;
              }
              if (start5) {
                walker.prev();
              } else {
                walker.next();
              }
            }
            return true;
          };
          const insertNewBlockAfter = () => {
            let block;
            if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== "HGROUP") {
              block = createNewBlock(newBlockName);
            } else {
              block = createNewBlock();
            }
            if (shouldEndContainer(editor, containerBlock) && canSplitBlock(dom2, containerBlock) && dom2.isEmpty(parentBlock, void 0, { includeZwsp: true })) {
              block = dom2.split(containerBlock, parentBlock);
            } else {
              dom2.insertAfter(block, parentBlock);
            }
            moveToCaretPosition(editor, block);
            return block;
          };
          normalize$2(dom2, rng).each((normRng) => {
            rng.setStart(normRng.startContainer, normRng.startOffset);
            rng.setEnd(normRng.endContainer, normRng.endOffset);
          });
          container = rng.startContainer;
          offset2 = rng.startOffset;
          const shiftKey = !!(evt && evt.shiftKey);
          const ctrlKey = !!(evt && evt.ctrlKey);
          if (isElement$6(container) && container.hasChildNodes() && !inRootAndLastOrCef) {
            isAfterLastNodeInContainer = offset2 > container.childNodes.length - 1;
            container = container.childNodes[Math.min(offset2, container.childNodes.length - 1)] || container;
            if (isAfterLastNodeInContainer && isText$a(container)) {
              offset2 = container.data.length;
            } else {
              offset2 = 0;
            }
          }
          const editableRoot = getEditableRoot(dom2, container);
          if (!editableRoot || isWithinNonEditableList(editor, container)) {
            return;
          }
          if (!shiftKey) {
            container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset2);
          }
          let parentBlock = dom2.getParent(container, dom2.isBlock) || dom2.getRoot();
          containerBlock = isNonNullable(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.parentNode) ? dom2.getParent(parentBlock.parentNode, dom2.isBlock) : null;
          parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : "";
          const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : "";
          if (containerBlockName === "LI" && !ctrlKey) {
            const liBlock = containerBlock;
            parentBlock = liBlock;
            containerBlock = liBlock.parentNode;
            parentBlockName = containerBlockName;
          }
          if (isElement$6(containerBlock) && isLastEmptyBlockInDetails(editor, shiftKey, parentBlock)) {
            return insertNewLine(editor, createNewBlock, parentBlock);
          }
          if (/^(LI|DT|DD)$/.test(parentBlockName) && isElement$6(containerBlock)) {
            if (dom2.isEmpty(parentBlock)) {
              insert$3(editor, createNewBlock, containerBlock, parentBlock, newBlockName);
              return;
            }
          }
          if (!inRootAndLastOrCef && (parentBlock === editor.getBody() || !canSplitBlock(dom2, parentBlock))) {
            return;
          }
          const parentBlockParent = parentBlock.parentNode;
          let newBlock;
          if (inRootAndLastOrCef) {
            newBlock = createNewBlock(newBlockName);
            child2.fold(() => {
              append$1(start4, SugarElement.fromDom(newBlock));
            }, (child3) => {
              before$3(child3, SugarElement.fromDom(newBlock));
            });
            editor.selection.setCursorLocation(newBlock, 0);
          } else if (isCaretContainerBlock$1(parentBlock)) {
            newBlock = showCaretContainerBlock(parentBlock);
            if (dom2.isEmpty(parentBlock)) {
              emptyBlock(parentBlock);
            }
            setForcedBlockAttrs(editor, newBlock);
            moveToCaretPosition(editor, newBlock);
          } else if (isCaretAtStartOrEndOfBlock(false)) {
            newBlock = insertNewBlockAfter();
          } else if (isCaretAtStartOrEndOfBlock(true) && parentBlockParent) {
            newBlock = parentBlockParent.insertBefore(createNewBlock(), parentBlock);
            const isNearChildren = hasChildNodes(SugarElement.fromDom(rng.startContainer)) && rng.collapsed;
            moveToCaretPosition(editor, containerAndSiblingName(parentBlock, "HR") || isNearChildren ? newBlock : parentBlock);
          } else {
            const tmpRng = includeZwspInRange(rng).cloneRange();
            tmpRng.setEndAfter(parentBlock);
            const fragment = tmpRng.extractContents();
            trimZwsp(fragment);
            trimLeadingLineBreaks(fragment);
            newBlock = fragment.firstChild;
            dom2.insertAfter(fragment, parentBlock);
            trimInlineElementsOnLeftSideOfBlock(dom2, nonEmptyElementsMap, newBlock);
            addBrToBlockIfNeeded(dom2, parentBlock);
            if (dom2.isEmpty(parentBlock)) {
              emptyBlock(parentBlock);
            }
            newBlock.normalize();
            if (dom2.isEmpty(newBlock)) {
              dom2.remove(newBlock);
              insertNewBlockAfter();
            } else {
              setForcedBlockAttrs(editor, newBlock);
              moveToCaretPosition(editor, newBlock);
            }
          }
          dom2.setAttrib(newBlock, "id", "");
          editor.dispatch("NewBlock", { newBlock });
        };
        const fakeEventName$1 = "insertParagraph";
        const blockbreak = {
          insert: insert$2,
          fakeEventName: fakeEventName$1
        };
        const hasRightSideContent = (schema, container, parentBlock) => {
          const walker = new DomTreeWalker(container, parentBlock);
          let node;
          const nonEmptyElementsMap = schema.getNonEmptyElements();
          while (node = walker.next()) {
            if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || isText$a(node) && node.length > 0) {
              return true;
            }
          }
          return false;
        };
        const moveSelectionToBr = (editor, brElm, extraBr) => {
          const rng = editor.dom.createRng();
          if (!extraBr) {
            rng.setStartAfter(brElm);
            rng.setEndAfter(brElm);
          } else {
            rng.setStartBefore(brElm);
            rng.setEndBefore(brElm);
          }
          editor.selection.setRng(rng);
          scrollRangeIntoView(editor, rng);
        };
        const insertBrAtCaret = (editor, evt) => {
          const selection = editor.selection;
          const dom2 = editor.dom;
          const rng = selection.getRng();
          let brElm;
          let extraBr = false;
          normalize$2(dom2, rng).each((normRng) => {
            rng.setStart(normRng.startContainer, normRng.startOffset);
            rng.setEnd(normRng.endContainer, normRng.endOffset);
          });
          let offset2 = rng.startOffset;
          let container = rng.startContainer;
          if (isElement$6(container) && container.hasChildNodes()) {
            const isAfterLastNodeInContainer = offset2 > container.childNodes.length - 1;
            container = container.childNodes[Math.min(offset2, container.childNodes.length - 1)] || container;
            if (isAfterLastNodeInContainer && isText$a(container)) {
              offset2 = container.data.length;
            } else {
              offset2 = 0;
            }
          }
          let parentBlock = dom2.getParent(container, dom2.isBlock);
          const containerBlock = parentBlock && parentBlock.parentNode ? dom2.getParent(parentBlock.parentNode, dom2.isBlock) : null;
          const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : "";
          const isControlKey = !!(evt && evt.ctrlKey);
          if (containerBlockName === "LI" && !isControlKey) {
            parentBlock = containerBlock;
          }
          if (isText$a(container) && offset2 >= container.data.length) {
            if (!hasRightSideContent(editor.schema, container, parentBlock || dom2.getRoot())) {
              brElm = dom2.create("br");
              rng.insertNode(brElm);
              rng.setStartAfter(brElm);
              rng.setEndAfter(brElm);
              extraBr = true;
            }
          }
          brElm = dom2.create("br");
          rangeInsertNode(dom2, rng, brElm);
          moveSelectionToBr(editor, brElm, extraBr);
          editor.undoManager.add();
        };
        const insertBrBefore = (editor, inline) => {
          const br = SugarElement.fromTag("br");
          before$3(SugarElement.fromDom(inline), br);
          editor.undoManager.add();
        };
        const insertBrAfter = (editor, inline) => {
          if (!hasBrAfter(editor.getBody(), inline)) {
            after$4(SugarElement.fromDom(inline), SugarElement.fromTag("br"));
          }
          const br = SugarElement.fromTag("br");
          after$4(SugarElement.fromDom(inline), br);
          moveSelectionToBr(editor, br.dom, false);
          editor.undoManager.add();
        };
        const isBeforeBr = (pos) => {
          return isBr$6(pos.getNode());
        };
        const hasBrAfter = (rootNode, startNode) => {
          if (isBeforeBr(CaretPosition.after(startNode))) {
            return true;
          } else {
            return nextPosition(rootNode, CaretPosition.after(startNode)).map((pos) => {
              return isBr$6(pos.getNode());
            }).getOr(false);
          }
        };
        const isAnchorLink = (elm) => {
          return elm && elm.nodeName === "A" && "href" in elm;
        };
        const isInsideAnchor = (location2) => {
          return location2.fold(never, isAnchorLink, isAnchorLink, never);
        };
        const readInlineAnchorLocation = (editor) => {
          const isInlineTarget$1 = curry(isInlineTarget, editor);
          const position = CaretPosition.fromRangeStart(editor.selection.getRng());
          return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);
        };
        const insertBrOutsideAnchor = (editor, location2) => {
          location2.fold(noop2, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop2);
        };
        const insert$1 = (editor, evt) => {
          const anchorLocation = readInlineAnchorLocation(editor);
          if (anchorLocation.isSome()) {
            anchorLocation.each(curry(insertBrOutsideAnchor, editor));
          } else {
            insertBrAtCaret(editor, evt);
          }
        };
        const fakeEventName = "insertLineBreak";
        const linebreak = {
          insert: insert$1,
          fakeEventName
        };
        const matchesSelector = (editor, selector) => {
          return getParentBlock$1(editor).filter((parentBlock) => {
            return selector.length > 0 && is$1(SugarElement.fromDom(parentBlock), selector);
          }).isSome();
        };
        const shouldInsertBr = (editor) => {
          return matchesSelector(editor, getBrNewLineSelector(editor));
        };
        const shouldBlockNewLine$1 = (editor) => {
          return matchesSelector(editor, getNoNewLineSelector(editor));
        };
        const newLineAction = Adt.generate([
          { br: [] },
          { block: [] },
          { none: [] }
        ]);
        const shouldBlockNewLine = (editor, _shiftKey) => {
          return shouldBlockNewLine$1(editor);
        };
        const inListBlock = (requiredState) => {
          return (editor, _shiftKey) => {
            return isListItemParentBlock(editor) === requiredState;
          };
        };
        const inBlock = (blockName, requiredState) => (editor, _shiftKey) => {
          const state = getParentBlockName(editor) === blockName.toUpperCase();
          return state === requiredState;
        };
        const inCefBlock = (editor) => {
          const editableRoot = getEditableRoot(editor.dom, editor.selection.getStart());
          return isNullable(editableRoot);
        };
        const inPreBlock = (requiredState) => inBlock("pre", requiredState);
        const inSummaryBlock = () => inBlock("summary", true);
        const shouldPutBrInPre = (requiredState) => {
          return (editor, _shiftKey) => {
            return shouldPutBrInPre$1(editor) === requiredState;
          };
        };
        const inBrContext = (editor, _shiftKey) => {
          return shouldInsertBr(editor);
        };
        const hasShiftKey = (_editor, shiftKey) => {
          return shiftKey;
        };
        const canInsertIntoEditableRoot = (editor) => {
          const forcedRootBlock = getForcedRootBlock(editor);
          const rootEditable = getEditableRoot(editor.dom, editor.selection.getStart());
          return isNonNullable(rootEditable) && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock);
        };
        const isInRootWithEmptyOrCEF = (editor) => {
          const rng = editor.selection.getRng();
          const isInRoot = rng.collapsed && rng.startContainer === editor.dom.getRoot();
          const start4 = SugarElement.fromDom(rng.startContainer);
          const child2 = child$1(start4, rng.startOffset);
          const isCefOpt = child2.map((element) => isHTMLElement2(element) && !isEditable$3(element));
          return isInRoot && isCefOpt.getOr(true);
        };
        const match = (predicates, action2) => {
          return (editor, shiftKey) => {
            const isMatch = foldl(predicates, (res, p2) => {
              return res && p2(editor, shiftKey);
            }, true);
            return isMatch ? Optional.some(action2) : Optional.none();
          };
        };
        const getAction2 = (editor, evt) => {
          return evaluateUntil([
            match([shouldBlockNewLine], newLineAction.none()),
            match([
              inPreBlock(true),
              inCefBlock
            ], newLineAction.none()),
            match([inSummaryBlock()], newLineAction.br()),
            match([
              inPreBlock(true),
              shouldPutBrInPre(false),
              hasShiftKey
            ], newLineAction.br()),
            match([
              inPreBlock(true),
              shouldPutBrInPre(false)
            ], newLineAction.block()),
            match([
              inPreBlock(true),
              shouldPutBrInPre(true),
              hasShiftKey
            ], newLineAction.block()),
            match([
              inPreBlock(true),
              shouldPutBrInPre(true)
            ], newLineAction.br()),
            match([
              inListBlock(true),
              hasShiftKey
            ], newLineAction.br()),
            match([inListBlock(true)], newLineAction.block()),
            match([inBrContext], newLineAction.br()),
            match([hasShiftKey], newLineAction.br()),
            match([canInsertIntoEditableRoot], newLineAction.block()),
            match([isInRootWithEmptyOrCEF], newLineAction.block())
          ], [
            editor,
            !!(evt && evt.shiftKey)
          ]).getOr(newLineAction.none());
        };
        const insertBreak = (breakType, editor, evt) => {
          if (!editor.selection.isCollapsed()) {
            execEditorDeleteCommand(editor);
          }
          if (isNonNullable(evt)) {
            const event = fireBeforeInputEvent(editor, breakType.fakeEventName);
            if (event.isDefaultPrevented()) {
              return;
            }
          }
          breakType.insert(editor, evt);
          if (isNonNullable(evt)) {
            fireInputEvent(editor, breakType.fakeEventName);
          }
        };
        const insert = (editor, evt) => {
          const br = () => insertBreak(linebreak, editor, evt);
          const block = () => insertBreak(blockbreak, editor, evt);
          const logicalAction = getAction2(editor, evt);
          switch (getNewlineBehavior(editor)) {
            case "linebreak":
              logicalAction.fold(br, br, noop2);
              break;
            case "block":
              logicalAction.fold(block, block, noop2);
              break;
            case "invert":
              logicalAction.fold(block, br, noop2);
              break;
            default:
              logicalAction.fold(br, block, noop2);
              break;
          }
        };
        const platform$2 = detect$2();
        const isIOSSafari = platform$2.os.isiOS() && platform$2.browser.isSafari();
        const handleEnterKeyEvent = (editor, event) => {
          if (event.isDefaultPrevented()) {
            return;
          }
          event.preventDefault();
          endTypingLevelIgnoreLocks(editor.undoManager);
          editor.undoManager.transact(() => {
            insert(editor, event);
          });
        };
        const isCaretAfterKoreanCharacter = (rng) => {
          if (!rng.collapsed) {
            return false;
          }
          const startContainer = rng.startContainer;
          if (isText$a(startContainer)) {
            const koreanCharRegex = /^[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF]$/;
            const char = startContainer.data.charAt(rng.startOffset - 1);
            return koreanCharRegex.test(char);
          } else {
            return false;
          }
        };
        const setup$h = (editor) => {
          let iOSSafariKeydownBookmark = Optional.none();
          const iOSSafariKeydownOverride = (editor2) => {
            iOSSafariKeydownBookmark = Optional.some(editor2.selection.getBookmark());
            editor2.undoManager.add();
          };
          const iOSSafariKeyupOverride = (editor2, event) => {
            editor2.undoManager.undo();
            iOSSafariKeydownBookmark.fold(noop2, (b2) => editor2.selection.moveToBookmark(b2));
            handleEnterKeyEvent(editor2, event);
            iOSSafariKeydownBookmark = Optional.none();
          };
          editor.on("keydown", (event) => {
            if (event.keyCode === VK.ENTER) {
              if (isIOSSafari && isCaretAfterKoreanCharacter(editor.selection.getRng())) {
                iOSSafariKeydownOverride(editor);
              } else {
                handleEnterKeyEvent(editor, event);
              }
            }
          });
          editor.on("keyup", (event) => {
            if (event.keyCode === VK.ENTER) {
              iOSSafariKeydownBookmark.each(() => iOSSafariKeyupOverride(editor, event));
            }
          });
        };
        const executeKeydownOverride$2 = (editor, caret, evt) => {
          const isMac = Env.os.isMacOS() || Env.os.isiOS();
          execute2([
            {
              keyCode: VK.END,
              action: action(moveToLineEndPoint$1, editor, true)
            },
            {
              keyCode: VK.HOME,
              action: action(moveToLineEndPoint$1, editor, false)
            },
            ...!isMac ? [
              {
                keyCode: VK.HOME,
                action: action(selectToEndPoint, editor, false),
                ctrlKey: true,
                shiftKey: true
              },
              {
                keyCode: VK.END,
                action: action(selectToEndPoint, editor, true),
                ctrlKey: true,
                shiftKey: true
              }
            ] : [],
            {
              keyCode: VK.END,
              action: action(moveToLineEndPoint, editor, true)
            },
            {
              keyCode: VK.HOME,
              action: action(moveToLineEndPoint, editor, false)
            },
            {
              keyCode: VK.END,
              action: action(moveToLineEndPoint$2, editor, true, caret)
            },
            {
              keyCode: VK.HOME,
              action: action(moveToLineEndPoint$2, editor, false, caret)
            }
          ], evt).each((_2) => {
            evt.preventDefault();
          });
        };
        const setup$g = (editor, caret) => {
          editor.on("keydown", (evt) => {
            if (!evt.isDefaultPrevented()) {
              executeKeydownOverride$2(editor, caret, evt);
            }
          });
        };
        const setup$f = (editor) => {
          editor.on("input", (e2) => {
            if (!e2.isComposing) {
              normalizeNbspsInEditor(editor);
            }
          });
        };
        const platform$1 = detect$2();
        const executeKeyupAction = (editor, caret, evt) => {
          execute2([
            {
              keyCode: VK.PAGE_UP,
              action: action(moveToLineEndPoint$2, editor, false, caret)
            },
            {
              keyCode: VK.PAGE_DOWN,
              action: action(moveToLineEndPoint$2, editor, true, caret)
            }
          ], evt);
        };
        const stopImmediatePropagation = (e2) => e2.stopImmediatePropagation();
        const isPageUpDown = (evt) => evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;
        const setNodeChangeBlocker = (blocked, editor, block) => {
          if (block && !blocked.get()) {
            editor.on("NodeChange", stopImmediatePropagation, true);
          } else if (!block && blocked.get()) {
            editor.off("NodeChange", stopImmediatePropagation);
          }
          blocked.set(block);
        };
        const setup$e = (editor, caret) => {
          if (platform$1.os.isMacOS()) {
            return;
          }
          const blocked = Cell(false);
          editor.on("keydown", (evt) => {
            if (isPageUpDown(evt)) {
              setNodeChangeBlocker(blocked, editor, true);
            }
          });
          editor.on("keyup", (evt) => {
            if (!evt.isDefaultPrevented()) {
              executeKeyupAction(editor, caret, evt);
            }
            if (isPageUpDown(evt) && blocked.get()) {
              setNodeChangeBlocker(blocked, editor, false);
              editor.nodeChanged();
            }
          });
        };
        const insertTextAtPosition = (text2, pos) => {
          const container = pos.container();
          const offset2 = pos.offset();
          if (isText$a(container)) {
            container.insertData(offset2, text2);
            return Optional.some(CaretPosition(container, offset2 + text2.length));
          } else {
            return getElementFromPosition(pos).map((elm) => {
              const textNode = SugarElement.fromText(text2);
              if (pos.isAtEnd()) {
                after$4(elm, textNode);
              } else {
                before$3(elm, textNode);
              }
              return CaretPosition(textNode.dom, text2.length);
            });
          }
        };
        const insertNbspAtPosition = curry(insertTextAtPosition, nbsp);
        const insertSpaceAtPosition = curry(insertTextAtPosition, " ");
        const insertSpaceOrNbspAtPosition = (root, pos) => needsToHaveNbsp(root, pos) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);
        const locationToCaretPosition = (root) => (location2) => location2.fold((element) => prevPosition(root.dom, CaretPosition.before(element)), (element) => firstPositionIn(element), (element) => lastPositionIn(element), (element) => nextPosition(root.dom, CaretPosition.after(element)));
        const insertInlineBoundarySpaceOrNbsp = (root, pos) => (checkPos) => needsToHaveNbsp(root, checkPos) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);
        const setSelection = (editor) => (pos) => {
          editor.selection.setRng(pos.toRange());
          editor.nodeChanged();
        };
        const isInsideSummary = (domUtils, node) => domUtils.isEditable(domUtils.getParent(node, "summary"));
        const insertSpaceOrNbspAtSelection = (editor) => {
          const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
          const root = SugarElement.fromDom(editor.getBody());
          if (editor.selection.isCollapsed()) {
            const isInlineTarget$1 = curry(isInlineTarget, editor);
            const caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());
            return readLocation(isInlineTarget$1, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).map((checkPos) => () => insertInlineBoundarySpaceOrNbsp(root, pos)(checkPos).each(setSelection(editor)));
          } else {
            return Optional.none();
          }
        };
        const insertSpaceInSummaryAtSelectionOnFirefox = (editor) => {
          const insertSpaceThunk = () => {
            const root = SugarElement.fromDom(editor.getBody());
            if (!editor.selection.isCollapsed()) {
              editor.getDoc().execCommand("Delete");
            }
            const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
            insertSpaceOrNbspAtPosition(root, pos).each(setSelection(editor));
          };
          return someIf(Env.browser.isFirefox() && editor.selection.isEditable() && isInsideSummary(editor.dom, editor.selection.getRng().startContainer), insertSpaceThunk);
        };
        const executeKeydownOverride$1 = (editor, evt) => {
          executeWithDelayedAction([
            {
              keyCode: VK.SPACEBAR,
              action: action(insertSpaceOrNbspAtSelection, editor)
            },
            {
              keyCode: VK.SPACEBAR,
              action: action(insertSpaceInSummaryAtSelectionOnFirefox, editor)
            }
          ], evt).each((applyAction) => {
            evt.preventDefault();
            const event = fireBeforeInputEvent(editor, "insertText", { data: " " });
            if (!event.isDefaultPrevented()) {
              applyAction();
              fireInputEvent(editor, "insertText", { data: " " });
            }
          });
        };
        const setup$d = (editor) => {
          editor.on("keydown", (evt) => {
            if (!evt.isDefaultPrevented()) {
              executeKeydownOverride$1(editor, evt);
            }
          });
        };
        const tableTabNavigation = (editor) => {
          if (hasTableTabNavigation(editor)) {
            return [
              {
                keyCode: VK.TAB,
                action: action(handleTab, editor, true)
              },
              {
                keyCode: VK.TAB,
                shiftKey: true,
                action: action(handleTab, editor, false)
              }
            ];
          } else {
            return [];
          }
        };
        const executeKeydownOverride = (editor, evt) => {
          execute2([...tableTabNavigation(editor)], evt).each((_2) => {
            evt.preventDefault();
          });
        };
        const setup$c = (editor) => {
          editor.on("keydown", (evt) => {
            if (!evt.isDefaultPrevented()) {
              executeKeydownOverride(editor, evt);
            }
          });
        };
        const setup$b = (editor) => {
          editor.addShortcut("Meta+P", "", "mcePrint");
          setup$j(editor);
          if (isRtc(editor)) {
            return Cell(null);
          } else {
            const caret = setupSelectedState(editor);
            setup$l(editor);
            setup$k(editor, caret);
            setup$i(editor, caret);
            setup$h(editor);
            setup$d(editor);
            setup$f(editor);
            setup$c(editor);
            setup$g(editor, caret);
            setup$e(editor, caret);
            return caret;
          }
        };
        class NodeChange {
          constructor(editor) {
            this.lastPath = [];
            this.editor = editor;
            let lastRng;
            const self2 = this;
            if (!("onselectionchange" in editor.getDoc())) {
              editor.on("NodeChange click mouseup keyup focus", (e2) => {
                const nativeRng = editor.selection.getRng();
                const fakeRng = {
                  startContainer: nativeRng.startContainer,
                  startOffset: nativeRng.startOffset,
                  endContainer: nativeRng.endContainer,
                  endOffset: nativeRng.endOffset
                };
                if (e2.type === "nodechange" || !isEq$4(fakeRng, lastRng)) {
                  editor.dispatch("SelectionChange");
                }
                lastRng = fakeRng;
              });
            }
            editor.on("contextmenu", () => {
              editor.dispatch("SelectionChange");
            });
            editor.on("SelectionChange", () => {
              const startElm = editor.selection.getStart(true);
              if (!startElm) {
                return;
              }
              if (hasAnyRanges(editor) && !self2.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {
                editor.nodeChanged({ selectionChange: true });
              }
            });
            editor.on("mouseup", (e2) => {
              if (!e2.isDefaultPrevented() && hasAnyRanges(editor)) {
                if (editor.selection.getNode().nodeName === "IMG") {
                  Delay.setEditorTimeout(editor, () => {
                    editor.nodeChanged();
                  });
                } else {
                  editor.nodeChanged();
                }
              }
            });
          }
          nodeChanged(args = {}) {
            const selection = this.editor.selection;
            let node;
            if (this.editor.initialized && selection && !shouldDisableNodeChange(this.editor) && !this.editor.mode.isReadOnly()) {
              const root = this.editor.getBody();
              node = selection.getStart(true) || root;
              if (node.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(node, root)) {
                node = root;
              }
              const parents2 = [];
              this.editor.dom.getParent(node, (node2) => {
                if (node2 === root) {
                  return true;
                } else {
                  parents2.push(node2);
                  return false;
                }
              });
              this.editor.dispatch("NodeChange", {
                ...args,
                element: node,
                parents: parents2
              });
            }
          }
          isSameElementPath(startElm) {
            let i2;
            const editor = this.editor;
            const currentPath = reverse(editor.dom.getParents(startElm, always, editor.getBody()));
            if (currentPath.length === this.lastPath.length) {
              for (i2 = currentPath.length; i2 >= 0; i2--) {
                if (currentPath[i2] !== this.lastPath[i2]) {
                  break;
                }
              }
              if (i2 === -1) {
                this.lastPath = currentPath;
                return true;
              }
            }
            this.lastPath = currentPath;
            return false;
          }
        }
        const imageId = generate$1("image");
        const getDragImage = (transfer) => {
          const dt = transfer;
          return Optional.from(dt[imageId]);
        };
        const setDragImage = (transfer, imageData) => {
          const dt = transfer;
          dt[imageId] = imageData;
        };
        const eventId = generate$1("event");
        const getEvent = (transfer) => {
          const dt = transfer;
          return Optional.from(dt[eventId]);
        };
        const mkSetEventFn = (type2) => (transfer) => {
          const dt = transfer;
          dt[eventId] = type2;
        };
        const setEvent = (transfer, type2) => mkSetEventFn(type2)(transfer);
        const setDragstartEvent = mkSetEventFn(0);
        const setDropEvent = mkSetEventFn(2);
        const setDragendEvent = mkSetEventFn(1);
        const checkEvent = (expectedType) => (transfer) => {
          const dt = transfer;
          return Optional.from(dt[eventId]).exists((type2) => type2 === expectedType);
        };
        const isInDragStartEvent = checkEvent(0);
        const createEmptyFileList = () => Object.freeze({
          length: 0,
          item: (_2) => null
        });
        const modeId = generate$1("mode");
        const getMode = (transfer) => {
          const dt = transfer;
          return Optional.from(dt[modeId]);
        };
        const mkSetModeFn = (mode) => (transfer) => {
          const dt = transfer;
          dt[modeId] = mode;
        };
        const setMode$1 = (transfer, mode) => mkSetModeFn(mode)(transfer);
        const setReadWriteMode = mkSetModeFn(0);
        const setReadOnlyMode = mkSetModeFn(2);
        const setProtectedMode = mkSetModeFn(1);
        const checkMode = (expectedMode) => (transfer) => {
          const dt = transfer;
          return Optional.from(dt[modeId]).exists((mode) => mode === expectedMode);
        };
        const isInReadWriteMode = checkMode(0);
        const isInProtectedMode = checkMode(1);
        const normalizeItems = (dataTransfer, itemsImpl) => ({
          ...itemsImpl,
          get length() {
            return itemsImpl.length;
          },
          add: (data2, type2) => {
            if (isInReadWriteMode(dataTransfer)) {
              if (isString(data2)) {
                if (!isUndefined(type2)) {
                  return itemsImpl.add(data2, type2);
                }
              } else {
                return itemsImpl.add(data2);
              }
            }
            return null;
          },
          remove: (idx) => {
            if (isInReadWriteMode(dataTransfer)) {
              itemsImpl.remove(idx);
            }
          },
          clear: () => {
            if (isInReadWriteMode(dataTransfer)) {
              itemsImpl.clear();
            }
          }
        });
        const validDropEffects = [
          "none",
          "copy",
          "link",
          "move"
        ];
        const validEffectAlloweds = [
          "none",
          "copy",
          "copyLink",
          "copyMove",
          "link",
          "linkMove",
          "move",
          "all",
          "uninitialized"
        ];
        const createDataTransfer = () => {
          const dataTransferImpl = new window.DataTransfer();
          let dropEffect = "move";
          let effectAllowed = "all";
          const dataTransfer = {
            get dropEffect() {
              return dropEffect;
            },
            set dropEffect(effect4) {
              if (contains$2(validDropEffects, effect4)) {
                dropEffect = effect4;
              }
            },
            get effectAllowed() {
              return effectAllowed;
            },
            set effectAllowed(allowed) {
              if (isInDragStartEvent(dataTransfer) && contains$2(validEffectAlloweds, allowed)) {
                effectAllowed = allowed;
              }
            },
            get items() {
              return normalizeItems(dataTransfer, dataTransferImpl.items);
            },
            get files() {
              if (isInProtectedMode(dataTransfer)) {
                return createEmptyFileList();
              } else {
                return dataTransferImpl.files;
              }
            },
            get types() {
              return dataTransferImpl.types;
            },
            setDragImage: (image, x2, y2) => {
              if (isInReadWriteMode(dataTransfer)) {
                setDragImage(dataTransfer, {
                  image,
                  x: x2,
                  y: y2
                });
                dataTransferImpl.setDragImage(image, x2, y2);
              }
            },
            getData: (format) => {
              if (isInProtectedMode(dataTransfer)) {
                return "";
              } else {
                return dataTransferImpl.getData(format);
              }
            },
            setData: (format, data2) => {
              if (isInReadWriteMode(dataTransfer)) {
                dataTransferImpl.setData(format, data2);
              }
            },
            clearData: (format) => {
              if (isInReadWriteMode(dataTransfer)) {
                dataTransferImpl.clearData(format);
              }
            }
          };
          setReadWriteMode(dataTransfer);
          return dataTransfer;
        };
        const cloneDataTransfer = (original) => {
          const clone2 = createDataTransfer();
          const originalMode = getMode(original);
          setReadOnlyMode(original);
          setDragstartEvent(clone2);
          clone2.dropEffect = original.dropEffect;
          clone2.effectAllowed = original.effectAllowed;
          getDragImage(original).each((imageData) => clone2.setDragImage(imageData.image, imageData.x, imageData.y));
          each$e(original.types, (type2) => {
            if (type2 !== "Files") {
              clone2.setData(type2, original.getData(type2));
            }
          });
          each$e(original.files, (file) => clone2.items.add(file));
          getEvent(original).each((type2) => {
            setEvent(clone2, type2);
          });
          originalMode.each((mode) => {
            setMode$1(original, mode);
            setMode$1(clone2, mode);
          });
          return clone2;
        };
        const getHtmlData = (dataTransfer) => {
          const html2 = dataTransfer.getData("text/html");
          return html2 === "" ? Optional.none() : Optional.some(html2);
        };
        const setHtmlData = (dataTransfer, html2) => dataTransfer.setData("text/html", html2);
        const internalMimeType = "x-tinymce/html";
        const internalHtmlMime = constant(internalMimeType);
        const internalMark = "<!-- " + internalMimeType + " -->";
        const mark = (html2) => internalMark + html2;
        const unmark = (html2) => html2.replace(internalMark, "");
        const isMarked = (html2) => html2.indexOf(internalMark) !== -1;
        const isPlainText = (text2) => {
          return !/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(text2);
        };
        const openContainer = (rootTag, rootAttrs) => {
          let tag = "<" + rootTag;
          const attrs = mapToArray(rootAttrs, (value2, key) => key + '="' + Entities.encodeAllRaw(value2) + '"');
          if (attrs.length) {
            tag += " " + attrs.join(" ");
          }
          return tag + ">";
        };
        const toBlockElements = (text2, rootTag, rootAttrs) => {
          const blocks2 = text2.split(/\n\n/);
          const tagOpen = openContainer(rootTag, rootAttrs);
          const tagClose = "</" + rootTag + ">";
          const paragraphs = map$3(blocks2, (p2) => {
            return p2.split(/\n/).join("<br />");
          });
          const stitch = (p2) => {
            return tagOpen + p2 + tagClose;
          };
          return paragraphs.length === 1 ? paragraphs[0] : map$3(paragraphs, stitch).join("");
        };
        const pasteBinDefaultContent = "%MCEPASTEBIN%";
        const create$6 = (editor, lastRngCell) => {
          const { dom: dom2, selection } = editor;
          const body = editor.getBody();
          lastRngCell.set(selection.getRng());
          const pasteBinElm = dom2.add(editor.getBody(), "div", {
            "id": "mcepastebin",
            "class": "mce-pastebin",
            "contentEditable": true,
            "data-mce-bogus": "all",
            "style": "position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0"
          }, pasteBinDefaultContent);
          if (Env.browser.isFirefox()) {
            dom2.setStyle(pasteBinElm, "left", dom2.getStyle(body, "direction", true) === "rtl" ? 65535 : -65535);
          }
          dom2.bind(pasteBinElm, "beforedeactivate focusin focusout", (e2) => {
            e2.stopPropagation();
          });
          pasteBinElm.focus();
          selection.select(pasteBinElm, true);
        };
        const remove = (editor, lastRngCell) => {
          const dom2 = editor.dom;
          if (getEl(editor)) {
            let pasteBinClone;
            const lastRng = lastRngCell.get();
            while (pasteBinClone = getEl(editor)) {
              dom2.remove(pasteBinClone);
              dom2.unbind(pasteBinClone);
            }
            if (lastRng) {
              editor.selection.setRng(lastRng);
            }
          }
          lastRngCell.set(null);
        };
        const getEl = (editor) => editor.dom.get("mcepastebin");
        const isPasteBin = (elm) => isNonNullable(elm) && elm.id === "mcepastebin";
        const getHtml = (editor) => {
          const dom2 = editor.dom;
          const copyAndRemove = (toElm, fromElm) => {
            toElm.appendChild(fromElm);
            dom2.remove(fromElm, true);
          };
          const [pasteBinElm, ...pasteBinClones] = filter$5(editor.getBody().childNodes, isPasteBin);
          each$e(pasteBinClones, (pasteBinClone) => {
            copyAndRemove(pasteBinElm, pasteBinClone);
          });
          const dirtyWrappers = dom2.select("div[id=mcepastebin]", pasteBinElm);
          for (let i2 = dirtyWrappers.length - 1; i2 >= 0; i2--) {
            const cleanWrapper = dom2.create("div");
            pasteBinElm.insertBefore(cleanWrapper, dirtyWrappers[i2]);
            copyAndRemove(cleanWrapper, dirtyWrappers[i2]);
          }
          return pasteBinElm ? pasteBinElm.innerHTML : "";
        };
        const isDefaultPasteBinContent = (content) => content === pasteBinDefaultContent;
        const PasteBin = (editor) => {
          const lastRng = Cell(null);
          return {
            create: () => create$6(editor, lastRng),
            remove: () => remove(editor, lastRng),
            getEl: () => getEl(editor),
            getHtml: () => getHtml(editor),
            getLastRng: lastRng.get
          };
        };
        const filter$1 = (content, items) => {
          Tools.each(items, (v2) => {
            if (is$4(v2, RegExp)) {
              content = content.replace(v2, "");
            } else {
              content = content.replace(v2[0], v2[1]);
            }
          });
          return content;
        };
        const innerText = (html2) => {
          const schema = Schema();
          const domParser = DomParser({}, schema);
          let text2 = "";
          const voidElements = schema.getVoidElements();
          const ignoreElements = Tools.makeMap("script noscript style textarea video audio iframe object", " ");
          const blockElements = schema.getBlockElements();
          const walk3 = (node) => {
            const name2 = node.name, currentNode = node;
            if (name2 === "br") {
              text2 += "\n";
              return;
            }
            if (name2 === "wbr") {
              return;
            }
            if (voidElements[name2]) {
              text2 += " ";
            }
            if (ignoreElements[name2]) {
              text2 += " ";
              return;
            }
            if (node.type === 3) {
              text2 += node.value;
            }
            if (!(node.name in schema.getVoidElements())) {
              let currentNode2 = node.firstChild;
              if (currentNode2) {
                do {
                  walk3(currentNode2);
                } while (currentNode2 = currentNode2.next);
              }
            }
            if (blockElements[name2] && currentNode.next) {
              text2 += "\n";
              if (name2 === "p") {
                text2 += "\n";
              }
            }
          };
          html2 = filter$1(html2, [/<!\[[^\]]+\]>/g]);
          walk3(domParser.parse(html2));
          return text2;
        };
        const trimHtml = (html2) => {
          const trimSpaces = (all2, s1, s2) => {
            if (!s1 && !s2) {
              return " ";
            }
            return nbsp;
          };
          html2 = filter$1(html2, [
            /^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/ig,
            /<!--StartFragment-->|<!--EndFragment-->/g,
            [
              /( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g,
              trimSpaces
            ],
            /<br class="Apple-interchange-newline">/g,
            /<br>$/i
          ]);
          return html2;
        };
        const createIdGenerator = (prefix) => {
          let count2 = 0;
          return () => {
            return prefix + count2++;
          };
        };
        const getImageMimeType = (ext) => {
          const lowerExt = ext.toLowerCase();
          const mimeOverrides = {
            jpg: "jpeg",
            jpe: "jpeg",
            jfi: "jpeg",
            jif: "jpeg",
            jfif: "jpeg",
            pjpeg: "jpeg",
            pjp: "jpeg",
            svg: "svg+xml"
          };
          return Tools.hasOwn(mimeOverrides, lowerExt) ? "image/" + mimeOverrides[lowerExt] : "image/" + lowerExt;
        };
        const preProcess = (editor, html2) => {
          const parser = DomParser({ sanitize: shouldSanitizeXss(editor) }, editor.schema);
          parser.addNodeFilter("meta", (nodes) => {
            Tools.each(nodes, (node) => {
              node.remove();
            });
          });
          const fragment = parser.parse(html2, {
            forced_root_block: false,
            isRootContent: true
          });
          return HtmlSerializer({ validate: true }, editor.schema).serialize(fragment);
        };
        const processResult = (content, cancelled) => ({
          content,
          cancelled
        });
        const postProcessFilter = (editor, html2, internal) => {
          const tempBody = editor.dom.create("div", { style: "display:none" }, html2);
          const postProcessArgs = firePastePostProcess(editor, tempBody, internal);
          return processResult(postProcessArgs.node.innerHTML, postProcessArgs.isDefaultPrevented());
        };
        const filterContent = (editor, content, internal) => {
          const preProcessArgs = firePastePreProcess(editor, content, internal);
          const filteredContent = preProcess(editor, preProcessArgs.content);
          if (editor.hasEventListeners("PastePostProcess") && !preProcessArgs.isDefaultPrevented()) {
            return postProcessFilter(editor, filteredContent, internal);
          } else {
            return processResult(filteredContent, preProcessArgs.isDefaultPrevented());
          }
        };
        const process = (editor, html2, internal) => {
          return filterContent(editor, html2, internal);
        };
        const pasteHtml$1 = (editor, html2) => {
          editor.insertContent(html2, {
            merge: shouldPasteMergeFormats(editor),
            paste: true
          });
          return true;
        };
        const isAbsoluteUrl = (url) => /^https?:\/\/[\w\-\/+=.,!;:&%@^~(){}?#]+$/i.test(url);
        const isImageUrl = (editor, url) => {
          return isAbsoluteUrl(url) && exists(getAllowedImageFileTypes(editor), (type2) => endsWith(url.toLowerCase(), `.${type2.toLowerCase()}`));
        };
        const createImage = (editor, url, pasteHtmlFn) => {
          editor.undoManager.extra(() => {
            pasteHtmlFn(editor, url);
          }, () => {
            editor.insertContent('<img src="' + url + '">');
          });
          return true;
        };
        const createLink = (editor, url, pasteHtmlFn) => {
          editor.undoManager.extra(() => {
            pasteHtmlFn(editor, url);
          }, () => {
            editor.execCommand("mceInsertLink", false, url);
          });
          return true;
        };
        const linkSelection = (editor, html2, pasteHtmlFn) => !editor.selection.isCollapsed() && isAbsoluteUrl(html2) ? createLink(editor, html2, pasteHtmlFn) : false;
        const insertImage = (editor, html2, pasteHtmlFn) => isImageUrl(editor, html2) ? createImage(editor, html2, pasteHtmlFn) : false;
        const smartInsertContent = (editor, html2) => {
          Tools.each([
            linkSelection,
            insertImage,
            pasteHtml$1
          ], (action2) => {
            return !action2(editor, html2, pasteHtml$1);
          });
        };
        const insertContent = (editor, html2, pasteAsText) => {
          if (pasteAsText || !isSmartPasteEnabled(editor)) {
            pasteHtml$1(editor, html2);
          } else {
            smartInsertContent(editor, html2);
          }
        };
        const uniqueId = createIdGenerator("mceclip");
        const createPasteDataTransfer = (html2) => {
          const dataTransfer = createDataTransfer();
          setHtmlData(dataTransfer, html2);
          setReadOnlyMode(dataTransfer);
          return dataTransfer;
        };
        const doPaste = (editor, content, internal, pasteAsText, shouldSimulateInputEvent) => {
          const res = process(editor, content, internal);
          if (!res.cancelled) {
            const content2 = res.content;
            const doPasteAction = () => insertContent(editor, content2, pasteAsText);
            if (shouldSimulateInputEvent) {
              const args = fireBeforeInputEvent(editor, "insertFromPaste", { dataTransfer: createPasteDataTransfer(content2) });
              if (!args.isDefaultPrevented()) {
                doPasteAction();
                fireInputEvent(editor, "insertFromPaste");
              }
            } else {
              doPasteAction();
            }
          }
        };
        const pasteHtml = (editor, html2, internalFlag, shouldSimulateInputEvent) => {
          const internal = internalFlag ? internalFlag : isMarked(html2);
          doPaste(editor, unmark(html2), internal, false, shouldSimulateInputEvent);
        };
        const pasteText = (editor, text2, shouldSimulateInputEvent) => {
          const encodedText = editor.dom.encode(text2).replace(/\r\n/g, "\n");
          const normalizedText = normalize$4(encodedText, getPasteTabSpaces(editor));
          const html2 = toBlockElements(normalizedText, getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));
          doPaste(editor, html2, false, true, shouldSimulateInputEvent);
        };
        const getDataTransferItems = (dataTransfer) => {
          const items = {};
          if (dataTransfer && dataTransfer.types) {
            for (let i2 = 0; i2 < dataTransfer.types.length; i2++) {
              const contentType = dataTransfer.types[i2];
              try {
                items[contentType] = dataTransfer.getData(contentType);
              } catch (ex) {
                items[contentType] = "";
              }
            }
          }
          return items;
        };
        const hasContentType = (clipboardContent, mimeType) => mimeType in clipboardContent && clipboardContent[mimeType].length > 0;
        const hasHtmlOrText = (content) => hasContentType(content, "text/html") || hasContentType(content, "text/plain");
        const extractFilename = (editor, str) => {
          const m2 = str.match(/([\s\S]+?)(?:\.[a-z0-9.]+)$/i);
          return isNonNullable(m2) ? editor.dom.encode(m2[1]) : void 0;
        };
        const createBlobInfo = (editor, blobCache, file, base64) => {
          const id = uniqueId();
          const useFileName = shouldReuseFileName(editor) && isNonNullable(file.name);
          const name2 = useFileName ? extractFilename(editor, file.name) : id;
          const filename = useFileName ? file.name : void 0;
          const blobInfo = blobCache.create(id, file, base64, name2, filename);
          blobCache.add(blobInfo);
          return blobInfo;
        };
        const pasteImage = (editor, imageItem) => {
          parseDataUri(imageItem.uri).each(({ data: data2, type: type2, base64Encoded }) => {
            const base64 = base64Encoded ? data2 : btoa(data2);
            const file = imageItem.file;
            const blobCache = editor.editorUpload.blobCache;
            const existingBlobInfo = blobCache.getByData(base64, type2);
            const blobInfo = existingBlobInfo !== null && existingBlobInfo !== void 0 ? existingBlobInfo : createBlobInfo(editor, blobCache, file, base64);
            pasteHtml(editor, `<img src="${blobInfo.blobUri()}">`, false, true);
          });
        };
        const isClipboardEvent = (event) => event.type === "paste";
        const readFilesAsDataUris = (items) => Promise.all(map$3(items, (file) => {
          return blobToDataUri(file).then((uri) => ({
            file,
            uri
          }));
        }));
        const isImage = (editor) => {
          const allowedExtensions = getAllowedImageFileTypes(editor);
          return (file) => startsWith(file.type, "image/") && exists(allowedExtensions, (extension) => {
            return getImageMimeType(extension) === file.type;
          });
        };
        const getImagesFromDataTransfer = (editor, dataTransfer) => {
          const items = dataTransfer.items ? bind$3(from(dataTransfer.items), (item) => {
            return item.kind === "file" ? [item.getAsFile()] : [];
          }) : [];
          const files = dataTransfer.files ? from(dataTransfer.files) : [];
          return filter$5(items.length > 0 ? items : files, isImage(editor));
        };
        const pasteImageData = (editor, e2, rng) => {
          const dataTransfer = isClipboardEvent(e2) ? e2.clipboardData : e2.dataTransfer;
          if (shouldPasteDataImages(editor) && dataTransfer) {
            const images = getImagesFromDataTransfer(editor, dataTransfer);
            if (images.length > 0) {
              e2.preventDefault();
              readFilesAsDataUris(images).then((fileResults) => {
                if (rng) {
                  editor.selection.setRng(rng);
                }
                each$e(fileResults, (result) => {
                  pasteImage(editor, result);
                });
              });
              return true;
            }
          }
          return false;
        };
        const isBrokenAndroidClipboardEvent = (e2) => {
          var _a, _b;
          return Env.os.isAndroid() && ((_b = (_a = e2.clipboardData) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.length) === 0;
        };
        const isKeyboardPasteEvent = (e2) => VK.metaKeyPressed(e2) && e2.keyCode === 86 || e2.shiftKey && e2.keyCode === 45;
        const insertClipboardContent = (editor, clipboardContent, html2, plainTextMode, shouldSimulateInputEvent) => {
          let content = trimHtml(html2);
          const isInternal = hasContentType(clipboardContent, internalHtmlMime()) || isMarked(html2);
          const isPlainTextHtml = !isInternal && isPlainText(content);
          const isAbsoluteUrl$1 = isAbsoluteUrl(content);
          if (isDefaultPasteBinContent(content) || !content.length || isPlainTextHtml && !isAbsoluteUrl$1) {
            plainTextMode = true;
          }
          if (plainTextMode || isAbsoluteUrl$1) {
            if (hasContentType(clipboardContent, "text/plain") && isPlainTextHtml) {
              content = clipboardContent["text/plain"];
            } else {
              content = innerText(content);
            }
          }
          if (isDefaultPasteBinContent(content)) {
            return;
          }
          if (plainTextMode) {
            pasteText(editor, content, shouldSimulateInputEvent);
          } else {
            pasteHtml(editor, content, isInternal, shouldSimulateInputEvent);
          }
        };
        const registerEventHandlers = (editor, pasteBin, pasteFormat) => {
          let keyboardPastePlainTextState;
          const getLastRng = () => pasteBin.getLastRng() || editor.selection.getRng();
          editor.on("keydown", (e2) => {
            if (isKeyboardPasteEvent(e2) && !e2.isDefaultPrevented()) {
              keyboardPastePlainTextState = e2.shiftKey && e2.keyCode === 86;
            }
          });
          editor.on("paste", (e2) => {
            if (e2.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e2)) {
              return;
            }
            const plainTextMode = pasteFormat.get() === "text" || keyboardPastePlainTextState;
            keyboardPastePlainTextState = false;
            const clipboardContent = getDataTransferItems(e2.clipboardData);
            if (!hasHtmlOrText(clipboardContent) && pasteImageData(editor, e2, getLastRng())) {
              return;
            }
            if (hasContentType(clipboardContent, "text/html")) {
              e2.preventDefault();
              insertClipboardContent(editor, clipboardContent, clipboardContent["text/html"], plainTextMode, true);
            } else if (hasContentType(clipboardContent, "text/plain") && hasContentType(clipboardContent, "text/uri-list")) {
              e2.preventDefault();
              insertClipboardContent(editor, clipboardContent, clipboardContent["text/plain"], plainTextMode, true);
            } else {
              pasteBin.create();
              Delay.setEditorTimeout(editor, () => {
                const html2 = pasteBin.getHtml();
                pasteBin.remove();
                insertClipboardContent(editor, clipboardContent, html2, plainTextMode, false);
              }, 0);
            }
          });
        };
        const registerDataImageFilter = (editor) => {
          const isWebKitFakeUrl = (src) => startsWith(src, "webkit-fake-url");
          const isDataUri = (src) => startsWith(src, "data:");
          const isPasteInsert = (args) => {
            var _a;
            return ((_a = args.data) === null || _a === void 0 ? void 0 : _a.paste) === true;
          };
          editor.parser.addNodeFilter("img", (nodes, name2, args) => {
            if (!shouldPasteDataImages(editor) && isPasteInsert(args)) {
              for (const node of nodes) {
                const src = node.attr("src");
                if (isString(src) && !node.attr("data-mce-object") && src !== Env.transparentSrc) {
                  if (isWebKitFakeUrl(src)) {
                    node.remove();
                  } else if (!shouldAllowHtmlDataUrls(editor) && isDataUri(src)) {
                    node.remove();
                  }
                }
              }
            }
          });
        };
        const registerEventsAndFilters = (editor, pasteBin, pasteFormat) => {
          registerEventHandlers(editor, pasteBin, pasteFormat);
          registerDataImageFilter(editor);
        };
        const togglePlainTextPaste = (editor, pasteFormat) => {
          if (pasteFormat.get() === "text") {
            pasteFormat.set("html");
            firePastePlainTextToggle(editor, false);
          } else {
            pasteFormat.set("text");
            firePastePlainTextToggle(editor, true);
          }
          editor.focus();
        };
        const register$1 = (editor, pasteFormat) => {
          editor.addCommand("mceTogglePlainTextPaste", () => {
            togglePlainTextPaste(editor, pasteFormat);
          });
          editor.addCommand("mceInsertClipboardContent", (ui, value2) => {
            if (value2.html) {
              pasteHtml(editor, value2.html, value2.internal, false);
            }
            if (value2.text) {
              pasteText(editor, value2.text, false);
            }
          });
        };
        const setHtml5Clipboard = (clipboardData, html2, text2) => {
          if (clipboardData) {
            try {
              clipboardData.clearData();
              clipboardData.setData("text/html", html2);
              clipboardData.setData("text/plain", text2);
              clipboardData.setData(internalHtmlMime(), html2);
              return true;
            } catch (e2) {
              return false;
            }
          } else {
            return false;
          }
        };
        const setClipboardData = (evt, data2, fallback2, done) => {
          if (setHtml5Clipboard(evt.clipboardData, data2.html, data2.text)) {
            evt.preventDefault();
            done();
          } else {
            fallback2(data2.html, done);
          }
        };
        const fallback = (editor) => (html2, done) => {
          const { dom: dom2, selection } = editor;
          const outer = dom2.create("div", {
            "contenteditable": "false",
            "data-mce-bogus": "all"
          });
          const inner = dom2.create("div", { contenteditable: "true" }, html2);
          dom2.setStyles(outer, {
            position: "fixed",
            top: "0",
            left: "-3000px",
            width: "1000px",
            overflow: "hidden"
          });
          outer.appendChild(inner);
          dom2.add(editor.getBody(), outer);
          const range2 = selection.getRng();
          inner.focus();
          const offscreenRange = dom2.createRng();
          offscreenRange.selectNodeContents(inner);
          selection.setRng(offscreenRange);
          Delay.setEditorTimeout(editor, () => {
            selection.setRng(range2);
            dom2.remove(outer);
            done();
          }, 0);
        };
        const getData = (editor) => ({
          html: mark(editor.selection.getContent({ contextual: true })),
          text: editor.selection.getContent({ format: "text" })
        });
        const isTableSelection = (editor) => !!editor.dom.getParent(editor.selection.getStart(), "td[data-mce-selected],th[data-mce-selected]", editor.getBody());
        const hasSelectedContent = (editor) => !editor.selection.isCollapsed() || isTableSelection(editor);
        const cut = (editor) => (evt) => {
          if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {
            setClipboardData(evt, getData(editor), fallback(editor), () => {
              if (Env.browser.isChromium() || Env.browser.isFirefox()) {
                const rng = editor.selection.getRng();
                Delay.setEditorTimeout(editor, () => {
                  editor.selection.setRng(rng);
                  editor.execCommand("Delete");
                }, 0);
              } else {
                editor.execCommand("Delete");
              }
            });
          }
        };
        const copy = (editor) => (evt) => {
          if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {
            setClipboardData(evt, getData(editor), fallback(editor), noop2);
          }
        };
        const register = (editor) => {
          editor.on("cut", cut(editor));
          editor.on("copy", copy(editor));
        };
        const getCaretRangeFromEvent = (editor, e2) => {
          var _a, _b;
          return RangeUtils.getCaretRangeFromPoint((_a = e2.clientX) !== null && _a !== void 0 ? _a : 0, (_b = e2.clientY) !== null && _b !== void 0 ? _b : 0, editor.getDoc());
        };
        const isPlainTextFileUrl = (content) => {
          const plainTextContent = content["text/plain"];
          return plainTextContent ? plainTextContent.indexOf("file://") === 0 : false;
        };
        const setFocusedRange = (editor, rng) => {
          editor.focus();
          if (rng) {
            editor.selection.setRng(rng);
          }
        };
        const hasImage = (dataTransfer) => exists(dataTransfer.files, (file) => /^image\//.test(file.type));
        const isTransparentBlockDrop = (dom2, schema, target, dropContent) => {
          const parentTransparent = dom2.getParent(target, (node) => isTransparentBlock(schema, node));
          if (parentTransparent && has$2(dropContent, "text/html")) {
            const fragment = new DOMParser().parseFromString(dropContent["text/html"], "text/html").body;
            return !isNull(fragment.querySelector(parentTransparent.nodeName.toLowerCase()));
          } else {
            return false;
          }
        };
        const setup$a = (editor, draggingInternallyState) => {
          if (shouldPasteBlockDrop(editor)) {
            editor.on("dragend dragover draggesture dragdrop drop drag", (e2) => {
              e2.preventDefault();
              e2.stopPropagation();
            });
          }
          if (!shouldPasteDataImages(editor)) {
            editor.on("drop", (e2) => {
              const dataTransfer = e2.dataTransfer;
              if (dataTransfer && hasImage(dataTransfer)) {
                e2.preventDefault();
              }
            });
          }
          editor.on("drop", (e2) => {
            if (e2.isDefaultPrevented()) {
              return;
            }
            const rng = getCaretRangeFromEvent(editor, e2);
            if (isNullable(rng)) {
              return;
            }
            const dropContent = getDataTransferItems(e2.dataTransfer);
            const internal = hasContentType(dropContent, internalHtmlMime());
            if ((!hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) && pasteImageData(editor, e2, rng)) {
              return;
            }
            const internalContent = dropContent[internalHtmlMime()];
            const content = internalContent || dropContent["text/html"] || dropContent["text/plain"];
            const transparentElementDrop = isTransparentBlockDrop(editor.dom, editor.schema, rng.startContainer, dropContent);
            if (draggingInternallyState.get() && !transparentElementDrop) {
              return;
            }
            if (content) {
              e2.preventDefault();
              Delay.setEditorTimeout(editor, () => {
                editor.undoManager.transact(() => {
                  if (internalContent) {
                    editor.execCommand("Delete");
                  }
                  setFocusedRange(editor, rng);
                  const trimmedContent = trimHtml(content);
                  if (dropContent["text/html"]) {
                    pasteHtml(editor, trimmedContent, internal, true);
                  } else {
                    pasteText(editor, trimmedContent, true);
                  }
                });
              });
            }
          });
          editor.on("dragstart", (_e) => {
            draggingInternallyState.set(true);
          });
          editor.on("dragover dragend", (e2) => {
            if (shouldPasteDataImages(editor) && !draggingInternallyState.get()) {
              e2.preventDefault();
              setFocusedRange(editor, getCaretRangeFromEvent(editor, e2));
            }
            if (e2.type === "dragend") {
              draggingInternallyState.set(false);
            }
          });
        };
        const setup$9 = (editor) => {
          const processEvent = (f2) => (e2) => {
            f2(editor, e2);
          };
          const preProcess2 = getPastePreProcess(editor);
          if (isFunction(preProcess2)) {
            editor.on("PastePreProcess", processEvent(preProcess2));
          }
          const postProcess2 = getPastePostProcess(editor);
          if (isFunction(postProcess2)) {
            editor.on("PastePostProcess", processEvent(postProcess2));
          }
        };
        const addPreProcessFilter = (editor, filterFunc) => {
          editor.on("PastePreProcess", (e2) => {
            e2.content = filterFunc(editor, e2.content, e2.internal);
          });
        };
        const rgbRegExp = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi;
        const rgbToHex = (value2) => Tools.trim(value2).replace(rgbRegExp, rgbaToHexString).toLowerCase();
        const removeWebKitStyles = (editor, content, internal) => {
          const webKitStylesOption = getPasteWebkitStyles(editor);
          if (internal || webKitStylesOption === "all" || !shouldPasteRemoveWebKitStyles(editor)) {
            return content;
          }
          const webKitStyles = webKitStylesOption ? webKitStylesOption.split(/[, ]/) : [];
          if (webKitStyles && webKitStylesOption !== "none") {
            const dom2 = editor.dom, node = editor.selection.getNode();
            content = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, (all2, before2, value2, after2) => {
              const inputStyles = dom2.parseStyle(dom2.decode(value2));
              const outputStyles = {};
              for (let i2 = 0; i2 < webKitStyles.length; i2++) {
                const inputValue = inputStyles[webKitStyles[i2]];
                let compareInput = inputValue;
                let currentValue = dom2.getStyle(node, webKitStyles[i2], true);
                if (/color/.test(webKitStyles[i2])) {
                  compareInput = rgbToHex(compareInput);
                  currentValue = rgbToHex(currentValue);
                }
                if (currentValue !== compareInput) {
                  outputStyles[webKitStyles[i2]] = inputValue;
                }
              }
              const outputStyle = dom2.serializeStyle(outputStyles, "span");
              if (outputStyle) {
                return before2 + ' style="' + outputStyle + '"' + after2;
              }
              return before2 + after2;
            });
          } else {
            content = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, "$1$3");
          }
          content = content.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, (all2, before2, value2, after2) => {
            return before2 + ' style="' + value2 + '"' + after2;
          });
          return content;
        };
        const setup$8 = (editor) => {
          if (Env.browser.isChromium() || Env.browser.isSafari()) {
            addPreProcessFilter(editor, removeWebKitStyles);
          }
        };
        const setup$7 = (editor) => {
          const draggingInternallyState = Cell(false);
          const pasteFormat = Cell(isPasteAsTextEnabled(editor) ? "text" : "html");
          const pasteBin = PasteBin(editor);
          setup$8(editor);
          register$1(editor, pasteFormat);
          setup$9(editor);
          editor.on("PreInit", () => {
            register(editor);
            setup$a(editor, draggingInternallyState);
            registerEventsAndFilters(editor, pasteBin, pasteFormat);
          });
        };
        const preventSummaryToggle = (editor) => {
          editor.on("click", (e2) => {
            if (editor.dom.getParent(e2.target, "details")) {
              e2.preventDefault();
            }
          });
        };
        const filterDetails = (editor) => {
          editor.parser.addNodeFilter("details", (elms) => {
            const initialStateOption = getDetailsInitialState(editor);
            each$e(elms, (details) => {
              if (initialStateOption === "expanded") {
                details.attr("open", "open");
              } else if (initialStateOption === "collapsed") {
                details.attr("open", null);
              }
            });
          });
          editor.serializer.addNodeFilter("details", (elms) => {
            const serializedStateOption = getDetailsSerializedState(editor);
            each$e(elms, (details) => {
              if (serializedStateOption === "expanded") {
                details.attr("open", "open");
              } else if (serializedStateOption === "collapsed") {
                details.attr("open", null);
              }
            });
          });
        };
        const emptyNodeContents = (node) => fillWithPaddingBr(SugarElement.fromDom(node));
        const setCaretToPosition = (editor, position) => {
          const node = position.getNode();
          if (!isUndefined(node)) {
            editor.selection.setCursorLocation(node, position.offset());
          }
        };
        const isEntireNodeSelected = (rng, node) => {
          var _a;
          return rng.startOffset === 0 && rng.endOffset === ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length);
        };
        const platform = detect$2();
        const browser = platform.browser;
        const os = platform.os;
        const isSafari = browser.isSafari();
        const isMacOSOriOS = os.isMacOS() || os.isiOS();
        const isCaretInTheBeginningOf = (caretPos, element) => firstPositionIn(element).exists((pos) => pos.isEqual(caretPos));
        const isCaretInTheEndOf = (caretPos, element) => {
          return lastPositionIn(element).exists((pos) => {
            if (isBr$6(pos.getNode())) {
              return prevPosition(element, pos).exists((pos2) => pos2.isEqual(caretPos)) || pos.isEqual(caretPos);
            } else {
              return pos.isEqual(caretPos);
            }
          });
        };
        const getDetailsElements = (dom2, rng) => {
          const startDetails = Optional.from(dom2.getParent(rng.startContainer, "details"));
          const endDetails = Optional.from(dom2.getParent(rng.endContainer, "details"));
          if (startDetails.isSome() || endDetails.isSome()) {
            const startSummary = startDetails.bind((details) => Optional.from(dom2.select("summary", details)[0]));
            return Optional.some({
              startSummary,
              startDetails,
              endDetails
            });
          } else {
            return Optional.none();
          }
        };
        const isPartialDelete = (rng, detailsElements) => {
          const containsStart = (element) => element.contains(rng.startContainer);
          const containsEnd = (element) => element.contains(rng.endContainer);
          const startInSummary = detailsElements.startSummary.exists(containsStart);
          const endInSummary = detailsElements.startSummary.exists(containsEnd);
          const isPartiallySelectedDetailsElements = detailsElements.startDetails.forall((startDetails) => detailsElements.endDetails.forall((endDetails) => startDetails !== endDetails));
          const isInPartiallySelectedSummary = (startInSummary || endInSummary) && !(startInSummary && endInSummary);
          return isInPartiallySelectedSummary || isPartiallySelectedDetailsElements;
        };
        const isCaretAtStartOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists((summary) => isCaretInTheBeginningOf(caretPos, summary));
        const isCaretAtEndOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists((summary) => isCaretInTheEndOf(caretPos, summary));
        const isCaretInFirstPositionInBody = (caretPos, detailsElements) => detailsElements.startDetails.exists((details) => prevPosition(details, caretPos).forall((pos) => detailsElements.startSummary.exists((summary) => !summary.contains(caretPos.container()) && summary.contains(pos.container()))));
        const isCaretInLastPositionInBody = (root, caretPos, detailsElements) => detailsElements.startDetails.exists((details) => nextPosition(root, caretPos).forall((pos) => !details.contains(pos.container())));
        const isInDetailsElement = (dom2, pos) => isNonNullable(dom2.getParent(pos.container(), "details"));
        const moveCaretToDetailsPos = (editor, pos) => {
          const details = editor.dom.getParent(pos.container(), "details");
          if (details && !details.open) {
            const summary = editor.dom.select("summary", details)[0];
            if (summary) {
              lastPositionIn(summary).each((pos2) => setCaretToPosition(editor, pos2));
            }
          } else {
            setCaretToPosition(editor, pos);
          }
        };
        const preventDeleteIntoDetails = (editor, forward) => {
          const { dom: dom2, selection } = editor;
          const root = editor.getBody();
          if (editor.selection.isCollapsed()) {
            const caretPos = CaretPosition.fromRangeStart(selection.getRng());
            const parentBlock = dom2.getParent(caretPos.container(), dom2.isBlock);
            if (parentBlock && dom2.isEmpty(parentBlock)) {
              if (isNull(parentBlock.nextSibling)) {
                const pos = prevPosition(root, caretPos).filter((pos2) => isInDetailsElement(dom2, pos2));
                if (pos.isSome()) {
                  pos.each((pos2) => {
                    if (!forward) {
                      moveCaretToDetailsPos(editor, pos2);
                    }
                  });
                  return true;
                }
              } else if (isNull(parentBlock.previousSibling)) {
                const pos = nextPosition(root, caretPos).filter((pos2) => isInDetailsElement(dom2, pos2));
                if (pos) {
                  return true;
                }
              }
            }
            return navigate(forward, root, caretPos).fold(never, (pos) => {
              if (isInDetailsElement(dom2, pos)) {
                if (parentBlock && dom2.isEmpty(parentBlock)) {
                  editor.dom.remove(parentBlock);
                }
                if (!forward) {
                  moveCaretToDetailsPos(editor, pos);
                }
                return true;
              } else {
                return false;
              }
            });
          } else {
            return false;
          }
        };
        const preventDeleteSummaryAction = (editor, detailElements, e2) => {
          const selection = editor.selection;
          const node = selection.getNode();
          const rng = selection.getRng();
          const isBackspace = e2.keyCode === VK.BACKSPACE;
          const isDelete = e2.keyCode === VK.DELETE;
          const isCollapsed = editor.selection.isCollapsed();
          const caretPos = CaretPosition.fromRangeStart(rng);
          const root = editor.getBody();
          if (!isCollapsed && isPartialDelete(rng, detailElements)) {
            return true;
          } else if (isCollapsed && isBackspace && isCaretAtStartOfSummary(caretPos, detailElements)) {
            return true;
          } else if (isCollapsed && isDelete && isCaretAtEndOfSummary(caretPos, detailElements)) {
            return true;
          } else if (isCollapsed && isBackspace && isCaretInFirstPositionInBody(caretPos, detailElements)) {
            return true;
          } else if (isCollapsed && isDelete && isCaretInLastPositionInBody(root, caretPos, detailElements)) {
            return true;
          } else if (isSafari && isSummary(node)) {
            if (!isCollapsed && isEntireNodeSelected(rng, node) || willDeleteLastPositionInElement(isDelete, caretPos, node)) {
              emptyNodeContents(node);
            } else {
              editor.undoManager.transact(() => {
                const sel = selection.getSel();
                let { anchorNode, anchorOffset, focusNode, focusOffset } = sel !== null && sel !== void 0 ? sel : {};
                const applySelection = () => {
                  if (isNonNullable(anchorNode) && isNonNullable(anchorOffset) && isNonNullable(focusNode) && isNonNullable(focusOffset)) {
                    sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);
                  }
                };
                const updateSelection = () => {
                  anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;
                  anchorOffset = sel === null || sel === void 0 ? void 0 : sel.anchorOffset;
                  focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;
                  focusOffset = sel === null || sel === void 0 ? void 0 : sel.focusOffset;
                };
                const appendAllChildNodes = (from2, to) => {
                  each$e(from2.childNodes, (child2) => {
                    if (isNode(child2)) {
                      to.appendChild(child2);
                    }
                  });
                };
                const container = editor.dom.create("span", { "data-mce-bogus": "all" });
                appendAllChildNodes(node, container);
                node.appendChild(container);
                applySelection();
                if (isCollapsed && (isMacOSOriOS && (e2.altKey || isBackspace && e2.metaKey) || !isMacOSOriOS && e2.ctrlKey)) {
                  sel === null || sel === void 0 ? void 0 : sel.modify("extend", isBackspace ? "left" : "right", e2.metaKey ? "line" : "word");
                }
                if (!selection.isCollapsed() && isEntireNodeSelected(selection.getRng(), container)) {
                  emptyNodeContents(node);
                } else {
                  editor.execCommand(isBackspace ? "Delete" : "ForwardDelete");
                  updateSelection();
                  appendAllChildNodes(container, node);
                  applySelection();
                }
                editor.dom.remove(container);
              });
            }
            return true;
          }
          return false;
        };
        const preventDeletingSummary = (editor) => {
          editor.on("keydown", (e2) => {
            if (e2.keyCode === VK.BACKSPACE || e2.keyCode === VK.DELETE) {
              getDetailsElements(editor.dom, editor.selection.getRng()).fold(() => {
                if (preventDeleteIntoDetails(editor, e2.keyCode === VK.DELETE)) {
                  e2.preventDefault();
                }
              }, (detailsElements) => {
                if (preventDeleteSummaryAction(editor, detailsElements, e2)) {
                  e2.preventDefault();
                }
              });
            }
          });
        };
        const setup$6 = (editor) => {
          preventSummaryToggle(editor);
          filterDetails(editor);
          preventDeletingSummary(editor);
        };
        const isBr = isBr$6;
        const isText = isText$a;
        const isContentEditableFalse$2 = (elm) => isContentEditableFalse$b(elm.dom);
        const isContentEditableTrue = (elm) => isContentEditableTrue$3(elm.dom);
        const isRoot = (rootNode) => (elm) => eq(SugarElement.fromDom(rootNode), elm);
        const getClosestScope = (node, rootNode) => closest$4(SugarElement.fromDom(node), (elm) => isContentEditableTrue(elm) || isBlock$2(elm), isRoot(rootNode)).getOr(SugarElement.fromDom(rootNode)).dom;
        const getClosestCef = (node, rootNode) => closest$4(SugarElement.fromDom(node), isContentEditableFalse$2, isRoot(rootNode));
        const findEdgeCaretCandidate = (startNode, scope, forward) => {
          const walker = new DomTreeWalker(startNode, scope);
          const next2 = forward ? walker.next.bind(walker) : walker.prev.bind(walker);
          let result = startNode;
          for (let current = forward ? startNode : next2(); current && !isBr(current); current = next2()) {
            if (isCaretCandidate$3(current)) {
              result = current;
            }
          }
          return result;
        };
        const findClosestBlockRange = (startRng, rootNode) => {
          const startPos = CaretPosition.fromRangeStart(startRng);
          const clickNode = startPos.getNode();
          const scope = getClosestScope(clickNode, rootNode);
          const startNode = findEdgeCaretCandidate(clickNode, scope, false);
          const endNode = findEdgeCaretCandidate(clickNode, scope, true);
          const rng = document.createRange();
          getClosestCef(startNode, scope).fold(() => {
            if (isText(startNode)) {
              rng.setStart(startNode, 0);
            } else {
              rng.setStartBefore(startNode);
            }
          }, (cef) => rng.setStartBefore(cef.dom));
          getClosestCef(endNode, scope).fold(() => {
            if (isText(endNode)) {
              rng.setEnd(endNode, endNode.data.length);
            } else {
              rng.setEndAfter(endNode);
            }
          }, (cef) => rng.setEndAfter(cef.dom));
          return rng;
        };
        const onTripleClickSelect = (editor) => {
          const rng = findClosestBlockRange(editor.selection.getRng(), editor.getBody());
          editor.selection.setRng(normalize(rng));
        };
        const setup$5 = (editor) => {
          editor.on("mousedown", (e2) => {
            if (e2.detail >= 3) {
              e2.preventDefault();
              onTripleClickSelect(editor);
            }
          });
        };
        var FakeCaretPosition;
        (function(FakeCaretPosition2) {
          FakeCaretPosition2["Before"] = "before";
          FakeCaretPosition2["After"] = "after";
        })(FakeCaretPosition || (FakeCaretPosition = {}));
        const distanceToRectLeft = (clientRect, clientX) => Math.abs(clientRect.left - clientX);
        const distanceToRectRight = (clientRect, clientX) => Math.abs(clientRect.right - clientX);
        const isInsideY = (clientY, clientRect) => clientY >= clientRect.top && clientY <= clientRect.bottom;
        const collidesY = (r1, r22) => r1.top < r22.bottom && r1.bottom > r22.top;
        const isOverlapping = (r1, r22) => {
          const overlap = overlapY(r1, r22) / Math.min(r1.height, r22.height);
          return collidesY(r1, r22) && overlap > 0.5;
        };
        const splitRectsPerAxis = (rects, y2) => {
          const intersectingRects = filter$5(rects, (rect) => isInsideY(y2, rect));
          return boundingClientRectFromRects(intersectingRects).fold(() => [
            [],
            rects
          ], (boundingRect) => {
            const {
              pass: horizontal,
              fail: vertical
            } = partition$2(rects, (rect) => isOverlapping(rect, boundingRect));
            return [
              horizontal,
              vertical
            ];
          });
        };
        const clientInfo = (rect, clientX) => {
          return {
            node: rect.node,
            position: distanceToRectLeft(rect, clientX) < distanceToRectRight(rect, clientX) ? FakeCaretPosition.Before : FakeCaretPosition.After
          };
        };
        const horizontalDistance = (rect, x2, _y) => x2 > rect.left && x2 < rect.right ? 0 : Math.min(Math.abs(rect.left - x2), Math.abs(rect.right - x2));
        const closestChildCaretCandidateNodeRect = (children2, clientX, clientY) => {
          const caretCandidateRect = (rect) => {
            if (isCaretCandidate$3(rect.node)) {
              return Optional.some(rect);
            } else if (isElement$6(rect.node)) {
              return closestChildCaretCandidateNodeRect(from(rect.node.childNodes), clientX, clientY);
            } else {
              return Optional.none();
            }
          };
          const getClosestTextNode = (rects, distance) => {
            if (rects.length >= 2) {
              const r1 = caretCandidateRect(rects[0]).getOr(rects[0]);
              const r22 = caretCandidateRect(rects[1]).getOr(rects[1]);
              const deltaDistance = Math.abs(distance(r1, clientX, clientY) - distance(r22, clientX, clientY));
              if (deltaDistance < 2) {
                if (isText$a(r1.node)) {
                  return Optional.some(r1);
                } else if (isText$a(r22.node)) {
                  return Optional.some(r22);
                }
              }
            }
            return Optional.none();
          };
          const findClosestCaretCandidateNodeRect = (rects, distance) => {
            const sortedRects = sort(rects, (r1, r22) => distance(r1, clientX, clientY) - distance(r22, clientX, clientY));
            return getClosestTextNode(sortedRects, distance).orThunk(() => findMap(sortedRects, caretCandidateRect));
          };
          const [horizontalRects, verticalRects] = splitRectsPerAxis(getClientRects(children2), clientY);
          const {
            pass: above,
            fail: below
          } = partition$2(verticalRects, (rect) => rect.top < clientY);
          return findClosestCaretCandidateNodeRect(horizontalRects, horizontalDistance).orThunk(() => findClosestCaretCandidateNodeRect(below, distanceToRectEdgeFromXY)).orThunk(() => findClosestCaretCandidateNodeRect(above, distanceToRectEdgeFromXY));
        };
        const traverseUp = (rootElm, scope, clientX, clientY) => {
          const helper = (scope2, prevScope) => {
            const isDragGhostContainer = (node) => isElement$6(node) && node.classList.contains("mce-drag-container");
            const childNodesWithoutGhost = filter$5(scope2.dom.childNodes, not(isDragGhostContainer));
            return prevScope.fold(() => closestChildCaretCandidateNodeRect(childNodesWithoutGhost, clientX, clientY), (prevScope2) => {
              const uncheckedChildren = filter$5(childNodesWithoutGhost, (node) => node !== prevScope2.dom);
              return closestChildCaretCandidateNodeRect(uncheckedChildren, clientX, clientY);
            }).orThunk(() => {
              const parent2 = eq(scope2, rootElm) ? Optional.none() : parentElement(scope2);
              return parent2.bind((newScope) => helper(newScope, Optional.some(scope2)));
            });
          };
          return helper(scope, Optional.none());
        };
        const closestCaretCandidateNodeRect = (root, clientX, clientY) => {
          const rootElm = SugarElement.fromDom(root);
          const ownerDoc = documentOrOwner(rootElm);
          const elementAtPoint = SugarElement.fromPoint(ownerDoc, clientX, clientY).filter((elm) => contains2(rootElm, elm));
          const element = elementAtPoint.getOr(rootElm);
          return traverseUp(rootElm, element, clientX, clientY);
        };
        const closestFakeCaretCandidate = (root, clientX, clientY) => closestCaretCandidateNodeRect(root, clientX, clientY).filter((rect) => isFakeCaretTarget(rect.node)).map((rect) => clientInfo(rect, clientX));
        const getAbsolutePosition = (elm) => {
          var _a, _b;
          const clientRect = elm.getBoundingClientRect();
          const doc = elm.ownerDocument;
          const docElem = doc.documentElement;
          const win = doc.defaultView;
          return {
            top: clientRect.top + ((_a = win === null || win === void 0 ? void 0 : win.scrollY) !== null && _a !== void 0 ? _a : 0) - docElem.clientTop,
            left: clientRect.left + ((_b = win === null || win === void 0 ? void 0 : win.scrollX) !== null && _b !== void 0 ? _b : 0) - docElem.clientLeft
          };
        };
        const getBodyPosition = (editor) => editor.inline ? getAbsolutePosition(editor.getBody()) : {
          left: 0,
          top: 0
        };
        const getScrollPosition = (editor) => {
          const body = editor.getBody();
          return editor.inline ? {
            left: body.scrollLeft,
            top: body.scrollTop
          } : {
            left: 0,
            top: 0
          };
        };
        const getBodyScroll = (editor) => {
          const body = editor.getBody(), docElm = editor.getDoc().documentElement;
          const inlineScroll = {
            left: body.scrollLeft,
            top: body.scrollTop
          };
          const iframeScroll = {
            left: body.scrollLeft || docElm.scrollLeft,
            top: body.scrollTop || docElm.scrollTop
          };
          return editor.inline ? inlineScroll : iframeScroll;
        };
        const getMousePosition = (editor, event) => {
          if (event.target.ownerDocument !== editor.getDoc()) {
            const iframePosition = getAbsolutePosition(editor.getContentAreaContainer());
            const scrollPosition = getBodyScroll(editor);
            return {
              left: event.pageX - iframePosition.left + scrollPosition.left,
              top: event.pageY - iframePosition.top + scrollPosition.top
            };
          }
          return {
            left: event.pageX,
            top: event.pageY
          };
        };
        const calculatePosition = (bodyPosition, scrollPosition, mousePosition) => ({
          pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,
          pageY: mousePosition.top - bodyPosition.top + scrollPosition.top
        });
        const calc = (editor, event) => calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));
        const getTargetProps = (target) => ({
          target,
          srcElement: target
        });
        const makeDndEventFromMouseEvent = (type2, mouseEvent, target, dataTransfer) => ({
          ...mouseEvent,
          dataTransfer,
          type: type2,
          ...getTargetProps(target)
        });
        const makeDndEvent = (type2, target, dataTransfer) => {
          const fail = die("Function not supported on simulated event.");
          const event = {
            bubbles: true,
            cancelBubble: false,
            cancelable: true,
            composed: false,
            currentTarget: null,
            defaultPrevented: false,
            eventPhase: 0,
            isTrusted: true,
            returnValue: false,
            timeStamp: 0,
            type: type2,
            composedPath: fail,
            initEvent: fail,
            preventDefault: noop2,
            stopImmediatePropagation: noop2,
            stopPropagation: noop2,
            AT_TARGET: window.Event.AT_TARGET,
            BUBBLING_PHASE: window.Event.BUBBLING_PHASE,
            CAPTURING_PHASE: window.Event.CAPTURING_PHASE,
            NONE: window.Event.NONE,
            altKey: false,
            button: 0,
            buttons: 0,
            clientX: 0,
            clientY: 0,
            ctrlKey: false,
            metaKey: false,
            movementX: 0,
            movementY: 0,
            offsetX: 0,
            offsetY: 0,
            pageX: 0,
            pageY: 0,
            relatedTarget: null,
            screenX: 0,
            screenY: 0,
            shiftKey: false,
            x: 0,
            y: 0,
            detail: 0,
            view: null,
            which: 0,
            initUIEvent: fail,
            initMouseEvent: fail,
            getModifierState: fail,
            dataTransfer,
            ...getTargetProps(target)
          };
          return event;
        };
        const makeDataTransferCopyForDragEvent = (dataTransfer, eventType) => {
          const copy2 = cloneDataTransfer(dataTransfer);
          if (eventType === "dragstart") {
            setDragstartEvent(copy2);
            setReadWriteMode(copy2);
          } else if (eventType === "drop") {
            setDropEvent(copy2);
            setReadOnlyMode(copy2);
          } else {
            setDragendEvent(copy2);
            setProtectedMode(copy2);
          }
          return copy2;
        };
        const makeDragEvent = (type2, target, dataTransfer, mouseEvent) => {
          const dataTransferForDispatch = makeDataTransferCopyForDragEvent(dataTransfer, type2);
          return isUndefined(mouseEvent) ? makeDndEvent(type2, target, dataTransferForDispatch) : makeDndEventFromMouseEvent(type2, mouseEvent, target, dataTransferForDispatch);
        };
        const scrollPixelsPerInterval = 32;
        const scrollIntervalValue = 100;
        const mouseRangeToTriggerScrollInsideEditor = 8;
        const mouseRangeToTriggerScrollOutsideEditor = 16;
        const isContentEditableFalse$1 = isContentEditableFalse$b;
        const isContentEditable = or(isContentEditableFalse$1, isContentEditableTrue$3);
        const isDraggable = (dom2, rootElm, elm) => isContentEditableFalse$1(elm) && elm !== rootElm && dom2.isEditable(elm.parentElement);
        const isValidDropTarget = (editor, targetElement, dragElement) => {
          if (isNullable(targetElement)) {
            return false;
          } else if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {
            return false;
          } else {
            return editor.dom.isEditable(targetElement);
          }
        };
        const createGhost = (editor, elm, width, height) => {
          const dom2 = editor.dom;
          const clonedElm = elm.cloneNode(true);
          dom2.setStyles(clonedElm, {
            width,
            height
          });
          dom2.setAttrib(clonedElm, "data-mce-selected", null);
          const ghostElm = dom2.create("div", {
            "class": "mce-drag-container",
            "data-mce-bogus": "all",
            "unselectable": "on",
            "contenteditable": "false"
          });
          dom2.setStyles(ghostElm, {
            position: "absolute",
            opacity: 0.5,
            overflow: "hidden",
            border: 0,
            padding: 0,
            margin: 0,
            width,
            height
          });
          dom2.setStyles(clonedElm, {
            margin: 0,
            boxSizing: "border-box"
          });
          ghostElm.appendChild(clonedElm);
          return ghostElm;
        };
        const appendGhostToBody = (ghostElm, bodyElm) => {
          if (ghostElm.parentNode !== bodyElm) {
            bodyElm.appendChild(ghostElm);
          }
        };
        const scrollEditor = (direction, amount) => (win) => () => {
          const current = direction === "left" ? win.scrollX : win.scrollY;
          win.scroll({
            [direction]: current + amount,
            behavior: "smooth"
          });
        };
        const scrollLeft = scrollEditor("left", -scrollPixelsPerInterval);
        const scrollRight = scrollEditor("left", scrollPixelsPerInterval);
        const scrollUp = scrollEditor("top", -scrollPixelsPerInterval);
        const scrollDown = scrollEditor("top", scrollPixelsPerInterval);
        const moveGhost = (ghostElm, position, width, height, maxX, maxY, mouseY, mouseX, contentAreaContainer, win, state, mouseEventOriginatedFromWithinTheEditor) => {
          let overflowX = 0, overflowY = 0;
          ghostElm.style.left = position.pageX + "px";
          ghostElm.style.top = position.pageY + "px";
          if (position.pageX + width > maxX) {
            overflowX = position.pageX + width - maxX;
          }
          if (position.pageY + height > maxY) {
            overflowY = position.pageY + height - maxY;
          }
          ghostElm.style.width = width - overflowX + "px";
          ghostElm.style.height = height - overflowY + "px";
          const clientHeight = contentAreaContainer.clientHeight;
          const clientWidth = contentAreaContainer.clientWidth;
          const outerMouseY = mouseY + contentAreaContainer.getBoundingClientRect().top;
          const outerMouseX = mouseX + contentAreaContainer.getBoundingClientRect().left;
          state.on((state2) => {
            state2.intervalId.clear();
            if (state2.dragging && mouseEventOriginatedFromWithinTheEditor) {
              if (mouseY + mouseRangeToTriggerScrollInsideEditor >= clientHeight) {
                state2.intervalId.set(scrollDown(win));
              } else if (mouseY - mouseRangeToTriggerScrollInsideEditor <= 0) {
                state2.intervalId.set(scrollUp(win));
              } else if (mouseX + mouseRangeToTriggerScrollInsideEditor >= clientWidth) {
                state2.intervalId.set(scrollRight(win));
              } else if (mouseX - mouseRangeToTriggerScrollInsideEditor <= 0) {
                state2.intervalId.set(scrollLeft(win));
              } else if (outerMouseY + mouseRangeToTriggerScrollOutsideEditor >= window.innerHeight) {
                state2.intervalId.set(scrollDown(window));
              } else if (outerMouseY - mouseRangeToTriggerScrollOutsideEditor <= 0) {
                state2.intervalId.set(scrollUp(window));
              } else if (outerMouseX + mouseRangeToTriggerScrollOutsideEditor >= window.innerWidth) {
                state2.intervalId.set(scrollRight(window));
              } else if (outerMouseX - mouseRangeToTriggerScrollOutsideEditor <= 0) {
                state2.intervalId.set(scrollLeft(window));
              }
            }
          });
        };
        const removeElement = (elm) => {
          if (elm && elm.parentNode) {
            elm.parentNode.removeChild(elm);
          }
        };
        const removeElementWithPadding = (dom2, elm) => {
          const parentBlock = dom2.getParent(elm.parentNode, dom2.isBlock);
          removeElement(elm);
          if (parentBlock && parentBlock !== dom2.getRoot() && dom2.isEmpty(parentBlock)) {
            fillWithPaddingBr(SugarElement.fromDom(parentBlock));
          }
        };
        const isLeftMouseButtonPressed = (e2) => e2.button === 0;
        const applyRelPos = (state, position) => ({
          pageX: position.pageX - state.relX,
          pageY: position.pageY + 5
        });
        const start3 = (state, editor) => (e2) => {
          if (isLeftMouseButtonPressed(e2)) {
            const ceElm = find$2(editor.dom.getParents(e2.target), isContentEditable).getOr(null);
            if (isNonNullable(ceElm) && isDraggable(editor.dom, editor.getBody(), ceElm)) {
              const elmPos = editor.dom.getPos(ceElm);
              const bodyElm = editor.getBody();
              const docElm = editor.getDoc().documentElement;
              state.set({
                element: ceElm,
                dataTransfer: createDataTransfer(),
                dragging: false,
                screenX: e2.screenX,
                screenY: e2.screenY,
                maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,
                maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,
                relX: e2.pageX - elmPos.x,
                relY: e2.pageY - elmPos.y,
                width: ceElm.offsetWidth,
                height: ceElm.offsetHeight,
                ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight),
                intervalId: repeatable(scrollIntervalValue)
              });
            }
          }
        };
        const placeCaretAt = (editor, clientX, clientY) => {
          editor._selectionOverrides.hideFakeCaret();
          closestFakeCaretCandidate(editor.getBody(), clientX, clientY).fold(() => editor.selection.placeCaretAt(clientX, clientY), (caretInfo) => {
            const range2 = editor._selectionOverrides.showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);
            if (range2) {
              editor.selection.setRng(range2);
            } else {
              editor.selection.placeCaretAt(clientX, clientY);
            }
          });
        };
        const dispatchDragEvent = (editor, type2, target, dataTransfer, mouseEvent) => {
          if (type2 === "dragstart") {
            setHtmlData(dataTransfer, editor.dom.getOuterHTML(target));
          }
          const event = makeDragEvent(type2, target, dataTransfer, mouseEvent);
          const args = editor.dispatch(type2, event);
          return args;
        };
        const move = (state, editor) => {
          const throttledPlaceCaretAt = first$1((clientX, clientY) => placeCaretAt(editor, clientX, clientY), 0);
          editor.on("remove", throttledPlaceCaretAt.cancel);
          const state_ = state;
          return (e2) => state.on((state2) => {
            const movement = Math.max(Math.abs(e2.screenX - state2.screenX), Math.abs(e2.screenY - state2.screenY));
            if (!state2.dragging && movement > 10) {
              const args = dispatchDragEvent(editor, "dragstart", state2.element, state2.dataTransfer, e2);
              if (isNonNullable(args.dataTransfer)) {
                state2.dataTransfer = args.dataTransfer;
              }
              if (args.isDefaultPrevented()) {
                return;
              }
              state2.dragging = true;
              editor.focus();
            }
            if (state2.dragging) {
              const mouseEventOriginatedFromWithinTheEditor = e2.currentTarget === editor.getDoc().documentElement;
              const targetPos = applyRelPos(state2, calc(editor, e2));
              appendGhostToBody(state2.ghost, editor.getBody());
              moveGhost(state2.ghost, targetPos, state2.width, state2.height, state2.maxX, state2.maxY, e2.clientY, e2.clientX, editor.getContentAreaContainer(), editor.getWin(), state_, mouseEventOriginatedFromWithinTheEditor);
              throttledPlaceCaretAt.throttle(e2.clientX, e2.clientY);
            }
          });
        };
        const getRawTarget = (selection) => {
          const sel = selection.getSel();
          if (isNonNullable(sel)) {
            const rng = sel.getRangeAt(0);
            const startContainer = rng.startContainer;
            return isText$a(startContainer) ? startContainer.parentNode : startContainer;
          } else {
            return null;
          }
        };
        const drop = (state, editor) => (e2) => {
          state.on((state2) => {
            var _a;
            state2.intervalId.clear();
            if (state2.dragging) {
              if (isValidDropTarget(editor, getRawTarget(editor.selection), state2.element)) {
                const dropTarget = (_a = editor.getDoc().elementFromPoint(e2.clientX, e2.clientY)) !== null && _a !== void 0 ? _a : editor.getBody();
                const args = dispatchDragEvent(editor, "drop", dropTarget, state2.dataTransfer, e2);
                if (!args.isDefaultPrevented()) {
                  editor.undoManager.transact(() => {
                    removeElementWithPadding(editor.dom, state2.element);
                    getHtmlData(state2.dataTransfer).each((content) => editor.insertContent(content));
                    editor._selectionOverrides.hideFakeCaret();
                  });
                }
              }
              dispatchDragEvent(editor, "dragend", editor.getBody(), state2.dataTransfer, e2);
            }
          });
          removeDragState(state);
        };
        const stopDragging = (state, editor, e2) => {
          state.on((state2) => {
            state2.intervalId.clear();
            if (state2.dragging) {
              e2.fold(() => dispatchDragEvent(editor, "dragend", state2.element, state2.dataTransfer), (mouseEvent) => dispatchDragEvent(editor, "dragend", state2.element, state2.dataTransfer, mouseEvent));
            }
          });
          removeDragState(state);
        };
        const stop = (state, editor) => (e2) => stopDragging(state, editor, Optional.some(e2));
        const removeDragState = (state) => {
          state.on((state2) => {
            state2.intervalId.clear();
            removeElement(state2.ghost);
          });
          state.clear();
        };
        const bindFakeDragEvents = (editor) => {
          const state = value$2();
          const pageDom = DOMUtils.DOM;
          const rootDocument = document;
          const dragStartHandler = start3(state, editor);
          const dragHandler = move(state, editor);
          const dropHandler = drop(state, editor);
          const dragEndHandler = stop(state, editor);
          editor.on("mousedown", dragStartHandler);
          editor.on("mousemove", dragHandler);
          editor.on("mouseup", dropHandler);
          pageDom.bind(rootDocument, "mousemove", dragHandler);
          pageDom.bind(rootDocument, "mouseup", dragEndHandler);
          editor.on("remove", () => {
            pageDom.unbind(rootDocument, "mousemove", dragHandler);
            pageDom.unbind(rootDocument, "mouseup", dragEndHandler);
          });
          editor.on("keydown", (e2) => {
            if (e2.keyCode === VK.ESC) {
              stopDragging(state, editor, Optional.none());
            }
          });
        };
        const blockUnsupportedFileDrop = (editor) => {
          const preventFileDrop = (e2) => {
            if (!e2.isDefaultPrevented()) {
              const dataTransfer = e2.dataTransfer;
              if (dataTransfer && (contains$2(dataTransfer.types, "Files") || dataTransfer.files.length > 0)) {
                e2.preventDefault();
                if (e2.type === "drop") {
                  displayError(editor, "Dropped file type is not supported");
                }
              }
            }
          };
          const preventFileDropIfUIElement = (e2) => {
            if (isUIElement(editor, e2.target)) {
              preventFileDrop(e2);
            }
          };
          const setup2 = () => {
            const pageDom = DOMUtils.DOM;
            const dom2 = editor.dom;
            const doc = document;
            const editorRoot = editor.inline ? editor.getBody() : editor.getDoc();
            const eventNames = [
              "drop",
              "dragover"
            ];
            each$e(eventNames, (name2) => {
              pageDom.bind(doc, name2, preventFileDropIfUIElement);
              dom2.bind(editorRoot, name2, preventFileDrop);
            });
            editor.on("remove", () => {
              each$e(eventNames, (name2) => {
                pageDom.unbind(doc, name2, preventFileDropIfUIElement);
                dom2.unbind(editorRoot, name2, preventFileDrop);
              });
            });
          };
          editor.on("init", () => {
            Delay.setEditorTimeout(editor, setup2, 0);
          });
        };
        const init$2 = (editor) => {
          bindFakeDragEvents(editor);
          if (shouldBlockUnsupportedDrop(editor)) {
            blockUnsupportedFileDrop(editor);
          }
        };
        const setup$4 = (editor) => {
          const renderFocusCaret = first$1(() => {
            if (!editor.removed && editor.getBody().contains(document.activeElement)) {
              const rng = editor.selection.getRng();
              if (rng.collapsed) {
                const caretRange = renderRangeCaret(editor, rng, false);
                editor.selection.setRng(caretRange);
              }
            }
          }, 0);
          editor.on("focus", () => {
            renderFocusCaret.throttle();
          });
          editor.on("blur", () => {
            renderFocusCaret.cancel();
          });
        };
        const setup$3 = (editor) => {
          editor.on("init", () => {
            editor.on("focusin", (e2) => {
              const target = e2.target;
              if (isMedia$2(target)) {
                const ceRoot = getContentEditableRoot$1(editor.getBody(), target);
                const node = isContentEditableFalse$b(ceRoot) ? ceRoot : target;
                if (editor.selection.getNode() !== node) {
                  selectNode(editor, node).each((rng) => editor.selection.setRng(rng));
                }
              }
            });
          });
        };
        const isContentEditableFalse = isContentEditableFalse$b;
        const getContentEditableRoot = (editor, node) => getContentEditableRoot$1(editor.getBody(), node);
        const SelectionOverrides = (editor) => {
          const selection = editor.selection, dom2 = editor.dom;
          const rootNode = editor.getBody();
          const fakeCaret = FakeCaret(editor, rootNode, dom2.isBlock, () => hasFocus(editor));
          const realSelectionId = "sel-" + dom2.uniqueId();
          const elementSelectionAttr2 = "data-mce-selected";
          let selectedElement;
          const isFakeSelectionElement = (node) => isNonNullable(node) && dom2.hasClass(node, "mce-offscreen-selection");
          const isFakeSelectionTargetElement = (node) => node !== rootNode && (isContentEditableFalse(node) || isMedia$2(node)) && dom2.isChildOf(node, rootNode) && dom2.isEditable(node.parentNode);
          const setRange = (range2) => {
            if (range2) {
              selection.setRng(range2);
            }
          };
          const showCaret2 = (direction, node, before2, scrollIntoView = true) => {
            const e2 = editor.dispatch("ShowCaret", {
              target: node,
              direction,
              before: before2
            });
            if (e2.isDefaultPrevented()) {
              return null;
            }
            if (scrollIntoView) {
              selection.scrollIntoView(node, direction === -1);
            }
            return fakeCaret.show(before2, node);
          };
          const showBlockCaretContainer2 = (blockCaretContainer) => {
            if (blockCaretContainer.hasAttribute("data-mce-caret")) {
              showCaretContainerBlock(blockCaretContainer);
              selection.scrollIntoView(blockCaretContainer);
            }
          };
          const registerEvents2 = () => {
            editor.on("click", (e2) => {
              if (!dom2.isEditable(e2.target)) {
                e2.preventDefault();
                editor.focus();
              }
            });
            editor.on("blur NewBlock", removeElementSelection);
            editor.on("ResizeWindow FullscreenStateChanged", fakeCaret.reposition);
            editor.on("tap", (e2) => {
              const targetElm = e2.target;
              const contentEditableRoot = getContentEditableRoot(editor, targetElm);
              if (isContentEditableFalse(contentEditableRoot)) {
                e2.preventDefault();
                selectNode(editor, contentEditableRoot).each(setElementSelection);
              } else if (isFakeSelectionTargetElement(targetElm)) {
                selectNode(editor, targetElm).each(setElementSelection);
              }
            }, true);
            editor.on("mousedown", (e2) => {
              const targetElm = e2.target;
              if (targetElm !== rootNode && targetElm.nodeName !== "HTML" && !dom2.isChildOf(targetElm, rootNode)) {
                return;
              }
              if (!isXYInContentArea(editor, e2.clientX, e2.clientY)) {
                return;
              }
              removeElementSelection();
              hideFakeCaret();
              const closestContentEditable = getContentEditableRoot(editor, targetElm);
              if (isContentEditableFalse(closestContentEditable)) {
                e2.preventDefault();
                selectNode(editor, closestContentEditable).each(setElementSelection);
              } else {
                closestFakeCaretCandidate(rootNode, e2.clientX, e2.clientY).each((caretInfo) => {
                  e2.preventDefault();
                  const range2 = showCaret2(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);
                  setRange(range2);
                  if (isElement$6(closestContentEditable)) {
                    closestContentEditable.focus();
                  } else {
                    editor.getBody().focus();
                  }
                });
              }
            });
            editor.on("keypress", (e2) => {
              if (VK.modifierPressed(e2)) {
                return;
              }
              if (isContentEditableFalse(selection.getNode())) {
                e2.preventDefault();
              }
            });
            editor.on("GetSelectionRange", (e2) => {
              let rng = e2.range;
              if (selectedElement) {
                if (!selectedElement.parentNode) {
                  selectedElement = null;
                  return;
                }
                rng = rng.cloneRange();
                rng.selectNode(selectedElement);
                e2.range = rng;
              }
            });
            editor.on("SetSelectionRange", (e2) => {
              e2.range = normalizeVoidElementSelection(e2.range);
              const rng = setElementSelection(e2.range, e2.forward);
              if (rng) {
                e2.range = rng;
              }
            });
            const isPasteBin2 = (node) => isElement$6(node) && node.id === "mcepastebin";
            editor.on("AfterSetSelectionRange", (e2) => {
              const rng = e2.range;
              const parent2 = rng.startContainer.parentElement;
              if (!isRangeInCaretContainer(rng) && !isPasteBin2(parent2)) {
                hideFakeCaret();
              }
              if (!isFakeSelectionElement(parent2)) {
                removeElementSelection();
              }
            });
            init$2(editor);
            setup$4(editor);
            setup$3(editor);
          };
          const isWithinCaretContainer = (node) => isCaretContainer$2(node) || startsWithCaretContainer$1(node) || endsWithCaretContainer$1(node);
          const isRangeInCaretContainer = (rng) => isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);
          const normalizeVoidElementSelection = (rng) => {
            const voidElements = editor.schema.getVoidElements();
            const newRng = dom2.createRng();
            const startContainer = rng.startContainer;
            const startOffset = rng.startOffset;
            const endContainer = rng.endContainer;
            const endOffset = rng.endOffset;
            if (has$2(voidElements, startContainer.nodeName.toLowerCase())) {
              if (startOffset === 0) {
                newRng.setStartBefore(startContainer);
              } else {
                newRng.setStartAfter(startContainer);
              }
            } else {
              newRng.setStart(startContainer, startOffset);
            }
            if (has$2(voidElements, endContainer.nodeName.toLowerCase())) {
              if (endOffset === 0) {
                newRng.setEndBefore(endContainer);
              } else {
                newRng.setEndAfter(endContainer);
              }
            } else {
              newRng.setEnd(endContainer, endOffset);
            }
            return newRng;
          };
          const setupOffscreenSelection = (node, targetClone) => {
            const body = SugarElement.fromDom(editor.getBody());
            const doc = editor.getDoc();
            const realSelectionContainer = descendant(body, "#" + realSelectionId).getOrThunk(() => {
              const newContainer = SugarElement.fromHtml('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>', doc);
              set$3(newContainer, "id", realSelectionId);
              append$1(body, newContainer);
              return newContainer;
            });
            const newRange = dom2.createRng();
            empty(realSelectionContainer);
            append(realSelectionContainer, [
              SugarElement.fromText(nbsp, doc),
              SugarElement.fromDom(targetClone),
              SugarElement.fromText(nbsp, doc)
            ]);
            newRange.setStart(realSelectionContainer.dom.firstChild, 1);
            newRange.setEnd(realSelectionContainer.dom.lastChild, 0);
            setAll(realSelectionContainer, { top: dom2.getPos(node, editor.getBody()).y + "px" });
            focus$1(realSelectionContainer);
            const sel = selection.getSel();
            if (sel) {
              sel.removeAllRanges();
              sel.addRange(newRange);
            }
            return newRange;
          };
          const selectElement = (elm) => {
            const targetClone = elm.cloneNode(true);
            const e2 = editor.dispatch("ObjectSelected", {
              target: elm,
              targetClone
            });
            if (e2.isDefaultPrevented()) {
              return null;
            }
            const range2 = setupOffscreenSelection(elm, e2.targetClone);
            const nodeElm = SugarElement.fromDom(elm);
            each$e(descendants(SugarElement.fromDom(editor.getBody()), `*[${elementSelectionAttr2}]`), (elm2) => {
              if (!eq(nodeElm, elm2)) {
                remove$a(elm2, elementSelectionAttr2);
              }
            });
            if (!dom2.getAttrib(elm, elementSelectionAttr2)) {
              elm.setAttribute(elementSelectionAttr2, "1");
            }
            selectedElement = elm;
            hideFakeCaret();
            return range2;
          };
          const setElementSelection = (range2, forward) => {
            if (!range2) {
              return null;
            }
            if (range2.collapsed) {
              if (!isRangeInCaretContainer(range2)) {
                const dir = forward ? 1 : -1;
                const caretPosition = getNormalizedRangeEndPoint(dir, rootNode, range2);
                const beforeNode = caretPosition.getNode(!forward);
                if (isNonNullable(beforeNode)) {
                  if (isFakeCaretTarget(beforeNode)) {
                    return showCaret2(dir, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);
                  }
                  if (isCaretContainerInline(beforeNode) && isContentEditableFalse$b(beforeNode.nextSibling)) {
                    const rng = dom2.createRng();
                    rng.setStart(beforeNode, 0);
                    rng.setEnd(beforeNode, 0);
                    return rng;
                  }
                }
                const afterNode = caretPosition.getNode(forward);
                if (isNonNullable(afterNode)) {
                  if (isFakeCaretTarget(afterNode)) {
                    return showCaret2(dir, afterNode, forward ? false : !caretPosition.isAtEnd(), false);
                  }
                  if (isCaretContainerInline(afterNode) && isContentEditableFalse$b(afterNode.previousSibling)) {
                    const rng = dom2.createRng();
                    rng.setStart(afterNode, 1);
                    rng.setEnd(afterNode, 1);
                    return rng;
                  }
                }
              }
              return null;
            }
            let startContainer = range2.startContainer;
            let startOffset = range2.startOffset;
            const endOffset = range2.endOffset;
            if (isText$a(startContainer) && startOffset === 0 && isContentEditableFalse(startContainer.parentNode)) {
              startContainer = startContainer.parentNode;
              startOffset = dom2.nodeIndex(startContainer);
              startContainer = startContainer.parentNode;
            }
            if (!isElement$6(startContainer)) {
              return null;
            }
            if (endOffset === startOffset + 1 && startContainer === range2.endContainer) {
              const node = startContainer.childNodes[startOffset];
              if (isFakeSelectionTargetElement(node)) {
                return selectElement(node);
              }
            }
            return null;
          };
          const removeElementSelection = () => {
            if (selectedElement) {
              selectedElement.removeAttribute(elementSelectionAttr2);
            }
            descendant(SugarElement.fromDom(editor.getBody()), "#" + realSelectionId).each(remove$5);
            selectedElement = null;
          };
          const destroy2 = () => {
            fakeCaret.destroy();
            selectedElement = null;
          };
          const hideFakeCaret = () => {
            fakeCaret.hide();
          };
          if (!isRtc(editor)) {
            registerEvents2();
          }
          return {
            showCaret: showCaret2,
            showBlockCaretContainer: showBlockCaretContainer2,
            hideFakeCaret,
            destroy: destroy2
          };
        };
        const getNormalizedTextOffset = (container, offset2) => {
          let normalizedOffset = offset2;
          for (let node = container.previousSibling; isText$a(node); node = node.previousSibling) {
            normalizedOffset += node.data.length;
          }
          return normalizedOffset;
        };
        const generatePath = (dom2, root, node, offset2, normalized) => {
          if (isText$a(node) && (offset2 < 0 || offset2 > node.data.length)) {
            return [];
          }
          const p2 = normalized && isText$a(node) ? [getNormalizedTextOffset(node, offset2)] : [offset2];
          let current = node;
          while (current !== root && current.parentNode) {
            p2.push(dom2.nodeIndex(current, normalized));
            current = current.parentNode;
          }
          return current === root ? p2.reverse() : [];
        };
        const generatePathRange = (dom2, root, startNode, startOffset, endNode, endOffset, normalized = false) => {
          const start4 = generatePath(dom2, root, startNode, startOffset, normalized);
          const end3 = generatePath(dom2, root, endNode, endOffset, normalized);
          return {
            start: start4,
            end: end3
          };
        };
        const resolvePath = (root, path2) => {
          const nodePath = path2.slice();
          const offset2 = nodePath.pop();
          if (!isNumber(offset2)) {
            return Optional.none();
          } else {
            const resolvedNode = foldl(nodePath, (optNode, index) => optNode.bind((node) => Optional.from(node.childNodes[index])), Optional.some(root));
            return resolvedNode.bind((node) => {
              if (isText$a(node) && (offset2 < 0 || offset2 > node.data.length)) {
                return Optional.none();
              } else {
                return Optional.some({
                  node,
                  offset: offset2
                });
              }
            });
          }
        };
        const resolvePathRange = (root, range2) => resolvePath(root, range2.start).bind(({
          node: startNode,
          offset: startOffset
        }) => resolvePath(root, range2.end).map(({
          node: endNode,
          offset: endOffset
        }) => {
          const rng = document.createRange();
          rng.setStart(startNode, startOffset);
          rng.setEnd(endNode, endOffset);
          return rng;
        }));
        const generatePathRangeFromRange = (dom2, root, range2, normalized = false) => generatePathRange(dom2, root, range2.startContainer, range2.startOffset, range2.endContainer, range2.endOffset, normalized);
        const cleanEmptyNodes = (dom2, node, isRoot2) => {
          if (node && dom2.isEmpty(node) && !isRoot2(node)) {
            const parent2 = node.parentNode;
            dom2.remove(node);
            cleanEmptyNodes(dom2, parent2, isRoot2);
          }
        };
        const deleteRng = (dom2, rng, isRoot2, clean = true) => {
          const startParent = rng.startContainer.parentNode;
          const endParent = rng.endContainer.parentNode;
          rng.deleteContents();
          if (clean && !isRoot2(rng.startContainer)) {
            if (isText$a(rng.startContainer) && rng.startContainer.data.length === 0) {
              dom2.remove(rng.startContainer);
            }
            if (isText$a(rng.endContainer) && rng.endContainer.data.length === 0) {
              dom2.remove(rng.endContainer);
            }
            cleanEmptyNodes(dom2, startParent, isRoot2);
            if (startParent !== endParent) {
              cleanEmptyNodes(dom2, endParent, isRoot2);
            }
          }
        };
        const getParentBlock = (editor, rng) => Optional.from(editor.dom.getParent(rng.startContainer, editor.dom.isBlock));
        const resolveFromDynamicPatterns = (patternSet, block, beforeText) => {
          const dynamicPatterns = patternSet.dynamicPatternsLookup({
            text: beforeText,
            block
          });
          return {
            ...patternSet,
            blockPatterns: getBlockPatterns(dynamicPatterns).concat(patternSet.blockPatterns),
            inlinePatterns: getInlinePatterns(dynamicPatterns).concat(patternSet.inlinePatterns)
          };
        };
        const getBeforeText = (dom2, block, node, offset2) => {
          const rng = dom2.createRng();
          rng.setStart(block, 0);
          rng.setEnd(node, offset2);
          return rng.toString();
        };
        const startsWithSingleSpace = (s2) => /^\s[^\s]/.test(s2);
        const stripPattern = (dom2, block, pattern) => {
          const firstTextNode = textAfter(block, 0, block);
          firstTextNode.each((spot) => {
            const node = spot.container;
            scanRight(node, pattern.start.length, block).each((end3) => {
              const rng = dom2.createRng();
              rng.setStart(node, 0);
              rng.setEnd(end3.container, end3.offset);
              deleteRng(dom2, rng, (e2) => e2 === block);
            });
            const text2 = SugarElement.fromDom(node);
            const textContent = get$3(text2);
            if (startsWithSingleSpace(textContent)) {
              set(text2, textContent.slice(1));
            }
          });
        };
        const applyPattern$1 = (editor, match2) => {
          const dom2 = editor.dom;
          const pattern = match2.pattern;
          const rng = resolvePathRange(dom2.getRoot(), match2.range).getOrDie("Unable to resolve path range");
          const isBlockFormatName = (name2, formatter) => {
            const formatSet = formatter.get(name2);
            return isArray$1(formatSet) && head(formatSet).exists((format) => has$2(format, "block"));
          };
          getParentBlock(editor, rng).each((block) => {
            if (pattern.type === "block-format") {
              if (isBlockFormatName(pattern.format, editor.formatter)) {
                editor.undoManager.transact(() => {
                  stripPattern(editor.dom, block, pattern);
                  editor.formatter.apply(pattern.format);
                });
              }
            } else if (pattern.type === "block-command") {
              editor.undoManager.transact(() => {
                stripPattern(editor.dom, block, pattern);
                editor.execCommand(pattern.cmd, false, pattern.value);
              });
            }
          });
          return true;
        };
        const sortPatterns$1 = (patterns) => sort(patterns, (a2, b2) => b2.start.length - a2.start.length);
        const findPattern$1 = (patterns, text2) => {
          const sortedPatterns = sortPatterns$1(patterns);
          const nuText = text2.replace(nbsp, " ");
          return find$2(sortedPatterns, (pattern) => text2.indexOf(pattern.start) === 0 || nuText.indexOf(pattern.start) === 0);
        };
        const findPatterns$1 = (editor, block, patternSet, normalizedMatches) => {
          var _a;
          const dom2 = editor.dom;
          const forcedRootBlock = getForcedRootBlock(editor);
          if (!dom2.is(block, forcedRootBlock)) {
            return [];
          }
          const blockText = (_a = block.textContent) !== null && _a !== void 0 ? _a : "";
          return findPattern$1(patternSet.blockPatterns, blockText).map((pattern) => {
            if (Tools.trim(blockText).length === pattern.start.length) {
              return [];
            }
            return [{
              pattern,
              range: generatePathRange(dom2, dom2.getRoot(), block, 0, block, 0, normalizedMatches)
            }];
          }).getOr([]);
        };
        const applyMatches$1 = (editor, matches) => {
          if (matches.length === 0) {
            return;
          }
          const bookmark = editor.selection.getBookmark();
          each$e(matches, (match2) => applyPattern$1(editor, match2));
          editor.selection.moveToBookmark(bookmark);
        };
        const newMarker = (dom2, id) => dom2.create("span", {
          "data-mce-type": "bookmark",
          id
        });
        const rangeFromMarker = (dom2, marker) => {
          const rng = dom2.createRng();
          rng.setStartAfter(marker.start);
          rng.setEndBefore(marker.end);
          return rng;
        };
        const createMarker = (dom2, markerPrefix, pathRange) => {
          const rng = resolvePathRange(dom2.getRoot(), pathRange).getOrDie("Unable to resolve path range");
          const startNode = rng.startContainer;
          const endNode = rng.endContainer;
          const textEnd = rng.endOffset === 0 ? endNode : endNode.splitText(rng.endOffset);
          const textStart = rng.startOffset === 0 ? startNode : startNode.splitText(rng.startOffset);
          const startParentNode = textStart.parentNode;
          const endParentNode = textEnd.parentNode;
          return {
            prefix: markerPrefix,
            end: endParentNode.insertBefore(newMarker(dom2, markerPrefix + "-end"), textEnd),
            start: startParentNode.insertBefore(newMarker(dom2, markerPrefix + "-start"), textStart)
          };
        };
        const removeMarker = (dom2, marker, isRoot2) => {
          cleanEmptyNodes(dom2, dom2.get(marker.prefix + "-end"), isRoot2);
          cleanEmptyNodes(dom2, dom2.get(marker.prefix + "-start"), isRoot2);
        };
        const isReplacementPattern = (pattern) => pattern.start.length === 0;
        const matchesPattern = (patternContent) => (element, offset2) => {
          const text2 = element.data;
          const searchText = text2.substring(0, offset2);
          const startEndIndex = searchText.lastIndexOf(patternContent.charAt(patternContent.length - 1));
          const startIndex = searchText.lastIndexOf(patternContent);
          if (startIndex !== -1) {
            return startIndex + patternContent.length;
          } else if (startEndIndex !== -1) {
            return startEndIndex + 1;
          } else {
            return -1;
          }
        };
        const findPatternStartFromSpot = (dom2, pattern, block, spot) => {
          const startPattern = pattern.start;
          const startSpot = repeatLeft(dom2, spot.container, spot.offset, matchesPattern(startPattern), block);
          return startSpot.bind((spot2) => {
            var _a, _b;
            const startPatternIndex = (_b = (_a = block.textContent) === null || _a === void 0 ? void 0 : _a.indexOf(startPattern)) !== null && _b !== void 0 ? _b : -1;
            const isCompleteMatch = startPatternIndex !== -1 && spot2.offset >= startPatternIndex + startPattern.length;
            if (isCompleteMatch) {
              const rng = dom2.createRng();
              rng.setStart(spot2.container, spot2.offset - startPattern.length);
              rng.setEnd(spot2.container, spot2.offset);
              return Optional.some(rng);
            } else {
              const offset2 = spot2.offset - startPattern.length;
              return scanLeft(spot2.container, offset2, block).map((nextSpot) => {
                const rng = dom2.createRng();
                rng.setStart(nextSpot.container, nextSpot.offset);
                rng.setEnd(spot2.container, spot2.offset);
                return rng;
              }).filter((rng) => rng.toString() === startPattern).orThunk(() => findPatternStartFromSpot(dom2, pattern, block, point(spot2.container, 0)));
            }
          });
        };
        const findPatternStart = (dom2, pattern, node, offset2, block, requireGap = false) => {
          if (pattern.start.length === 0 && !requireGap) {
            const rng = dom2.createRng();
            rng.setStart(node, offset2);
            rng.setEnd(node, offset2);
            return Optional.some(rng);
          }
          return textBefore(node, offset2, block).bind((spot) => {
            const start4 = findPatternStartFromSpot(dom2, pattern, block, spot);
            return start4.bind((startRange) => {
              var _a;
              if (requireGap) {
                if (startRange.endContainer === spot.container && startRange.endOffset === spot.offset) {
                  return Optional.none();
                } else if (spot.offset === 0 && ((_a = startRange.endContainer.textContent) === null || _a === void 0 ? void 0 : _a.length) === startRange.endOffset) {
                  return Optional.none();
                }
              }
              return Optional.some(startRange);
            });
          });
        };
        const findPattern = (editor, block, details, normalizedMatches) => {
          const dom2 = editor.dom;
          const root = dom2.getRoot();
          const pattern = details.pattern;
          const endNode = details.position.container;
          const endOffset = details.position.offset;
          return scanLeft(endNode, endOffset - details.pattern.end.length, block).bind((spot) => {
            const endPathRng = generatePathRange(dom2, root, spot.container, spot.offset, endNode, endOffset, normalizedMatches);
            if (isReplacementPattern(pattern)) {
              return Optional.some({
                matches: [{
                  pattern,
                  startRng: endPathRng,
                  endRng: endPathRng
                }],
                position: spot
              });
            } else {
              const resultsOpt = findPatternsRec(editor, details.remainingPatterns, spot.container, spot.offset, block, normalizedMatches);
              const results = resultsOpt.getOr({
                matches: [],
                position: spot
              });
              const pos = results.position;
              const start4 = findPatternStart(dom2, pattern, pos.container, pos.offset, block, resultsOpt.isNone());
              return start4.map((startRng) => {
                const startPathRng = generatePathRangeFromRange(dom2, root, startRng, normalizedMatches);
                return {
                  matches: results.matches.concat([{
                    pattern,
                    startRng: startPathRng,
                    endRng: endPathRng
                  }]),
                  position: point(startRng.startContainer, startRng.startOffset)
                };
              });
            }
          });
        };
        const findPatternsRec = (editor, patterns, node, offset2, block, normalizedMatches) => {
          const dom2 = editor.dom;
          return textBefore(node, offset2, dom2.getRoot()).bind((endSpot) => {
            const text2 = getBeforeText(dom2, block, node, offset2);
            for (let i2 = 0; i2 < patterns.length; i2++) {
              const pattern = patterns[i2];
              if (!endsWith(text2, pattern.end)) {
                continue;
              }
              const patternsWithoutCurrent = patterns.slice();
              patternsWithoutCurrent.splice(i2, 1);
              const result = findPattern(editor, block, {
                pattern,
                remainingPatterns: patternsWithoutCurrent,
                position: endSpot
              }, normalizedMatches);
              if (result.isNone() && offset2 > 0) {
                return findPatternsRec(editor, patterns, node, offset2 - 1, block, normalizedMatches);
              }
              if (result.isSome()) {
                return result;
              }
            }
            return Optional.none();
          });
        };
        const applyPattern = (editor, pattern, patternRange) => {
          editor.selection.setRng(patternRange);
          if (pattern.type === "inline-format") {
            each$e(pattern.format, (format) => {
              editor.formatter.apply(format);
            });
          } else {
            editor.execCommand(pattern.cmd, false, pattern.value);
          }
        };
        const applyReplacementPattern = (editor, pattern, marker, isRoot2) => {
          const markerRange = rangeFromMarker(editor.dom, marker);
          deleteRng(editor.dom, markerRange, isRoot2);
          applyPattern(editor, pattern, markerRange);
        };
        const applyPatternWithContent = (editor, pattern, startMarker, endMarker, isRoot2) => {
          const dom2 = editor.dom;
          const markerEndRange = rangeFromMarker(dom2, endMarker);
          const markerStartRange = rangeFromMarker(dom2, startMarker);
          deleteRng(dom2, markerStartRange, isRoot2);
          deleteRng(dom2, markerEndRange, isRoot2);
          const patternMarker = {
            prefix: startMarker.prefix,
            start: startMarker.end,
            end: endMarker.start
          };
          const patternRange = rangeFromMarker(dom2, patternMarker);
          applyPattern(editor, pattern, patternRange);
        };
        const addMarkers = (dom2, matches) => {
          const markerPrefix = generate$1("mce_textpattern");
          const matchesWithEnds = foldr(matches, (acc, match2) => {
            const endMarker = createMarker(dom2, markerPrefix + `_end${acc.length}`, match2.endRng);
            return acc.concat([{
              ...match2,
              endMarker
            }]);
          }, []);
          return foldr(matchesWithEnds, (acc, match2) => {
            const idx = matchesWithEnds.length - acc.length - 1;
            const startMarker = isReplacementPattern(match2.pattern) ? match2.endMarker : createMarker(dom2, markerPrefix + `_start${idx}`, match2.startRng);
            return acc.concat([{
              ...match2,
              startMarker
            }]);
          }, []);
        };
        const sortPatterns = (patterns) => sort(patterns, (a2, b2) => b2.end.length - a2.end.length);
        const getBestMatches = (matches, matchesWithSortedPatterns) => {
          const hasSameMatches = forall(matches, (match2) => exists(matchesWithSortedPatterns, (sortedMatch) => match2.pattern.start === sortedMatch.pattern.start && match2.pattern.end === sortedMatch.pattern.end));
          if (matches.length === matchesWithSortedPatterns.length) {
            if (hasSameMatches) {
              return matches;
            } else {
              return matchesWithSortedPatterns;
            }
          }
          return matches.length > matchesWithSortedPatterns.length ? matches : matchesWithSortedPatterns;
        };
        const findPatterns = (editor, block, node, offset2, patternSet, normalizedMatches) => {
          const matches = findPatternsRec(editor, patternSet.inlinePatterns, node, offset2, block, normalizedMatches).fold(() => [], (result) => result.matches);
          const matchesWithSortedPatterns = findPatternsRec(editor, sortPatterns(patternSet.inlinePatterns), node, offset2, block, normalizedMatches).fold(() => [], (result) => result.matches);
          return getBestMatches(matches, matchesWithSortedPatterns);
        };
        const applyMatches = (editor, matches) => {
          if (matches.length === 0) {
            return;
          }
          const dom2 = editor.dom;
          const bookmark = editor.selection.getBookmark();
          const matchesWithMarkers = addMarkers(dom2, matches);
          each$e(matchesWithMarkers, (match2) => {
            const block = dom2.getParent(match2.startMarker.start, dom2.isBlock);
            const isRoot2 = (node) => node === block;
            if (isReplacementPattern(match2.pattern)) {
              applyReplacementPattern(editor, match2.pattern, match2.endMarker, isRoot2);
            } else {
              applyPatternWithContent(editor, match2.pattern, match2.startMarker, match2.endMarker, isRoot2);
            }
            removeMarker(dom2, match2.endMarker, isRoot2);
            removeMarker(dom2, match2.startMarker, isRoot2);
          });
          editor.selection.moveToBookmark(bookmark);
        };
        const handleEnter = (editor, patternSet) => {
          const rng = editor.selection.getRng();
          return getParentBlock(editor, rng).map((block) => {
            var _a;
            const offset2 = Math.max(0, rng.startOffset);
            const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, (_a = block.textContent) !== null && _a !== void 0 ? _a : "");
            const inlineMatches = findPatterns(editor, block, rng.startContainer, offset2, dynamicPatternSet, true);
            const blockMatches = findPatterns$1(editor, block, dynamicPatternSet, true);
            if (blockMatches.length > 0 || inlineMatches.length > 0) {
              editor.undoManager.add();
              editor.undoManager.extra(() => {
                editor.execCommand("mceInsertNewLine");
              }, () => {
                editor.insertContent(zeroWidth);
                applyMatches(editor, inlineMatches);
                applyMatches$1(editor, blockMatches);
                const range2 = editor.selection.getRng();
                const spot = textBefore(range2.startContainer, range2.startOffset, editor.dom.getRoot());
                editor.execCommand("mceInsertNewLine");
                spot.each((s2) => {
                  const node = s2.container;
                  if (node.data.charAt(s2.offset - 1) === zeroWidth) {
                    node.deleteData(s2.offset - 1, 1);
                    cleanEmptyNodes(editor.dom, node.parentNode, (e2) => e2 === editor.dom.getRoot());
                  }
                });
              });
              return true;
            }
            return false;
          }).getOr(false);
        };
        const handleInlineKey = (editor, patternSet) => {
          const rng = editor.selection.getRng();
          getParentBlock(editor, rng).map((block) => {
            const offset2 = Math.max(0, rng.startOffset - 1);
            const beforeText = getBeforeText(editor.dom, block, rng.startContainer, offset2);
            const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, beforeText);
            const inlineMatches = findPatterns(editor, block, rng.startContainer, offset2, dynamicPatternSet, false);
            if (inlineMatches.length > 0) {
              editor.undoManager.transact(() => {
                applyMatches(editor, inlineMatches);
              });
            }
          });
        };
        const checkKeyEvent = (codes, event, predicate) => {
          for (let i2 = 0; i2 < codes.length; i2++) {
            if (predicate(codes[i2], event)) {
              return true;
            }
          }
          return false;
        };
        const checkKeyCode = (codes, event) => checkKeyEvent(codes, event, (code, event2) => {
          return code === event2.keyCode && !VK.modifierPressed(event2);
        });
        const checkCharCode = (chars, event) => checkKeyEvent(chars, event, (chr, event2) => {
          return chr.charCodeAt(0) === event2.charCode;
        });
        const setup$2 = (editor) => {
          const charCodes = [
            ",",
            ".",
            ";",
            ":",
            "!",
            "?"
          ];
          const keyCodes = [32];
          const getPatternSet = () => createPatternSet(getTextPatterns(editor), getTextPatternsLookup(editor));
          const hasDynamicPatterns = () => hasTextPatternsLookup(editor);
          editor.on("keydown", (e2) => {
            if (e2.keyCode === 13 && !VK.modifierPressed(e2) && editor.selection.isCollapsed()) {
              const patternSet = getPatternSet();
              const hasPatterns = patternSet.inlinePatterns.length > 0 || patternSet.blockPatterns.length > 0 || hasDynamicPatterns();
              if (hasPatterns && handleEnter(editor, patternSet)) {
                e2.preventDefault();
              }
            }
          }, true);
          const handleInlineTrigger = () => {
            if (editor.selection.isCollapsed()) {
              const patternSet = getPatternSet();
              const hasPatterns = patternSet.inlinePatterns.length > 0 || hasDynamicPatterns();
              if (hasPatterns) {
                handleInlineKey(editor, patternSet);
              }
            }
          };
          editor.on("keyup", (e2) => {
            if (checkKeyCode(keyCodes, e2)) {
              handleInlineTrigger();
            }
          });
          editor.on("keypress", (e2) => {
            if (checkCharCode(charCodes, e2)) {
              Delay.setEditorTimeout(editor, handleInlineTrigger);
            }
          });
        };
        const setup$1 = (editor) => {
          setup$2(editor);
        };
        const Quirks = (editor) => {
          const each2 = Tools.each;
          const BACKSPACE = VK.BACKSPACE, DELETE2 = VK.DELETE, dom2 = editor.dom, selection = editor.selection, parser = editor.parser;
          const browser2 = Env.browser;
          const isGecko = browser2.isFirefox();
          const isWebKit = browser2.isChromium() || browser2.isSafari();
          const isiOS = Env.deviceType.isiPhone() || Env.deviceType.isiPad();
          const isMac = Env.os.isMacOS() || Env.os.isiOS();
          const setEditorCommandState2 = (cmd, state) => {
            try {
              editor.getDoc().execCommand(cmd, false, String(state));
            } catch (ex) {
            }
          };
          const isDefaultPrevented = (e2) => {
            return e2.isDefaultPrevented();
          };
          const emptyEditorWhenDeleting = () => {
            const serializeRng = (rng) => {
              const body = dom2.create("body");
              const contents = rng.cloneContents();
              body.appendChild(contents);
              return selection.serializer.serialize(body, { format: "html" });
            };
            const allContentsSelected = (rng) => {
              const selection2 = serializeRng(rng);
              const allRng = dom2.createRng();
              allRng.selectNode(editor.getBody());
              const allSelection = serializeRng(allRng);
              return selection2 === allSelection;
            };
            editor.on("keydown", (e2) => {
              const keyCode = e2.keyCode;
              if (!isDefaultPrevented(e2) && (keyCode === DELETE2 || keyCode === BACKSPACE) && editor.selection.isEditable()) {
                const isCollapsed = editor.selection.isCollapsed();
                const body = editor.getBody();
                if (isCollapsed && !dom2.isEmpty(body)) {
                  return;
                }
                if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {
                  return;
                }
                e2.preventDefault();
                editor.setContent("");
                if (body.firstChild && dom2.isBlock(body.firstChild)) {
                  editor.selection.setCursorLocation(body.firstChild, 0);
                } else {
                  editor.selection.setCursorLocation(body, 0);
                }
                editor.nodeChanged();
              }
            });
          };
          const selectAll = () => {
            editor.shortcuts.add("meta+a", null, "SelectAll");
          };
          const documentElementEditingFocus = () => {
            if (!editor.inline) {
              dom2.bind(editor.getDoc(), "mousedown mouseup", (e2) => {
                let rng;
                if (e2.target === editor.getDoc().documentElement) {
                  rng = selection.getRng();
                  editor.getBody().focus();
                  if (e2.type === "mousedown") {
                    if (isCaretContainer$2(rng.startContainer)) {
                      return;
                    }
                    selection.placeCaretAt(e2.clientX, e2.clientY);
                  } else {
                    selection.setRng(rng);
                  }
                }
              });
            }
          };
          const removeHrOnBackspace = () => {
            editor.on("keydown", (e2) => {
              if (!isDefaultPrevented(e2) && e2.keyCode === BACKSPACE) {
                if (!editor.getBody().getElementsByTagName("hr").length) {
                  return;
                }
                if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
                  const node = selection.getNode();
                  const previousSibling = node.previousSibling;
                  if (node.nodeName === "HR") {
                    dom2.remove(node);
                    e2.preventDefault();
                    return;
                  }
                  if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "hr") {
                    dom2.remove(previousSibling);
                    e2.preventDefault();
                  }
                }
              }
            });
          };
          const focusBody2 = () => {
            if (!Range.prototype.getClientRects) {
              editor.on("mousedown", (e2) => {
                if (!isDefaultPrevented(e2) && e2.target.nodeName === "HTML") {
                  const body = editor.getBody();
                  body.blur();
                  Delay.setEditorTimeout(editor, () => {
                    body.focus();
                  });
                }
              });
            }
          };
          const selectControlElements = () => {
            const visualAidsAnchorClass = getVisualAidsAnchorClass(editor);
            editor.on("click", (e2) => {
              const target = e2.target;
              if (/^(IMG|HR)$/.test(target.nodeName) && dom2.isEditable(target.parentNode)) {
                e2.preventDefault();
                editor.selection.select(target);
                editor.nodeChanged();
              }
              if (target.nodeName === "A" && dom2.hasClass(target, visualAidsAnchorClass) && target.childNodes.length === 0 && dom2.isEditable(target.parentNode)) {
                e2.preventDefault();
                selection.select(target);
              }
            });
          };
          const removeStylesWhenDeletingAcrossBlockElements = () => {
            const getAttributeApplyFunction = () => {
              const template = dom2.getAttribs(selection.getStart().cloneNode(false));
              return () => {
                const target = selection.getStart();
                if (target !== editor.getBody()) {
                  dom2.setAttrib(target, "style", null);
                  each2(template, (attr) => {
                    target.setAttributeNode(attr.cloneNode(true));
                  });
                }
              };
            };
            const isSelectionAcrossElements = () => {
              return !selection.isCollapsed() && dom2.getParent(selection.getStart(), dom2.isBlock) !== dom2.getParent(selection.getEnd(), dom2.isBlock);
            };
            editor.on("keypress", (e2) => {
              let applyAttributes2;
              if (!isDefaultPrevented(e2) && (e2.keyCode === 8 || e2.keyCode === 46) && isSelectionAcrossElements()) {
                applyAttributes2 = getAttributeApplyFunction();
                editor.getDoc().execCommand("delete", false);
                applyAttributes2();
                e2.preventDefault();
                return false;
              } else {
                return true;
              }
            });
            dom2.bind(editor.getDoc(), "cut", (e2) => {
              if (!isDefaultPrevented(e2) && isSelectionAcrossElements()) {
                const applyAttributes2 = getAttributeApplyFunction();
                Delay.setEditorTimeout(editor, () => {
                  applyAttributes2();
                });
              }
            });
          };
          const disableBackspaceIntoATable = () => {
            editor.on("keydown", (e2) => {
              if (!isDefaultPrevented(e2) && e2.keyCode === BACKSPACE) {
                if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
                  const previousSibling = selection.getNode().previousSibling;
                  if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "table") {
                    e2.preventDefault();
                    return false;
                  }
                }
              }
              return true;
            });
          };
          const removeBlockQuoteOnBackSpace = () => {
            editor.on("keydown", (e2) => {
              if (isDefaultPrevented(e2) || e2.keyCode !== VK.BACKSPACE) {
                return;
              }
              let rng = selection.getRng();
              const container = rng.startContainer;
              const offset2 = rng.startOffset;
              const root = dom2.getRoot();
              let parent2 = container;
              if (!rng.collapsed || offset2 !== 0) {
                return;
              }
              while (parent2.parentNode && parent2.parentNode.firstChild === parent2 && parent2.parentNode !== root) {
                parent2 = parent2.parentNode;
              }
              if (parent2.nodeName === "BLOCKQUOTE") {
                editor.formatter.toggle("blockquote", void 0, parent2);
                rng = dom2.createRng();
                rng.setStart(container, 0);
                rng.setEnd(container, 0);
                selection.setRng(rng);
              }
            });
          };
          const setGeckoEditingOptions = () => {
            const setOpts = () => {
              setEditorCommandState2("StyleWithCSS", false);
              setEditorCommandState2("enableInlineTableEditing", false);
              if (!getObjectResizing(editor)) {
                setEditorCommandState2("enableObjectResizing", false);
              }
            };
            if (!isReadOnly$1(editor)) {
              editor.on("BeforeExecCommand mousedown", setOpts);
            }
          };
          const addBrAfterLastLinks = () => {
            const fixLinks = () => {
              each2(dom2.select("a:not([data-mce-block])"), (node) => {
                var _a;
                let parentNode = node.parentNode;
                const root = dom2.getRoot();
                if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.lastChild) === node) {
                  while (parentNode && !dom2.isBlock(parentNode)) {
                    if (((_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.lastChild) !== parentNode || parentNode === root) {
                      return;
                    }
                    parentNode = parentNode.parentNode;
                  }
                  dom2.add(parentNode, "br", { "data-mce-bogus": 1 });
                }
              });
            };
            editor.on("SetContent ExecCommand", (e2) => {
              if (e2.type === "setcontent" || e2.command === "mceInsertLink") {
                fixLinks();
              }
            });
          };
          const setDefaultBlockType = () => {
            editor.on("init", () => {
              setEditorCommandState2("DefaultParagraphSeparator", getForcedRootBlock(editor));
            });
          };
          const isAllContentSelected = (editor2) => {
            const body = editor2.getBody();
            const rng = editor2.selection.getRng();
            return rng.startContainer === rng.endContainer && rng.startContainer === body && rng.startOffset === 0 && rng.endOffset === body.childNodes.length;
          };
          const normalizeSelection2 = () => {
            editor.on("keyup focusin mouseup", (e2) => {
              if (!VK.modifierPressed(e2) && !isAllContentSelected(editor)) {
                selection.normalize();
              }
            }, true);
          };
          const showBrokenImageIcon = () => {
            editor.contentStyles.push("img:-moz-broken {-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}");
          };
          const restoreFocusOnKeyDown = () => {
            if (!editor.inline) {
              editor.on("keydown", () => {
                if (document.activeElement === document.body) {
                  editor.getWin().focus();
                }
              });
            }
          };
          const bodyHeight = () => {
            if (!editor.inline) {
              editor.contentStyles.push("body {min-height: 150px}");
              editor.on("click", (e2) => {
                let rng;
                if (e2.target.nodeName === "HTML") {
                  rng = editor.selection.getRng();
                  editor.getBody().focus();
                  editor.selection.setRng(rng);
                  editor.selection.normalize();
                  editor.nodeChanged();
                }
              });
            }
          };
          const blockCmdArrowNavigation = () => {
            if (isMac) {
              editor.on("keydown", (e2) => {
                if (VK.metaKeyPressed(e2) && !e2.shiftKey && (e2.keyCode === 37 || e2.keyCode === 39)) {
                  e2.preventDefault();
                  const selection2 = editor.selection.getSel();
                  selection2.modify("move", e2.keyCode === 37 ? "backward" : "forward", "lineboundary");
                }
              });
            }
          };
          const tapLinksAndImages = () => {
            editor.on("click", (e2) => {
              let elm = e2.target;
              do {
                if (elm.tagName === "A") {
                  e2.preventDefault();
                  return;
                }
              } while (elm = elm.parentNode);
            });
            editor.contentStyles.push(".mce-content-body {-webkit-touch-callout: none}");
          };
          const blockFormSubmitInsideEditor = () => {
            editor.on("init", () => {
              editor.dom.bind(editor.getBody(), "submit", (e2) => {
                e2.preventDefault();
              });
            });
          };
          const removeAppleInterchangeBrs = () => {
            parser.addNodeFilter("br", (nodes) => {
              let i2 = nodes.length;
              while (i2--) {
                if (nodes[i2].attr("class") === "Apple-interchange-newline") {
                  nodes[i2].remove();
                }
              }
            });
          };
          const refreshContentEditable = noop2;
          const isHidden = () => {
            if (!isGecko || editor.removed) {
              return false;
            }
            const sel = editor.selection.getSel();
            return !sel || !sel.rangeCount || sel.rangeCount === 0;
          };
          const setupRtc = () => {
            if (isWebKit) {
              documentElementEditingFocus();
              selectControlElements();
              blockFormSubmitInsideEditor();
              selectAll();
              if (isiOS) {
                restoreFocusOnKeyDown();
                bodyHeight();
                tapLinksAndImages();
              }
            }
            if (isGecko) {
              focusBody2();
              setGeckoEditingOptions();
              showBrokenImageIcon();
              blockCmdArrowNavigation();
            }
          };
          const dropDragEndEvent = () => {
            editor.on("drop", (event) => {
              var _a;
              const data2 = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.getData("text/html");
              if (isString(data2) && /^<img[^>]*>$/.test(data2)) {
                editor.dispatch("dragend", new window.DragEvent("dragend", event));
              }
            });
          };
          const setup2 = () => {
            removeBlockQuoteOnBackSpace();
            emptyEditorWhenDeleting();
            if (!Env.windowsPhone) {
              normalizeSelection2();
            }
            if (isWebKit) {
              documentElementEditingFocus();
              selectControlElements();
              setDefaultBlockType();
              blockFormSubmitInsideEditor();
              disableBackspaceIntoATable();
              removeAppleInterchangeBrs();
              if (isiOS) {
                restoreFocusOnKeyDown();
                bodyHeight();
                tapLinksAndImages();
              } else {
                selectAll();
              }
            }
            if (isGecko) {
              removeHrOnBackspace();
              focusBody2();
              removeStylesWhenDeletingAcrossBlockElements();
              setGeckoEditingOptions();
              addBrAfterLastLinks();
              showBrokenImageIcon();
              blockCmdArrowNavigation();
              disableBackspaceIntoATable();
              dropDragEndEvent();
            }
          };
          if (isRtc(editor)) {
            setupRtc();
          } else {
            setup2();
          }
          return {
            refreshContentEditable,
            isHidden
          };
        };
        const DOM$6 = DOMUtils.DOM;
        const appendStyle = (editor, text2) => {
          const body = SugarElement.fromDom(editor.getBody());
          const container = getStyleContainer(getRootNode(body));
          const style = SugarElement.fromTag("style");
          set$3(style, "type", "text/css");
          append$1(style, SugarElement.fromText(text2));
          append$1(container, style);
          editor.on("remove", () => {
            remove$5(style);
          });
        };
        const getRootName = (editor) => editor.inline ? editor.getElement().nodeName.toLowerCase() : void 0;
        const removeUndefined = (obj) => filter$4(obj, (v2) => isUndefined(v2) === false);
        const mkParserSettings = (editor) => {
          const getOption2 = editor.options.get;
          const blobCache = editor.editorUpload.blobCache;
          return removeUndefined({
            allow_conditional_comments: getOption2("allow_conditional_comments"),
            allow_html_data_urls: getOption2("allow_html_data_urls"),
            allow_svg_data_urls: getOption2("allow_svg_data_urls"),
            allow_html_in_named_anchor: getOption2("allow_html_in_named_anchor"),
            allow_script_urls: getOption2("allow_script_urls"),
            allow_unsafe_link_target: getOption2("allow_unsafe_link_target"),
            convert_fonts_to_spans: getOption2("convert_fonts_to_spans"),
            fix_list_elements: getOption2("fix_list_elements"),
            font_size_legacy_values: getOption2("font_size_legacy_values"),
            forced_root_block: getOption2("forced_root_block"),
            forced_root_block_attrs: getOption2("forced_root_block_attrs"),
            preserve_cdata: getOption2("preserve_cdata"),
            inline_styles: getOption2("inline_styles"),
            root_name: getRootName(editor),
            sanitize: getOption2("xss_sanitization"),
            validate: true,
            blob_cache: blobCache,
            document: editor.getDoc()
          });
        };
        const mkSchemaSettings = (editor) => {
          const getOption2 = editor.options.get;
          return removeUndefined({
            custom_elements: getOption2("custom_elements"),
            extended_valid_elements: getOption2("extended_valid_elements"),
            invalid_elements: getOption2("invalid_elements"),
            invalid_styles: getOption2("invalid_styles"),
            schema: getOption2("schema"),
            valid_children: getOption2("valid_children"),
            valid_classes: getOption2("valid_classes"),
            valid_elements: getOption2("valid_elements"),
            valid_styles: getOption2("valid_styles"),
            verify_html: getOption2("verify_html"),
            padd_empty_block_inline_children: getOption2("format_empty_lines")
          });
        };
        const mkSerializerSettings = (editor) => {
          const getOption2 = editor.options.get;
          return {
            ...mkParserSettings(editor),
            ...mkSchemaSettings(editor),
            ...removeUndefined({
              remove_trailing_brs: getOption2("remove_trailing_brs"),
              url_converter: getOption2("url_converter"),
              url_converter_scope: getOption2("url_converter_scope"),
              element_format: getOption2("element_format"),
              entities: getOption2("entities"),
              entity_encoding: getOption2("entity_encoding"),
              indent: getOption2("indent"),
              indent_after: getOption2("indent_after"),
              indent_before: getOption2("indent_before")
            })
          };
        };
        const createParser = (editor) => {
          const parser = DomParser(mkParserSettings(editor), editor.schema);
          parser.addAttributeFilter("src,href,style,tabindex", (nodes, name2) => {
            const dom2 = editor.dom;
            const internalName = "data-mce-" + name2;
            let i2 = nodes.length;
            while (i2--) {
              const node = nodes[i2];
              let value2 = node.attr(name2);
              if (value2 && !node.attr(internalName)) {
                if (value2.indexOf("data:") === 0 || value2.indexOf("blob:") === 0) {
                  continue;
                }
                if (name2 === "style") {
                  value2 = dom2.serializeStyle(dom2.parseStyle(value2), node.name);
                  if (!value2.length) {
                    value2 = null;
                  }
                  node.attr(internalName, value2);
                  node.attr(name2, value2);
                } else if (name2 === "tabindex") {
                  node.attr(internalName, value2);
                  node.attr(name2, null);
                } else {
                  node.attr(internalName, editor.convertURL(value2, name2, node.name));
                }
              }
            }
          });
          parser.addNodeFilter("script", (nodes) => {
            let i2 = nodes.length;
            while (i2--) {
              const node = nodes[i2];
              const type2 = node.attr("type") || "no/type";
              if (type2.indexOf("mce-") !== 0) {
                node.attr("type", "mce-" + type2);
              }
            }
          });
          if (shouldPreserveCData(editor)) {
            parser.addNodeFilter("#cdata", (nodes) => {
              var _a;
              let i2 = nodes.length;
              while (i2--) {
                const node = nodes[i2];
                node.type = 8;
                node.name = "#comment";
                node.value = "[CDATA[" + editor.dom.encode((_a = node.value) !== null && _a !== void 0 ? _a : "") + "]]";
              }
            });
          }
          parser.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", (nodes) => {
            let i2 = nodes.length;
            const nonEmptyElements = editor.schema.getNonEmptyElements();
            while (i2--) {
              const node = nodes[i2];
              if (node.isEmpty(nonEmptyElements) && node.getAll("br").length === 0) {
                node.append(new AstNode("br", 1));
              }
            }
          });
          return parser;
        };
        const autoFocus = (editor) => {
          const autoFocus2 = getAutoFocus(editor);
          if (autoFocus2) {
            Delay.setEditorTimeout(editor, () => {
              let focusEditor2;
              if (autoFocus2 === true) {
                focusEditor2 = editor;
              } else {
                focusEditor2 = editor.editorManager.get(autoFocus2);
              }
              if (focusEditor2 && !focusEditor2.destroyed) {
                focusEditor2.focus();
                focusEditor2.selection.scrollIntoView();
              }
            }, 100);
          }
        };
        const moveSelectionToFirstCaretPosition = (editor) => {
          const root = editor.dom.getRoot();
          if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) {
            firstPositionIn(root).each((pos) => {
              const node = pos.getNode();
              const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;
              editor.selection.setRng(caretPos.toRange());
            });
          }
        };
        const initEditor = (editor) => {
          editor.bindPendingEventDelegates();
          editor.initialized = true;
          fireInit(editor);
          editor.focus(true);
          moveSelectionToFirstCaretPosition(editor);
          editor.nodeChanged({ initial: true });
          const initInstanceCallback = getInitInstanceCallback(editor);
          if (isFunction(initInstanceCallback)) {
            initInstanceCallback.call(editor, editor);
          }
          autoFocus(editor);
        };
        const getStyleSheetLoader$1 = (editor) => editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;
        const makeStylesheetLoadingPromises = (editor, css, framedFonts) => {
          const promises = [getStyleSheetLoader$1(editor).loadAll(css)];
          if (editor.inline) {
            return promises;
          } else {
            return promises.concat([editor.ui.styleSheetLoader.loadAll(framedFonts)]);
          }
        };
        const loadContentCss = (editor) => {
          const styleSheetLoader = getStyleSheetLoader$1(editor);
          const fontCss = getFontCss(editor);
          const css = editor.contentCSS;
          const removeCss = () => {
            styleSheetLoader.unloadAll(css);
            if (!editor.inline) {
              editor.ui.styleSheetLoader.unloadAll(fontCss);
            }
          };
          const loaded = () => {
            if (editor.removed) {
              removeCss();
            } else {
              editor.on("remove", removeCss);
            }
          };
          if (editor.contentStyles.length > 0) {
            let contentCssText = "";
            Tools.each(editor.contentStyles, (style) => {
              contentCssText += style + "\r\n";
            });
            editor.dom.addStyle(contentCssText);
          }
          const allStylesheets = Promise.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);
          const contentStyle = getContentStyle(editor);
          if (contentStyle) {
            appendStyle(editor, contentStyle);
          }
          return allStylesheets;
        };
        const preInit = (editor) => {
          const doc = editor.getDoc(), body = editor.getBody();
          firePreInit(editor);
          if (!shouldBrowserSpellcheck(editor)) {
            doc.body.spellcheck = false;
            DOM$6.setAttrib(body, "spellcheck", "false");
          }
          editor.quirks = Quirks(editor);
          firePostRender(editor);
          const directionality = getDirectionality(editor);
          if (directionality !== void 0) {
            body.dir = directionality;
          }
          const protect = getProtect(editor);
          if (protect) {
            editor.on("BeforeSetContent", (e2) => {
              Tools.each(protect, (pattern) => {
                e2.content = e2.content.replace(pattern, (str) => {
                  return "<!--mce:protected " + escape(str) + "-->";
                });
              });
            });
          }
          editor.on("SetContent", () => {
            editor.addVisual(editor.getBody());
          });
          editor.on("compositionstart compositionend", (e2) => {
            editor.composing = e2.type === "compositionstart";
          });
        };
        const loadInitialContent = (editor) => {
          if (!isRtc(editor)) {
            editor.load({
              initial: true,
              format: "html"
            });
          }
          editor.startContent = editor.getContent({ format: "raw" });
        };
        const initEditorWithInitialContent = (editor) => {
          if (editor.removed !== true) {
            loadInitialContent(editor);
            initEditor(editor);
          }
        };
        const contentBodyLoaded = (editor) => {
          const targetElm = editor.getElement();
          let doc = editor.getDoc();
          if (editor.inline) {
            DOM$6.addClass(targetElm, "mce-content-body");
            editor.contentDocument = doc = document;
            editor.contentWindow = window;
            editor.bodyElement = targetElm;
            editor.contentAreaContainer = targetElm;
          }
          const body = editor.getBody();
          body.disabled = true;
          editor.readonly = isReadOnly$1(editor);
          editor._editableRoot = hasEditableRoot$1(editor);
          if (!editor.readonly && editor.hasEditableRoot()) {
            if (editor.inline && DOM$6.getStyle(body, "position", true) === "static") {
              body.style.position = "relative";
            }
            body.contentEditable = "true";
          }
          body.disabled = false;
          editor.editorUpload = EditorUpload(editor);
          editor.schema = Schema(mkSchemaSettings(editor));
          editor.dom = DOMUtils(doc, {
            keep_values: true,
            url_converter: editor.convertURL,
            url_converter_scope: editor,
            update_styles: true,
            root_element: editor.inline ? editor.getBody() : null,
            collect: editor.inline,
            schema: editor.schema,
            contentCssCors: shouldUseContentCssCors(editor),
            referrerPolicy: getReferrerPolicy(editor),
            onSetAttrib: (e2) => {
              editor.dispatch("SetAttrib", e2);
            }
          });
          editor.parser = createParser(editor);
          editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);
          editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);
          editor.annotator = Annotator(editor);
          editor.formatter = Formatter(editor);
          editor.undoManager = UndoManager(editor);
          editor._nodeChangeDispatcher = new NodeChange(editor);
          editor._selectionOverrides = SelectionOverrides(editor);
          setup$o(editor);
          setup$6(editor);
          setup$m(editor);
          if (!isRtc(editor)) {
            setup$5(editor);
            setup$1(editor);
          }
          const caret = setup$b(editor);
          setup$p(editor, caret);
          setup$n(editor);
          setup$q(editor);
          setup$7(editor);
          const setupRtcThunk = setup$s(editor);
          preInit(editor);
          setupRtcThunk.fold(() => {
            loadContentCss(editor).then(() => initEditorWithInitialContent(editor));
          }, (setupRtc) => {
            editor.setProgressState(true);
            loadContentCss(editor).then(() => {
              setupRtc().then((_rtcMode) => {
                editor.setProgressState(false);
                initEditorWithInitialContent(editor);
                bindEvents(editor);
              }, (err) => {
                editor.notificationManager.open({
                  type: "error",
                  text: String(err)
                });
                initEditorWithInitialContent(editor);
                bindEvents(editor);
              });
            });
          });
        };
        const filter = always;
        const bind = (element, event, handler) => bind$2(element, event, filter, handler);
        const DOM$5 = DOMUtils.DOM;
        const createIframeElement = (id, title, customAttrs, tabindex) => {
          const iframe = SugarElement.fromTag("iframe");
          tabindex.each((t2) => set$3(iframe, "tabindex", t2));
          setAll$1(iframe, customAttrs);
          setAll$1(iframe, {
            id: id + "_ifr",
            frameBorder: "0",
            allowTransparency: "true",
            title
          });
          add$2(iframe, "tox-edit-area__iframe");
          return iframe;
        };
        const getIframeHtml = (editor) => {
          let iframeHTML = getDocType(editor) + "<html><head>";
          if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {
            iframeHTML += '<base href="' + editor.documentBaseURI.getURI() + '" />';
          }
          iframeHTML += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
          const bodyId = getBodyId(editor);
          const bodyClass = getBodyClass(editor);
          const translatedAriaText = editor.translate(getIframeAriaText(editor));
          if (getContentSecurityPolicy(editor)) {
            iframeHTML += '<meta http-equiv="Content-Security-Policy" content="' + getContentSecurityPolicy(editor) + '" />';
          }
          iframeHTML += `</head><body id="${bodyId}" class="mce-content-body ${bodyClass}" data-id="${editor.id}" aria-label="${translatedAriaText}"><br></body></html>`;
          return iframeHTML;
        };
        const createIframe = (editor, boxInfo) => {
          const iframeTitle = editor.translate("Rich Text Area");
          const tabindex = getOpt(SugarElement.fromDom(editor.getElement()), "tabindex").bind(toInt);
          const ifr = createIframeElement(editor.id, iframeTitle, getIframeAttrs(editor), tabindex).dom;
          ifr.onload = () => {
            ifr.onload = null;
            editor.dispatch("load");
          };
          editor.contentAreaContainer = boxInfo.iframeContainer;
          editor.iframeElement = ifr;
          editor.iframeHTML = getIframeHtml(editor);
          DOM$5.add(boxInfo.iframeContainer, ifr);
        };
        const setupIframeBody = (editor) => {
          const iframe = editor.iframeElement;
          const ready = () => {
            editor.contentDocument = iframe.contentDocument;
            contentBodyLoaded(editor);
          };
          if (shouldUseDocumentWrite(editor) || Env.browser.isFirefox()) {
            const doc = editor.getDoc();
            doc.open();
            doc.write(editor.iframeHTML);
            doc.close();
            ready();
          } else {
            const binder2 = bind(SugarElement.fromDom(iframe), "load", () => {
              binder2.unbind();
              ready();
            });
            iframe.srcdoc = editor.iframeHTML;
          }
        };
        const init$1 = (editor, boxInfo) => {
          createIframe(editor, boxInfo);
          if (boxInfo.editorContainer) {
            boxInfo.editorContainer.style.display = editor.orgDisplay;
            editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);
          }
          editor.getElement().style.display = "none";
          DOM$5.setAttrib(editor.id, "aria-hidden", "true");
          editor.getElement().style.visibility = editor.orgVisibility;
          setupIframeBody(editor);
        };
        const DOM$4 = DOMUtils.DOM;
        const initPlugin = (editor, initializedPlugins, plugin) => {
          const Plugin = PluginManager.get(plugin);
          const pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\/$/, "");
          plugin = Tools.trim(plugin);
          if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {
            if (editor.plugins[plugin]) {
              return;
            }
            try {
              const pluginInstance = Plugin(editor, pluginUrl) || {};
              editor.plugins[plugin] = pluginInstance;
              if (isFunction(pluginInstance.init)) {
                pluginInstance.init(editor, pluginUrl);
                initializedPlugins.push(plugin);
              }
            } catch (e2) {
              pluginInitError(editor, plugin, e2);
            }
          }
        };
        const trimLegacyPrefix = (name2) => {
          return name2.replace(/^\-/, "");
        };
        const initPlugins = (editor) => {
          const initializedPlugins = [];
          each$e(getPlugins(editor), (name2) => {
            initPlugin(editor, initializedPlugins, trimLegacyPrefix(name2));
          });
        };
        const initIcons = (editor) => {
          const iconPackName = Tools.trim(getIconPackName(editor));
          const currentIcons = editor.ui.registry.getAll().icons;
          const loadIcons2 = {
            ...IconManager.get("default").icons,
            ...IconManager.get(iconPackName).icons
          };
          each$d(loadIcons2, (svgData, icon) => {
            if (!has$2(currentIcons, icon)) {
              editor.ui.registry.addIcon(icon, svgData);
            }
          });
        };
        const initTheme = (editor) => {
          const theme = getTheme(editor);
          if (isString(theme)) {
            const Theme = ThemeManager.get(theme);
            editor.theme = Theme(editor, ThemeManager.urls[theme]) || {};
            if (isFunction(editor.theme.init)) {
              editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\/$/, ""));
            }
          } else {
            editor.theme = {};
          }
        };
        const initModel = (editor) => {
          const model = getModel(editor);
          const Model = ModelManager.get(model);
          editor.model = Model(editor, ModelManager.urls[model]);
        };
        const renderFromLoadedTheme = (editor) => {
          const render2 = editor.theme.renderUI;
          return render2 ? render2() : renderThemeFalse(editor);
        };
        const renderFromThemeFunc = (editor) => {
          const elm = editor.getElement();
          const theme = getTheme(editor);
          const info = theme(editor, elm);
          if (info.editorContainer.nodeType) {
            info.editorContainer.id = info.editorContainer.id || editor.id + "_parent";
          }
          if (info.iframeContainer && info.iframeContainer.nodeType) {
            info.iframeContainer.id = info.iframeContainer.id || editor.id + "_iframecontainer";
          }
          info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;
          return info;
        };
        const createThemeFalseResult = (element, iframe) => {
          return {
            editorContainer: element,
            iframeContainer: iframe,
            api: {}
          };
        };
        const renderThemeFalseIframe = (targetElement) => {
          const iframeContainer = DOM$4.create("div");
          DOM$4.insertAfter(iframeContainer, targetElement);
          return createThemeFalseResult(iframeContainer, iframeContainer);
        };
        const renderThemeFalse = (editor) => {
          const targetElement = editor.getElement();
          return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);
        };
        const renderThemeUi = (editor) => {
          const elm = editor.getElement();
          editor.orgDisplay = elm.style.display;
          if (isString(getTheme(editor))) {
            return renderFromLoadedTheme(editor);
          } else if (isFunction(getTheme(editor))) {
            return renderFromThemeFunc(editor);
          } else {
            return renderThemeFalse(editor);
          }
        };
        const augmentEditorUiApi = (editor, api2) => {
          const uiApiFacade = {
            show: Optional.from(api2.show).getOr(noop2),
            hide: Optional.from(api2.hide).getOr(noop2),
            isEnabled: Optional.from(api2.isEnabled).getOr(always),
            setEnabled: (state) => {
              if (!editor.mode.isReadOnly()) {
                Optional.from(api2.setEnabled).each((f2) => f2(state));
              }
            }
          };
          editor.ui = {
            ...editor.ui,
            ...uiApiFacade
          };
        };
        const init = async (editor) => {
          editor.dispatch("ScriptsLoaded");
          initIcons(editor);
          initTheme(editor);
          initModel(editor);
          initPlugins(editor);
          const renderInfo = await renderThemeUi(editor);
          augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));
          editor.editorContainer = renderInfo.editorContainer;
          appendContentCssFromSettings(editor);
          if (editor.inline) {
            contentBodyLoaded(editor);
          } else {
            init$1(editor, {
              editorContainer: renderInfo.editorContainer,
              iframeContainer: renderInfo.iframeContainer
            });
          }
        };
        const DOM$3 = DOMUtils.DOM;
        const hasSkipLoadPrefix = (name2) => name2.charAt(0) === "-";
        const loadLanguage = (scriptLoader, editor) => {
          const languageCode = getLanguageCode(editor);
          const languageUrl = getLanguageUrl(editor);
          if (!I18n.hasCode(languageCode) && languageCode !== "en") {
            const url = isNotEmpty(languageUrl) ? languageUrl : `${editor.editorManager.baseURL}/langs/${languageCode}.js`;
            scriptLoader.add(url).catch(() => {
              languageLoadError(editor, url, languageCode);
            });
          }
        };
        const loadTheme = (editor, suffix) => {
          const theme = getTheme(editor);
          if (isString(theme) && !hasSkipLoadPrefix(theme) && !has$2(ThemeManager.urls, theme)) {
            const themeUrl = getThemeUrl(editor);
            const url = themeUrl ? editor.documentBaseURI.toAbsolute(themeUrl) : `themes/${theme}/theme${suffix}.js`;
            ThemeManager.load(theme, url).catch(() => {
              themeLoadError(editor, url, theme);
            });
          }
        };
        const loadModel = (editor, suffix) => {
          const model = getModel(editor);
          if (model !== "plugin" && !has$2(ModelManager.urls, model)) {
            const modelUrl = getModelUrl(editor);
            const url = isString(modelUrl) ? editor.documentBaseURI.toAbsolute(modelUrl) : `models/${model}/model${suffix}.js`;
            ModelManager.load(model, url).catch(() => {
              modelLoadError(editor, url, model);
            });
          }
        };
        const getIconsUrlMetaFromUrl = (editor) => Optional.from(getIconsUrl(editor)).filter(isNotEmpty).map((url) => ({
          url,
          name: Optional.none()
        }));
        const getIconsUrlMetaFromName = (editor, name2, suffix) => Optional.from(name2).filter((name3) => isNotEmpty(name3) && !IconManager.has(name3)).map((name3) => ({
          url: `${editor.editorManager.baseURL}/icons/${name3}/icons${suffix}.js`,
          name: Optional.some(name3)
        }));
        const loadIcons = (scriptLoader, editor, suffix) => {
          const defaultIconsUrl = getIconsUrlMetaFromName(editor, "default", suffix);
          const customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(() => getIconsUrlMetaFromName(editor, getIconPackName(editor), ""));
          each$e(cat([
            defaultIconsUrl,
            customIconsUrl
          ]), (urlMeta) => {
            scriptLoader.add(urlMeta.url).catch(() => {
              iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());
            });
          });
        };
        const loadPlugins = (editor, suffix) => {
          const loadPlugin = (name2, url) => {
            PluginManager.load(name2, url).catch(() => {
              pluginLoadError(editor, url, name2);
            });
          };
          each$d(getExternalPlugins$1(editor), (url, name2) => {
            loadPlugin(name2, url);
            editor.options.set("plugins", getPlugins(editor).concat(name2));
          });
          each$e(getPlugins(editor), (plugin) => {
            plugin = Tools.trim(plugin);
            if (plugin && !PluginManager.urls[plugin] && !hasSkipLoadPrefix(plugin)) {
              loadPlugin(plugin, `plugins/${plugin}/plugin${suffix}.js`);
            }
          });
        };
        const isThemeLoaded = (editor) => {
          const theme = getTheme(editor);
          return !isString(theme) || isNonNullable(ThemeManager.get(theme));
        };
        const isModelLoaded = (editor) => {
          const model = getModel(editor);
          return isNonNullable(ModelManager.get(model));
        };
        const loadScripts = (editor, suffix) => {
          const scriptLoader = ScriptLoader.ScriptLoader;
          const initEditor2 = () => {
            if (!editor.removed && isThemeLoaded(editor) && isModelLoaded(editor)) {
              init(editor);
            }
          };
          loadTheme(editor, suffix);
          loadModel(editor, suffix);
          loadLanguage(scriptLoader, editor);
          loadIcons(scriptLoader, editor, suffix);
          loadPlugins(editor, suffix);
          scriptLoader.loadQueue().then(initEditor2, initEditor2);
        };
        const getStyleSheetLoader = (element, editor) => instance.forElement(element, {
          contentCssCors: hasContentCssCors(editor),
          referrerPolicy: getReferrerPolicy(editor)
        });
        const render = (editor) => {
          const id = editor.id;
          I18n.setCode(getLanguageCode(editor));
          const readyHandler = () => {
            DOM$3.unbind(window, "ready", readyHandler);
            editor.render();
          };
          if (!EventUtils.Event.domLoaded) {
            DOM$3.bind(window, "ready", readyHandler);
            return;
          }
          if (!editor.getElement()) {
            return;
          }
          const element = SugarElement.fromDom(editor.getElement());
          const snapshot = clone$4(element);
          editor.on("remove", () => {
            eachr(element.dom.attributes, (attr) => remove$a(element, attr.name));
            setAll$1(element, snapshot);
          });
          editor.ui.styleSheetLoader = getStyleSheetLoader(element, editor);
          if (!isInline(editor)) {
            editor.orgVisibility = editor.getElement().style.visibility;
            editor.getElement().style.visibility = "hidden";
          } else {
            editor.inline = true;
          }
          const form = editor.getElement().form || DOM$3.getParent(id, "form");
          if (form) {
            editor.formElement = form;
            if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {
              DOM$3.insertAfter(DOM$3.create("input", {
                type: "hidden",
                name: id
              }), id);
              editor.hasHiddenInput = true;
            }
            editor.formEventDelegate = (e2) => {
              editor.dispatch(e2.type, e2);
            };
            DOM$3.bind(form, "submit reset", editor.formEventDelegate);
            editor.on("reset", () => {
              editor.resetContent();
            });
            if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {
              form._mceOldSubmit = form.submit;
              form.submit = () => {
                editor.editorManager.triggerSave();
                editor.setDirty(false);
                return form._mceOldSubmit(form);
              };
            }
          }
          editor.windowManager = WindowManager(editor);
          editor.notificationManager = NotificationManager(editor);
          if (isEncodingXml(editor)) {
            editor.on("GetContent", (e2) => {
              if (e2.save) {
                e2.content = DOM$3.encode(e2.content);
              }
            });
          }
          if (shouldAddFormSubmitTrigger(editor)) {
            editor.on("submit", () => {
              if (editor.initialized) {
                editor.save();
              }
            });
          }
          if (shouldAddUnloadTrigger(editor)) {
            editor._beforeUnload = () => {
              if (editor.initialized && !editor.destroyed && !editor.isHidden()) {
                editor.save({
                  format: "raw",
                  no_events: true,
                  set_dirty: false
                });
              }
            };
            editor.editorManager.on("BeforeUnload", editor._beforeUnload);
          }
          editor.editorManager.add(editor);
          loadScripts(editor, editor.suffix);
        };
        const setEditableRoot = (editor, state) => {
          if (editor._editableRoot !== state) {
            editor._editableRoot = state;
            if (!editor.readonly) {
              editor.getBody().contentEditable = String(editor.hasEditableRoot());
              editor.nodeChanged();
            }
            fireEditableRootStateChange(editor, state);
          }
        };
        const hasEditableRoot = (editor) => editor._editableRoot;
        const sectionResult = (sections, settings) => ({
          sections: constant(sections),
          options: constant(settings)
        });
        const deviceDetection = detect$2().deviceType;
        const isPhone = deviceDetection.isPhone();
        const isTablet = deviceDetection.isTablet();
        const normalizePlugins = (plugins) => {
          if (isNullable(plugins)) {
            return [];
          } else {
            const pluginNames = isArray$1(plugins) ? plugins : plugins.split(/[ ,]/);
            const trimmedPlugins = map$3(pluginNames, trim$3);
            return filter$5(trimmedPlugins, isNotEmpty);
          }
        };
        const extractSections = (keys2, options) => {
          const result = bifilter(options, (value2, key) => {
            return contains$2(keys2, key);
          });
          return sectionResult(result.t, result.f);
        };
        const getSection = (sectionResult2, name2, defaults = {}) => {
          const sections = sectionResult2.sections();
          const sectionOptions = get$a(sections, name2).getOr({});
          return Tools.extend({}, defaults, sectionOptions);
        };
        const hasSection = (sectionResult2, name2) => {
          return has$2(sectionResult2.sections(), name2);
        };
        const getSectionConfig = (sectionResult2, name2) => {
          return hasSection(sectionResult2, name2) ? sectionResult2.sections()[name2] : {};
        };
        const getMobileOverrideOptions = (mobileOptions, isPhone2) => {
          const defaultMobileOptions = {
            table_grid: false,
            object_resizing: false,
            resize: false,
            toolbar_mode: get$a(mobileOptions, "toolbar_mode").getOr("scrolling"),
            toolbar_sticky: false
          };
          const defaultPhoneOptions = { menubar: false };
          return {
            ...defaultMobileOptions,
            ...isPhone2 ? defaultPhoneOptions : {}
          };
        };
        const getExternalPlugins = (overrideOptions, options) => {
          var _a;
          const userDefinedExternalPlugins = (_a = options.external_plugins) !== null && _a !== void 0 ? _a : {};
          if (overrideOptions && overrideOptions.external_plugins) {
            return Tools.extend({}, overrideOptions.external_plugins, userDefinedExternalPlugins);
          } else {
            return userDefinedExternalPlugins;
          }
        };
        const combinePlugins = (forcedPlugins, plugins) => [
          ...normalizePlugins(forcedPlugins),
          ...normalizePlugins(plugins)
        ];
        const getPlatformPlugins = (isMobileDevice, sectionResult2, desktopPlugins, mobilePlugins) => {
          if (isMobileDevice && hasSection(sectionResult2, "mobile")) {
            return mobilePlugins;
          } else {
            return desktopPlugins;
          }
        };
        const processPlugins = (isMobileDevice, sectionResult2, defaultOverrideOptions, options) => {
          const forcedPlugins = normalizePlugins(defaultOverrideOptions.forced_plugins);
          const desktopPlugins = normalizePlugins(options.plugins);
          const mobileConfig = getSectionConfig(sectionResult2, "mobile");
          const mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;
          const platformPlugins = getPlatformPlugins(isMobileDevice, sectionResult2, desktopPlugins, mobilePlugins);
          const combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);
          return Tools.extend(options, {
            forced_plugins: forcedPlugins,
            plugins: combinedPlugins
          });
        };
        const isOnMobile = (isMobileDevice, sectionResult2) => {
          return isMobileDevice && hasSection(sectionResult2, "mobile");
        };
        const combineOptions = (isMobileDevice, isPhone2, defaultOptions2, defaultOverrideOptions, options) => {
          var _a;
          const deviceOverrideOptions = isMobileDevice ? { mobile: getMobileOverrideOptions((_a = options.mobile) !== null && _a !== void 0 ? _a : {}, isPhone2) } : {};
          const sectionResult2 = extractSections(["mobile"], deepMerge(deviceOverrideOptions, options));
          const extendedOptions = Tools.extend(defaultOptions2, defaultOverrideOptions, sectionResult2.options(), isOnMobile(isMobileDevice, sectionResult2) ? getSection(sectionResult2, "mobile") : {}, { external_plugins: getExternalPlugins(defaultOverrideOptions, sectionResult2.options()) });
          return processPlugins(isMobileDevice, sectionResult2, defaultOverrideOptions, extendedOptions);
        };
        const normalizeOptions = (defaultOverrideOptions, options) => combineOptions(isPhone || isTablet, isPhone, options, defaultOverrideOptions, options);
        const addVisual = (editor, elm) => addVisual$1(editor, elm);
        const registerExecCommands$3 = (editor) => {
          const toggleFormat2 = (name2, value2) => {
            editor.formatter.toggle(name2, value2);
            editor.nodeChanged();
          };
          const toggleAlign = (align) => () => {
            each$e("left,center,right,justify".split(","), (name2) => {
              if (align !== name2) {
                editor.formatter.remove("align" + name2);
              }
            });
            if (align !== "none") {
              toggleFormat2("align" + align);
            }
          };
          editor.editorCommands.addCommands({
            JustifyLeft: toggleAlign("left"),
            JustifyCenter: toggleAlign("center"),
            JustifyRight: toggleAlign("right"),
            JustifyFull: toggleAlign("justify"),
            JustifyNone: toggleAlign("none")
          });
        };
        const registerQueryStateCommands$1 = (editor) => {
          const alignStates = (name2) => () => {
            const selection = editor.selection;
            const nodes = selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks();
            return exists(nodes, (node) => isNonNullable(editor.formatter.matchNode(node, name2)));
          };
          editor.editorCommands.addCommands({
            JustifyLeft: alignStates("alignleft"),
            JustifyCenter: alignStates("aligncenter"),
            JustifyRight: alignStates("alignright"),
            JustifyFull: alignStates("alignjustify")
          }, "state");
        };
        const registerCommands$a = (editor) => {
          registerExecCommands$3(editor);
          registerQueryStateCommands$1(editor);
        };
        const registerCommands$9 = (editor) => {
          editor.editorCommands.addCommands({
            "Cut,Copy,Paste": (command) => {
              const doc = editor.getDoc();
              let failed;
              try {
                doc.execCommand(command);
              } catch (ex) {
                failed = true;
              }
              if (command === "paste" && !doc.queryCommandEnabled(command)) {
                failed = true;
              }
              if (failed || !doc.queryCommandSupported(command)) {
                let msg = editor.translate(`Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.`);
                if (Env.os.isMacOS() || Env.os.isiOS()) {
                  msg = msg.replace(/Ctrl\+/g, "\u2318+");
                }
                editor.notificationManager.open({
                  text: msg,
                  type: "error"
                });
              }
            }
          });
        };
        const trimOrPadLeftRight = (dom2, rng, html2) => {
          const root = SugarElement.fromDom(dom2.getRoot());
          if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng))) {
            html2 = html2.replace(/^ /, "&nbsp;");
          } else {
            html2 = html2.replace(/^&nbsp;/, " ");
          }
          if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng))) {
            html2 = html2.replace(/(&nbsp;| )(<br( \/)>)?$/, "&nbsp;");
          } else {
            html2 = html2.replace(/&nbsp;(<br( \/)?>)?$/, " ");
          }
          return html2;
        };
        const processValue$1 = (value2) => {
          if (typeof value2 !== "string") {
            const details = Tools.extend({
              paste: value2.paste,
              data: { paste: value2.paste }
            }, value2);
            return {
              content: value2.content,
              details
            };
          }
          return {
            content: value2,
            details: {}
          };
        };
        const trimOrPad = (editor, value2) => {
          const selection = editor.selection;
          const dom2 = editor.dom;
          if (/^ | $/.test(value2)) {
            return trimOrPadLeftRight(dom2, selection.getRng(), value2);
          } else {
            return value2;
          }
        };
        const insertAtCaret = (editor, value2) => {
          if (editor.selection.isEditable()) {
            const { content, details } = processValue$1(value2);
            preProcessSetContent(editor, {
              ...details,
              content: trimOrPad(editor, content),
              format: "html",
              set: false,
              selection: true
            }).each((args) => {
              const insertedContent = insertContent$1(editor, args.content, details);
              postProcessSetContent(editor, insertedContent, args);
              editor.addVisual();
            });
          }
        };
        const registerCommands$8 = (editor) => {
          editor.editorCommands.addCommands({
            mceCleanup: () => {
              const bm = editor.selection.getBookmark();
              editor.setContent(editor.getContent());
              editor.selection.moveToBookmark(bm);
            },
            insertImage: (_command, _ui, value2) => {
              insertAtCaret(editor, editor.dom.createHTML("img", { src: value2 }));
            },
            insertHorizontalRule: () => {
              editor.execCommand("mceInsertContent", false, "<hr>");
            },
            insertText: (_command, _ui, value2) => {
              insertAtCaret(editor, editor.dom.encode(value2));
            },
            insertHTML: (_command, _ui, value2) => {
              insertAtCaret(editor, value2);
            },
            mceInsertContent: (_command, _ui, value2) => {
              insertAtCaret(editor, value2);
            },
            mceSetContent: (_command, _ui, value2) => {
              editor.setContent(value2);
            },
            mceReplaceContent: (_command, _ui, value2) => {
              editor.execCommand("mceInsertContent", false, value2.replace(/\{\$selection\}/g, editor.selection.getContent({ format: "text" })));
            },
            mceNewDocument: () => {
              editor.setContent(getNewDocumentContent(editor));
            }
          });
        };
        const legacyPropNames = {
          "font-size": "size",
          "font-family": "face"
        };
        const isFont = isTag("font");
        const getSpecifiedFontProp = (propName, rootElm, elm) => {
          const getProperty = (elm2) => getRaw(elm2, propName).orThunk(() => {
            if (isFont(elm2)) {
              return get$a(legacyPropNames, propName).bind((legacyPropName) => getOpt(elm2, legacyPropName));
            } else {
              return Optional.none();
            }
          });
          const isRoot2 = (elm2) => eq(SugarElement.fromDom(rootElm), elm2);
          return closest$1(SugarElement.fromDom(elm), (elm2) => getProperty(elm2), isRoot2);
        };
        const normalizeFontFamily = (fontFamily) => fontFamily.replace(/[\'\"\\]/g, "").replace(/,\s+/g, ",");
        const getComputedFontProp = (propName, elm) => Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));
        const getFontProp = (propName) => (rootElm, elm) => Optional.from(elm).map(SugarElement.fromDom).filter(isElement$7).bind((element) => getSpecifiedFontProp(propName, rootElm, element.dom).or(getComputedFontProp(propName, element.dom))).getOr("");
        const getFontSize = getFontProp("font-size");
        const getFontFamily = compose(normalizeFontFamily, getFontProp("font-family"));
        const findFirstCaretElement = (editor) => firstPositionIn(editor.getBody()).bind((caret) => {
          const container = caret.container();
          return Optional.from(isText$a(container) ? container.parentNode : container);
        });
        const getCaretElement = (editor) => Optional.from(editor.selection.getRng()).bind((rng) => {
          const root = editor.getBody();
          const atStartOfNode = rng.startContainer === root && rng.startOffset === 0;
          return atStartOfNode ? Optional.none() : Optional.from(editor.selection.getStart(true));
        });
        const bindRange = (editor, binder2) => getCaretElement(editor).orThunk(curry(findFirstCaretElement, editor)).map(SugarElement.fromDom).filter(isElement$7).bind(binder2);
        const mapRange = (editor, mapper) => bindRange(editor, compose1(Optional.some, mapper));
        const fromFontSizeNumber = (editor, value2) => {
          if (/^[0-9.]+$/.test(value2)) {
            const fontSizeNumber = parseInt(value2, 10);
            if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {
              const fontSizes = getFontStyleValues(editor);
              const fontClasses = getFontSizeClasses(editor);
              if (fontClasses.length > 0) {
                return fontClasses[fontSizeNumber - 1] || value2;
              } else {
                return fontSizes[fontSizeNumber - 1] || value2;
              }
            } else {
              return value2;
            }
          } else {
            return value2;
          }
        };
        const normalizeFontNames = (font) => {
          const fonts = font.split(/\s*,\s*/);
          return map$3(fonts, (font2) => {
            if (font2.indexOf(" ") !== -1 && !(startsWith(font2, '"') || startsWith(font2, `'`))) {
              return `'${font2}'`;
            } else {
              return font2;
            }
          }).join(",");
        };
        const fontNameAction = (editor, value2) => {
          const font = fromFontSizeNumber(editor, value2);
          editor.formatter.toggle("fontname", { value: normalizeFontNames(font) });
          editor.nodeChanged();
        };
        const fontNameQuery = (editor) => mapRange(editor, (elm) => getFontFamily(editor.getBody(), elm.dom)).getOr("");
        const fontSizeAction = (editor, value2) => {
          editor.formatter.toggle("fontsize", { value: fromFontSizeNumber(editor, value2) });
          editor.nodeChanged();
        };
        const fontSizeQuery = (editor) => mapRange(editor, (elm) => getFontSize(editor.getBody(), elm.dom)).getOr("");
        const lineHeightQuery = (editor) => mapRange(editor, (elm) => {
          const root = SugarElement.fromDom(editor.getBody());
          const specifiedStyle = closest$1(elm, (elm2) => getRaw(elm2, "line-height"), curry(eq, root));
          const computedStyle = () => {
            const lineHeight = parseFloat(get$7(elm, "line-height"));
            const fontSize = parseFloat(get$7(elm, "font-size"));
            return String(lineHeight / fontSize);
          };
          return specifiedStyle.getOrThunk(computedStyle);
        }).getOr("");
        const lineHeightAction = (editor, lineHeight) => {
          editor.formatter.toggle("lineheight", { value: String(lineHeight) });
          editor.nodeChanged();
        };
        const registerExecCommands$2 = (editor) => {
          const toggleFormat2 = (name2, value2) => {
            editor.formatter.toggle(name2, value2);
            editor.nodeChanged();
          };
          editor.editorCommands.addCommands({
            "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (command) => {
              toggleFormat2(command);
            },
            "ForeColor,HiliteColor": (command, _ui, value2) => {
              toggleFormat2(command, { value: value2 });
            },
            "BackColor": (_command, _ui, value2) => {
              toggleFormat2("hilitecolor", { value: value2 });
            },
            "FontName": (_command, _ui, value2) => {
              fontNameAction(editor, value2);
            },
            "FontSize": (_command, _ui, value2) => {
              fontSizeAction(editor, value2);
            },
            "LineHeight": (_command, _ui, value2) => {
              lineHeightAction(editor, value2);
            },
            "Lang": (command, _ui, lang) => {
              var _a;
              toggleFormat2(command, {
                value: lang.code,
                customValue: (_a = lang.customCode) !== null && _a !== void 0 ? _a : null
              });
            },
            "RemoveFormat": (command) => {
              editor.formatter.remove(command);
            },
            "mceBlockQuote": () => {
              toggleFormat2("blockquote");
            },
            "FormatBlock": (_command, _ui, value2) => {
              toggleFormat2(isString(value2) ? value2 : "p");
            },
            "mceToggleFormat": (_command, _ui, value2) => {
              toggleFormat2(value2);
            }
          });
        };
        const registerQueryValueCommands = (editor) => {
          const isFormatMatch = (name2) => editor.formatter.match(name2);
          editor.editorCommands.addCommands({
            "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (command) => isFormatMatch(command),
            "mceBlockQuote": () => isFormatMatch("blockquote")
          }, "state");
          editor.editorCommands.addQueryValueHandler("FontName", () => fontNameQuery(editor));
          editor.editorCommands.addQueryValueHandler("FontSize", () => fontSizeQuery(editor));
          editor.editorCommands.addQueryValueHandler("LineHeight", () => lineHeightQuery(editor));
        };
        const registerCommands$7 = (editor) => {
          registerExecCommands$2(editor);
          registerQueryValueCommands(editor);
        };
        const registerCommands$6 = (editor) => {
          editor.editorCommands.addCommands({
            mceAddUndoLevel: () => {
              editor.undoManager.add();
            },
            mceEndUndoLevel: () => {
              editor.undoManager.add();
            },
            Undo: () => {
              editor.undoManager.undo();
            },
            Redo: () => {
              editor.undoManager.redo();
            }
          });
        };
        const registerCommands$5 = (editor) => {
          editor.editorCommands.addCommands({
            Indent: () => {
              indent(editor);
            },
            Outdent: () => {
              outdent(editor);
            }
          });
          editor.editorCommands.addCommands({ Outdent: () => canOutdent(editor) }, "state");
        };
        const registerCommands$4 = (editor) => {
          const applyLinkToSelection = (_command, _ui, value2) => {
            const linkDetails = isString(value2) ? { href: value2 } : value2;
            const anchor = editor.dom.getParent(editor.selection.getNode(), "a");
            if (isObject(linkDetails) && isString(linkDetails.href)) {
              linkDetails.href = linkDetails.href.replace(/ /g, "%20");
              if (!anchor || !linkDetails.href) {
                editor.formatter.remove("link");
              }
              if (linkDetails.href) {
                editor.formatter.apply("link", linkDetails, anchor);
              }
            }
          };
          editor.editorCommands.addCommands({
            unlink: () => {
              if (editor.selection.isEditable()) {
                if (editor.selection.isCollapsed()) {
                  const elm = editor.dom.getParent(editor.selection.getStart(), "a");
                  if (elm) {
                    editor.dom.remove(elm, true);
                  }
                  return;
                }
                editor.formatter.remove("link");
              }
            },
            mceInsertLink: applyLinkToSelection,
            createLink: applyLinkToSelection
          });
        };
        const registerExecCommands$1 = (editor) => {
          editor.editorCommands.addCommands({
            "InsertUnorderedList,InsertOrderedList": (command) => {
              editor.getDoc().execCommand(command);
              const listElm = editor.dom.getParent(editor.selection.getNode(), "ol,ul");
              if (listElm) {
                const listParent = listElm.parentNode;
                if (listParent && /^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {
                  const bm = editor.selection.getBookmark();
                  editor.dom.split(listParent, listElm);
                  editor.selection.moveToBookmark(bm);
                }
              }
            }
          });
        };
        const registerQueryStateCommands = (editor) => {
          editor.editorCommands.addCommands({
            "InsertUnorderedList,InsertOrderedList": (command) => {
              const list = editor.dom.getParent(editor.selection.getNode(), "ul,ol");
              return list && (command === "insertunorderedlist" && list.tagName === "UL" || command === "insertorderedlist" && list.tagName === "OL");
            }
          }, "state");
        };
        const registerCommands$3 = (editor) => {
          registerExecCommands$1(editor);
          registerQueryStateCommands(editor);
        };
        const registerCommands$2 = (editor) => {
          editor.editorCommands.addCommands({
            insertParagraph: () => {
              insertBreak(blockbreak, editor);
            },
            mceInsertNewLine: (_command, _ui, value2) => {
              insert(editor, value2);
            },
            InsertLineBreak: (_command, _ui, _value) => {
              insertBreak(linebreak, editor);
            }
          });
        };
        const registerCommands$1 = (editor) => {
          editor.editorCommands.addCommands({
            mceSelectNodeDepth: (_command, _ui, value2) => {
              let counter = 0;
              editor.dom.getParent(editor.selection.getNode(), (node) => {
                if (isElement$6(node) && counter++ === value2) {
                  editor.selection.select(node);
                  return false;
                } else {
                  return true;
                }
              }, editor.getBody());
            },
            mceSelectNode: (_command, _ui, value2) => {
              editor.selection.select(value2);
            },
            selectAll: () => {
              const editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue$3);
              if (editingHost) {
                const rng = editor.dom.createRng();
                rng.selectNodeContents(editingHost);
                editor.selection.setRng(rng);
              }
            }
          });
        };
        const registerExecCommands = (editor) => {
          editor.editorCommands.addCommands({
            mceRemoveNode: (_command, _ui, value2) => {
              const node = value2 !== null && value2 !== void 0 ? value2 : editor.selection.getNode();
              if (node !== editor.getBody()) {
                const bm = editor.selection.getBookmark();
                editor.dom.remove(node, true);
                editor.selection.moveToBookmark(bm);
              }
            },
            mcePrint: () => {
              editor.getWin().print();
            },
            mceFocus: (_command, _ui, value2) => {
              focus(editor, value2 === true);
            },
            mceToggleVisualAid: () => {
              editor.hasVisual = !editor.hasVisual;
              editor.addVisual();
            }
          });
        };
        const registerCommands = (editor) => {
          registerCommands$a(editor);
          registerCommands$9(editor);
          registerCommands$6(editor);
          registerCommands$1(editor);
          registerCommands$8(editor);
          registerCommands$4(editor);
          registerCommands$5(editor);
          registerCommands$2(editor);
          registerCommands$3(editor);
          registerCommands$7(editor);
          registerExecCommands(editor);
        };
        const selectionSafeCommands = ["toggleview"];
        const isSelectionSafeCommand = (command) => contains$2(selectionSafeCommands, command.toLowerCase());
        class EditorCommands {
          constructor(editor) {
            this.commands = {
              state: {},
              exec: {},
              value: {}
            };
            this.editor = editor;
          }
          execCommand(command, ui = false, value2, args) {
            const editor = this.editor;
            const lowerCaseCommand = command.toLowerCase();
            const skipFocus = args === null || args === void 0 ? void 0 : args.skip_focus;
            if (editor.removed) {
              return false;
            }
            if (lowerCaseCommand !== "mcefocus") {
              if (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(lowerCaseCommand) && !skipFocus) {
                editor.focus();
              } else {
                restore(editor);
              }
            }
            const eventArgs = editor.dispatch("BeforeExecCommand", {
              command,
              ui,
              value: value2
            });
            if (eventArgs.isDefaultPrevented()) {
              return false;
            }
            const func = this.commands.exec[lowerCaseCommand];
            if (isFunction(func)) {
              func(lowerCaseCommand, ui, value2);
              editor.dispatch("ExecCommand", {
                command,
                ui,
                value: value2
              });
              return true;
            }
            return false;
          }
          queryCommandState(command) {
            if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {
              return false;
            }
            const lowerCaseCommand = command.toLowerCase();
            const func = this.commands.state[lowerCaseCommand];
            if (isFunction(func)) {
              return func(lowerCaseCommand);
            }
            return false;
          }
          queryCommandValue(command) {
            if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {
              return "";
            }
            const lowerCaseCommand = command.toLowerCase();
            const func = this.commands.value[lowerCaseCommand];
            if (isFunction(func)) {
              return func(lowerCaseCommand);
            }
            return "";
          }
          addCommands(commandList, type2 = "exec") {
            const commands = this.commands;
            each$d(commandList, (callback, command) => {
              each$e(command.toLowerCase().split(","), (command2) => {
                commands[type2][command2] = callback;
              });
            });
          }
          addCommand(command, callback, scope) {
            const lowerCaseCommand = command.toLowerCase();
            this.commands.exec[lowerCaseCommand] = (_command, ui, value2) => callback.call(scope !== null && scope !== void 0 ? scope : this.editor, ui, value2);
          }
          queryCommandSupported(command) {
            const lowerCaseCommand = command.toLowerCase();
            if (this.commands.exec[lowerCaseCommand]) {
              return true;
            } else {
              return false;
            }
          }
          addQueryStateHandler(command, callback, scope) {
            this.commands.state[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);
          }
          addQueryValueHandler(command, callback, scope) {
            this.commands.value[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);
          }
        }
        const internalContentEditableAttr = "data-mce-contenteditable";
        const toggleClass = (elm, cls, state) => {
          if (has(elm, cls) && !state) {
            remove$7(elm, cls);
          } else if (state) {
            add$2(elm, cls);
          }
        };
        const setEditorCommandState = (editor, cmd, state) => {
          try {
            editor.getDoc().execCommand(cmd, false, String(state));
          } catch (ex) {
          }
        };
        const setContentEditable = (elm, state) => {
          elm.dom.contentEditable = state ? "true" : "false";
        };
        const switchOffContentEditableTrue = (elm) => {
          each$e(descendants(elm, '*[contenteditable="true"]'), (elm2) => {
            set$3(elm2, internalContentEditableAttr, "true");
            setContentEditable(elm2, false);
          });
        };
        const switchOnContentEditableTrue = (elm) => {
          each$e(descendants(elm, `*[${internalContentEditableAttr}="true"]`), (elm2) => {
            remove$a(elm2, internalContentEditableAttr);
            setContentEditable(elm2, true);
          });
        };
        const removeFakeSelection = (editor) => {
          Optional.from(editor.selection.getNode()).each((elm) => {
            elm.removeAttribute("data-mce-selected");
          });
        };
        const restoreFakeSelection = (editor) => {
          editor.selection.setRng(editor.selection.getRng());
        };
        const toggleReadOnly = (editor, state) => {
          const body = SugarElement.fromDom(editor.getBody());
          toggleClass(body, "mce-content-readonly", state);
          if (state) {
            editor.selection.controlSelection.hideResizeRect();
            editor._selectionOverrides.hideFakeCaret();
            removeFakeSelection(editor);
            editor.readonly = true;
            setContentEditable(body, false);
            switchOffContentEditableTrue(body);
          } else {
            editor.readonly = false;
            if (editor.hasEditableRoot()) {
              setContentEditable(body, true);
            }
            switchOnContentEditableTrue(body);
            setEditorCommandState(editor, "StyleWithCSS", false);
            setEditorCommandState(editor, "enableInlineTableEditing", false);
            setEditorCommandState(editor, "enableObjectResizing", false);
            if (hasEditorOrUiFocus(editor)) {
              editor.focus();
            }
            restoreFakeSelection(editor);
            editor.nodeChanged();
          }
        };
        const isReadOnly = (editor) => editor.readonly;
        const registerFilters = (editor) => {
          editor.parser.addAttributeFilter("contenteditable", (nodes) => {
            if (isReadOnly(editor)) {
              each$e(nodes, (node) => {
                node.attr(internalContentEditableAttr, node.attr("contenteditable"));
                node.attr("contenteditable", "false");
              });
            }
          });
          editor.serializer.addAttributeFilter(internalContentEditableAttr, (nodes) => {
            if (isReadOnly(editor)) {
              each$e(nodes, (node) => {
                node.attr("contenteditable", node.attr(internalContentEditableAttr));
              });
            }
          });
          editor.serializer.addTempAttr(internalContentEditableAttr);
        };
        const registerReadOnlyContentFilters = (editor) => {
          if (editor.serializer) {
            registerFilters(editor);
          } else {
            editor.on("PreInit", () => {
              registerFilters(editor);
            });
          }
        };
        const isClickEvent = (e2) => e2.type === "click";
        const allowedEvents = ["copy"];
        const isReadOnlyAllowedEvent = (e2) => contains$2(allowedEvents, e2.type);
        const getAnchorHrefOpt = (editor, elm) => {
          const isRoot2 = (elm2) => eq(elm2, SugarElement.fromDom(editor.getBody()));
          return closest$3(elm, "a", isRoot2).bind((a2) => getOpt(a2, "href"));
        };
        const processReadonlyEvents = (editor, e2) => {
          if (isClickEvent(e2) && !VK.metaKeyPressed(e2)) {
            const elm = SugarElement.fromDom(e2.target);
            getAnchorHrefOpt(editor, elm).each((href) => {
              e2.preventDefault();
              if (/^#/.test(href)) {
                const targetEl = editor.dom.select(`${href},[name="${removeLeading(href, "#")}"]`);
                if (targetEl.length) {
                  editor.selection.scrollIntoView(targetEl[0], true);
                }
              } else {
                window.open(href, "_blank", "rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes");
              }
            });
          } else if (isReadOnlyAllowedEvent(e2)) {
            editor.dispatch(e2.type, e2);
          }
        };
        const registerReadOnlySelectionBlockers = (editor) => {
          editor.on("ShowCaret", (e2) => {
            if (isReadOnly(editor)) {
              e2.preventDefault();
            }
          });
          editor.on("ObjectSelected", (e2) => {
            if (isReadOnly(editor)) {
              e2.preventDefault();
            }
          });
        };
        const nativeEvents2 = Tools.makeMap("focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover draggesture dragdrop drop drag submit compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel", " ");
        class EventDispatcher {
          static isNative(name2) {
            return !!nativeEvents2[name2.toLowerCase()];
          }
          constructor(settings) {
            this.bindings = {};
            this.settings = settings || {};
            this.scope = this.settings.scope || this;
            this.toggleEvent = this.settings.toggleEvent || never;
          }
          fire(name2, args) {
            return this.dispatch(name2, args);
          }
          dispatch(name2, args) {
            const lcName = name2.toLowerCase();
            const event = normalize$3(lcName, args !== null && args !== void 0 ? args : {}, this.scope);
            if (this.settings.beforeFire) {
              this.settings.beforeFire(event);
            }
            const handlers = this.bindings[lcName];
            if (handlers) {
              for (let i2 = 0, l2 = handlers.length; i2 < l2; i2++) {
                const callback = handlers[i2];
                if (callback.removed) {
                  continue;
                }
                if (callback.once) {
                  this.off(lcName, callback.func);
                }
                if (event.isImmediatePropagationStopped()) {
                  return event;
                }
                if (callback.func.call(this.scope, event) === false) {
                  event.preventDefault();
                  return event;
                }
              }
            }
            return event;
          }
          on(name2, callback, prepend2, extra2) {
            if (callback === false) {
              callback = never;
            }
            if (callback) {
              const wrappedCallback = {
                func: callback,
                removed: false
              };
              if (extra2) {
                Tools.extend(wrappedCallback, extra2);
              }
              const names = name2.toLowerCase().split(" ");
              let i2 = names.length;
              while (i2--) {
                const currentName = names[i2];
                let handlers = this.bindings[currentName];
                if (!handlers) {
                  handlers = [];
                  this.toggleEvent(currentName, true);
                }
                if (prepend2) {
                  handlers = [
                    wrappedCallback,
                    ...handlers
                  ];
                } else {
                  handlers = [
                    ...handlers,
                    wrappedCallback
                  ];
                }
                this.bindings[currentName] = handlers;
              }
            }
            return this;
          }
          off(name2, callback) {
            if (name2) {
              const names = name2.toLowerCase().split(" ");
              let i2 = names.length;
              while (i2--) {
                const currentName = names[i2];
                let handlers = this.bindings[currentName];
                if (!currentName) {
                  each$d(this.bindings, (_value, bindingName) => {
                    this.toggleEvent(bindingName, false);
                    delete this.bindings[bindingName];
                  });
                  return this;
                }
                if (handlers) {
                  if (!callback) {
                    handlers.length = 0;
                  } else {
                    const filteredHandlers = partition$2(handlers, (handler) => handler.func === callback);
                    handlers = filteredHandlers.fail;
                    this.bindings[currentName] = handlers;
                    each$e(filteredHandlers.pass, (handler) => {
                      handler.removed = true;
                    });
                  }
                  if (!handlers.length) {
                    this.toggleEvent(name2, false);
                    delete this.bindings[currentName];
                  }
                }
              }
            } else {
              each$d(this.bindings, (_value, name3) => {
                this.toggleEvent(name3, false);
              });
              this.bindings = {};
            }
            return this;
          }
          once(name2, callback, prepend2) {
            return this.on(name2, callback, prepend2, { once: true });
          }
          has(name2) {
            name2 = name2.toLowerCase();
            const binding = this.bindings[name2];
            return !(!binding || binding.length === 0);
          }
        }
        const getEventDispatcher = (obj) => {
          if (!obj._eventDispatcher) {
            obj._eventDispatcher = new EventDispatcher({
              scope: obj,
              toggleEvent: (name2, state) => {
                if (EventDispatcher.isNative(name2) && obj.toggleNativeEvent) {
                  obj.toggleNativeEvent(name2, state);
                }
              }
            });
          }
          return obj._eventDispatcher;
        };
        const Observable = {
          fire(name2, args, bubble) {
            return this.dispatch(name2, args, bubble);
          },
          dispatch(name2, args, bubble) {
            const self2 = this;
            if (self2.removed && name2 !== "remove" && name2 !== "detach") {
              return normalize$3(name2.toLowerCase(), args !== null && args !== void 0 ? args : {}, self2);
            }
            const dispatcherArgs = getEventDispatcher(self2).dispatch(name2, args);
            if (bubble !== false && self2.parent) {
              let parent2 = self2.parent();
              while (parent2 && !dispatcherArgs.isPropagationStopped()) {
                parent2.dispatch(name2, dispatcherArgs, false);
                parent2 = parent2.parent ? parent2.parent() : void 0;
              }
            }
            return dispatcherArgs;
          },
          on(name2, callback, prepend2) {
            return getEventDispatcher(this).on(name2, callback, prepend2);
          },
          off(name2, callback) {
            return getEventDispatcher(this).off(name2, callback);
          },
          once(name2, callback) {
            return getEventDispatcher(this).once(name2, callback);
          },
          hasEventListeners(name2) {
            return getEventDispatcher(this).has(name2);
          }
        };
        const DOM$2 = DOMUtils.DOM;
        let customEventRootDelegates;
        const getEventTarget = (editor, eventName) => {
          if (eventName === "selectionchange") {
            return editor.getDoc();
          }
          if (!editor.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(eventName)) {
            return editor.getDoc().documentElement;
          }
          const eventRoot = getEventRoot(editor);
          if (eventRoot) {
            if (!editor.eventRoot) {
              editor.eventRoot = DOM$2.select(eventRoot)[0];
            }
            return editor.eventRoot;
          }
          return editor.getBody();
        };
        const isListening = (editor) => !editor.hidden && !isReadOnly(editor);
        const fireEvent = (editor, eventName, e2) => {
          if (isListening(editor)) {
            editor.dispatch(eventName, e2);
          } else if (isReadOnly(editor)) {
            processReadonlyEvents(editor, e2);
          }
        };
        const bindEventDelegate = (editor, eventName) => {
          if (!editor.delegates) {
            editor.delegates = {};
          }
          if (editor.delegates[eventName] || editor.removed) {
            return;
          }
          const eventRootElm = getEventTarget(editor, eventName);
          if (getEventRoot(editor)) {
            if (!customEventRootDelegates) {
              customEventRootDelegates = {};
              editor.editorManager.on("removeEditor", () => {
                if (!editor.editorManager.activeEditor) {
                  if (customEventRootDelegates) {
                    each$d(customEventRootDelegates, (_value, name2) => {
                      editor.dom.unbind(getEventTarget(editor, name2));
                    });
                    customEventRootDelegates = null;
                  }
                }
              });
            }
            if (customEventRootDelegates[eventName]) {
              return;
            }
            const delegate = (e2) => {
              const target = e2.target;
              const editors2 = editor.editorManager.get();
              let i2 = editors2.length;
              while (i2--) {
                const body = editors2[i2].getBody();
                if (body === target || DOM$2.isChildOf(target, body)) {
                  fireEvent(editors2[i2], eventName, e2);
                }
              }
            };
            customEventRootDelegates[eventName] = delegate;
            DOM$2.bind(eventRootElm, eventName, delegate);
          } else {
            const delegate = (e2) => {
              fireEvent(editor, eventName, e2);
            };
            DOM$2.bind(eventRootElm, eventName, delegate);
            editor.delegates[eventName] = delegate;
          }
        };
        const EditorObservable = {
          ...Observable,
          bindPendingEventDelegates() {
            const self2 = this;
            Tools.each(self2._pendingNativeEvents, (name2) => {
              bindEventDelegate(self2, name2);
            });
          },
          toggleNativeEvent(name2, state) {
            const self2 = this;
            if (name2 === "focus" || name2 === "blur") {
              return;
            }
            if (self2.removed) {
              return;
            }
            if (state) {
              if (self2.initialized) {
                bindEventDelegate(self2, name2);
              } else {
                if (!self2._pendingNativeEvents) {
                  self2._pendingNativeEvents = [name2];
                } else {
                  self2._pendingNativeEvents.push(name2);
                }
              }
            } else if (self2.initialized && self2.delegates) {
              self2.dom.unbind(getEventTarget(self2, name2), name2, self2.delegates[name2]);
              delete self2.delegates[name2];
            }
          },
          unbindAllNativeEvents() {
            const self2 = this;
            const body = self2.getBody();
            const dom2 = self2.dom;
            if (self2.delegates) {
              each$d(self2.delegates, (value2, name2) => {
                self2.dom.unbind(getEventTarget(self2, name2), name2, value2);
              });
              delete self2.delegates;
            }
            if (!self2.inline && body && dom2) {
              body.onload = null;
              dom2.unbind(self2.getWin());
              dom2.unbind(self2.getDoc());
            }
            if (dom2) {
              dom2.unbind(body);
              dom2.unbind(self2.getContainer());
            }
          }
        };
        const stringListProcessor = (value2) => {
          if (isString(value2)) {
            return {
              value: value2.split(/[ ,]/),
              valid: true
            };
          } else if (isArrayOf(value2, isString)) {
            return {
              value: value2,
              valid: true
            };
          } else {
            return {
              valid: false,
              message: `The value must be a string[] or a comma/space separated string.`
            };
          }
        };
        const getBuiltInProcessor = (type2) => {
          const validator = (() => {
            switch (type2) {
              case "array":
                return isArray$1;
              case "boolean":
                return isBoolean;
              case "function":
                return isFunction;
              case "number":
                return isNumber;
              case "object":
                return isObject;
              case "string":
                return isString;
              case "string[]":
                return stringListProcessor;
              case "object[]":
                return (val) => isArrayOf(val, isObject);
              case "regexp":
                return (val) => is$4(val, RegExp);
              default:
                return always;
            }
          })();
          return (value2) => processValue(value2, validator, `The value must be a ${type2}.`);
        };
        const isBuiltInSpec = (spec) => isString(spec.processor);
        const getErrorMessage = (message, result) => {
          const additionalText = isEmpty$3(result.message) ? "" : `. ${result.message}`;
          return message + additionalText;
        };
        const isValidResult = (result) => result.valid;
        const processValue = (value2, processor, message = "") => {
          const result = processor(value2);
          if (isBoolean(result)) {
            return result ? {
              value: value2,
              valid: true
            } : {
              valid: false,
              message
            };
          } else {
            return result;
          }
        };
        const processDefaultValue = (name2, defaultValue, processor) => {
          if (!isUndefined(defaultValue)) {
            const result = processValue(defaultValue, processor);
            if (isValidResult(result)) {
              return result.value;
            } else {
              console.error(getErrorMessage(`Invalid default value passed for the "${name2}" option`, result));
            }
          }
          return void 0;
        };
        const create$5 = (editor, initialOptions) => {
          const registry2 = {};
          const values2 = {};
          const setValue = (name2, value2, processor) => {
            const result = processValue(value2, processor);
            if (isValidResult(result)) {
              values2[name2] = result.value;
              return true;
            } else {
              console.warn(getErrorMessage(`Invalid value passed for the ${name2} option`, result));
              return false;
            }
          };
          const register2 = (name2, spec) => {
            const processor = isBuiltInSpec(spec) ? getBuiltInProcessor(spec.processor) : spec.processor;
            const defaultValue = processDefaultValue(name2, spec.default, processor);
            registry2[name2] = {
              ...spec,
              default: defaultValue,
              processor
            };
            const initValue = get$a(values2, name2).orThunk(() => get$a(initialOptions, name2));
            initValue.each((value2) => setValue(name2, value2, processor));
          };
          const isRegistered = (name2) => has$2(registry2, name2);
          const get2 = (name2) => get$a(values2, name2).orThunk(() => get$a(registry2, name2).map((spec) => spec.default)).getOrUndefined();
          const set2 = (name2, value2) => {
            if (!isRegistered(name2)) {
              console.warn(`"${name2}" is not a registered option. Ensure the option has been registered before setting a value.`);
              return false;
            } else {
              const spec = registry2[name2];
              if (spec.immutable) {
                console.error(`"${name2}" is an immutable option and cannot be updated`);
                return false;
              } else {
                return setValue(name2, value2, spec.processor);
              }
            }
          };
          const unset = (name2) => {
            const registered = isRegistered(name2);
            if (registered) {
              delete values2[name2];
            }
            return registered;
          };
          const isSet = (name2) => has$2(values2, name2);
          return {
            register: register2,
            isRegistered,
            get: get2,
            set: set2,
            unset,
            isSet
          };
        };
        const defaultModes = [
          "design",
          "readonly"
        ];
        const switchToMode = (editor, activeMode, availableModes, mode) => {
          const oldMode = availableModes[activeMode.get()];
          const newMode = availableModes[mode];
          try {
            newMode.activate();
          } catch (e2) {
            console.error(`problem while activating editor mode ${mode}:`, e2);
            return;
          }
          oldMode.deactivate();
          if (oldMode.editorReadOnly !== newMode.editorReadOnly) {
            toggleReadOnly(editor, newMode.editorReadOnly);
          }
          activeMode.set(mode);
          fireSwitchMode(editor, mode);
        };
        const setMode = (editor, availableModes, activeMode, mode) => {
          if (mode === activeMode.get()) {
            return;
          } else if (!has$2(availableModes, mode)) {
            throw new Error(`Editor mode '${mode}' is invalid`);
          }
          if (editor.initialized) {
            switchToMode(editor, activeMode, availableModes, mode);
          } else {
            editor.on("init", () => switchToMode(editor, activeMode, availableModes, mode));
          }
        };
        const registerMode = (availableModes, mode, api2) => {
          if (contains$2(defaultModes, mode)) {
            throw new Error(`Cannot override default mode ${mode}`);
          }
          return {
            ...availableModes,
            [mode]: {
              ...api2,
              deactivate: () => {
                try {
                  api2.deactivate();
                } catch (e2) {
                  console.error(`problem while deactivating editor mode ${mode}:`, e2);
                }
              }
            }
          };
        };
        const create$4 = (editor) => {
          const activeMode = Cell("design");
          const availableModes = Cell({
            design: {
              activate: noop2,
              deactivate: noop2,
              editorReadOnly: false
            },
            readonly: {
              activate: noop2,
              deactivate: noop2,
              editorReadOnly: true
            }
          });
          registerReadOnlyContentFilters(editor);
          registerReadOnlySelectionBlockers(editor);
          return {
            isReadOnly: () => isReadOnly(editor),
            set: (mode) => setMode(editor, availableModes.get(), activeMode, mode),
            get: () => activeMode.get(),
            register: (mode, api2) => {
              availableModes.set(registerMode(availableModes.get(), mode, api2));
            }
          };
        };
        const each$2 = Tools.each, explode = Tools.explode;
        const keyCodeLookup = {
          f1: 112,
          f2: 113,
          f3: 114,
          f4: 115,
          f5: 116,
          f6: 117,
          f7: 118,
          f8: 119,
          f9: 120,
          f10: 121,
          f11: 122,
          f12: 123
        };
        const modifierNames = Tools.makeMap("alt,ctrl,shift,meta,access");
        const isModifier = (key) => key in modifierNames;
        const parseShortcut = (pattern) => {
          const shortcut = {};
          const isMac = Env.os.isMacOS() || Env.os.isiOS();
          each$2(explode(pattern.toLowerCase(), "+"), (value2) => {
            if (isModifier(value2)) {
              shortcut[value2] = true;
            } else {
              if (/^[0-9]{2,}$/.test(value2)) {
                shortcut.keyCode = parseInt(value2, 10);
              } else {
                shortcut.charCode = value2.charCodeAt(0);
                shortcut.keyCode = keyCodeLookup[value2] || value2.toUpperCase().charCodeAt(0);
              }
            }
          });
          const id = [shortcut.keyCode];
          let key;
          for (key in modifierNames) {
            if (shortcut[key]) {
              id.push(key);
            } else {
              shortcut[key] = false;
            }
          }
          shortcut.id = id.join(",");
          if (shortcut.access) {
            shortcut.alt = true;
            if (isMac) {
              shortcut.ctrl = true;
            } else {
              shortcut.shift = true;
            }
          }
          if (shortcut.meta) {
            if (isMac) {
              shortcut.meta = true;
            } else {
              shortcut.ctrl = true;
              shortcut.meta = false;
            }
          }
          return shortcut;
        };
        class Shortcuts {
          constructor(editor) {
            this.shortcuts = {};
            this.pendingPatterns = [];
            this.editor = editor;
            const self2 = this;
            editor.on("keyup keypress keydown", (e2) => {
              if ((self2.hasModifier(e2) || self2.isFunctionKey(e2)) && !e2.isDefaultPrevented()) {
                each$2(self2.shortcuts, (shortcut) => {
                  if (self2.matchShortcut(e2, shortcut)) {
                    self2.pendingPatterns = shortcut.subpatterns.slice(0);
                    if (e2.type === "keydown") {
                      self2.executeShortcutAction(shortcut);
                    }
                  }
                });
                if (self2.matchShortcut(e2, self2.pendingPatterns[0])) {
                  if (self2.pendingPatterns.length === 1) {
                    if (e2.type === "keydown") {
                      self2.executeShortcutAction(self2.pendingPatterns[0]);
                    }
                  }
                  self2.pendingPatterns.shift();
                }
              }
            });
          }
          add(pattern, desc, cmdFunc, scope) {
            const self2 = this;
            const func = self2.normalizeCommandFunc(cmdFunc);
            each$2(explode(Tools.trim(pattern)), (pattern2) => {
              const shortcut = self2.createShortcut(pattern2, desc, func, scope);
              self2.shortcuts[shortcut.id] = shortcut;
            });
            return true;
          }
          remove(pattern) {
            const shortcut = this.createShortcut(pattern);
            if (this.shortcuts[shortcut.id]) {
              delete this.shortcuts[shortcut.id];
              return true;
            }
            return false;
          }
          normalizeCommandFunc(cmdFunc) {
            const self2 = this;
            const cmd = cmdFunc;
            if (typeof cmd === "string") {
              return () => {
                self2.editor.execCommand(cmd, false, null);
              };
            } else if (Tools.isArray(cmd)) {
              return () => {
                self2.editor.execCommand(cmd[0], cmd[1], cmd[2]);
              };
            } else {
              return cmd;
            }
          }
          createShortcut(pattern, desc, cmdFunc, scope) {
            const shortcuts = Tools.map(explode(pattern, ">"), parseShortcut);
            shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {
              func: cmdFunc,
              scope: scope || this.editor
            });
            return Tools.extend(shortcuts[0], {
              desc: this.editor.translate(desc),
              subpatterns: shortcuts.slice(1)
            });
          }
          hasModifier(e2) {
            return e2.altKey || e2.ctrlKey || e2.metaKey;
          }
          isFunctionKey(e2) {
            return e2.type === "keydown" && e2.keyCode >= 112 && e2.keyCode <= 123;
          }
          matchShortcut(e2, shortcut) {
            if (!shortcut) {
              return false;
            }
            if (shortcut.ctrl !== e2.ctrlKey || shortcut.meta !== e2.metaKey) {
              return false;
            }
            if (shortcut.alt !== e2.altKey || shortcut.shift !== e2.shiftKey) {
              return false;
            }
            if (e2.keyCode === shortcut.keyCode || e2.charCode && e2.charCode === shortcut.charCode) {
              e2.preventDefault();
              return true;
            }
            return false;
          }
          executeShortcutAction(shortcut) {
            return shortcut.func ? shortcut.func.call(shortcut.scope) : null;
          }
        }
        const create$3 = () => {
          const buttons = {};
          const menuItems = {};
          const popups = {};
          const icons = {};
          const contextMenus = {};
          const contextToolbars = {};
          const sidebars = {};
          const views = {};
          const add3 = (collection, type2) => (name2, spec) => {
            collection[name2.toLowerCase()] = {
              ...spec,
              type: type2
            };
          };
          const addIcon = (name2, svgData) => icons[name2.toLowerCase()] = svgData;
          return {
            addButton: add3(buttons, "button"),
            addGroupToolbarButton: add3(buttons, "grouptoolbarbutton"),
            addToggleButton: add3(buttons, "togglebutton"),
            addMenuButton: add3(buttons, "menubutton"),
            addSplitButton: add3(buttons, "splitbutton"),
            addMenuItem: add3(menuItems, "menuitem"),
            addNestedMenuItem: add3(menuItems, "nestedmenuitem"),
            addToggleMenuItem: add3(menuItems, "togglemenuitem"),
            addAutocompleter: add3(popups, "autocompleter"),
            addContextMenu: add3(contextMenus, "contextmenu"),
            addContextToolbar: add3(contextToolbars, "contexttoolbar"),
            addContextForm: add3(contextToolbars, "contextform"),
            addSidebar: add3(sidebars, "sidebar"),
            addView: add3(views, "views"),
            addIcon,
            getAll: () => ({
              buttons,
              menuItems,
              icons,
              popups,
              contextMenus,
              contextToolbars,
              sidebars,
              views
            })
          };
        };
        const registry = () => {
          const bridge = create$3();
          return {
            addAutocompleter: bridge.addAutocompleter,
            addButton: bridge.addButton,
            addContextForm: bridge.addContextForm,
            addContextMenu: bridge.addContextMenu,
            addContextToolbar: bridge.addContextToolbar,
            addIcon: bridge.addIcon,
            addMenuButton: bridge.addMenuButton,
            addMenuItem: bridge.addMenuItem,
            addNestedMenuItem: bridge.addNestedMenuItem,
            addSidebar: bridge.addSidebar,
            addSplitButton: bridge.addSplitButton,
            addToggleButton: bridge.addToggleButton,
            addGroupToolbarButton: bridge.addGroupToolbarButton,
            addToggleMenuItem: bridge.addToggleMenuItem,
            addView: bridge.addView,
            getAll: bridge.getAll
          };
        };
        const DOM$1 = DOMUtils.DOM;
        const extend3 = Tools.extend, each$1 = Tools.each;
        class Editor {
          constructor(id, options, editorManager) {
            this.plugins = {};
            this.contentCSS = [];
            this.contentStyles = [];
            this.loadedCSS = {};
            this.isNotDirty = false;
            this.composing = false;
            this.destroyed = false;
            this.hasHiddenInput = false;
            this.iframeElement = null;
            this.initialized = false;
            this.readonly = false;
            this.removed = false;
            this.startContent = "";
            this._pendingNativeEvents = [];
            this._skinLoaded = false;
            this._editableRoot = true;
            this.editorManager = editorManager;
            this.documentBaseUrl = editorManager.documentBaseURL;
            extend3(this, EditorObservable);
            const self2 = this;
            this.id = id;
            this.hidden = false;
            const normalizedOptions = normalizeOptions(editorManager.defaultOptions, options);
            this.options = create$5(self2, normalizedOptions);
            register$7(self2);
            const getOption2 = this.options.get;
            if (getOption2("deprecation_warnings")) {
              logWarnings(options, normalizedOptions);
            }
            const suffix = getOption2("suffix");
            if (suffix) {
              editorManager.suffix = suffix;
            }
            this.suffix = editorManager.suffix;
            const baseUrl = getOption2("base_url");
            if (baseUrl) {
              editorManager._setBaseUrl(baseUrl);
            }
            this.baseUri = editorManager.baseURI;
            const referrerPolicy = getReferrerPolicy(self2);
            if (referrerPolicy) {
              ScriptLoader.ScriptLoader._setReferrerPolicy(referrerPolicy);
              DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(referrerPolicy);
            }
            const contentCssCors = hasContentCssCors(self2);
            if (isNonNullable(contentCssCors)) {
              DOMUtils.DOM.styleSheetLoader._setContentCssCors(contentCssCors);
            }
            AddOnManager.languageLoad = getOption2("language_load");
            AddOnManager.baseURL = editorManager.baseURL;
            this.setDirty(false);
            this.documentBaseURI = new URI(getDocumentBaseUrl(self2), { base_uri: this.baseUri });
            this.baseURI = this.baseUri;
            this.inline = isInline(self2);
            this.hasVisual = isVisualAidsEnabled(self2);
            this.shortcuts = new Shortcuts(this);
            this.editorCommands = new EditorCommands(this);
            registerCommands(this);
            const cacheSuffix = getOption2("cache_suffix");
            if (cacheSuffix) {
              Env.cacheSuffix = cacheSuffix.replace(/^[\?\&]+/, "");
            }
            this.ui = {
              registry: registry(),
              styleSheetLoader: void 0,
              show: noop2,
              hide: noop2,
              setEnabled: noop2,
              isEnabled: always
            };
            this.mode = create$4(self2);
            editorManager.dispatch("SetupEditor", { editor: this });
            const setupCallback = getSetupCallback(self2);
            if (isFunction(setupCallback)) {
              setupCallback.call(self2, self2);
            }
          }
          render() {
            render(this);
          }
          focus(skipFocus) {
            this.execCommand("mceFocus", false, skipFocus);
          }
          hasFocus() {
            return hasFocus(this);
          }
          translate(text2) {
            return I18n.translate(text2);
          }
          getParam(name2, defaultVal, type2) {
            const options = this.options;
            if (!options.isRegistered(name2)) {
              if (isNonNullable(type2)) {
                options.register(name2, {
                  processor: type2,
                  default: defaultVal
                });
              } else {
                options.register(name2, {
                  processor: always,
                  default: defaultVal
                });
              }
            }
            return !options.isSet(name2) && !isUndefined(defaultVal) ? defaultVal : options.get(name2);
          }
          hasPlugin(name2, loaded) {
            const hasPlugin = contains$2(getPlugins(this), name2);
            if (hasPlugin) {
              return loaded ? PluginManager.get(name2) !== void 0 : true;
            } else {
              return false;
            }
          }
          nodeChanged(args) {
            this._nodeChangeDispatcher.nodeChanged(args);
          }
          addCommand(name2, callback, scope) {
            this.editorCommands.addCommand(name2, callback, scope);
          }
          addQueryStateHandler(name2, callback, scope) {
            this.editorCommands.addQueryStateHandler(name2, callback, scope);
          }
          addQueryValueHandler(name2, callback, scope) {
            this.editorCommands.addQueryValueHandler(name2, callback, scope);
          }
          addShortcut(pattern, desc, cmdFunc, scope) {
            this.shortcuts.add(pattern, desc, cmdFunc, scope);
          }
          execCommand(cmd, ui, value2, args) {
            return this.editorCommands.execCommand(cmd, ui, value2, args);
          }
          queryCommandState(cmd) {
            return this.editorCommands.queryCommandState(cmd);
          }
          queryCommandValue(cmd) {
            return this.editorCommands.queryCommandValue(cmd);
          }
          queryCommandSupported(cmd) {
            return this.editorCommands.queryCommandSupported(cmd);
          }
          show() {
            const self2 = this;
            if (self2.hidden) {
              self2.hidden = false;
              if (self2.inline) {
                self2.getBody().contentEditable = "true";
              } else {
                DOM$1.show(self2.getContainer());
                DOM$1.hide(self2.id);
              }
              self2.load();
              self2.dispatch("show");
            }
          }
          hide() {
            const self2 = this;
            if (!self2.hidden) {
              self2.save();
              if (self2.inline) {
                self2.getBody().contentEditable = "false";
                if (self2 === self2.editorManager.focusedEditor) {
                  self2.editorManager.focusedEditor = null;
                }
              } else {
                DOM$1.hide(self2.getContainer());
                DOM$1.setStyle(self2.id, "display", self2.orgDisplay);
              }
              self2.hidden = true;
              self2.dispatch("hide");
            }
          }
          isHidden() {
            return this.hidden;
          }
          setProgressState(state, time) {
            this.dispatch("ProgressState", {
              state,
              time
            });
          }
          load(args = {}) {
            const self2 = this;
            const elm = self2.getElement();
            if (self2.removed) {
              return "";
            }
            if (elm) {
              const loadArgs = {
                ...args,
                load: true
              };
              const value2 = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;
              const html2 = self2.setContent(value2, loadArgs);
              if (!loadArgs.no_events) {
                self2.dispatch("LoadContent", {
                  ...loadArgs,
                  element: elm
                });
              }
              return html2;
            } else {
              return "";
            }
          }
          save(args = {}) {
            const self2 = this;
            let elm = self2.getElement();
            if (!elm || !self2.initialized || self2.removed) {
              return "";
            }
            const getArgs = {
              ...args,
              save: true,
              element: elm
            };
            let html2 = self2.getContent(getArgs);
            const saveArgs = {
              ...getArgs,
              content: html2
            };
            if (!saveArgs.no_events) {
              self2.dispatch("SaveContent", saveArgs);
            }
            if (saveArgs.format === "raw") {
              self2.dispatch("RawSaveContent", saveArgs);
            }
            html2 = saveArgs.content;
            if (!isTextareaOrInput(elm)) {
              if (args.is_removing || !self2.inline) {
                elm.innerHTML = html2;
              }
              const form = DOM$1.getParent(self2.id, "form");
              if (form) {
                each$1(form.elements, (elm2) => {
                  if (elm2.name === self2.id) {
                    elm2.value = html2;
                    return false;
                  } else {
                    return true;
                  }
                });
              }
            } else {
              elm.value = html2;
            }
            saveArgs.element = getArgs.element = elm = null;
            if (saveArgs.set_dirty !== false) {
              self2.setDirty(false);
            }
            return html2;
          }
          setContent(content, args) {
            return setContent(this, content, args);
          }
          getContent(args) {
            return getContent(this, args);
          }
          insertContent(content, args) {
            if (args) {
              content = extend3({ content }, args);
            }
            this.execCommand("mceInsertContent", false, content);
          }
          resetContent(initialContent) {
            if (initialContent === void 0) {
              setContent(this, this.startContent, { format: "raw" });
            } else {
              setContent(this, initialContent);
            }
            this.undoManager.reset();
            this.setDirty(false);
            this.nodeChanged();
          }
          isDirty() {
            return !this.isNotDirty;
          }
          setDirty(state) {
            const oldState = !this.isNotDirty;
            this.isNotDirty = !state;
            if (state && state !== oldState) {
              this.dispatch("dirty");
            }
          }
          getContainer() {
            const self2 = this;
            if (!self2.container) {
              self2.container = self2.editorContainer || DOM$1.get(self2.id + "_parent");
            }
            return self2.container;
          }
          getContentAreaContainer() {
            return this.contentAreaContainer;
          }
          getElement() {
            if (!this.targetElm) {
              this.targetElm = DOM$1.get(this.id);
            }
            return this.targetElm;
          }
          getWin() {
            const self2 = this;
            if (!self2.contentWindow) {
              const elm = self2.iframeElement;
              if (elm) {
                self2.contentWindow = elm.contentWindow;
              }
            }
            return self2.contentWindow;
          }
          getDoc() {
            const self2 = this;
            if (!self2.contentDocument) {
              const win = self2.getWin();
              if (win) {
                self2.contentDocument = win.document;
              }
            }
            return self2.contentDocument;
          }
          getBody() {
            var _a, _b;
            const doc = this.getDoc();
            return (_b = (_a = this.bodyElement) !== null && _a !== void 0 ? _a : doc === null || doc === void 0 ? void 0 : doc.body) !== null && _b !== void 0 ? _b : null;
          }
          convertURL(url, name2, elm) {
            const self2 = this, getOption2 = self2.options.get;
            const urlConverterCallback = getUrlConverterCallback(self2);
            if (isFunction(urlConverterCallback)) {
              return urlConverterCallback.call(self2, url, elm, true, name2);
            }
            if (!getOption2("convert_urls") || elm === "link" || isObject(elm) && elm.nodeName === "LINK" || url.indexOf("file:") === 0 || url.length === 0) {
              return url;
            }
            if (getOption2("relative_urls")) {
              return self2.documentBaseURI.toRelative(url);
            }
            url = self2.documentBaseURI.toAbsolute(url, getOption2("remove_script_host"));
            return url;
          }
          addVisual(elm) {
            addVisual(this, elm);
          }
          setEditableRoot(state) {
            setEditableRoot(this, state);
          }
          hasEditableRoot() {
            return hasEditableRoot(this);
          }
          remove() {
            remove$1(this);
          }
          destroy(automatic) {
            destroy(this, automatic);
          }
          uploadImages() {
            return this.editorUpload.uploadImages();
          }
          _scanForImages() {
            return this.editorUpload.scanForImages();
          }
        }
        const DOM = DOMUtils.DOM;
        const each = Tools.each;
        let boundGlobalEvents = false;
        let beforeUnloadDelegate;
        let editors = [];
        const globalEventDelegate = (e2) => {
          const type2 = e2.type;
          each(EditorManager.get(), (editor) => {
            switch (type2) {
              case "scroll":
                editor.dispatch("ScrollWindow", e2);
                break;
              case "resize":
                editor.dispatch("ResizeWindow", e2);
                break;
            }
          });
        };
        const toggleGlobalEvents = (state) => {
          if (state !== boundGlobalEvents) {
            const DOM2 = DOMUtils.DOM;
            if (state) {
              DOM2.bind(window, "resize", globalEventDelegate);
              DOM2.bind(window, "scroll", globalEventDelegate);
            } else {
              DOM2.unbind(window, "resize", globalEventDelegate);
              DOM2.unbind(window, "scroll", globalEventDelegate);
            }
            boundGlobalEvents = state;
          }
        };
        const removeEditorFromList = (targetEditor) => {
          const oldEditors = editors;
          editors = filter$5(editors, (editor) => {
            return targetEditor !== editor;
          });
          if (EditorManager.activeEditor === targetEditor) {
            EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;
          }
          if (EditorManager.focusedEditor === targetEditor) {
            EditorManager.focusedEditor = null;
          }
          return oldEditors.length !== editors.length;
        };
        const purgeDestroyedEditor = (editor) => {
          if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {
            removeEditorFromList(editor);
            editor.unbindAllNativeEvents();
            editor.destroy(true);
            editor.removed = true;
          }
        };
        const isQuirksMode = document.compatMode !== "CSS1Compat";
        const EditorManager = {
          ...Observable,
          baseURI: null,
          baseURL: null,
          defaultOptions: {},
          documentBaseURL: null,
          suffix: null,
          majorVersion: "6",
          minorVersion: "6.0",
          releaseDate: "2023-07-12",
          i18n: I18n,
          activeEditor: null,
          focusedEditor: null,
          setup() {
            const self2 = this;
            let baseURL = "";
            let suffix = "";
            let documentBaseURL = URI.getDocumentBaseUrl(document.location);
            if (/^[^:]+:\/\/\/?[^\/]+\//.test(documentBaseURL)) {
              documentBaseURL = documentBaseURL.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, "");
              if (!/[\/\\]$/.test(documentBaseURL)) {
                documentBaseURL += "/";
              }
            }
            const preInit2 = window.tinymce || window.tinyMCEPreInit;
            if (preInit2) {
              baseURL = preInit2.base || preInit2.baseURL;
              suffix = preInit2.suffix;
            } else {
              const scripts = document.getElementsByTagName("script");
              for (let i2 = 0; i2 < scripts.length; i2++) {
                const src = scripts[i2].src || "";
                if (src === "") {
                  continue;
                }
                const srcScript = src.substring(src.lastIndexOf("/"));
                if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(src)) {
                  if (srcScript.indexOf(".min") !== -1) {
                    suffix = ".min";
                  }
                  baseURL = src.substring(0, src.lastIndexOf("/"));
                  break;
                }
              }
              if (!baseURL && document.currentScript) {
                const src = document.currentScript.src;
                if (src.indexOf(".min") !== -1) {
                  suffix = ".min";
                }
                baseURL = src.substring(0, src.lastIndexOf("/"));
              }
            }
            self2.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);
            self2.documentBaseURL = documentBaseURL;
            self2.baseURI = new URI(self2.baseURL);
            self2.suffix = suffix;
            setup$v(self2);
          },
          overrideDefaults(defaultOptions2) {
            const baseUrl = defaultOptions2.base_url;
            if (baseUrl) {
              this._setBaseUrl(baseUrl);
            }
            const suffix = defaultOptions2.suffix;
            if (suffix) {
              this.suffix = suffix;
            }
            this.defaultOptions = defaultOptions2;
            const pluginBaseUrls = defaultOptions2.plugin_base_urls;
            if (pluginBaseUrls !== void 0) {
              each$d(pluginBaseUrls, (pluginBaseUrl, pluginName) => {
                AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;
              });
            }
          },
          init(options) {
            const self2 = this;
            let result;
            const invalidInlineTargets = Tools.makeMap("area base basefont br col frame hr img input isindex link meta param embed source wbr track colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu", " ");
            const isInvalidInlineTarget = (options2, elm) => options2.inline && elm.tagName.toLowerCase() in invalidInlineTargets;
            const createId = (elm) => {
              let id = elm.id;
              if (!id) {
                id = get$a(elm, "name").filter((name2) => !DOM.get(name2)).getOrThunk(DOM.uniqueId);
                elm.setAttribute("id", id);
              }
              return id;
            };
            const execCallback = (name2) => {
              const callback = options[name2];
              if (!callback) {
                return;
              }
              return callback.apply(self2, []);
            };
            const findTargets = (options2) => {
              if (Env.browser.isIE() || Env.browser.isEdge()) {
                initError("TinyMCE does not support the browser you are using. For a list of supported browsers please see: https://www.tiny.cloud/docs/tinymce/6/support/#supportedwebbrowsers");
                return [];
              } else if (isQuirksMode) {
                initError("Failed to initialize the editor as the document is not in standards mode. TinyMCE requires standards mode.");
                return [];
              } else if (isString(options2.selector)) {
                return DOM.select(options2.selector);
              } else if (isNonNullable(options2.target)) {
                return [options2.target];
              } else {
                return [];
              }
            };
            let provideResults = (editors2) => {
              result = editors2;
            };
            const initEditors = () => {
              let initCount = 0;
              const editors2 = [];
              let targets;
              const createEditor = (id, options2, targetElm) => {
                const editor = new Editor(id, options2, self2);
                editors2.push(editor);
                editor.on("init", () => {
                  if (++initCount === targets.length) {
                    provideResults(editors2);
                  }
                });
                editor.targetElm = editor.targetElm || targetElm;
                editor.render();
              };
              DOM.unbind(window, "ready", initEditors);
              execCallback("onpageload");
              targets = unique$1(findTargets(options));
              Tools.each(targets, (elm) => {
                purgeDestroyedEditor(self2.get(elm.id));
              });
              targets = Tools.grep(targets, (elm) => {
                return !self2.get(elm.id);
              });
              if (targets.length === 0) {
                provideResults([]);
              } else {
                each(targets, (elm) => {
                  if (isInvalidInlineTarget(options, elm)) {
                    initError("Could not initialize inline editor on invalid inline target element", elm);
                  } else {
                    createEditor(createId(elm), options, elm);
                  }
                });
              }
            };
            DOM.bind(window, "ready", initEditors);
            return new Promise((resolve2) => {
              if (result) {
                resolve2(result);
              } else {
                provideResults = (editors2) => {
                  resolve2(editors2);
                };
              }
            });
          },
          get(id) {
            if (arguments.length === 0) {
              return editors.slice(0);
            } else if (isString(id)) {
              return find$2(editors, (editor) => {
                return editor.id === id;
              }).getOr(null);
            } else if (isNumber(id)) {
              return editors[id] ? editors[id] : null;
            } else {
              return null;
            }
          },
          add(editor) {
            const self2 = this;
            const existingEditor = self2.get(editor.id);
            if (existingEditor === editor) {
              return editor;
            }
            if (existingEditor === null) {
              editors.push(editor);
            }
            toggleGlobalEvents(true);
            self2.activeEditor = editor;
            self2.dispatch("AddEditor", { editor });
            if (!beforeUnloadDelegate) {
              beforeUnloadDelegate = (e2) => {
                const event = self2.dispatch("BeforeUnload");
                if (event.returnValue) {
                  e2.preventDefault();
                  e2.returnValue = event.returnValue;
                  return event.returnValue;
                }
              };
              window.addEventListener("beforeunload", beforeUnloadDelegate);
            }
            return editor;
          },
          createEditor(id, options) {
            return this.add(new Editor(id, options, this));
          },
          remove(selector) {
            const self2 = this;
            let editor;
            if (!selector) {
              for (let i2 = editors.length - 1; i2 >= 0; i2--) {
                self2.remove(editors[i2]);
              }
              return;
            }
            if (isString(selector)) {
              each(DOM.select(selector), (elm) => {
                editor = self2.get(elm.id);
                if (editor) {
                  self2.remove(editor);
                }
              });
              return;
            }
            editor = selector;
            if (isNull(self2.get(editor.id))) {
              return null;
            }
            if (removeEditorFromList(editor)) {
              self2.dispatch("RemoveEditor", { editor });
            }
            if (editors.length === 0) {
              window.removeEventListener("beforeunload", beforeUnloadDelegate);
            }
            editor.remove();
            toggleGlobalEvents(editors.length > 0);
            return editor;
          },
          execCommand(cmd, ui, value2) {
            var _a;
            const self2 = this;
            const editorId = isObject(value2) ? (_a = value2.id) !== null && _a !== void 0 ? _a : value2.index : value2;
            switch (cmd) {
              case "mceAddEditor": {
                if (!self2.get(editorId)) {
                  const editorOptions = value2.options;
                  new Editor(editorId, editorOptions, self2).render();
                }
                return true;
              }
              case "mceRemoveEditor": {
                const editor = self2.get(editorId);
                if (editor) {
                  editor.remove();
                }
                return true;
              }
              case "mceToggleEditor": {
                const editor = self2.get(editorId);
                if (!editor) {
                  self2.execCommand("mceAddEditor", false, value2);
                  return true;
                }
                if (editor.isHidden()) {
                  editor.show();
                } else {
                  editor.hide();
                }
                return true;
              }
            }
            if (self2.activeEditor) {
              return self2.activeEditor.execCommand(cmd, ui, value2);
            }
            return false;
          },
          triggerSave: () => {
            each(editors, (editor) => {
              editor.save();
            });
          },
          addI18n: (code, items) => {
            I18n.add(code, items);
          },
          translate: (text2) => {
            return I18n.translate(text2);
          },
          setActive(editor) {
            const activeEditor = this.activeEditor;
            if (this.activeEditor !== editor) {
              if (activeEditor) {
                activeEditor.dispatch("deactivate", { relatedTarget: editor });
              }
              editor.dispatch("activate", { relatedTarget: activeEditor });
            }
            this.activeEditor = editor;
          },
          _setBaseUrl(baseUrl) {
            this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\/+$/, ""));
            this.baseURI = new URI(this.baseURL);
          }
        };
        EditorManager.setup();
        const setup = () => {
          const dataValue = value$2();
          const FakeClipboardItem = (items) => ({
            items,
            types: keys(items),
            getType: (type2) => get$a(items, type2).getOrUndefined()
          });
          const write3 = (data2) => {
            dataValue.set(data2);
          };
          const read3 = () => dataValue.get().getOrUndefined();
          const clear2 = dataValue.clear;
          return {
            FakeClipboardItem,
            write: write3,
            read: read3,
            clear: clear2
          };
        };
        const FakeClipboard = setup();
        const min2 = Math.min, max2 = Math.max, round2 = Math.round;
        const relativePosition = (rect, targetRect, rel) => {
          let x2 = targetRect.x;
          let y2 = targetRect.y;
          const w2 = rect.w;
          const h2 = rect.h;
          const targetW = targetRect.w;
          const targetH = targetRect.h;
          const relChars = (rel || "").split("");
          if (relChars[0] === "b") {
            y2 += targetH;
          }
          if (relChars[1] === "r") {
            x2 += targetW;
          }
          if (relChars[0] === "c") {
            y2 += round2(targetH / 2);
          }
          if (relChars[1] === "c") {
            x2 += round2(targetW / 2);
          }
          if (relChars[3] === "b") {
            y2 -= h2;
          }
          if (relChars[4] === "r") {
            x2 -= w2;
          }
          if (relChars[3] === "c") {
            y2 -= round2(h2 / 2);
          }
          if (relChars[4] === "c") {
            x2 -= round2(w2 / 2);
          }
          return create$2(x2, y2, w2, h2);
        };
        const findBestRelativePosition = (rect, targetRect, constrainRect, rels) => {
          for (let i2 = 0; i2 < rels.length; i2++) {
            const pos = relativePosition(rect, targetRect, rels[i2]);
            if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {
              return rels[i2];
            }
          }
          return null;
        };
        const inflate = (rect, w2, h2) => {
          return create$2(rect.x - w2, rect.y - h2, rect.w + w2 * 2, rect.h + h2 * 2);
        };
        const intersect = (rect, cropRect) => {
          const x1 = max2(rect.x, cropRect.x);
          const y1 = max2(rect.y, cropRect.y);
          const x2 = min2(rect.x + rect.w, cropRect.x + cropRect.w);
          const y2 = min2(rect.y + rect.h, cropRect.y + cropRect.h);
          if (x2 - x1 < 0 || y2 - y1 < 0) {
            return null;
          }
          return create$2(x1, y1, x2 - x1, y2 - y1);
        };
        const clamp = (rect, clampRect, fixedSize) => {
          let x1 = rect.x;
          let y1 = rect.y;
          let x2 = rect.x + rect.w;
          let y2 = rect.y + rect.h;
          const cx2 = clampRect.x + clampRect.w;
          const cy2 = clampRect.y + clampRect.h;
          const underflowX1 = max2(0, clampRect.x - x1);
          const underflowY1 = max2(0, clampRect.y - y1);
          const overflowX2 = max2(0, x2 - cx2);
          const overflowY2 = max2(0, y2 - cy2);
          x1 += underflowX1;
          y1 += underflowY1;
          if (fixedSize) {
            x2 += underflowX1;
            y2 += underflowY1;
            x1 -= overflowX2;
            y1 -= overflowY2;
          }
          x2 -= overflowX2;
          y2 -= overflowY2;
          return create$2(x1, y1, x2 - x1, y2 - y1);
        };
        const create$2 = (x2, y2, w2, h2) => {
          return {
            x: x2,
            y: y2,
            w: w2,
            h: h2
          };
        };
        const fromClientRect = (clientRect) => {
          return create$2(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
        };
        const Rect = {
          inflate,
          relativePosition,
          findBestRelativePosition,
          intersect,
          clamp,
          create: create$2,
          fromClientRect
        };
        const awaiter = (resolveCb, rejectCb, timeout = 1e3) => {
          let done = false;
          let timer = null;
          const complete = (completer) => (...args) => {
            if (!done) {
              done = true;
              if (timer !== null) {
                clearTimeout(timer);
                timer = null;
              }
              completer.apply(null, args);
            }
          };
          const resolve2 = complete(resolveCb);
          const reject = complete(rejectCb);
          const start4 = (...args) => {
            if (!done && timer === null) {
              timer = setTimeout(() => reject.apply(null, args), timeout);
            }
          };
          return {
            start: start4,
            resolve: resolve2,
            reject
          };
        };
        const create$1 = () => {
          const tasks = {};
          const resultFns = {};
          const load = (id, url) => {
            const loadErrMsg = `Script at URL "${url}" failed to load`;
            const runErrMsg = `Script at URL "${url}" did not call \`tinymce.Resource.add('${id}', data)\` within 1 second`;
            if (tasks[id] !== void 0) {
              return tasks[id];
            } else {
              const task = new Promise((resolve2, reject) => {
                const waiter = awaiter(resolve2, reject);
                resultFns[id] = waiter.resolve;
                ScriptLoader.ScriptLoader.loadScript(url).then(() => waiter.start(runErrMsg), () => waiter.reject(loadErrMsg));
              });
              tasks[id] = task;
              return task;
            }
          };
          const add3 = (id, data2) => {
            if (resultFns[id] !== void 0) {
              resultFns[id](data2);
              delete resultFns[id];
            }
            tasks[id] = Promise.resolve(data2);
          };
          const unload = (id) => {
            delete tasks[id];
          };
          return {
            load,
            add: add3,
            unload
          };
        };
        const Resource = create$1();
        const create = () => (() => {
          let data2 = {};
          let keys2 = [];
          const storage = {
            getItem: (key) => {
              const item = data2[key];
              return item ? item : null;
            },
            setItem: (key, value2) => {
              keys2.push(key);
              data2[key] = String(value2);
            },
            key: (index) => {
              return keys2[index];
            },
            removeItem: (key) => {
              keys2 = keys2.filter((k2) => k2 === key);
              delete data2[key];
            },
            clear: () => {
              keys2 = [];
              data2 = {};
            },
            length: 0
          };
          Object.defineProperty(storage, "length", {
            get: () => keys2.length,
            configurable: false,
            enumerable: false
          });
          return storage;
        })();
        let localStorage2;
        try {
          const test = "__storage_test__";
          localStorage2 = window.localStorage;
          localStorage2.setItem(test, test);
          localStorage2.removeItem(test);
        } catch (e2) {
          localStorage2 = create();
        }
        var LocalStorage = localStorage2;
        const publicApi = {
          geom: { Rect },
          util: {
            Delay,
            Tools,
            VK,
            URI,
            EventDispatcher,
            Observable,
            I18n,
            LocalStorage,
            ImageUploader
          },
          dom: {
            EventUtils,
            TreeWalker: DomTreeWalker,
            TextSeeker,
            DOMUtils,
            ScriptLoader,
            RangeUtils,
            Serializer: DomSerializer,
            StyleSheetLoader,
            ControlSelection,
            BookmarkManager,
            Selection: EditorSelection,
            Event: EventUtils.Event
          },
          html: {
            Styles,
            Entities,
            Node: AstNode,
            Schema,
            DomParser,
            Writer,
            Serializer: HtmlSerializer
          },
          Env,
          AddOnManager,
          Annotator,
          Formatter,
          UndoManager,
          EditorCommands,
          WindowManager,
          NotificationManager,
          EditorObservable,
          Shortcuts,
          Editor,
          FocusManager,
          EditorManager,
          DOM: DOMUtils.DOM,
          ScriptLoader: ScriptLoader.ScriptLoader,
          PluginManager,
          ThemeManager,
          ModelManager,
          IconManager,
          Resource,
          FakeClipboard,
          trim: Tools.trim,
          isArray: Tools.isArray,
          is: Tools.is,
          toArray: Tools.toArray,
          makeMap: Tools.makeMap,
          each: Tools.each,
          map: Tools.map,
          grep: Tools.grep,
          inArray: Tools.inArray,
          extend: Tools.extend,
          walk: Tools.walk,
          resolve: Tools.resolve,
          explode: Tools.explode,
          _addCacheSuffix: Tools._addCacheSuffix
        };
        const tinymce2 = Tools.extend(EditorManager, publicApi);
        const exportToModuleLoaders = (tinymce3) => {
          if (typeof module === "object") {
            try {
              module.exports = tinymce3;
            } catch (_2) {
            }
          }
        };
        const exportToWindowGlobal = (tinymce3) => {
          window.tinymce = tinymce3;
          window.tinyMCE = tinymce3;
        };
        exportToWindowGlobal(tinymce2);
        exportToModuleLoaders(tinymce2);
      })();
    }
  });

  // node_modules/@hotwired/stimulus/dist/stimulus.js
  var EventListener = class {
    constructor(eventTarget, eventName, eventOptions) {
      this.eventTarget = eventTarget;
      this.eventName = eventName;
      this.eventOptions = eventOptions;
      this.unorderedBindings = /* @__PURE__ */ new Set();
    }
    connect() {
      this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
    }
    disconnect() {
      this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
    }
    bindingConnected(binding) {
      this.unorderedBindings.add(binding);
    }
    bindingDisconnected(binding) {
      this.unorderedBindings.delete(binding);
    }
    handleEvent(event) {
      const extendedEvent = extendEvent(event);
      for (const binding of this.bindings) {
        if (extendedEvent.immediatePropagationStopped) {
          break;
        } else {
          binding.handleEvent(extendedEvent);
        }
      }
    }
    hasBindings() {
      return this.unorderedBindings.size > 0;
    }
    get bindings() {
      return Array.from(this.unorderedBindings).sort((left2, right2) => {
        const leftIndex = left2.index, rightIndex = right2.index;
        return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
      });
    }
  };
  function extendEvent(event) {
    if ("immediatePropagationStopped" in event) {
      return event;
    } else {
      const { stopImmediatePropagation } = event;
      return Object.assign(event, {
        immediatePropagationStopped: false,
        stopImmediatePropagation() {
          this.immediatePropagationStopped = true;
          stopImmediatePropagation.call(this);
        }
      });
    }
  }
  var Dispatcher = class {
    constructor(application2) {
      this.application = application2;
      this.eventListenerMaps = /* @__PURE__ */ new Map();
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.eventListeners.forEach((eventListener) => eventListener.connect());
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.eventListeners.forEach((eventListener) => eventListener.disconnect());
      }
    }
    get eventListeners() {
      return Array.from(this.eventListenerMaps.values()).reduce((listeners, map) => listeners.concat(Array.from(map.values())), []);
    }
    bindingConnected(binding) {
      this.fetchEventListenerForBinding(binding).bindingConnected(binding);
    }
    bindingDisconnected(binding, clearEventListeners = false) {
      this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
      if (clearEventListeners)
        this.clearEventListenersForBinding(binding);
    }
    handleError(error2, message, detail = {}) {
      this.application.handleError(error2, `Error ${message}`, detail);
    }
    clearEventListenersForBinding(binding) {
      const eventListener = this.fetchEventListenerForBinding(binding);
      if (!eventListener.hasBindings()) {
        eventListener.disconnect();
        this.removeMappedEventListenerFor(binding);
      }
    }
    removeMappedEventListenerFor(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      eventListenerMap.delete(cacheKey);
      if (eventListenerMap.size == 0)
        this.eventListenerMaps.delete(eventTarget);
    }
    fetchEventListenerForBinding(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      return this.fetchEventListener(eventTarget, eventName, eventOptions);
    }
    fetchEventListener(eventTarget, eventName, eventOptions) {
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      let eventListener = eventListenerMap.get(cacheKey);
      if (!eventListener) {
        eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
        eventListenerMap.set(cacheKey, eventListener);
      }
      return eventListener;
    }
    createEventListener(eventTarget, eventName, eventOptions) {
      const eventListener = new EventListener(eventTarget, eventName, eventOptions);
      if (this.started) {
        eventListener.connect();
      }
      return eventListener;
    }
    fetchEventListenerMapForEventTarget(eventTarget) {
      let eventListenerMap = this.eventListenerMaps.get(eventTarget);
      if (!eventListenerMap) {
        eventListenerMap = /* @__PURE__ */ new Map();
        this.eventListenerMaps.set(eventTarget, eventListenerMap);
      }
      return eventListenerMap;
    }
    cacheKey(eventName, eventOptions) {
      const parts = [eventName];
      Object.keys(eventOptions).sort().forEach((key) => {
        parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
      });
      return parts.join(":");
    }
  };
  var defaultActionDescriptorFilters = {
    stop({ event, value }) {
      if (value)
        event.stopPropagation();
      return true;
    },
    prevent({ event, value }) {
      if (value)
        event.preventDefault();
      return true;
    },
    self({ event, value, element }) {
      if (value) {
        return element === event.target;
      } else {
        return true;
      }
    }
  };
  var descriptorPattern = /^(?:(?:([^.]+?)\+)?(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
  function parseActionDescriptorString(descriptorString) {
    const source = descriptorString.trim();
    const matches = source.match(descriptorPattern) || [];
    let eventName = matches[2];
    let keyFilter = matches[3];
    if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
      eventName += `.${keyFilter}`;
      keyFilter = "";
    }
    return {
      eventTarget: parseEventTarget(matches[4]),
      eventName,
      eventOptions: matches[7] ? parseEventOptions(matches[7]) : {},
      identifier: matches[5],
      methodName: matches[6],
      keyFilter: matches[1] || keyFilter
    };
  }
  function parseEventTarget(eventTargetName) {
    if (eventTargetName == "window") {
      return window;
    } else if (eventTargetName == "document") {
      return document;
    }
  }
  function parseEventOptions(eventOptions) {
    return eventOptions.split(":").reduce((options, token) => Object.assign(options, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
  }
  function stringifyEventTarget(eventTarget) {
    if (eventTarget == window) {
      return "window";
    } else if (eventTarget == document) {
      return "document";
    }
  }
  function camelize(value) {
    return value.replace(/(?:[_-])([a-z0-9])/g, (_2, char) => char.toUpperCase());
  }
  function namespaceCamelize(value) {
    return camelize(value.replace(/--/g, "-").replace(/__/g, "_"));
  }
  function capitalize(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
  function dasherize(value) {
    return value.replace(/([A-Z])/g, (_2, char) => `-${char.toLowerCase()}`);
  }
  function tokenize(value) {
    return value.match(/[^\s]+/g) || [];
  }
  function isSomething(object) {
    return object !== null && object !== void 0;
  }
  function hasProperty(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }
  var allModifiers = ["meta", "ctrl", "alt", "shift"];
  var Action = class {
    constructor(element, index, descriptor, schema) {
      this.element = element;
      this.index = index;
      this.eventTarget = descriptor.eventTarget || element;
      this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
      this.eventOptions = descriptor.eventOptions || {};
      this.identifier = descriptor.identifier || error("missing identifier");
      this.methodName = descriptor.methodName || error("missing method name");
      this.keyFilter = descriptor.keyFilter || "";
      this.schema = schema;
    }
    static forToken(token, schema) {
      return new this(token.element, token.index, parseActionDescriptorString(token.content), schema);
    }
    toString() {
      const eventFilter = this.keyFilter ? `.${this.keyFilter}` : "";
      const eventTarget = this.eventTargetName ? `@${this.eventTargetName}` : "";
      return `${this.eventName}${eventFilter}${eventTarget}->${this.identifier}#${this.methodName}`;
    }
    shouldIgnoreKeyboardEvent(event) {
      if (!this.keyFilter) {
        return false;
      }
      const filters = this.keyFilter.split("+");
      if (this.keyFilterDissatisfied(event, filters)) {
        return true;
      }
      const standardFilter = filters.filter((key) => !allModifiers.includes(key))[0];
      if (!standardFilter) {
        return false;
      }
      if (!hasProperty(this.keyMappings, standardFilter)) {
        error(`contains unknown key filter: ${this.keyFilter}`);
      }
      return this.keyMappings[standardFilter].toLowerCase() !== event.key.toLowerCase();
    }
    shouldIgnoreMouseEvent(event) {
      if (!this.keyFilter) {
        return false;
      }
      const filters = [this.keyFilter];
      if (this.keyFilterDissatisfied(event, filters)) {
        return true;
      }
      return false;
    }
    get params() {
      const params = {};
      const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`, "i");
      for (const { name, value } of Array.from(this.element.attributes)) {
        const match = name.match(pattern);
        const key = match && match[1];
        if (key) {
          params[camelize(key)] = typecast(value);
        }
      }
      return params;
    }
    get eventTargetName() {
      return stringifyEventTarget(this.eventTarget);
    }
    get keyMappings() {
      return this.schema.keyMappings;
    }
    keyFilterDissatisfied(event, filters) {
      const [meta, ctrl, alt, shift] = allModifiers.map((modifier) => filters.includes(modifier));
      return event.metaKey !== meta || event.ctrlKey !== ctrl || event.altKey !== alt || event.shiftKey !== shift;
    }
  };
  var defaultEventNames = {
    a: () => "click",
    button: () => "click",
    form: () => "submit",
    details: () => "toggle",
    input: (e2) => e2.getAttribute("type") == "submit" ? "click" : "input",
    select: () => "change",
    textarea: () => "input"
  };
  function getDefaultEventNameForElement(element) {
    const tagName = element.tagName.toLowerCase();
    if (tagName in defaultEventNames) {
      return defaultEventNames[tagName](element);
    }
  }
  function error(message) {
    throw new Error(message);
  }
  function typecast(value) {
    try {
      return JSON.parse(value);
    } catch (o_O) {
      return value;
    }
  }
  var Binding = class {
    constructor(context, action) {
      this.context = context;
      this.action = action;
    }
    get index() {
      return this.action.index;
    }
    get eventTarget() {
      return this.action.eventTarget;
    }
    get eventOptions() {
      return this.action.eventOptions;
    }
    get identifier() {
      return this.context.identifier;
    }
    handleEvent(event) {
      const actionEvent = this.prepareActionEvent(event);
      if (this.willBeInvokedByEvent(event) && this.applyEventModifiers(actionEvent)) {
        this.invokeWithEvent(actionEvent);
      }
    }
    get eventName() {
      return this.action.eventName;
    }
    get method() {
      const method = this.controller[this.methodName];
      if (typeof method == "function") {
        return method;
      }
      throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
    }
    applyEventModifiers(event) {
      const { element } = this.action;
      const { actionDescriptorFilters } = this.context.application;
      const { controller } = this.context;
      let passes = true;
      for (const [name, value] of Object.entries(this.eventOptions)) {
        if (name in actionDescriptorFilters) {
          const filter = actionDescriptorFilters[name];
          passes = passes && filter({ name, value, event, element, controller });
        } else {
          continue;
        }
      }
      return passes;
    }
    prepareActionEvent(event) {
      return Object.assign(event, { params: this.action.params });
    }
    invokeWithEvent(event) {
      const { target, currentTarget } = event;
      try {
        this.method.call(this.controller, event);
        this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
      } catch (error2) {
        const { identifier, controller, element, index } = this;
        const detail = { identifier, controller, element, index, event };
        this.context.handleError(error2, `invoking action "${this.action}"`, detail);
      }
    }
    willBeInvokedByEvent(event) {
      const eventTarget = event.target;
      if (event instanceof KeyboardEvent && this.action.shouldIgnoreKeyboardEvent(event)) {
        return false;
      }
      if (event instanceof MouseEvent && this.action.shouldIgnoreMouseEvent(event)) {
        return false;
      }
      if (this.element === eventTarget) {
        return true;
      } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
        return this.scope.containsElement(eventTarget);
      } else {
        return this.scope.containsElement(this.action.element);
      }
    }
    get controller() {
      return this.context.controller;
    }
    get methodName() {
      return this.action.methodName;
    }
    get element() {
      return this.scope.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  var ElementObserver = class {
    constructor(element, delegate) {
      this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
      this.element = element;
      this.started = false;
      this.delegate = delegate;
      this.elements = /* @__PURE__ */ new Set();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.refresh();
      }
    }
    pause(callback) {
      if (this.started) {
        this.mutationObserver.disconnect();
        this.started = false;
      }
      callback();
      if (!this.started) {
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        const matches = new Set(this.matchElementsInTree());
        for (const element of Array.from(this.elements)) {
          if (!matches.has(element)) {
            this.removeElement(element);
          }
        }
        for (const element of Array.from(matches)) {
          this.addElement(element);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      if (mutation.type == "attributes") {
        this.processAttributeChange(mutation.target, mutation.attributeName);
      } else if (mutation.type == "childList") {
        this.processRemovedNodes(mutation.removedNodes);
        this.processAddedNodes(mutation.addedNodes);
      }
    }
    processAttributeChange(element, attributeName) {
      if (this.elements.has(element)) {
        if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
          this.delegate.elementAttributeChanged(element, attributeName);
        } else {
          this.removeElement(element);
        }
      } else if (this.matchElement(element)) {
        this.addElement(element);
      }
    }
    processRemovedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element) {
          this.processTree(element, this.removeElement);
        }
      }
    }
    processAddedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element && this.elementIsActive(element)) {
          this.processTree(element, this.addElement);
        }
      }
    }
    matchElement(element) {
      return this.delegate.matchElement(element);
    }
    matchElementsInTree(tree = this.element) {
      return this.delegate.matchElementsInTree(tree);
    }
    processTree(tree, processor) {
      for (const element of this.matchElementsInTree(tree)) {
        processor.call(this, element);
      }
    }
    elementFromNode(node) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        return node;
      }
    }
    elementIsActive(element) {
      if (element.isConnected != this.element.isConnected) {
        return false;
      } else {
        return this.element.contains(element);
      }
    }
    addElement(element) {
      if (!this.elements.has(element)) {
        if (this.elementIsActive(element)) {
          this.elements.add(element);
          if (this.delegate.elementMatched) {
            this.delegate.elementMatched(element);
          }
        }
      }
    }
    removeElement(element) {
      if (this.elements.has(element)) {
        this.elements.delete(element);
        if (this.delegate.elementUnmatched) {
          this.delegate.elementUnmatched(element);
        }
      }
    }
  };
  var AttributeObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeName = attributeName;
      this.delegate = delegate;
      this.elementObserver = new ElementObserver(element, this);
    }
    get element() {
      return this.elementObserver.element;
    }
    get selector() {
      return `[${this.attributeName}]`;
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback) {
      this.elementObserver.pause(callback);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get started() {
      return this.elementObserver.started;
    }
    matchElement(element) {
      return element.hasAttribute(this.attributeName);
    }
    matchElementsInTree(tree) {
      const match = this.matchElement(tree) ? [tree] : [];
      const matches = Array.from(tree.querySelectorAll(this.selector));
      return match.concat(matches);
    }
    elementMatched(element) {
      if (this.delegate.elementMatchedAttribute) {
        this.delegate.elementMatchedAttribute(element, this.attributeName);
      }
    }
    elementUnmatched(element) {
      if (this.delegate.elementUnmatchedAttribute) {
        this.delegate.elementUnmatchedAttribute(element, this.attributeName);
      }
    }
    elementAttributeChanged(element, attributeName) {
      if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
        this.delegate.elementAttributeValueChanged(element, attributeName);
      }
    }
  };
  function add(map, key, value) {
    fetch2(map, key).add(value);
  }
  function del(map, key, value) {
    fetch2(map, key).delete(value);
    prune(map, key);
  }
  function fetch2(map, key) {
    let values = map.get(key);
    if (!values) {
      values = /* @__PURE__ */ new Set();
      map.set(key, values);
    }
    return values;
  }
  function prune(map, key) {
    const values = map.get(key);
    if (values != null && values.size == 0) {
      map.delete(key);
    }
  }
  var Multimap = class {
    constructor() {
      this.valuesByKey = /* @__PURE__ */ new Map();
    }
    get keys() {
      return Array.from(this.valuesByKey.keys());
    }
    get values() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((values, set) => values.concat(Array.from(set)), []);
    }
    get size() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((size, set) => size + set.size, 0);
    }
    add(key, value) {
      add(this.valuesByKey, key, value);
    }
    delete(key, value) {
      del(this.valuesByKey, key, value);
    }
    has(key, value) {
      const values = this.valuesByKey.get(key);
      return values != null && values.has(value);
    }
    hasKey(key) {
      return this.valuesByKey.has(key);
    }
    hasValue(value) {
      const sets = Array.from(this.valuesByKey.values());
      return sets.some((set) => set.has(value));
    }
    getValuesForKey(key) {
      const values = this.valuesByKey.get(key);
      return values ? Array.from(values) : [];
    }
    getKeysForValue(value) {
      return Array.from(this.valuesByKey).filter(([_key, values]) => values.has(value)).map(([key, _values]) => key);
    }
  };
  var SelectorObserver = class {
    constructor(element, selector, delegate, details) {
      this._selector = selector;
      this.details = details;
      this.elementObserver = new ElementObserver(element, this);
      this.delegate = delegate;
      this.matchesByElement = new Multimap();
    }
    get started() {
      return this.elementObserver.started;
    }
    get selector() {
      return this._selector;
    }
    set selector(selector) {
      this._selector = selector;
      this.refresh();
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback) {
      this.elementObserver.pause(callback);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get element() {
      return this.elementObserver.element;
    }
    matchElement(element) {
      const { selector } = this;
      if (selector) {
        const matches = element.matches(selector);
        if (this.delegate.selectorMatchElement) {
          return matches && this.delegate.selectorMatchElement(element, this.details);
        }
        return matches;
      } else {
        return false;
      }
    }
    matchElementsInTree(tree) {
      const { selector } = this;
      if (selector) {
        const match = this.matchElement(tree) ? [tree] : [];
        const matches = Array.from(tree.querySelectorAll(selector)).filter((match2) => this.matchElement(match2));
        return match.concat(matches);
      } else {
        return [];
      }
    }
    elementMatched(element) {
      const { selector } = this;
      if (selector) {
        this.selectorMatched(element, selector);
      }
    }
    elementUnmatched(element) {
      const selectors = this.matchesByElement.getKeysForValue(element);
      for (const selector of selectors) {
        this.selectorUnmatched(element, selector);
      }
    }
    elementAttributeChanged(element, _attributeName) {
      const { selector } = this;
      if (selector) {
        const matches = this.matchElement(element);
        const matchedBefore = this.matchesByElement.has(selector, element);
        if (matches && !matchedBefore) {
          this.selectorMatched(element, selector);
        } else if (!matches && matchedBefore) {
          this.selectorUnmatched(element, selector);
        }
      }
    }
    selectorMatched(element, selector) {
      this.delegate.selectorMatched(element, selector, this.details);
      this.matchesByElement.add(selector, element);
    }
    selectorUnmatched(element, selector) {
      this.delegate.selectorUnmatched(element, selector, this.details);
      this.matchesByElement.delete(selector, element);
    }
  };
  var StringMapObserver = class {
    constructor(element, delegate) {
      this.element = element;
      this.delegate = delegate;
      this.started = false;
      this.stringMap = /* @__PURE__ */ new Map();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
        this.refresh();
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        for (const attributeName of this.knownAttributeNames) {
          this.refreshAttribute(attributeName, null);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      const attributeName = mutation.attributeName;
      if (attributeName) {
        this.refreshAttribute(attributeName, mutation.oldValue);
      }
    }
    refreshAttribute(attributeName, oldValue) {
      const key = this.delegate.getStringMapKeyForAttribute(attributeName);
      if (key != null) {
        if (!this.stringMap.has(attributeName)) {
          this.stringMapKeyAdded(key, attributeName);
        }
        const value = this.element.getAttribute(attributeName);
        if (this.stringMap.get(attributeName) != value) {
          this.stringMapValueChanged(value, key, oldValue);
        }
        if (value == null) {
          const oldValue2 = this.stringMap.get(attributeName);
          this.stringMap.delete(attributeName);
          if (oldValue2)
            this.stringMapKeyRemoved(key, attributeName, oldValue2);
        } else {
          this.stringMap.set(attributeName, value);
        }
      }
    }
    stringMapKeyAdded(key, attributeName) {
      if (this.delegate.stringMapKeyAdded) {
        this.delegate.stringMapKeyAdded(key, attributeName);
      }
    }
    stringMapValueChanged(value, key, oldValue) {
      if (this.delegate.stringMapValueChanged) {
        this.delegate.stringMapValueChanged(value, key, oldValue);
      }
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      if (this.delegate.stringMapKeyRemoved) {
        this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
      }
    }
    get knownAttributeNames() {
      return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
    }
    get currentAttributeNames() {
      return Array.from(this.element.attributes).map((attribute) => attribute.name);
    }
    get recordedAttributeNames() {
      return Array.from(this.stringMap.keys());
    }
  };
  var TokenListObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeObserver = new AttributeObserver(element, attributeName, this);
      this.delegate = delegate;
      this.tokensByElement = new Multimap();
    }
    get started() {
      return this.attributeObserver.started;
    }
    start() {
      this.attributeObserver.start();
    }
    pause(callback) {
      this.attributeObserver.pause(callback);
    }
    stop() {
      this.attributeObserver.stop();
    }
    refresh() {
      this.attributeObserver.refresh();
    }
    get element() {
      return this.attributeObserver.element;
    }
    get attributeName() {
      return this.attributeObserver.attributeName;
    }
    elementMatchedAttribute(element) {
      this.tokensMatched(this.readTokensForElement(element));
    }
    elementAttributeValueChanged(element) {
      const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
      this.tokensUnmatched(unmatchedTokens);
      this.tokensMatched(matchedTokens);
    }
    elementUnmatchedAttribute(element) {
      this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
    }
    tokensMatched(tokens) {
      tokens.forEach((token) => this.tokenMatched(token));
    }
    tokensUnmatched(tokens) {
      tokens.forEach((token) => this.tokenUnmatched(token));
    }
    tokenMatched(token) {
      this.delegate.tokenMatched(token);
      this.tokensByElement.add(token.element, token);
    }
    tokenUnmatched(token) {
      this.delegate.tokenUnmatched(token);
      this.tokensByElement.delete(token.element, token);
    }
    refreshTokensForElement(element) {
      const previousTokens = this.tokensByElement.getValuesForKey(element);
      const currentTokens = this.readTokensForElement(element);
      const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
      if (firstDifferingIndex == -1) {
        return [[], []];
      } else {
        return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
      }
    }
    readTokensForElement(element) {
      const attributeName = this.attributeName;
      const tokenString = element.getAttribute(attributeName) || "";
      return parseTokenString(tokenString, element, attributeName);
    }
  };
  function parseTokenString(tokenString, element, attributeName) {
    return tokenString.trim().split(/\s+/).filter((content) => content.length).map((content, index) => ({ element, attributeName, content, index }));
  }
  function zip(left2, right2) {
    const length = Math.max(left2.length, right2.length);
    return Array.from({ length }, (_2, index) => [left2[index], right2[index]]);
  }
  function tokensAreEqual(left2, right2) {
    return left2 && right2 && left2.index == right2.index && left2.content == right2.content;
  }
  var ValueListObserver = class {
    constructor(element, attributeName, delegate) {
      this.tokenListObserver = new TokenListObserver(element, attributeName, this);
      this.delegate = delegate;
      this.parseResultsByToken = /* @__PURE__ */ new WeakMap();
      this.valuesByTokenByElement = /* @__PURE__ */ new WeakMap();
    }
    get started() {
      return this.tokenListObserver.started;
    }
    start() {
      this.tokenListObserver.start();
    }
    stop() {
      this.tokenListObserver.stop();
    }
    refresh() {
      this.tokenListObserver.refresh();
    }
    get element() {
      return this.tokenListObserver.element;
    }
    get attributeName() {
      return this.tokenListObserver.attributeName;
    }
    tokenMatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).set(token, value);
        this.delegate.elementMatchedValue(element, value);
      }
    }
    tokenUnmatched(token) {
      const { element } = token;
      const { value } = this.fetchParseResultForToken(token);
      if (value) {
        this.fetchValuesByTokenForElement(element).delete(token);
        this.delegate.elementUnmatchedValue(element, value);
      }
    }
    fetchParseResultForToken(token) {
      let parseResult = this.parseResultsByToken.get(token);
      if (!parseResult) {
        parseResult = this.parseToken(token);
        this.parseResultsByToken.set(token, parseResult);
      }
      return parseResult;
    }
    fetchValuesByTokenForElement(element) {
      let valuesByToken = this.valuesByTokenByElement.get(element);
      if (!valuesByToken) {
        valuesByToken = /* @__PURE__ */ new Map();
        this.valuesByTokenByElement.set(element, valuesByToken);
      }
      return valuesByToken;
    }
    parseToken(token) {
      try {
        const value = this.delegate.parseValueForToken(token);
        return { value };
      } catch (error2) {
        return { error: error2 };
      }
    }
  };
  var BindingObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.bindingsByAction = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.valueListObserver) {
        this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
        this.valueListObserver.start();
      }
    }
    stop() {
      if (this.valueListObserver) {
        this.valueListObserver.stop();
        delete this.valueListObserver;
        this.disconnectAllActions();
      }
    }
    get element() {
      return this.context.element;
    }
    get identifier() {
      return this.context.identifier;
    }
    get actionAttribute() {
      return this.schema.actionAttribute;
    }
    get schema() {
      return this.context.schema;
    }
    get bindings() {
      return Array.from(this.bindingsByAction.values());
    }
    connectAction(action) {
      const binding = new Binding(this.context, action);
      this.bindingsByAction.set(action, binding);
      this.delegate.bindingConnected(binding);
    }
    disconnectAction(action) {
      const binding = this.bindingsByAction.get(action);
      if (binding) {
        this.bindingsByAction.delete(action);
        this.delegate.bindingDisconnected(binding);
      }
    }
    disconnectAllActions() {
      this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding, true));
      this.bindingsByAction.clear();
    }
    parseValueForToken(token) {
      const action = Action.forToken(token, this.schema);
      if (action.identifier == this.identifier) {
        return action;
      }
    }
    elementMatchedValue(element, action) {
      this.connectAction(action);
    }
    elementUnmatchedValue(element, action) {
      this.disconnectAction(action);
    }
  };
  var ValueObserver = class {
    constructor(context, receiver) {
      this.context = context;
      this.receiver = receiver;
      this.stringMapObserver = new StringMapObserver(this.element, this);
      this.valueDescriptorMap = this.controller.valueDescriptorMap;
    }
    start() {
      this.stringMapObserver.start();
      this.invokeChangedCallbacksForDefaultValues();
    }
    stop() {
      this.stringMapObserver.stop();
    }
    get element() {
      return this.context.element;
    }
    get controller() {
      return this.context.controller;
    }
    getStringMapKeyForAttribute(attributeName) {
      if (attributeName in this.valueDescriptorMap) {
        return this.valueDescriptorMap[attributeName].name;
      }
    }
    stringMapKeyAdded(key, attributeName) {
      const descriptor = this.valueDescriptorMap[attributeName];
      if (!this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
      }
    }
    stringMapValueChanged(value, name, oldValue) {
      const descriptor = this.valueDescriptorNameMap[name];
      if (value === null)
        return;
      if (oldValue === null) {
        oldValue = descriptor.writer(descriptor.defaultValue);
      }
      this.invokeChangedCallback(name, value, oldValue);
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      const descriptor = this.valueDescriptorNameMap[key];
      if (this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
      } else {
        this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
      }
    }
    invokeChangedCallbacksForDefaultValues() {
      for (const { key, name, defaultValue, writer } of this.valueDescriptors) {
        if (defaultValue != void 0 && !this.controller.data.has(key)) {
          this.invokeChangedCallback(name, writer(defaultValue), void 0);
        }
      }
    }
    invokeChangedCallback(name, rawValue, rawOldValue) {
      const changedMethodName = `${name}Changed`;
      const changedMethod = this.receiver[changedMethodName];
      if (typeof changedMethod == "function") {
        const descriptor = this.valueDescriptorNameMap[name];
        try {
          const value = descriptor.reader(rawValue);
          let oldValue = rawOldValue;
          if (rawOldValue) {
            oldValue = descriptor.reader(rawOldValue);
          }
          changedMethod.call(this.receiver, value, oldValue);
        } catch (error2) {
          if (error2 instanceof TypeError) {
            error2.message = `Stimulus Value "${this.context.identifier}.${descriptor.name}" - ${error2.message}`;
          }
          throw error2;
        }
      }
    }
    get valueDescriptors() {
      const { valueDescriptorMap } = this;
      return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
    }
    get valueDescriptorNameMap() {
      const descriptors = {};
      Object.keys(this.valueDescriptorMap).forEach((key) => {
        const descriptor = this.valueDescriptorMap[key];
        descriptors[descriptor.name] = descriptor;
      });
      return descriptors;
    }
    hasValue(attributeName) {
      const descriptor = this.valueDescriptorNameMap[attributeName];
      const hasMethodName = `has${capitalize(descriptor.name)}`;
      return this.receiver[hasMethodName];
    }
  };
  var TargetObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.targetsByName = new Multimap();
    }
    start() {
      if (!this.tokenListObserver) {
        this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
        this.tokenListObserver.start();
      }
    }
    stop() {
      if (this.tokenListObserver) {
        this.disconnectAllTargets();
        this.tokenListObserver.stop();
        delete this.tokenListObserver;
      }
    }
    tokenMatched({ element, content: name }) {
      if (this.scope.containsElement(element)) {
        this.connectTarget(element, name);
      }
    }
    tokenUnmatched({ element, content: name }) {
      this.disconnectTarget(element, name);
    }
    connectTarget(element, name) {
      var _a;
      if (!this.targetsByName.has(name, element)) {
        this.targetsByName.add(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name));
      }
    }
    disconnectTarget(element, name) {
      var _a;
      if (this.targetsByName.has(name, element)) {
        this.targetsByName.delete(name, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name));
      }
    }
    disconnectAllTargets() {
      for (const name of this.targetsByName.keys) {
        for (const element of this.targetsByName.getValuesForKey(name)) {
          this.disconnectTarget(element, name);
        }
      }
    }
    get attributeName() {
      return `data-${this.context.identifier}-target`;
    }
    get element() {
      return this.context.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  function readInheritableStaticArrayValues(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return Array.from(ancestors.reduce((values, constructor2) => {
      getOwnStaticArrayValues(constructor2, propertyName).forEach((name) => values.add(name));
      return values;
    }, /* @__PURE__ */ new Set()));
  }
  function readInheritableStaticObjectPairs(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return ancestors.reduce((pairs, constructor2) => {
      pairs.push(...getOwnStaticObjectPairs(constructor2, propertyName));
      return pairs;
    }, []);
  }
  function getAncestorsForConstructor(constructor) {
    const ancestors = [];
    while (constructor) {
      ancestors.push(constructor);
      constructor = Object.getPrototypeOf(constructor);
    }
    return ancestors.reverse();
  }
  function getOwnStaticArrayValues(constructor, propertyName) {
    const definition = constructor[propertyName];
    return Array.isArray(definition) ? definition : [];
  }
  function getOwnStaticObjectPairs(constructor, propertyName) {
    const definition = constructor[propertyName];
    return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
  }
  var OutletObserver = class {
    constructor(context, delegate) {
      this.started = false;
      this.context = context;
      this.delegate = delegate;
      this.outletsByName = new Multimap();
      this.outletElementsByName = new Multimap();
      this.selectorObserverMap = /* @__PURE__ */ new Map();
      this.attributeObserverMap = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.started) {
        this.outletDefinitions.forEach((outletName) => {
          this.setupSelectorObserverForOutlet(outletName);
          this.setupAttributeObserverForOutlet(outletName);
        });
        this.started = true;
        this.dependentContexts.forEach((context) => context.refresh());
      }
    }
    refresh() {
      this.selectorObserverMap.forEach((observer) => observer.refresh());
      this.attributeObserverMap.forEach((observer) => observer.refresh());
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.disconnectAllOutlets();
        this.stopSelectorObservers();
        this.stopAttributeObservers();
      }
    }
    stopSelectorObservers() {
      if (this.selectorObserverMap.size > 0) {
        this.selectorObserverMap.forEach((observer) => observer.stop());
        this.selectorObserverMap.clear();
      }
    }
    stopAttributeObservers() {
      if (this.attributeObserverMap.size > 0) {
        this.attributeObserverMap.forEach((observer) => observer.stop());
        this.attributeObserverMap.clear();
      }
    }
    selectorMatched(element, _selector, { outletName }) {
      const outlet = this.getOutlet(element, outletName);
      if (outlet) {
        this.connectOutlet(outlet, element, outletName);
      }
    }
    selectorUnmatched(element, _selector, { outletName }) {
      const outlet = this.getOutletFromMap(element, outletName);
      if (outlet) {
        this.disconnectOutlet(outlet, element, outletName);
      }
    }
    selectorMatchElement(element, { outletName }) {
      const selector = this.selector(outletName);
      const hasOutlet = this.hasOutlet(element, outletName);
      const hasOutletController = element.matches(`[${this.schema.controllerAttribute}~=${outletName}]`);
      if (selector) {
        return hasOutlet && hasOutletController && element.matches(selector);
      } else {
        return false;
      }
    }
    elementMatchedAttribute(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    elementAttributeValueChanged(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    elementUnmatchedAttribute(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    connectOutlet(outlet, element, outletName) {
      var _a;
      if (!this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.add(outletName, outlet);
        this.outletElementsByName.add(outletName, element);
        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletConnected(outlet, element, outletName));
      }
    }
    disconnectOutlet(outlet, element, outletName) {
      var _a;
      if (this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.delete(outletName, outlet);
        this.outletElementsByName.delete(outletName, element);
        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletDisconnected(outlet, element, outletName));
      }
    }
    disconnectAllOutlets() {
      for (const outletName of this.outletElementsByName.keys) {
        for (const element of this.outletElementsByName.getValuesForKey(outletName)) {
          for (const outlet of this.outletsByName.getValuesForKey(outletName)) {
            this.disconnectOutlet(outlet, element, outletName);
          }
        }
      }
    }
    updateSelectorObserverForOutlet(outletName) {
      const observer = this.selectorObserverMap.get(outletName);
      if (observer) {
        observer.selector = this.selector(outletName);
      }
    }
    setupSelectorObserverForOutlet(outletName) {
      const selector = this.selector(outletName);
      const selectorObserver = new SelectorObserver(document.body, selector, this, { outletName });
      this.selectorObserverMap.set(outletName, selectorObserver);
      selectorObserver.start();
    }
    setupAttributeObserverForOutlet(outletName) {
      const attributeName = this.attributeNameForOutletName(outletName);
      const attributeObserver = new AttributeObserver(this.scope.element, attributeName, this);
      this.attributeObserverMap.set(outletName, attributeObserver);
      attributeObserver.start();
    }
    selector(outletName) {
      return this.scope.outlets.getSelectorForOutletName(outletName);
    }
    attributeNameForOutletName(outletName) {
      return this.scope.schema.outletAttributeForScope(this.identifier, outletName);
    }
    getOutletNameFromOutletAttributeName(attributeName) {
      return this.outletDefinitions.find((outletName) => this.attributeNameForOutletName(outletName) === attributeName);
    }
    get outletDependencies() {
      const dependencies = new Multimap();
      this.router.modules.forEach((module) => {
        const constructor = module.definition.controllerConstructor;
        const outlets = readInheritableStaticArrayValues(constructor, "outlets");
        outlets.forEach((outlet) => dependencies.add(outlet, module.identifier));
      });
      return dependencies;
    }
    get outletDefinitions() {
      return this.outletDependencies.getKeysForValue(this.identifier);
    }
    get dependentControllerIdentifiers() {
      return this.outletDependencies.getValuesForKey(this.identifier);
    }
    get dependentContexts() {
      const identifiers = this.dependentControllerIdentifiers;
      return this.router.contexts.filter((context) => identifiers.includes(context.identifier));
    }
    hasOutlet(element, outletName) {
      return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);
    }
    getOutlet(element, outletName) {
      return this.application.getControllerForElementAndIdentifier(element, outletName);
    }
    getOutletFromMap(element, outletName) {
      return this.outletsByName.getValuesForKey(outletName).find((outlet) => outlet.element === element);
    }
    get scope() {
      return this.context.scope;
    }
    get schema() {
      return this.context.schema;
    }
    get identifier() {
      return this.context.identifier;
    }
    get application() {
      return this.context.application;
    }
    get router() {
      return this.application.router;
    }
  };
  var Context = class {
    constructor(module, scope) {
      this.logDebugActivity = (functionName, detail = {}) => {
        const { identifier, controller, element } = this;
        detail = Object.assign({ identifier, controller, element }, detail);
        this.application.logDebugActivity(this.identifier, functionName, detail);
      };
      this.module = module;
      this.scope = scope;
      this.controller = new module.controllerConstructor(this);
      this.bindingObserver = new BindingObserver(this, this.dispatcher);
      this.valueObserver = new ValueObserver(this, this.controller);
      this.targetObserver = new TargetObserver(this, this);
      this.outletObserver = new OutletObserver(this, this);
      try {
        this.controller.initialize();
        this.logDebugActivity("initialize");
      } catch (error2) {
        this.handleError(error2, "initializing controller");
      }
    }
    connect() {
      this.bindingObserver.start();
      this.valueObserver.start();
      this.targetObserver.start();
      this.outletObserver.start();
      try {
        this.controller.connect();
        this.logDebugActivity("connect");
      } catch (error2) {
        this.handleError(error2, "connecting controller");
      }
    }
    refresh() {
      this.outletObserver.refresh();
    }
    disconnect() {
      try {
        this.controller.disconnect();
        this.logDebugActivity("disconnect");
      } catch (error2) {
        this.handleError(error2, "disconnecting controller");
      }
      this.outletObserver.stop();
      this.targetObserver.stop();
      this.valueObserver.stop();
      this.bindingObserver.stop();
    }
    get application() {
      return this.module.application;
    }
    get identifier() {
      return this.module.identifier;
    }
    get schema() {
      return this.application.schema;
    }
    get dispatcher() {
      return this.application.dispatcher;
    }
    get element() {
      return this.scope.element;
    }
    get parentElement() {
      return this.element.parentElement;
    }
    handleError(error2, message, detail = {}) {
      const { identifier, controller, element } = this;
      detail = Object.assign({ identifier, controller, element }, detail);
      this.application.handleError(error2, `Error ${message}`, detail);
    }
    targetConnected(element, name) {
      this.invokeControllerMethod(`${name}TargetConnected`, element);
    }
    targetDisconnected(element, name) {
      this.invokeControllerMethod(`${name}TargetDisconnected`, element);
    }
    outletConnected(outlet, element, name) {
      this.invokeControllerMethod(`${namespaceCamelize(name)}OutletConnected`, outlet, element);
    }
    outletDisconnected(outlet, element, name) {
      this.invokeControllerMethod(`${namespaceCamelize(name)}OutletDisconnected`, outlet, element);
    }
    invokeControllerMethod(methodName, ...args) {
      const controller = this.controller;
      if (typeof controller[methodName] == "function") {
        controller[methodName](...args);
      }
    }
  };
  function bless(constructor) {
    return shadow(constructor, getBlessedProperties(constructor));
  }
  function shadow(constructor, properties) {
    const shadowConstructor = extend(constructor);
    const shadowProperties = getShadowProperties(constructor.prototype, properties);
    Object.defineProperties(shadowConstructor.prototype, shadowProperties);
    return shadowConstructor;
  }
  function getBlessedProperties(constructor) {
    const blessings = readInheritableStaticArrayValues(constructor, "blessings");
    return blessings.reduce((blessedProperties, blessing) => {
      const properties = blessing(constructor);
      for (const key in properties) {
        const descriptor = blessedProperties[key] || {};
        blessedProperties[key] = Object.assign(descriptor, properties[key]);
      }
      return blessedProperties;
    }, {});
  }
  function getShadowProperties(prototype, properties) {
    return getOwnKeys(properties).reduce((shadowProperties, key) => {
      const descriptor = getShadowedDescriptor(prototype, properties, key);
      if (descriptor) {
        Object.assign(shadowProperties, { [key]: descriptor });
      }
      return shadowProperties;
    }, {});
  }
  function getShadowedDescriptor(prototype, properties, key) {
    const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
    const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
    if (!shadowedByValue) {
      const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
      if (shadowingDescriptor) {
        descriptor.get = shadowingDescriptor.get || descriptor.get;
        descriptor.set = shadowingDescriptor.set || descriptor.set;
      }
      return descriptor;
    }
  }
  var getOwnKeys = (() => {
    if (typeof Object.getOwnPropertySymbols == "function") {
      return (object) => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
    } else {
      return Object.getOwnPropertyNames;
    }
  })();
  var extend = (() => {
    function extendWithReflect(constructor) {
      function extended() {
        return Reflect.construct(constructor, arguments, new.target);
      }
      extended.prototype = Object.create(constructor.prototype, {
        constructor: { value: extended }
      });
      Reflect.setPrototypeOf(extended, constructor);
      return extended;
    }
    function testReflectExtension() {
      const a2 = function() {
        this.a.call(this);
      };
      const b2 = extendWithReflect(a2);
      b2.prototype.a = function() {
      };
      return new b2();
    }
    try {
      testReflectExtension();
      return extendWithReflect;
    } catch (error2) {
      return (constructor) => class extended extends constructor {
      };
    }
  })();
  function blessDefinition(definition) {
    return {
      identifier: definition.identifier,
      controllerConstructor: bless(definition.controllerConstructor)
    };
  }
  var Module = class {
    constructor(application2, definition) {
      this.application = application2;
      this.definition = blessDefinition(definition);
      this.contextsByScope = /* @__PURE__ */ new WeakMap();
      this.connectedContexts = /* @__PURE__ */ new Set();
    }
    get identifier() {
      return this.definition.identifier;
    }
    get controllerConstructor() {
      return this.definition.controllerConstructor;
    }
    get contexts() {
      return Array.from(this.connectedContexts);
    }
    connectContextForScope(scope) {
      const context = this.fetchContextForScope(scope);
      this.connectedContexts.add(context);
      context.connect();
    }
    disconnectContextForScope(scope) {
      const context = this.contextsByScope.get(scope);
      if (context) {
        this.connectedContexts.delete(context);
        context.disconnect();
      }
    }
    fetchContextForScope(scope) {
      let context = this.contextsByScope.get(scope);
      if (!context) {
        context = new Context(this, scope);
        this.contextsByScope.set(scope, context);
      }
      return context;
    }
  };
  var ClassMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    has(name) {
      return this.data.has(this.getDataKey(name));
    }
    get(name) {
      return this.getAll(name)[0];
    }
    getAll(name) {
      const tokenString = this.data.get(this.getDataKey(name)) || "";
      return tokenize(tokenString);
    }
    getAttributeName(name) {
      return this.data.getAttributeNameForKey(this.getDataKey(name));
    }
    getDataKey(name) {
      return `${name}-class`;
    }
    get data() {
      return this.scope.data;
    }
  };
  var DataMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get(key) {
      const name = this.getAttributeNameForKey(key);
      return this.element.getAttribute(name);
    }
    set(key, value) {
      const name = this.getAttributeNameForKey(key);
      this.element.setAttribute(name, value);
      return this.get(key);
    }
    has(key) {
      const name = this.getAttributeNameForKey(key);
      return this.element.hasAttribute(name);
    }
    delete(key) {
      if (this.has(key)) {
        const name = this.getAttributeNameForKey(key);
        this.element.removeAttribute(name);
        return true;
      } else {
        return false;
      }
    }
    getAttributeNameForKey(key) {
      return `data-${this.identifier}-${dasherize(key)}`;
    }
  };
  var Guide = class {
    constructor(logger) {
      this.warnedKeysByObject = /* @__PURE__ */ new WeakMap();
      this.logger = logger;
    }
    warn(object, key, message) {
      let warnedKeys = this.warnedKeysByObject.get(object);
      if (!warnedKeys) {
        warnedKeys = /* @__PURE__ */ new Set();
        this.warnedKeysByObject.set(object, warnedKeys);
      }
      if (!warnedKeys.has(key)) {
        warnedKeys.add(key);
        this.logger.warn(message, object);
      }
    }
  };
  function attributeValueContainsToken(attributeName, token) {
    return `[${attributeName}~="${token}"]`;
  }
  var TargetSet = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(targetName) {
      return this.find(targetName) != null;
    }
    find(...targetNames) {
      return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), void 0);
    }
    findAll(...targetNames) {
      return targetNames.reduce((targets, targetName) => [
        ...targets,
        ...this.findAllTargets(targetName),
        ...this.findAllLegacyTargets(targetName)
      ], []);
    }
    findTarget(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findElement(selector);
    }
    findAllTargets(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findAllElements(selector);
    }
    getSelectorForTargetName(targetName) {
      const attributeName = this.schema.targetAttributeForScope(this.identifier);
      return attributeValueContainsToken(attributeName, targetName);
    }
    findLegacyTarget(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.deprecate(this.scope.findElement(selector), targetName);
    }
    findAllLegacyTargets(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
    }
    getLegacySelectorForTargetName(targetName) {
      const targetDescriptor = `${this.identifier}.${targetName}`;
      return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
    }
    deprecate(element, targetName) {
      if (element) {
        const { identifier } = this;
        const attributeName = this.schema.targetAttribute;
        const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
        this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
      }
      return element;
    }
    get guide() {
      return this.scope.guide;
    }
  };
  var OutletSet = class {
    constructor(scope, controllerElement) {
      this.scope = scope;
      this.controllerElement = controllerElement;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(outletName) {
      return this.find(outletName) != null;
    }
    find(...outletNames) {
      return outletNames.reduce((outlet, outletName) => outlet || this.findOutlet(outletName), void 0);
    }
    findAll(...outletNames) {
      return outletNames.reduce((outlets, outletName) => [...outlets, ...this.findAllOutlets(outletName)], []);
    }
    getSelectorForOutletName(outletName) {
      const attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);
      return this.controllerElement.getAttribute(attributeName);
    }
    findOutlet(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      if (selector)
        return this.findElement(selector, outletName);
    }
    findAllOutlets(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      return selector ? this.findAllElements(selector, outletName) : [];
    }
    findElement(selector, outletName) {
      const elements = this.scope.queryElements(selector);
      return elements.filter((element) => this.matchesElement(element, selector, outletName))[0];
    }
    findAllElements(selector, outletName) {
      const elements = this.scope.queryElements(selector);
      return elements.filter((element) => this.matchesElement(element, selector, outletName));
    }
    matchesElement(element, selector, outletName) {
      const controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || "";
      return element.matches(selector) && controllerAttribute.split(" ").includes(outletName);
    }
  };
  var Scope = class _Scope {
    constructor(schema, element, identifier, logger) {
      this.targets = new TargetSet(this);
      this.classes = new ClassMap(this);
      this.data = new DataMap(this);
      this.containsElement = (element2) => {
        return element2.closest(this.controllerSelector) === this.element;
      };
      this.schema = schema;
      this.element = element;
      this.identifier = identifier;
      this.guide = new Guide(logger);
      this.outlets = new OutletSet(this.documentScope, element);
    }
    findElement(selector) {
      return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
    }
    findAllElements(selector) {
      return [
        ...this.element.matches(selector) ? [this.element] : [],
        ...this.queryElements(selector).filter(this.containsElement)
      ];
    }
    queryElements(selector) {
      return Array.from(this.element.querySelectorAll(selector));
    }
    get controllerSelector() {
      return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
    }
    get isDocumentScope() {
      return this.element === document.documentElement;
    }
    get documentScope() {
      return this.isDocumentScope ? this : new _Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);
    }
  };
  var ScopeObserver = class {
    constructor(element, schema, delegate) {
      this.element = element;
      this.schema = schema;
      this.delegate = delegate;
      this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
      this.scopesByIdentifierByElement = /* @__PURE__ */ new WeakMap();
      this.scopeReferenceCounts = /* @__PURE__ */ new WeakMap();
    }
    start() {
      this.valueListObserver.start();
    }
    stop() {
      this.valueListObserver.stop();
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    parseValueForToken(token) {
      const { element, content: identifier } = token;
      return this.parseValueForElementAndIdentifier(element, identifier);
    }
    parseValueForElementAndIdentifier(element, identifier) {
      const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
      let scope = scopesByIdentifier.get(identifier);
      if (!scope) {
        scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
        scopesByIdentifier.set(identifier, scope);
      }
      return scope;
    }
    elementMatchedValue(element, value) {
      const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
      this.scopeReferenceCounts.set(value, referenceCount);
      if (referenceCount == 1) {
        this.delegate.scopeConnected(value);
      }
    }
    elementUnmatchedValue(element, value) {
      const referenceCount = this.scopeReferenceCounts.get(value);
      if (referenceCount) {
        this.scopeReferenceCounts.set(value, referenceCount - 1);
        if (referenceCount == 1) {
          this.delegate.scopeDisconnected(value);
        }
      }
    }
    fetchScopesByIdentifierForElement(element) {
      let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
      if (!scopesByIdentifier) {
        scopesByIdentifier = /* @__PURE__ */ new Map();
        this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
      }
      return scopesByIdentifier;
    }
  };
  var Router = class {
    constructor(application2) {
      this.application = application2;
      this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
      this.scopesByIdentifier = new Multimap();
      this.modulesByIdentifier = /* @__PURE__ */ new Map();
    }
    get element() {
      return this.application.element;
    }
    get schema() {
      return this.application.schema;
    }
    get logger() {
      return this.application.logger;
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    get modules() {
      return Array.from(this.modulesByIdentifier.values());
    }
    get contexts() {
      return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
    }
    start() {
      this.scopeObserver.start();
    }
    stop() {
      this.scopeObserver.stop();
    }
    loadDefinition(definition) {
      this.unloadIdentifier(definition.identifier);
      const module = new Module(this.application, definition);
      this.connectModule(module);
      const afterLoad = definition.controllerConstructor.afterLoad;
      if (afterLoad) {
        afterLoad.call(definition.controllerConstructor, definition.identifier, this.application);
      }
    }
    unloadIdentifier(identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        this.disconnectModule(module);
      }
    }
    getContextForElementAndIdentifier(element, identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        return module.contexts.find((context) => context.element == element);
      }
    }
    proposeToConnectScopeForElementAndIdentifier(element, identifier) {
      const scope = this.scopeObserver.parseValueForElementAndIdentifier(element, identifier);
      if (scope) {
        this.scopeObserver.elementMatchedValue(scope.element, scope);
      } else {
        console.error(`Couldn't find or create scope for identifier: "${identifier}" and element:`, element);
      }
    }
    handleError(error2, message, detail) {
      this.application.handleError(error2, message, detail);
    }
    createScopeForElementAndIdentifier(element, identifier) {
      return new Scope(this.schema, element, identifier, this.logger);
    }
    scopeConnected(scope) {
      this.scopesByIdentifier.add(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.connectContextForScope(scope);
      }
    }
    scopeDisconnected(scope) {
      this.scopesByIdentifier.delete(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.disconnectContextForScope(scope);
      }
    }
    connectModule(module) {
      this.modulesByIdentifier.set(module.identifier, module);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.connectContextForScope(scope));
    }
    disconnectModule(module) {
      this.modulesByIdentifier.delete(module.identifier);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.disconnectContextForScope(scope));
    }
  };
  var defaultSchema = {
    controllerAttribute: "data-controller",
    actionAttribute: "data-action",
    targetAttribute: "data-target",
    targetAttributeForScope: (identifier) => `data-${identifier}-target`,
    outletAttributeForScope: (identifier, outlet) => `data-${identifier}-${outlet}-outlet`,
    keyMappings: Object.assign(Object.assign({ enter: "Enter", tab: "Tab", esc: "Escape", space: " ", up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight", home: "Home", end: "End", page_up: "PageUp", page_down: "PageDown" }, objectFromEntries("abcdefghijklmnopqrstuvwxyz".split("").map((c2) => [c2, c2]))), objectFromEntries("0123456789".split("").map((n2) => [n2, n2])))
  };
  function objectFromEntries(array) {
    return array.reduce((memo, [k2, v2]) => Object.assign(Object.assign({}, memo), { [k2]: v2 }), {});
  }
  var Application = class {
    constructor(element = document.documentElement, schema = defaultSchema) {
      this.logger = console;
      this.debug = false;
      this.logDebugActivity = (identifier, functionName, detail = {}) => {
        if (this.debug) {
          this.logFormattedMessage(identifier, functionName, detail);
        }
      };
      this.element = element;
      this.schema = schema;
      this.dispatcher = new Dispatcher(this);
      this.router = new Router(this);
      this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);
    }
    static start(element, schema) {
      const application2 = new this(element, schema);
      application2.start();
      return application2;
    }
    async start() {
      await domReady();
      this.logDebugActivity("application", "starting");
      this.dispatcher.start();
      this.router.start();
      this.logDebugActivity("application", "start");
    }
    stop() {
      this.logDebugActivity("application", "stopping");
      this.dispatcher.stop();
      this.router.stop();
      this.logDebugActivity("application", "stop");
    }
    register(identifier, controllerConstructor) {
      this.load({ identifier, controllerConstructor });
    }
    registerActionOption(name, filter) {
      this.actionDescriptorFilters[name] = filter;
    }
    load(head, ...rest) {
      const definitions = Array.isArray(head) ? head : [head, ...rest];
      definitions.forEach((definition) => {
        if (definition.controllerConstructor.shouldLoad) {
          this.router.loadDefinition(definition);
        }
      });
    }
    unload(head, ...rest) {
      const identifiers = Array.isArray(head) ? head : [head, ...rest];
      identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
    }
    get controllers() {
      return this.router.contexts.map((context) => context.controller);
    }
    getControllerForElementAndIdentifier(element, identifier) {
      const context = this.router.getContextForElementAndIdentifier(element, identifier);
      return context ? context.controller : null;
    }
    handleError(error2, message, detail) {
      var _a;
      this.logger.error(`%s

%o

%o`, message, error2, detail);
      (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error2);
    }
    logFormattedMessage(identifier, functionName, detail = {}) {
      detail = Object.assign({ application: this }, detail);
      this.logger.groupCollapsed(`${identifier} #${functionName}`);
      this.logger.log("details:", Object.assign({}, detail));
      this.logger.groupEnd();
    }
  };
  function domReady() {
    return new Promise((resolve) => {
      if (document.readyState == "loading") {
        document.addEventListener("DOMContentLoaded", () => resolve());
      } else {
        resolve();
      }
    });
  }
  function ClassPropertiesBlessing(constructor) {
    const classes = readInheritableStaticArrayValues(constructor, "classes");
    return classes.reduce((properties, classDefinition) => {
      return Object.assign(properties, propertiesForClassDefinition(classDefinition));
    }, {});
  }
  function propertiesForClassDefinition(key) {
    return {
      [`${key}Class`]: {
        get() {
          const { classes } = this;
          if (classes.has(key)) {
            return classes.get(key);
          } else {
            const attribute = classes.getAttributeName(key);
            throw new Error(`Missing attribute "${attribute}"`);
          }
        }
      },
      [`${key}Classes`]: {
        get() {
          return this.classes.getAll(key);
        }
      },
      [`has${capitalize(key)}Class`]: {
        get() {
          return this.classes.has(key);
        }
      }
    };
  }
  function OutletPropertiesBlessing(constructor) {
    const outlets = readInheritableStaticArrayValues(constructor, "outlets");
    return outlets.reduce((properties, outletDefinition) => {
      return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));
    }, {});
  }
  function getOutletController(controller, element, identifier) {
    return controller.application.getControllerForElementAndIdentifier(element, identifier);
  }
  function getControllerAndEnsureConnectedScope(controller, element, outletName) {
    let outletController = getOutletController(controller, element, outletName);
    if (outletController)
      return outletController;
    controller.application.router.proposeToConnectScopeForElementAndIdentifier(element, outletName);
    outletController = getOutletController(controller, element, outletName);
    if (outletController)
      return outletController;
  }
  function propertiesForOutletDefinition(name) {
    const camelizedName = namespaceCamelize(name);
    return {
      [`${camelizedName}Outlet`]: {
        get() {
          const outletElement = this.outlets.find(name);
          const selector = this.outlets.getSelectorForOutletName(name);
          if (outletElement) {
            const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
            if (outletController)
              return outletController;
            throw new Error(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`);
          }
          throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
        }
      },
      [`${camelizedName}Outlets`]: {
        get() {
          const outlets = this.outlets.findAll(name);
          if (outlets.length > 0) {
            return outlets.map((outletElement) => {
              const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
              if (outletController)
                return outletController;
              console.warn(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`, outletElement);
            }).filter((controller) => controller);
          }
          return [];
        }
      },
      [`${camelizedName}OutletElement`]: {
        get() {
          const outletElement = this.outlets.find(name);
          const selector = this.outlets.getSelectorForOutletName(name);
          if (outletElement) {
            return outletElement;
          } else {
            throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
          }
        }
      },
      [`${camelizedName}OutletElements`]: {
        get() {
          return this.outlets.findAll(name);
        }
      },
      [`has${capitalize(camelizedName)}Outlet`]: {
        get() {
          return this.outlets.has(name);
        }
      }
    };
  }
  function TargetPropertiesBlessing(constructor) {
    const targets = readInheritableStaticArrayValues(constructor, "targets");
    return targets.reduce((properties, targetDefinition) => {
      return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
    }, {});
  }
  function propertiesForTargetDefinition(name) {
    return {
      [`${name}Target`]: {
        get() {
          const target = this.targets.find(name);
          if (target) {
            return target;
          } else {
            throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
          }
        }
      },
      [`${name}Targets`]: {
        get() {
          return this.targets.findAll(name);
        }
      },
      [`has${capitalize(name)}Target`]: {
        get() {
          return this.targets.has(name);
        }
      }
    };
  }
  function ValuePropertiesBlessing(constructor) {
    const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
    const propertyDescriptorMap = {
      valueDescriptorMap: {
        get() {
          return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
            const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);
            const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
            return Object.assign(result, { [attributeName]: valueDescriptor });
          }, {});
        }
      }
    };
    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
      return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
    }, propertyDescriptorMap);
  }
  function propertiesForValueDefinitionPair(valueDefinitionPair, controller) {
    const definition = parseValueDefinitionPair(valueDefinitionPair, controller);
    const { key, name, reader: read2, writer: write2 } = definition;
    return {
      [name]: {
        get() {
          const value = this.data.get(key);
          if (value !== null) {
            return read2(value);
          } else {
            return definition.defaultValue;
          }
        },
        set(value) {
          if (value === void 0) {
            this.data.delete(key);
          } else {
            this.data.set(key, write2(value));
          }
        }
      },
      [`has${capitalize(name)}`]: {
        get() {
          return this.data.has(key) || definition.hasCustomDefaultValue;
        }
      }
    };
  }
  function parseValueDefinitionPair([token, typeDefinition], controller) {
    return valueDescriptorForTokenAndTypeDefinition({
      controller,
      token,
      typeDefinition
    });
  }
  function parseValueTypeConstant(constant) {
    switch (constant) {
      case Array:
        return "array";
      case Boolean:
        return "boolean";
      case Number:
        return "number";
      case Object:
        return "object";
      case String:
        return "string";
    }
  }
  function parseValueTypeDefault(defaultValue) {
    switch (typeof defaultValue) {
      case "boolean":
        return "boolean";
      case "number":
        return "number";
      case "string":
        return "string";
    }
    if (Array.isArray(defaultValue))
      return "array";
    if (Object.prototype.toString.call(defaultValue) === "[object Object]")
      return "object";
  }
  function parseValueTypeObject(payload) {
    const { controller, token, typeObject } = payload;
    const hasType = isSomething(typeObject.type);
    const hasDefault = isSomething(typeObject.default);
    const fullObject = hasType && hasDefault;
    const onlyType = hasType && !hasDefault;
    const onlyDefault = !hasType && hasDefault;
    const typeFromObject = parseValueTypeConstant(typeObject.type);
    const typeFromDefaultValue = parseValueTypeDefault(payload.typeObject.default);
    if (onlyType)
      return typeFromObject;
    if (onlyDefault)
      return typeFromDefaultValue;
    if (typeFromObject !== typeFromDefaultValue) {
      const propertyPath = controller ? `${controller}.${token}` : token;
      throw new Error(`The specified default value for the Stimulus Value "${propertyPath}" must match the defined type "${typeFromObject}". The provided default value of "${typeObject.default}" is of type "${typeFromDefaultValue}".`);
    }
    if (fullObject)
      return typeFromObject;
  }
  function parseValueTypeDefinition(payload) {
    const { controller, token, typeDefinition } = payload;
    const typeObject = { controller, token, typeObject: typeDefinition };
    const typeFromObject = parseValueTypeObject(typeObject);
    const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
    const typeFromConstant = parseValueTypeConstant(typeDefinition);
    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
    if (type)
      return type;
    const propertyPath = controller ? `${controller}.${typeDefinition}` : token;
    throw new Error(`Unknown value type "${propertyPath}" for "${token}" value`);
  }
  function defaultValueForDefinition(typeDefinition) {
    const constant = parseValueTypeConstant(typeDefinition);
    if (constant)
      return defaultValuesByType[constant];
    const hasDefault = hasProperty(typeDefinition, "default");
    const hasType = hasProperty(typeDefinition, "type");
    const typeObject = typeDefinition;
    if (hasDefault)
      return typeObject.default;
    if (hasType) {
      const { type } = typeObject;
      const constantFromType = parseValueTypeConstant(type);
      if (constantFromType)
        return defaultValuesByType[constantFromType];
    }
    return typeDefinition;
  }
  function valueDescriptorForTokenAndTypeDefinition(payload) {
    const { token, typeDefinition } = payload;
    const key = `${dasherize(token)}-value`;
    const type = parseValueTypeDefinition(payload);
    return {
      type,
      key,
      name: camelize(key),
      get defaultValue() {
        return defaultValueForDefinition(typeDefinition);
      },
      get hasCustomDefaultValue() {
        return parseValueTypeDefault(typeDefinition) !== void 0;
      },
      reader: readers[type],
      writer: writers[type] || writers.default
    };
  }
  var defaultValuesByType = {
    get array() {
      return [];
    },
    boolean: false,
    number: 0,
    get object() {
      return {};
    },
    string: ""
  };
  var readers = {
    array(value) {
      const array = JSON.parse(value);
      if (!Array.isArray(array)) {
        throw new TypeError(`expected value of type "array" but instead got value "${value}" of type "${parseValueTypeDefault(array)}"`);
      }
      return array;
    },
    boolean(value) {
      return !(value == "0" || String(value).toLowerCase() == "false");
    },
    number(value) {
      return Number(value.replace(/_/g, ""));
    },
    object(value) {
      const object = JSON.parse(value);
      if (object === null || typeof object != "object" || Array.isArray(object)) {
        throw new TypeError(`expected value of type "object" but instead got value "${value}" of type "${parseValueTypeDefault(object)}"`);
      }
      return object;
    },
    string(value) {
      return value;
    }
  };
  var writers = {
    default: writeString,
    array: writeJSON,
    object: writeJSON
  };
  function writeJSON(value) {
    return JSON.stringify(value);
  }
  function writeString(value) {
    return `${value}`;
  }
  var Controller = class {
    constructor(context) {
      this.context = context;
    }
    static get shouldLoad() {
      return true;
    }
    static afterLoad(_identifier, _application) {
      return;
    }
    get application() {
      return this.context.application;
    }
    get scope() {
      return this.context.scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get targets() {
      return this.scope.targets;
    }
    get outlets() {
      return this.scope.outlets;
    }
    get classes() {
      return this.scope.classes;
    }
    get data() {
      return this.scope.data;
    }
    initialize() {
    }
    connect() {
    }
    disconnect() {
    }
    dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
      const type = prefix ? `${prefix}:${eventName}` : eventName;
      const event = new CustomEvent(type, { detail, bubbles, cancelable });
      target.dispatchEvent(event);
      return event;
    }
  };
  Controller.blessings = [
    ClassPropertiesBlessing,
    TargetPropertiesBlessing,
    ValuePropertiesBlessing,
    OutletPropertiesBlessing
  ];
  Controller.targets = [];
  Controller.outlets = [];
  Controller.values = {};

  // app/javascript/controllers/application.js
  var application = Application.start();
  application.debug = false;
  window.Stimulus = application;

  // app/javascript/controllers/hello_controller.js
  var hello_controller_default = class extends Controller {
    connect() {
      this.element.textContent = "Hello World!";
    }
  };

  // app/javascript/controllers/select2_controller.js
  var import_jquery = __toESM(require_jquery());
  var import_select2 = __toESM(require_select2());
  var select2_controller_default = class extends Controller {
    connect() {
      console.log("connect select2");
      (0, import_select2.default)();
      (0, import_jquery.default)(".content-search").select2({
        theme: "bootstrap-5"
      });
    }
  };

  // app/javascript/controllers/sweetalert_controller.js
  var import_sweetalert2 = __toESM(require_sweetalert2_all());
  var sweetalert_controller_default = class extends Controller {
    connect() {
    }
    showAlert() {
      import_sweetalert2.default.fire("Hello from SweetAlert2!");
    }
  };

  // node_modules/@yaireo/tagify/dist/tagify.esm.js
  var t = "&#8203;";
  function e(t2, e2) {
    (null == e2 || e2 > t2.length) && (e2 = t2.length);
    for (var i2 = 0, n2 = new Array(e2); i2 < e2; i2++)
      n2[i2] = t2[i2];
    return n2;
  }
  function i(t2) {
    return function(t3) {
      if (Array.isArray(t3))
        return e(t3);
    }(t2) || function(t3) {
      if ("undefined" != typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"])
        return Array.from(t3);
    }(t2) || function(t3, i2) {
      if (!t3)
        return;
      if ("string" == typeof t3)
        return e(t3, i2);
      var n2 = Object.prototype.toString.call(t3).slice(8, -1);
      "Object" === n2 && t3.constructor && (n2 = t3.constructor.name);
      if ("Map" === n2 || "Set" === n2)
        return Array.from(n2);
      if ("Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return e(t3, i2);
    }(t2) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  var n = { isEnabled: function() {
    var t2;
    return null === (t2 = window.TAGIFY_DEBUG) || void 0 === t2 || t2;
  }, log: function() {
    for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++)
      e2[n2] = arguments[n2];
    var s2;
    this.isEnabled() && (s2 = console).log.apply(s2, ["[Tagify]:"].concat(i(e2)));
  }, warn: function() {
    for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++)
      e2[n2] = arguments[n2];
    var s2;
    this.isEnabled() && (s2 = console).warn.apply(s2, ["[Tagify]:"].concat(i(e2)));
  } };
  var s = function(t2, e2, i2, n2) {
    return t2 = "" + t2, e2 = "" + e2, n2 && (t2 = t2.trim(), e2 = e2.trim()), i2 ? t2 == e2 : t2.toLowerCase() == e2.toLowerCase();
  };
  var a = function(t2, e2) {
    return t2 && Array.isArray(t2) && t2.map(function(t3) {
      return o(t3, e2);
    });
  };
  function o(t2, e2) {
    var i2, n2 = {};
    for (i2 in t2)
      e2.indexOf(i2) < 0 && (n2[i2] = t2[i2]);
    return n2;
  }
  function r(t2) {
    return new DOMParser().parseFromString(t2.trim(), "text/html").body.firstElementChild;
  }
  function l(t2, e2) {
    for (e2 = e2 || "previous"; t2 = t2[e2 + "Sibling"]; )
      if (3 == t2.nodeType)
        return t2;
  }
  function d(t2) {
    return "string" == typeof t2 ? t2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/`|'/g, "&#039;") : t2;
  }
  function c(t2) {
    var e2 = Object.prototype.toString.call(t2).split(" ")[1].slice(0, -1);
    return t2 === Object(t2) && "Array" != e2 && "Function" != e2 && "RegExp" != e2 && "HTMLUnknownElement" != e2;
  }
  function u(t2, e2, i2) {
    var n2, s2;
    function a2(t3, e3) {
      for (var i3 in e3)
        if (e3.hasOwnProperty(i3)) {
          if (c(e3[i3])) {
            c(t3[i3]) ? a2(t3[i3], e3[i3]) : t3[i3] = Object.assign({}, e3[i3]);
            continue;
          }
          if (Array.isArray(e3[i3])) {
            t3[i3] = Object.assign([], e3[i3]);
            continue;
          }
          t3[i3] = e3[i3];
        }
    }
    return n2 = t2, (null != (s2 = Object) && "undefined" != typeof Symbol && s2[Symbol.hasInstance] ? s2[Symbol.hasInstance](n2) : n2 instanceof s2) || (t2 = {}), a2(t2, e2), i2 && a2(t2, i2), t2;
  }
  function g() {
    var t2 = [], e2 = {}, i2 = true, n2 = false, s2 = void 0;
    try {
      for (var a2, o2 = arguments[Symbol.iterator](); !(i2 = (a2 = o2.next()).done); i2 = true) {
        var r2 = a2.value, l2 = true, d2 = false, u2 = void 0;
        try {
          for (var g2, h2 = r2[Symbol.iterator](); !(l2 = (g2 = h2.next()).done); l2 = true) {
            var p2 = g2.value;
            c(p2) ? e2[p2.value] || (t2.push(p2), e2[p2.value] = 1) : t2.includes(p2) || t2.push(p2);
          }
        } catch (t3) {
          d2 = true, u2 = t3;
        } finally {
          try {
            l2 || null == h2.return || h2.return();
          } finally {
            if (d2)
              throw u2;
          }
        }
      }
    } catch (t3) {
      n2 = true, s2 = t3;
    } finally {
      try {
        i2 || null == o2.return || o2.return();
      } finally {
        if (n2)
          throw s2;
      }
    }
    return t2;
  }
  function h(t2) {
    return String.prototype.normalize ? "string" == typeof t2 ? t2.normalize("NFD").replace(/[\u0300-\u036f]/g, "") : void 0 : t2;
  }
  var p = function() {
    return /(?=.*chrome)(?=.*android)/i.test(navigator.userAgent);
  };
  function f() {
    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, function(t2) {
      return (t2 ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> t2 / 4).toString(16);
    });
  }
  function m(t2) {
    return t2 && t2.classList && t2.classList.contains(this.settings.classNames.tag);
  }
  function v(t2) {
    return t2 && t2.closest(this.settings.classNames.tagSelector);
  }
  function b(t2, e2) {
    var i2 = window.getSelection();
    return e2 = e2 || i2.getRangeAt(0), "string" == typeof t2 && (t2 = document.createTextNode(t2)), e2 && (e2.deleteContents(), e2.insertNode(t2)), t2;
  }
  function w(t2, e2, i2) {
    return t2 ? (e2 && (t2.__tagifyTagData = i2 ? e2 : u({}, t2.__tagifyTagData || {}, e2)), t2.__tagifyTagData) : (n.warn("tag element doesn't exist", { tagElm: t2, data: e2 }), e2);
  }
  function y(t2) {
    if (t2 && t2.parentNode) {
      var e2 = t2, i2 = window.getSelection(), n2 = i2.getRangeAt(0);
      i2.rangeCount && (n2.setStartAfter(e2), n2.collapse(true), i2.removeAllRanges(), i2.addRange(n2));
    }
  }
  function T(t2, e2) {
    t2.forEach(function(t3) {
      if (w(t3.previousSibling) || !t3.previousSibling) {
        var i2 = document.createTextNode("\u200B");
        t3.before(i2), e2 && y(i2);
      }
    });
  }
  var O = { delimiters: ",", pattern: null, tagTextProp: "value", maxTags: 1 / 0, callbacks: {}, addTagOnBlur: true, addTagOn: ["blur", "tab", "enter"], onChangeAfterBlur: true, duplicates: false, whitelist: [], blacklist: [], enforceWhitelist: false, userInput: true, focusable: true, keepInvalidTags: false, createInvalidTags: true, mixTagsAllowedAfter: /,|\.|\:|\s/, mixTagsInterpolator: ["[[", "]]"], backspace: true, skipInvalid: false, pasteAsTags: true, editTags: { clicks: 2, keepInvalid: true }, transformTag: function() {
  }, trim: true, a11y: { focusableTags: false }, mixMode: { insertAfterTag: "\xA0" }, autoComplete: { enabled: true, rightKey: false, tabKey: false }, classNames: { namespace: "tagify", mixMode: "tagify--mix", selectMode: "tagify--select", input: "tagify__input", focus: "tagify--focus", tagNoAnimation: "tagify--noAnim", tagInvalid: "tagify--invalid", tagNotAllowed: "tagify--notAllowed", scopeLoading: "tagify--loading", hasMaxTags: "tagify--hasMaxTags", hasNoTags: "tagify--noTags", empty: "tagify--empty", inputInvalid: "tagify__input--invalid", dropdown: "tagify__dropdown", dropdownWrapper: "tagify__dropdown__wrapper", dropdownHeader: "tagify__dropdown__header", dropdownFooter: "tagify__dropdown__footer", dropdownItem: "tagify__dropdown__item", dropdownItemActive: "tagify__dropdown__item--active", dropdownItemHidden: "tagify__dropdown__item--hidden", dropdownItemSelected: "tagify__dropdown__item--selected", dropdownInital: "tagify__dropdown--initial", tag: "tagify__tag", tagText: "tagify__tag-text", tagX: "tagify__tag__removeBtn", tagLoading: "tagify__tag--loading", tagEditing: "tagify__tag--editable", tagFlash: "tagify__tag--flash", tagHide: "tagify__tag--hide" }, dropdown: { classname: "", enabled: 2, maxItems: 10, searchKeys: ["value", "searchBy"], fuzzySearch: true, caseSensitive: false, accentedSearch: true, includeSelectedTags: false, escapeHTML: true, highlightFirst: true, closeOnSelect: true, clearOnSelect: true, position: "all", appendTarget: null }, hooks: { beforeRemoveTag: function() {
    return Promise.resolve();
  }, beforePaste: function() {
    return Promise.resolve();
  }, suggestionClick: function() {
    return Promise.resolve();
  }, beforeKeyDown: function() {
    return Promise.resolve();
  } } };
  function x(t2, e2, i2) {
    return e2 in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
  }
  function D(t2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var i2 = null != arguments[e2] ? arguments[e2] : {}, n2 = Object.keys(i2);
      "function" == typeof Object.getOwnPropertySymbols && (n2 = n2.concat(Object.getOwnPropertySymbols(i2).filter(function(t3) {
        return Object.getOwnPropertyDescriptor(i2, t3).enumerable;
      }))), n2.forEach(function(e3) {
        x(t2, e3, i2[e3]);
      });
    }
    return t2;
  }
  function I(t2, e2) {
    return e2 = null != e2 ? e2 : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(e2)) : function(t3, e3) {
      var i2 = Object.keys(t3);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(t3);
        e3 && (n2 = n2.filter(function(e4) {
          return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
        })), i2.push.apply(i2, n2);
      }
      return i2;
    }(Object(e2)).forEach(function(i2) {
      Object.defineProperty(t2, i2, Object.getOwnPropertyDescriptor(e2, i2));
    }), t2;
  }
  function S(t2, e2) {
    (null == e2 || e2 > t2.length) && (e2 = t2.length);
    for (var i2 = 0, n2 = new Array(e2); i2 < e2; i2++)
      n2[i2] = t2[i2];
    return n2;
  }
  function E(t2, e2, i2) {
    return e2 in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
  }
  function M(t2) {
    return function(t3) {
      if (Array.isArray(t3))
        return S(t3);
    }(t2) || function(t3) {
      if ("undefined" != typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"])
        return Array.from(t3);
    }(t2) || function(t3, e2) {
      if (!t3)
        return;
      if ("string" == typeof t3)
        return S(t3, e2);
      var i2 = Object.prototype.toString.call(t3).slice(8, -1);
      "Object" === i2 && t3.constructor && (i2 = t3.constructor.name);
      if ("Map" === i2 || "Set" === i2)
        return Array.from(i2);
      if ("Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2))
        return S(t3, e2);
    }(t2) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function N() {
    for (var t2 in this.dropdown = {}, this._dropdown)
      this.dropdown[t2] = "function" == typeof this._dropdown[t2] ? this._dropdown[t2].bind(this) : this._dropdown[t2];
    this.dropdown.refs(), this.DOM.dropdown.__tagify = this;
  }
  var _;
  var A;
  var C = (_ = function(t2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var i2 = null != arguments[e2] ? arguments[e2] : {}, n2 = Object.keys(i2);
      "function" == typeof Object.getOwnPropertySymbols && (n2 = n2.concat(Object.getOwnPropertySymbols(i2).filter(function(t3) {
        return Object.getOwnPropertyDescriptor(i2, t3).enumerable;
      }))), n2.forEach(function(e3) {
        E(t2, e3, i2[e3]);
      });
    }
    return t2;
  }({}, { events: { binding: function() {
    var t2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e2 = this.dropdown.events.callbacks, i2 = this.listeners.dropdown = this.listeners.dropdown || { position: this.dropdown.position.bind(this, null), onKeyDown: e2.onKeyDown.bind(this), onMouseOver: e2.onMouseOver.bind(this), onMouseLeave: e2.onMouseLeave.bind(this), onClick: e2.onClick.bind(this), onScroll: e2.onScroll.bind(this) }, n2 = t2 ? "addEventListener" : "removeEventListener";
    "manual" != this.settings.dropdown.position && (document[n2]("scroll", i2.position, true), window[n2]("resize", i2.position), window[n2]("keydown", i2.onKeyDown)), this.DOM.dropdown[n2]("mouseover", i2.onMouseOver), this.DOM.dropdown[n2]("mouseleave", i2.onMouseLeave), this.DOM.dropdown[n2]("mousedown", i2.onClick), this.DOM.dropdown.content[n2]("scroll", i2.onScroll);
  }, callbacks: { onKeyDown: function(t2) {
    var e2 = this;
    if (this.state.hasFocus && !this.state.composing) {
      var i2 = this.settings, s2 = this.DOM.dropdown.querySelector(i2.classNames.dropdownItemActiveSelector), a2 = this.dropdown.getSuggestionDataByNode(s2), o2 = "mix" == i2.mode, r2 = "select" == i2.mode;
      i2.hooks.beforeKeyDown(t2, { tagify: this }).then(function(l2) {
        switch (t2.key) {
          case "ArrowDown":
          case "ArrowUp":
          case "Down":
          case "Up":
            t2.preventDefault();
            var d2 = e2.dropdown.getAllSuggestionsRefs(), c2 = "ArrowUp" == t2.key || "Up" == t2.key;
            s2 && (s2 = e2.dropdown.getNextOrPrevOption(s2, !c2)), s2 && s2.matches(i2.classNames.dropdownItemSelector) || (s2 = d2[c2 ? d2.length - 1 : 0]), e2.dropdown.highlightOption(s2, true);
            break;
          case "Escape":
          case "Esc":
            e2.dropdown.hide();
            break;
          case "ArrowRight":
            if (e2.state.actions.ArrowLeft || i2.autoComplete.rightKey)
              return;
          case "Tab":
            var u2 = !i2.autoComplete.rightKey || !i2.autoComplete.tabKey;
            if (!o2 && !r2 && s2 && u2 && !e2.state.editing && a2) {
              t2.preventDefault();
              var g2 = e2.dropdown.getMappedValue(a2);
              return e2.input.autocomplete.set.call(e2, g2), false;
            }
            return true;
          case "Enter":
            t2.preventDefault(), i2.hooks.suggestionClick(t2, { tagify: e2, tagData: a2, suggestionElm: s2 }).then(function() {
              if (s2)
                return e2.dropdown.selectOption(s2), s2 = e2.dropdown.getNextOrPrevOption(s2, !c2), void e2.dropdown.highlightOption(s2);
              e2.dropdown.hide(), o2 || e2.addTags(e2.state.inputText.trim(), true);
            }).catch(function(t3) {
              return n.warn(t3);
            });
            break;
          case "Backspace":
            if (o2 || e2.state.editing.scope)
              return;
            var h2 = e2.input.raw.call(e2);
            "" != h2 && 8203 != h2.charCodeAt(0) || (true === i2.backspace ? e2.removeTags() : "edit" == i2.backspace && setTimeout(e2.editTag.bind(e2), 0));
        }
      });
    }
  }, onMouseOver: function(t2) {
    var e2 = t2.target.closest(this.settings.classNames.dropdownItemSelector);
    this.dropdown.highlightOption(e2);
  }, onMouseLeave: function(t2) {
    this.dropdown.highlightOption();
  }, onClick: function(t2) {
    var e2 = this;
    if (0 == t2.button && t2.target != this.DOM.dropdown && t2.target != this.DOM.dropdown.content) {
      var i2 = t2.target.closest(this.settings.classNames.dropdownItemSelector), s2 = this.dropdown.getSuggestionDataByNode(i2);
      this.state.actions.selectOption = true, setTimeout(function() {
        return e2.state.actions.selectOption = false;
      }, 50), this.settings.hooks.suggestionClick(t2, { tagify: this, tagData: s2, suggestionElm: i2 }).then(function() {
        i2 ? e2.dropdown.selectOption(i2, t2) : e2.dropdown.hide();
      }).catch(function(t3) {
        return n.warn(t3);
      });
    }
  }, onScroll: function(t2) {
    var e2 = t2.target, i2 = e2.scrollTop / (e2.scrollHeight - e2.parentNode.clientHeight) * 100;
    this.trigger("dropdown:scroll", { percentage: Math.round(i2) });
  } } }, refilter: function(t2) {
    t2 = t2 || this.state.dropdown.query || "", this.suggestedListItems = this.dropdown.filterListItems(t2), this.dropdown.fill(), this.suggestedListItems.length || this.dropdown.hide(), this.trigger("dropdown:updated", this.DOM.dropdown);
  }, getSuggestionDataByNode: function(t2) {
    for (var e2, i2 = t2 && t2.getAttribute("value"), n2 = this.suggestedListItems.length; n2--; ) {
      if (c(e2 = this.suggestedListItems[n2]) && e2.value == i2)
        return e2;
      if (e2 == i2)
        return { value: e2 };
    }
  }, getNextOrPrevOption: function(t2) {
    var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = this.dropdown.getAllSuggestionsRefs(), n2 = i2.findIndex(function(e3) {
      return e3 === t2;
    });
    return e2 ? i2[n2 + 1] : i2[n2 - 1];
  }, highlightOption: function(t2, e2) {
    var i2, n2 = this.settings.classNames.dropdownItemActive;
    if (this.state.ddItemElm && (this.state.ddItemElm.classList.remove(n2), this.state.ddItemElm.removeAttribute("aria-selected")), !t2)
      return this.state.ddItemData = null, this.state.ddItemElm = null, void this.input.autocomplete.suggest.call(this);
    i2 = this.dropdown.getSuggestionDataByNode(t2), this.state.ddItemData = i2, this.state.ddItemElm = t2, t2.classList.add(n2), t2.setAttribute("aria-selected", true), e2 && (t2.parentNode.scrollTop = t2.clientHeight + t2.offsetTop - t2.parentNode.clientHeight), this.settings.autoComplete && (this.input.autocomplete.suggest.call(this, i2), this.dropdown.position());
  }, selectOption: function(t2, e2) {
    var i2 = this, n2 = this.settings, s2 = n2.dropdown, a2 = s2.clearOnSelect, o2 = s2.closeOnSelect;
    if (!t2)
      return this.addTags(this.state.inputText, true), void (o2 && this.dropdown.hide());
    e2 = e2 || {};
    var r2 = t2.getAttribute("value"), l2 = "noMatch" == r2, d2 = "mix" == n2.mode, c2 = this.suggestedListItems.find(function(t3) {
      var e3;
      return (null !== (e3 = t3.value) && void 0 !== e3 ? e3 : t3) == r2;
    });
    if (this.trigger("dropdown:select", { data: c2, elm: t2, event: e2 }), c2 || l2) {
      if (this.state.editing) {
        var g2 = this.normalizeTags([c2])[0];
        c2 = n2.transformTag.call(this, g2) || g2, this.onEditTagDone(null, u({ __isValid: true }, c2));
      } else
        this[d2 ? "addMixTags" : "addTags"]([c2 || this.input.raw.call(this)], a2);
      (d2 || this.DOM.input.parentNode) && (setTimeout(function() {
        i2.DOM.input.focus(), i2.toggleFocusClass(true);
      }), o2 && setTimeout(this.dropdown.hide.bind(this)), t2.addEventListener("transitionend", function() {
        i2.dropdown.fillHeaderFooter(), setTimeout(function() {
          t2.remove(), i2.dropdown.refilter();
        }, 100);
      }, { once: true }), t2.classList.add(this.settings.classNames.dropdownItemHidden));
    } else
      o2 && setTimeout(this.dropdown.hide.bind(this));
  }, selectAll: function(t2) {
    this.suggestedListItems.length = 0, this.dropdown.hide(), this.dropdown.filterListItems("");
    var e2 = this.dropdown.filterListItems("");
    return t2 || (e2 = this.state.dropdown.suggestions), this.addTags(e2, true), this;
  }, filterListItems: function(t2, e2) {
    var i2, n2, s2, a2, o2, r2, l2 = function() {
      var t3, l3, d3 = void 0, u3 = void 0;
      t3 = m2[y2], n2 = (null != (l3 = Object) && "undefined" != typeof Symbol && l3[Symbol.hasInstance] ? l3[Symbol.hasInstance](t3) : t3 instanceof l3) ? m2[y2] : { value: m2[y2] };
      var v3, b3 = !Object.keys(n2).some(function(t4) {
        return w2.includes(t4);
      }) ? ["value"] : w2;
      g2.fuzzySearch && !e2.exact ? (a2 = b3.reduce(function(t4, e3) {
        return t4 + " " + (n2[e3] || "");
      }, "").toLowerCase().trim(), g2.accentedSearch && (a2 = h(a2), r2 = h(r2)), d3 = 0 == a2.indexOf(r2), u3 = a2 === r2, v3 = a2, s2 = r2.toLowerCase().split(" ").every(function(t4) {
        return v3.includes(t4.toLowerCase());
      })) : (d3 = true, s2 = b3.some(function(t4) {
        var i3 = "" + (n2[t4] || "");
        return g2.accentedSearch && (i3 = h(i3), r2 = h(r2)), g2.caseSensitive || (i3 = i3.toLowerCase()), u3 = i3 === r2, e2.exact ? i3 === r2 : 0 == i3.indexOf(r2);
      })), o2 = !g2.includeSelectedTags && i2.isTagDuplicate(c(n2) ? n2.value : n2), s2 && !o2 && (u3 && d3 ? f2.push(n2) : "startsWith" == g2.sortby && d3 ? p2.unshift(n2) : p2.push(n2));
    }, d2 = this, u2 = this.settings, g2 = u2.dropdown, p2 = (e2 = e2 || {}, []), f2 = [], m2 = u2.whitelist, v2 = g2.maxItems >= 0 ? g2.maxItems : 1 / 0, b2 = g2.includeSelectedTags || "select" == u2.mode, w2 = g2.searchKeys, y2 = 0;
    if (!(t2 = "select" == u2.mode && this.value.length && this.value[0][u2.tagTextProp] == t2 ? "" : t2) || !w2.length)
      return p2 = b2 ? m2 : m2.filter(function(t3) {
        return !d2.isTagDuplicate(c(t3) ? t3.value : t3);
      }), this.state.dropdown.suggestions = p2, p2.slice(0, v2);
    for (r2 = g2.caseSensitive ? "" + t2 : ("" + t2).toLowerCase(); y2 < m2.length; y2++)
      i2 = this, l2();
    return this.state.dropdown.suggestions = f2.concat(p2), "function" == typeof g2.sortby ? g2.sortby(f2.concat(p2), r2) : f2.concat(p2).slice(0, v2);
  }, getMappedValue: function(t2) {
    var e2 = this.settings.dropdown.mapValueTo;
    return e2 ? "function" == typeof e2 ? e2(t2) : t2[e2] || t2.value : t2.value;
  }, createListHTML: function(t2) {
    var e2 = this;
    return u([], t2).map(function(t3, i2) {
      "string" != typeof t3 && "number" != typeof t3 || (t3 = { value: t3 });
      var n2 = e2.dropdown.getMappedValue(t3);
      return n2 = "string" == typeof n2 && e2.settings.dropdown.escapeHTML ? d(n2) : n2, e2.settings.templates.dropdownItem.apply(e2, [I(D({}, t3), { mappedValue: n2 }), e2]);
    }).join("");
  } }), A = null != (A = { refs: function() {
    this.DOM.dropdown = this.parseTemplate("dropdown", [this.settings]), this.DOM.dropdown.content = this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-wrapper']");
  }, getHeaderRef: function() {
    return this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-header']");
  }, getFooterRef: function() {
    return this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-footer']");
  }, getAllSuggestionsRefs: function() {
    return M(this.DOM.dropdown.content.querySelectorAll(this.settings.classNames.dropdownItemSelector));
  }, show: function(t2) {
    var e2, i2, n2, a2 = this, o2 = this.settings, r2 = "mix" == o2.mode && !o2.enforceWhitelist, l2 = !o2.whitelist || !o2.whitelist.length, d2 = "manual" == o2.dropdown.position;
    if (t2 = void 0 === t2 ? this.state.inputText : t2, !(l2 && !r2 && !o2.templates.dropdownItemNoMatch || false === o2.dropdown.enable || this.state.isLoading || this.settings.readonly)) {
      if (clearTimeout(this.dropdownHide__bindEventsTimeout), this.suggestedListItems = this.dropdown.filterListItems(t2), t2 && !this.suggestedListItems.length && (this.trigger("dropdown:noMatch", t2), o2.templates.dropdownItemNoMatch && (n2 = o2.templates.dropdownItemNoMatch.call(this, { value: t2 }))), !n2) {
        if (this.suggestedListItems.length)
          t2 && r2 && !this.state.editing.scope && !s(this.suggestedListItems[0].value, t2) && this.suggestedListItems.unshift({ value: t2 });
        else {
          if (!t2 || !r2 || this.state.editing.scope)
            return this.input.autocomplete.suggest.call(this), void this.dropdown.hide();
          this.suggestedListItems = [{ value: t2 }];
        }
        i2 = "" + (c(e2 = this.suggestedListItems[0]) ? e2.value : e2), o2.autoComplete && i2 && 0 == i2.indexOf(t2) && this.input.autocomplete.suggest.call(this, e2);
      }
      this.dropdown.fill(n2), o2.dropdown.highlightFirst && this.dropdown.highlightOption(this.DOM.dropdown.content.querySelector(o2.classNames.dropdownItemSelector)), this.state.dropdown.visible || setTimeout(this.dropdown.events.binding.bind(this)), this.state.dropdown.visible = t2 || true, this.state.dropdown.query = t2, this.setStateSelection(), d2 || setTimeout(function() {
        a2.dropdown.position(), a2.dropdown.render();
      }), setTimeout(function() {
        a2.trigger("dropdown:show", a2.DOM.dropdown);
      });
    }
  }, hide: function(t2) {
    var e2 = this, i2 = this.DOM, n2 = i2.scope, s2 = i2.dropdown, a2 = "manual" == this.settings.dropdown.position && !t2;
    if (s2 && document.body.contains(s2) && !a2)
      return window.removeEventListener("resize", this.dropdown.position), this.dropdown.events.binding.call(this, false), n2.setAttribute("aria-expanded", false), s2.parentNode.removeChild(s2), setTimeout(function() {
        e2.state.dropdown.visible = false;
      }, 100), this.state.dropdown.query = this.state.ddItemData = this.state.ddItemElm = this.state.selection = null, this.state.tag && this.state.tag.value.length && (this.state.flaggedTags[this.state.tag.baseOffset] = this.state.tag), this.trigger("dropdown:hide", s2), this;
  }, toggle: function(t2) {
    this.dropdown[this.state.dropdown.visible && !t2 ? "hide" : "show"]();
  }, getAppendTarget: function() {
    var t2 = this.settings.dropdown;
    return "function" == typeof t2.appendTarget ? t2.appendTarget() : t2.appendTarget;
  }, render: function() {
    var t2, e2, i2, n2 = this, s2 = (t2 = this.DOM.dropdown, (i2 = t2.cloneNode(true)).style.cssText = "position:fixed; top:-9999px; opacity:0", document.body.appendChild(i2), e2 = i2.clientHeight, i2.parentNode.removeChild(i2), e2), a2 = this.settings, o2 = this.dropdown.getAppendTarget();
    return false === a2.dropdown.enabled || (this.DOM.scope.setAttribute("aria-expanded", true), document.body.contains(this.DOM.dropdown) || (this.DOM.dropdown.classList.add(a2.classNames.dropdownInital), this.dropdown.position(s2), o2.appendChild(this.DOM.dropdown), setTimeout(function() {
      return n2.DOM.dropdown.classList.remove(a2.classNames.dropdownInital);
    }))), this;
  }, fill: function(t2) {
    t2 = "string" == typeof t2 ? t2 : this.dropdown.createListHTML(t2 || this.suggestedListItems);
    var e2, i2 = this.settings.templates.dropdownContent.call(this, t2);
    this.DOM.dropdown.content.innerHTML = (e2 = i2) ? e2.replace(/\>[\r\n ]+\</g, "><").split(/>\s+</).join("><").trim() : "";
  }, fillHeaderFooter: function() {
    var t2 = this.dropdown.filterListItems(this.state.dropdown.query), e2 = this.parseTemplate("dropdownHeader", [t2]), i2 = this.parseTemplate("dropdownFooter", [t2]), n2 = this.dropdown.getHeaderRef(), s2 = this.dropdown.getFooterRef();
    e2 && (null == n2 || n2.parentNode.replaceChild(e2, n2)), i2 && (null == s2 || s2.parentNode.replaceChild(i2, s2));
  }, position: function(t2) {
    var e2 = this.settings.dropdown, i2 = this.dropdown.getAppendTarget();
    if ("manual" != e2.position && i2) {
      var n2, s2, a2, o2, r2, l2, d2, c2, u2, g2 = this.DOM.dropdown, h2 = e2.RTL, p2 = i2 === document.body, f2 = i2 === this.DOM.scope, m2 = p2 ? window.pageYOffset : i2.scrollTop, v2 = document.fullscreenElement || document.webkitFullscreenElement || document.documentElement, b2 = v2.clientHeight, w2 = Math.max(v2.clientWidth || 0, window.innerWidth || 0) > 480 ? e2.position : "all", y2 = this.DOM["input" == w2 ? "input" : "scope"];
      if (t2 = t2 || g2.clientHeight, this.state.dropdown.visible) {
        if ("text" == w2 ? (a2 = (n2 = function() {
          var t3 = document.getSelection();
          if (t3.rangeCount) {
            var e3, i3, n3 = t3.getRangeAt(0), s3 = n3.startContainer, a3 = n3.startOffset;
            if (a3 > 0)
              return (i3 = document.createRange()).setStart(s3, a3 - 1), i3.setEnd(s3, a3), { left: (e3 = i3.getBoundingClientRect()).right, top: e3.top, bottom: e3.bottom };
            if (s3.getBoundingClientRect)
              return s3.getBoundingClientRect();
          }
          return { left: -9999, top: -9999 };
        }()).bottom, s2 = n2.top, o2 = n2.left, r2 = "auto") : (l2 = function(t3) {
          var e3 = 0, i3 = 0;
          for (t3 = t3.parentNode; t3 && t3 != v2; )
            e3 += t3.offsetTop || 0, i3 += t3.offsetLeft || 0, t3 = t3.parentNode;
          return { top: e3, left: i3 };
        }(i2), n2 = y2.getBoundingClientRect(), s2 = f2 ? -1 : n2.top - l2.top, a2 = (f2 ? n2.height : n2.bottom - l2.top) - 1, o2 = f2 ? -1 : n2.left - l2.left, r2 = n2.width + "px"), !p2) {
          var T2 = function() {
            for (var t3 = 0, i3 = e2.appendTarget.parentNode; i3; )
              t3 += i3.scrollTop || 0, i3 = i3.parentNode;
            return t3;
          }();
          s2 += T2, a2 += T2;
        }
        var O2;
        s2 = Math.floor(s2), a2 = Math.ceil(a2), c2 = ((d2 = null !== (O2 = e2.placeAbove) && void 0 !== O2 ? O2 : b2 - n2.bottom < t2) ? s2 : a2) + m2, u2 = "left: ".concat(o2 + (h2 && n2.width || 0) + window.pageXOffset, "px;"), g2.style.cssText = "".concat(u2, "; top: ").concat(c2, "px; min-width: ").concat(r2, "; max-width: ").concat(r2), g2.setAttribute("placement", d2 ? "top" : "bottom"), g2.setAttribute("position", w2);
      }
    }
  } }) ? A : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(_, Object.getOwnPropertyDescriptors(A)) : function(t2, e2) {
    var i2 = Object.keys(t2);
    if (Object.getOwnPropertySymbols) {
      var n2 = Object.getOwnPropertySymbols(t2);
      e2 && (n2 = n2.filter(function(e3) {
        return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
      })), i2.push.apply(i2, n2);
    }
    return i2;
  }(Object(A)).forEach(function(t2) {
    Object.defineProperty(_, t2, Object.getOwnPropertyDescriptor(A, t2));
  }), _);
  var k = "@yaireo/tagify/";
  var L = { empty: "empty", exceed: "number of tags exceeded", pattern: "pattern mismatch", duplicate: "already exists", notAllowed: "not allowed" };
  var j = { wrapper: function(e2, i2) {
    return '<tags class="'.concat(i2.classNames.namespace, " ").concat(i2.mode ? "".concat(i2.classNames[i2.mode + "Mode"]) : "", " ").concat(e2.className, '"\n                    ').concat(i2.readonly ? "readonly" : "", "\n                    ").concat(i2.disabled ? "disabled" : "", "\n                    ").concat(i2.required ? "required" : "", "\n                    ").concat("select" === i2.mode ? "spellcheck='false'" : "", '\n                    tabIndex="-1">\n                    ').concat(this.settings.templates.input.call(this), "\n                ").concat(t, "\n        </tags>");
  }, input: function() {
    var e2 = this.settings, i2 = e2.placeholder || t;
    return "<span ".concat(!e2.readonly && e2.userInput ? "contenteditable" : "", ' tabIndex="0" data-placeholder="').concat(i2, '" aria-placeholder="').concat(e2.placeholder || "", '"\n                    class="').concat(e2.classNames.input, '"\n                    role="textbox"\n                    autocapitalize="false"\n                    autocorrect="off"\n                    spellcheck="false"\n                    aria-autocomplete="both"\n                    aria-multiline="').concat("mix" == e2.mode, '"></span>');
  }, tag: function(t2, e2) {
    var i2 = e2.settings;
    return '<tag title="'.concat(t2.title || t2.value, `"
                    contenteditable='false'
                    tabIndex="`).concat(i2.a11y.focusableTags ? 0 : -1, '"\n                    class="').concat(i2.classNames.tag, " ").concat(t2.class || "", '"\n                    ').concat(this.getAttributes(t2), `>
            <x title='' tabIndex="`).concat(i2.a11y.focusableTags ? 0 : -1, '" class="').concat(i2.classNames.tagX, `" role='button' aria-label='remove tag'></x>
            <div>
                <span `).concat("select" === i2.mode && i2.userInput ? "contenteditable='true'" : "", ` autocapitalize="false" autocorrect="off" spellcheck='false' class="`).concat(i2.classNames.tagText, '">').concat(t2[i2.tagTextProp] || t2.value, "</span>\n            </div>\n        </tag>");
  }, dropdown: function(t2) {
    var e2 = t2.dropdown, i2 = "manual" == e2.position;
    return '<div class="'.concat(i2 ? "" : t2.classNames.dropdown, " ").concat(e2.classname, '" role="listbox" aria-labelledby="dropdown" dir="').concat(e2.RTL ? "rtl" : "", `">
                    <div data-selector='tagify-suggestions-wrapper' class="`).concat(t2.classNames.dropdownWrapper, '"></div>\n                </div>');
  }, dropdownContent: function(t2) {
    var e2 = this.settings.templates, i2 = this.state.dropdown.suggestions;
    return "\n            ".concat(e2.dropdownHeader.call(this, i2), "\n            ").concat(t2, "\n            ").concat(e2.dropdownFooter.call(this, i2), "\n        ");
  }, dropdownItem: function(t2) {
    return "<div ".concat(this.getAttributes(t2), "\n                    class='").concat(this.settings.classNames.dropdownItem, " ").concat(this.isTagDuplicate(t2.value) ? this.settings.classNames.dropdownItemSelected : "", " ").concat(t2.class || "", `'
                    tabindex="0"
                    role="option">`).concat(t2.mappedValue || t2.value, "</div>");
  }, dropdownHeader: function(t2) {
    return `<header data-selector='tagify-suggestions-header' class="`.concat(this.settings.classNames.dropdownHeader, '"></header>');
  }, dropdownFooter: function(t2) {
    var e2 = t2.length - this.settings.dropdown.maxItems;
    return e2 > 0 ? `<footer data-selector='tagify-suggestions-footer' class="`.concat(this.settings.classNames.dropdownFooter, '">\n                ').concat(e2, " more items. Refine your search.\n            </footer>") : "";
  }, dropdownItemNoMatch: null };
  function P(t2, e2) {
    (null == e2 || e2 > t2.length) && (e2 = t2.length);
    for (var i2 = 0, n2 = new Array(e2); i2 < e2; i2++)
      n2[i2] = t2[i2];
    return n2;
  }
  function V(t2, e2) {
    return null != e2 && "undefined" != typeof Symbol && e2[Symbol.hasInstance] ? !!e2[Symbol.hasInstance](t2) : t2 instanceof e2;
  }
  function F(t2, e2) {
    return function(t3) {
      if (Array.isArray(t3))
        return t3;
    }(t2) || function(t3, e3) {
      var i2 = null == t3 ? null : "undefined" != typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
      if (null != i2) {
        var n2, s2, a2 = [], o2 = true, r2 = false;
        try {
          for (i2 = i2.call(t3); !(o2 = (n2 = i2.next()).done) && (a2.push(n2.value), !e3 || a2.length !== e3); o2 = true)
            ;
        } catch (t4) {
          r2 = true, s2 = t4;
        } finally {
          try {
            o2 || null == i2.return || i2.return();
          } finally {
            if (r2)
              throw s2;
          }
        }
        return a2;
      }
    }(t2, e2) || function(t3, e3) {
      if (!t3)
        return;
      if ("string" == typeof t3)
        return P(t3, e3);
      var i2 = Object.prototype.toString.call(t3).slice(8, -1);
      "Object" === i2 && t3.constructor && (i2 = t3.constructor.name);
      if ("Map" === i2 || "Set" === i2)
        return Array.from(i2);
      if ("Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2))
        return P(t3, e3);
    }(t2, e2) || function() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function R(t2, e2) {
    (null == e2 || e2 > t2.length) && (e2 = t2.length);
    for (var i2 = 0, n2 = new Array(e2); i2 < e2; i2++)
      n2[i2] = t2[i2];
    return n2;
  }
  function H(t2, e2, i2) {
    return e2 in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
  }
  function B(t2, e2) {
    return null != e2 && "undefined" != typeof Symbol && e2[Symbol.hasInstance] ? !!e2[Symbol.hasInstance](t2) : t2 instanceof e2;
  }
  function W(t2, e2) {
    return e2 = null != e2 ? e2 : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(e2)) : function(t3, e3) {
      var i2 = Object.keys(t3);
      if (Object.getOwnPropertySymbols) {
        var n2 = Object.getOwnPropertySymbols(t3);
        e3 && (n2 = n2.filter(function(e4) {
          return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
        })), i2.push.apply(i2, n2);
      }
      return i2;
    }(Object(e2)).forEach(function(i2) {
      Object.defineProperty(t2, i2, Object.getOwnPropertyDescriptor(e2, i2));
    }), t2;
  }
  function K(t2) {
    return function(t3) {
      if (Array.isArray(t3))
        return R(t3);
    }(t2) || function(t3) {
      if ("undefined" != typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"])
        return Array.from(t3);
    }(t2) || function(t3, e2) {
      if (!t3)
        return;
      if ("string" == typeof t3)
        return R(t3, e2);
      var i2 = Object.prototype.toString.call(t3).slice(8, -1);
      "Object" === i2 && t3.constructor && (i2 = t3.constructor.name);
      if ("Map" === i2 || "Set" === i2)
        return Array.from(i2);
      if ("Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2))
        return R(t3, e2);
    }(t2) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  var U = { customBinding: function() {
    var t2 = this;
    this.customEventsList.forEach(function(e2) {
      t2.on(e2, t2.settings.callbacks[e2]);
    });
  }, binding: function() {
    var t2, e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], i2 = this.settings, n2 = this.events.callbacks, s2 = e2 ? "addEventListener" : "removeEventListener";
    if (!this.state.mainEvents || !e2) {
      for (var a2 in this.state.mainEvents = e2, e2 && !this.listeners.main && (this.events.bindGlobal.call(this), this.settings.isJQueryPlugin && jQuery(this.DOM.originalInput).on("tagify.removeAllTags", this.removeAllTags.bind(this))), t2 = this.listeners.main = this.listeners.main || { keydown: ["input", n2.onKeydown.bind(this)], click: ["scope", n2.onClickScope.bind(this)], dblclick: "select" != i2.mode && ["scope", n2.onDoubleClickScope.bind(this)], paste: ["input", n2.onPaste.bind(this)], drop: ["input", n2.onDrop.bind(this)], compositionstart: ["input", n2.onCompositionStart.bind(this)], compositionend: ["input", n2.onCompositionEnd.bind(this)] })
        t2[a2] && this.DOM[t2[a2][0]][s2](a2, t2[a2][1]);
      var o2 = this.listeners.main.inputMutationObserver || new MutationObserver(n2.onInputDOMChange.bind(this));
      o2.disconnect(), "mix" == i2.mode && o2.observe(this.DOM.input, { childList: true }), this.events.bindOriginaInputListener.call(this);
    }
  }, bindOriginaInputListener: function(t2) {
    var e2 = (t2 || 0) + 500;
    this.listeners.main && (clearInterval(this.listeners.main.originalInputValueObserverInterval), this.listeners.main.originalInputValueObserverInterval = setInterval(this.events.callbacks.observeOriginalInputValue.bind(this), e2));
  }, bindGlobal: function(t2) {
    var e2, i2 = this.events.callbacks, n2 = t2 ? "removeEventListener" : "addEventListener";
    if (this.listeners && (t2 || !this.listeners.global)) {
      this.listeners.global = this.listeners.global || [{ type: this.isIE ? "keydown" : "input", target: this.DOM.input, cb: i2[this.isIE ? "onInputIE" : "onInput"].bind(this) }, { type: "keydown", target: window, cb: i2.onWindowKeyDown.bind(this) }, { type: "focusin", target: this.DOM.scope, cb: i2.onFocusBlur.bind(this) }, { type: "focusout", target: this.DOM.scope, cb: i2.onFocusBlur.bind(this) }, { type: "click", target: document, cb: i2.onClickAnywhere.bind(this), useCapture: true }];
      var s2 = true, a2 = false, o2 = void 0;
      try {
        for (var r2, l2 = this.listeners.global[Symbol.iterator](); !(s2 = (r2 = l2.next()).done); s2 = true)
          (e2 = r2.value).target[n2](e2.type, e2.cb, !!e2.useCapture);
      } catch (t3) {
        a2 = true, o2 = t3;
      } finally {
        try {
          s2 || null == l2.return || l2.return();
        } finally {
          if (a2)
            throw o2;
        }
      }
    }
  }, unbindGlobal: function() {
    this.events.bindGlobal.call(this, true);
  }, callbacks: { onFocusBlur: function(t2) {
    var e2, i2, n2 = this.settings, s2 = v.call(this, t2.target), a2 = m.call(this, t2.target), o2 = t2.target.classList.contains(n2.classNames.tagX), r2 = "focusin" == t2.type, l2 = "focusout" == t2.type;
    s2 && r2 && !a2 && !o2 && this.toggleFocusClass(this.state.hasFocus = +/* @__PURE__ */ new Date());
    var d2 = t2.target ? this.trim(this.DOM.input.textContent) : "", c2 = null === (i2 = this.value) || void 0 === i2 || null === (e2 = i2[0]) || void 0 === e2 ? void 0 : e2[n2.tagTextProp], u2 = n2.dropdown.enabled >= 0, g2 = { relatedTarget: t2.relatedTarget }, h2 = this.state.actions.selectOption && (u2 || !n2.dropdown.closeOnSelect), p2 = this.state.actions.addNew && u2;
    if (l2) {
      if (t2.relatedTarget === this.DOM.scope)
        return this.dropdown.hide(), void this.DOM.input.focus();
      this.postUpdate(), n2.onChangeAfterBlur && this.triggerChangeEvent();
    }
    if (!(h2 || p2 || o2))
      if (r2 || s2 ? (this.state.hasFocus = +/* @__PURE__ */ new Date(), this.toggleFocusClass(this.state.hasFocus)) : this.state.hasFocus = false, "mix" != n2.mode) {
        if (r2) {
          if (!n2.focusable)
            return;
          var f2 = 0 === n2.dropdown.enabled && !this.state.dropdown.visible, b2 = !a2 || "select" === n2.mode;
          return this.toggleFocusClass(true), this.trigger("focus", g2), void (f2 && b2 && this.dropdown.show(this.value.length ? "" : void 0));
        }
        if (l2) {
          if (this.trigger("blur", g2), this.loading(false), "select" == n2.mode) {
            if (this.value.length) {
              var w2 = this.getTagElms()[0];
              d2 = this.trim(w2.textContent);
            }
            c2 === d2 && (d2 = "");
          }
          d2 && !this.state.actions.selectOption && n2.addTagOnBlur && n2.addTagOn.includes("blur") && this.addTags(d2, true);
        }
        s2 || (this.DOM.input.removeAttribute("style"), this.dropdown.hide());
      } else
        r2 ? this.trigger("focus", g2) : l2 && (this.trigger("blur", g2), this.loading(false), this.dropdown.hide(), this.state.dropdown.visible = void 0, this.setStateSelection());
  }, onCompositionStart: function(t2) {
    this.state.composing = true;
  }, onCompositionEnd: function(t2) {
    this.state.composing = false;
  }, onWindowKeyDown: function(t2) {
    var e2, i2 = this.settings, n2 = document.activeElement, s2 = v.call(this, n2) && this.DOM.scope.contains(document.activeElement), a2 = s2 && n2.hasAttribute("readonly");
    if (this.state.hasFocus || s2 && !a2) {
      e2 = n2.nextElementSibling;
      var o2 = t2.target.classList.contains(i2.classNames.tagX);
      switch (t2.key) {
        case "Backspace":
          i2.readonly || this.state.editing || (this.removeTags(n2), (e2 || this.DOM.input).focus());
          break;
        case "Enter":
          if (o2)
            return void this.removeTags(t2.target.parentNode);
          i2.a11y.focusableTags && m.call(this, n2) && setTimeout(this.editTag.bind(this), 0, n2);
          break;
        case "ArrowDown":
          this.state.dropdown.visible || "mix" == i2.mode || this.dropdown.show();
      }
    }
  }, onKeydown: function(t2) {
    var e2 = this, i2 = this.settings;
    if (!this.state.composing && i2.userInput) {
      "select" == i2.mode && i2.enforceWhitelist && this.value.length && "Tab" != t2.key && t2.preventDefault();
      var n2 = this.trim(t2.target.textContent);
      this.trigger("keydown", { event: t2 }), i2.hooks.beforeKeyDown(t2, { tagify: this }).then(function(s2) {
        if ("mix" == i2.mode) {
          switch (t2.key) {
            case "Left":
            case "ArrowLeft":
              e2.state.actions.ArrowLeft = true;
              break;
            case "Delete":
            case "Backspace":
              if (e2.state.editing)
                return;
              var a2 = document.getSelection(), o2 = "Delete" == t2.key && a2.anchorOffset == (a2.anchorNode.length || 0), r2 = a2.anchorNode.previousSibling, d2 = 1 == a2.anchorNode.nodeType || !a2.anchorOffset && r2 && 1 == r2.nodeType && a2.anchorNode.previousSibling;
              !function(t3) {
                var e3 = document.createElement("div");
                t3.replace(/\&#?[0-9a-z]+;/gi, function(t4) {
                  return e3.innerHTML = t4, e3.innerText;
                });
              }(e2.DOM.input.innerHTML);
              var c2, u2, g2, h2 = e2.getTagElms(), f2 = 1 === a2.anchorNode.length && a2.anchorNode.nodeValue == String.fromCharCode(8203);
              if ("edit" == i2.backspace && d2)
                return c2 = 1 == a2.anchorNode.nodeType ? null : a2.anchorNode.previousElementSibling, setTimeout(e2.editTag.bind(e2), 0, c2), void t2.preventDefault();
              if (p() && B(d2, Element))
                return g2 = l(d2), d2.hasAttribute("readonly") || d2.remove(), e2.DOM.input.focus(), void setTimeout(function() {
                  y(g2), e2.DOM.input.click();
                });
              if ("BR" == a2.anchorNode.nodeName)
                return;
              if ((o2 || d2) && 1 == a2.anchorNode.nodeType ? u2 = 0 == a2.anchorOffset ? o2 ? h2[0] : null : h2[Math.min(h2.length, a2.anchorOffset) - 1] : o2 ? u2 = a2.anchorNode.nextElementSibling : B(d2, Element) && (u2 = d2), 3 == a2.anchorNode.nodeType && !a2.anchorNode.nodeValue && a2.anchorNode.previousElementSibling && t2.preventDefault(), (d2 || o2) && !i2.backspace)
                return void t2.preventDefault();
              if ("Range" != a2.type && !a2.anchorOffset && a2.anchorNode == e2.DOM.input && "Delete" != t2.key)
                return void t2.preventDefault();
              if ("Range" != a2.type && u2 && u2.hasAttribute("readonly"))
                return void y(l(u2));
              "Delete" == t2.key && f2 && w(a2.anchorNode.nextSibling) && e2.removeTags(a2.anchorNode.nextSibling);
          }
          return true;
        }
        var m2 = "manual" == i2.dropdown.position;
        switch (t2.key) {
          case "Backspace":
            "select" == i2.mode && i2.enforceWhitelist && e2.value.length ? e2.removeTags() : e2.state.dropdown.visible && "manual" != i2.dropdown.position || "" != t2.target.textContent && 8203 != n2.charCodeAt(0) || (true === i2.backspace ? e2.removeTags() : "edit" == i2.backspace && setTimeout(e2.editTag.bind(e2), 0));
            break;
          case "Esc":
          case "Escape":
            if (e2.state.dropdown.visible)
              return;
            t2.target.blur();
            break;
          case "Down":
          case "ArrowDown":
            e2.state.dropdown.visible || e2.dropdown.show();
            break;
          case "ArrowRight":
            var v2 = e2.state.inputSuggestion || e2.state.ddItemData;
            if (v2 && i2.autoComplete.rightKey)
              return void e2.addTags([v2], true);
            break;
          case "Tab":
            var b2 = "select" == i2.mode;
            if (!n2 || b2)
              return true;
            t2.preventDefault();
          case "Enter":
            if (e2.state.dropdown.visible && !m2)
              return;
            t2.preventDefault(), setTimeout(function() {
              e2.state.dropdown.visible && !m2 || e2.state.actions.selectOption || !i2.addTagOn.includes(t2.key.toLowerCase()) || e2.addTags(n2, true);
            });
        }
      }).catch(function(t3) {
        return t3;
      });
    }
  }, onInput: function(t2) {
    this.postUpdate();
    var e2 = this.settings;
    if ("mix" == e2.mode)
      return this.events.callbacks.onMixTagsInput.call(this, t2);
    var i2 = this.input.normalize.call(this, void 0, { trim: false }), n2 = i2.length >= e2.dropdown.enabled, s2 = { value: i2, inputElm: this.DOM.input }, a2 = this.validateTag({ value: i2 });
    "select" == e2.mode && this.toggleScopeValidation(a2), s2.isValid = a2, this.state.inputText != i2 && (this.input.set.call(this, i2, false), -1 != i2.search(e2.delimiters) ? this.addTags(i2) && this.input.set.call(this) : e2.dropdown.enabled >= 0 && this.dropdown[n2 ? "show" : "hide"](i2), this.trigger("input", s2));
  }, onMixTagsInput: function(t2) {
    var e2, i2, n2, s2, a2, o2, r2, l2, d2 = this, c2 = this.settings, g2 = this.value.length, h2 = this.getTagElms(), f2 = document.createDocumentFragment(), m2 = window.getSelection().getRangeAt(0), v2 = [].map.call(h2, function(t3) {
      return w(t3).value;
    });
    if ("deleteContentBackward" == t2.inputType && p() && this.events.callbacks.onKeydown.call(this, { target: t2.target, key: "Backspace" }), T(this.getTagElms()), this.value.slice().forEach(function(t3) {
      t3.readonly && !v2.includes(t3.value) && f2.appendChild(d2.createTagElem(t3));
    }), f2.childNodes.length && (m2.insertNode(f2), this.setRangeAtStartEnd(false, f2.lastChild)), h2.length != g2)
      return this.value = [].map.call(this.getTagElms(), function(t3) {
        return w(t3);
      }), void this.update({ withoutChangeEvent: true });
    if (this.hasMaxTags())
      return true;
    if (window.getSelection && (o2 = window.getSelection()).rangeCount > 0 && 3 == o2.anchorNode.nodeType) {
      if ((m2 = o2.getRangeAt(0).cloneRange()).collapse(true), m2.setStart(o2.focusNode, 0), n2 = (e2 = m2.toString().slice(0, m2.endOffset)).split(c2.pattern).length - 1, (i2 = e2.match(c2.pattern)) && (s2 = e2.slice(e2.lastIndexOf(i2[i2.length - 1]))), s2) {
        if (this.state.actions.ArrowLeft = false, this.state.tag = { prefix: s2.match(c2.pattern)[0], value: s2.replace(c2.pattern, "") }, this.state.tag.baseOffset = o2.baseOffset - this.state.tag.value.length, l2 = this.state.tag.value.match(c2.delimiters))
          return this.state.tag.value = this.state.tag.value.replace(c2.delimiters, ""), this.state.tag.delimiters = l2[0], this.addTags(this.state.tag.value, c2.dropdown.clearOnSelect), void this.dropdown.hide();
        a2 = this.state.tag.value.length >= c2.dropdown.enabled;
        try {
          r2 = (r2 = this.state.flaggedTags[this.state.tag.baseOffset]).prefix == this.state.tag.prefix && r2.value[0] == this.state.tag.value[0], this.state.flaggedTags[this.state.tag.baseOffset] && !this.state.tag.value && delete this.state.flaggedTags[this.state.tag.baseOffset];
        } catch (t3) {
        }
        (r2 || n2 < this.state.mixMode.matchedPatternCount) && (a2 = false);
      } else
        this.state.flaggedTags = {};
      this.state.mixMode.matchedPatternCount = n2;
    }
    setTimeout(function() {
      d2.update({ withoutChangeEvent: true }), d2.trigger("input", u({}, d2.state.tag, { textContent: d2.DOM.input.textContent })), d2.state.tag && d2.dropdown[a2 ? "show" : "hide"](d2.state.tag.value);
    }, 10);
  }, onInputIE: function(t2) {
    var e2 = this;
    setTimeout(function() {
      e2.events.callbacks.onInput.call(e2, t2);
    });
  }, observeOriginalInputValue: function() {
    this.DOM.originalInput.parentNode || this.destroy(), this.DOM.originalInput.value != this.DOM.originalInput.tagifyValue && this.loadOriginalValues();
  }, onClickAnywhere: function(t2) {
    t2.target == this.DOM.scope || this.DOM.scope.contains(t2.target) || (this.toggleFocusClass(false), this.state.hasFocus = false, t2.target.closest(".tagify__dropdown") && t2.target.closest(".tagify__dropdown").__tagify != this && this.dropdown.hide());
  }, onClickScope: function(t2) {
    var e2 = this.settings, i2 = t2.target.closest("." + e2.classNames.tag), n2 = t2.target === this.DOM.scope, s2 = +/* @__PURE__ */ new Date() - this.state.hasFocus;
    if (n2 && "select" != e2.mode)
      this.DOM.input.focus();
    else {
      if (!t2.target.classList.contains(e2.classNames.tagX))
        return i2 && !this.state.editing ? (this.trigger("click", { tag: i2, index: this.getNodeIndex(i2), data: w(i2), event: t2 }), void (1 !== e2.editTags && 1 !== e2.editTags.clicks && "select" != e2.mode || this.events.callbacks.onDoubleClickScope.call(this, t2))) : void (t2.target == this.DOM.input && ("mix" == e2.mode && this.fixFirefoxLastTagNoCaret(), s2 > 500 || !e2.focusable) ? this.state.dropdown.visible ? this.dropdown.hide() : 0 === e2.dropdown.enabled && "mix" != e2.mode && this.dropdown.show(this.value.length ? "" : void 0) : "select" != e2.mode || 0 !== e2.dropdown.enabled || this.state.dropdown.visible || (this.events.callbacks.onDoubleClickScope.call(this, W(function(t3) {
          for (var e3 = 1; e3 < arguments.length; e3++) {
            var i3 = null != arguments[e3] ? arguments[e3] : {}, n3 = Object.keys(i3);
            "function" == typeof Object.getOwnPropertySymbols && (n3 = n3.concat(Object.getOwnPropertySymbols(i3).filter(function(t4) {
              return Object.getOwnPropertyDescriptor(i3, t4).enumerable;
            }))), n3.forEach(function(e4) {
              H(t3, e4, i3[e4]);
            });
          }
          return t3;
        }({}, t2), { target: this.getTagElms()[0] })), !e2.userInput && this.dropdown.show()));
      this.removeTags(t2.target.parentNode);
    }
  }, onPaste: function(t2) {
    var e2 = this;
    t2.preventDefault();
    var i2, n2, s2, a2 = this.settings;
    if ("select" == a2.mode && a2.enforceWhitelist || !a2.userInput)
      return false;
    a2.readonly || (n2 = t2.clipboardData || window.clipboardData, s2 = n2.getData("Text"), a2.hooks.beforePaste(t2, { tagify: this, pastedText: s2, clipboardData: n2 }).then(function(a3) {
      void 0 === a3 && (a3 = s2), a3 && (e2.injectAtCaret(a3, window.getSelection().getRangeAt(0)), "mix" == e2.settings.mode ? e2.events.callbacks.onMixTagsInput.call(e2, t2) : e2.settings.pasteAsTags ? i2 = e2.addTags(e2.state.inputText + a3, true) : (e2.state.inputText = a3, e2.dropdown.show(a3))), e2.trigger("paste", { event: t2, pastedText: s2, clipboardData: n2, tagsElems: i2 });
    }).catch(function(t3) {
      return t3;
    }));
  }, onDrop: function(t2) {
    t2.preventDefault();
  }, onEditTagInput: function(t2, e2) {
    var i2, n2 = t2.closest("." + this.settings.classNames.tag), s2 = this.getNodeIndex(n2), a2 = w(n2), o2 = this.input.normalize.call(this, t2), r2 = (H(i2 = {}, this.settings.tagTextProp, o2), H(i2, "__tagId", a2.__tagId), i2), l2 = this.validateTag(r2);
    this.editTagChangeDetected(u(a2, r2)) || true !== t2.originalIsValid || (l2 = true), n2.classList.toggle(this.settings.classNames.tagInvalid, true !== l2), a2.__isValid = l2, n2.title = true === l2 ? a2.title || a2.value : l2, o2.length >= this.settings.dropdown.enabled && (this.state.editing && (this.state.editing.value = o2), this.dropdown.show(o2)), this.trigger("edit:input", { tag: n2, index: s2, data: u({}, this.value[s2], { newValue: o2 }), event: e2 });
  }, onEditTagPaste: function(t2, e2) {
    var i2 = (e2.clipboardData || window.clipboardData).getData("Text");
    e2.preventDefault();
    var n2 = b(i2);
    this.setRangeAtStartEnd(false, n2);
  }, onEditTagClick: function(t2, e2) {
    this.events.callbacks.onClickScope.call(this, e2);
  }, onEditTagFocus: function(t2) {
    this.state.editing = { scope: t2, input: t2.querySelector("[contenteditable]") };
  }, onEditTagBlur: function(t2, e2) {
    var i2 = m.call(this, e2.relatedTarget);
    if ("select" == this.settings.mode && i2 && e2.relatedTarget.contains(e2.target))
      this.dropdown.hide();
    else if (this.state.editing && (this.state.hasFocus || this.toggleFocusClass(), this.DOM.scope.contains(t2))) {
      var n2, s2, a2, o2 = this.settings, r2 = t2.closest("." + o2.classNames.tag), l2 = w(r2), d2 = this.input.normalize.call(this, t2), c2 = (H(n2 = {}, o2.tagTextProp, d2), H(n2, "__tagId", l2.__tagId), n2), g2 = l2.__originalData, h2 = this.editTagChangeDetected(u(l2, c2)), p2 = this.validateTag(c2);
      if (d2)
        if (h2) {
          var f2;
          if (s2 = this.hasMaxTags(), a2 = u({}, g2, (H(f2 = {}, o2.tagTextProp, this.trim(d2)), H(f2, "__isValid", p2), f2)), o2.transformTag.call(this, a2, g2), true !== (p2 = (!s2 || true === g2.__isValid) && this.validateTag(a2))) {
            if (this.trigger("invalid", { data: a2, tag: r2, message: p2 }), o2.editTags.keepInvalid)
              return;
            o2.keepInvalidTags ? a2.__isValid = p2 : a2 = g2;
          } else
            o2.keepInvalidTags && (delete a2.title, delete a2["aria-invalid"], delete a2.class);
          this.onEditTagDone(r2, a2);
        } else
          this.onEditTagDone(r2, g2);
      else
        this.onEditTagDone(r2);
    }
  }, onEditTagkeydown: function(t2, e2) {
    if (!this.state.composing)
      switch (this.trigger("edit:keydown", { event: t2 }), t2.key) {
        case "Esc":
        case "Escape":
          this.state.editing = false, !!e2.__tagifyTagData.__originalData.value ? e2.parentNode.replaceChild(e2.__tagifyTagData.__originalHTML, e2) : e2.remove();
          break;
        case "Enter":
        case "Tab":
          t2.preventDefault();
          setTimeout(function() {
            return t2.target.blur();
          }, 0);
      }
  }, onDoubleClickScope: function(t2) {
    var e2, i2, n2 = t2.target.closest("." + this.settings.classNames.tag), s2 = w(n2), a2 = this.settings;
    n2 && false !== s2.editable && (e2 = n2.classList.contains(this.settings.classNames.tagEditing), i2 = n2.hasAttribute("readonly"), a2.readonly || e2 || i2 || !this.settings.editTags || !a2.userInput || (this.events.callbacks.onEditTagFocus.call(this, n2), this.editTag(n2)), this.toggleFocusClass(true), "select" != a2.mode && this.trigger("dblclick", { tag: n2, index: this.getNodeIndex(n2), data: w(n2) }));
  }, onInputDOMChange: function(t2) {
    var e2 = this;
    t2.forEach(function(t3) {
      t3.addedNodes.forEach(function(t4) {
        if ("<div><br></div>" == t4.outerHTML)
          t4.replaceWith(document.createElement("br"));
        else if (1 == t4.nodeType && t4.querySelector(e2.settings.classNames.tagSelector)) {
          var i3, n2 = document.createTextNode("");
          3 == t4.childNodes[0].nodeType && "BR" != t4.previousSibling.nodeName && (n2 = document.createTextNode("\n")), (i3 = t4).replaceWith.apply(i3, K([n2].concat(K(K(t4.childNodes).slice(0, -1))))), y(n2);
        } else if (m.call(e2, t4)) {
          var s2;
          if (3 != (null === (s2 = t4.previousSibling) || void 0 === s2 ? void 0 : s2.nodeType) || t4.previousSibling.textContent || t4.previousSibling.remove(), t4.previousSibling && "BR" == t4.previousSibling.nodeName) {
            t4.previousSibling.replaceWith("\n\u200B");
            for (var a2 = t4.nextSibling, o2 = ""; a2; )
              o2 += a2.textContent, a2 = a2.nextSibling;
            o2.trim() && y(t4.previousSibling);
          } else
            t4.previousSibling && !w(t4.previousSibling) || t4.before("\u200B");
        }
      }), t3.removedNodes.forEach(function(t4) {
        t4 && "BR" == t4.nodeName && m.call(e2, i2) && (e2.removeTags(i2), e2.fixFirefoxLastTagNoCaret());
      });
    });
    var i2 = this.DOM.input.lastChild;
    i2 && "" == i2.nodeValue && i2.remove(), i2 && "BR" == i2.nodeName || this.DOM.input.appendChild(document.createElement("br"));
  } } };
  function q(t2, e2) {
    (null == e2 || e2 > t2.length) && (e2 = t2.length);
    for (var i2 = 0, n2 = new Array(e2); i2 < e2; i2++)
      n2[i2] = t2[i2];
    return n2;
  }
  function z(t2, e2, i2) {
    return e2 in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
  }
  function X(t2, e2) {
    return null != e2 && "undefined" != typeof Symbol && e2[Symbol.hasInstance] ? !!e2[Symbol.hasInstance](t2) : t2 instanceof e2;
  }
  function J(t2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var i2 = null != arguments[e2] ? arguments[e2] : {}, n2 = Object.keys(i2);
      "function" == typeof Object.getOwnPropertySymbols && (n2 = n2.concat(Object.getOwnPropertySymbols(i2).filter(function(t3) {
        return Object.getOwnPropertyDescriptor(i2, t3).enumerable;
      }))), n2.forEach(function(e3) {
        z(t2, e3, i2[e3]);
      });
    }
    return t2;
  }
  function G(t2) {
    return function(t3) {
      if (Array.isArray(t3))
        return q(t3);
    }(t2) || function(t3) {
      if ("undefined" != typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"])
        return Array.from(t3);
    }(t2) || function(t3, e2) {
      if (!t3)
        return;
      if ("string" == typeof t3)
        return q(t3, e2);
      var i2 = Object.prototype.toString.call(t3).slice(8, -1);
      "Object" === i2 && t3.constructor && (i2 = t3.constructor.name);
      if ("Map" === i2 || "Set" === i2)
        return Array.from(i2);
      if ("Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2))
        return q(t3, e2);
    }(t2) || function() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }();
  }
  function $3(t2, e2) {
    if (!t2) {
      n.warn("input element not found", t2);
      var i2 = new Proxy(this, { get: function() {
        return function() {
          return i2;
        };
      } });
      return i2;
    }
    if (t2.__tagify)
      return n.warn("input element is already Tagified - Same instance is returned.", t2), t2.__tagify;
    var s2;
    u(this, function(t3) {
      var e3 = document.createTextNode(""), i3 = {};
      function s3(t4, i4, n2) {
        n2 && i4.split(/\s+/g).forEach(function(i5) {
          return e3[t4 + "EventListener"].call(e3, i5, n2);
        });
      }
      return { removeAllCustomListeners: function() {
        Object.entries(i3).forEach(function(t4) {
          var e4 = F(t4, 2), i4 = e4[0];
          e4[1].forEach(function(t5) {
            return s3("remove", i4, t5);
          });
        }), i3 = {};
      }, off: function(t4, e4) {
        return t4 && (e4 ? s3("remove", t4, e4) : t4.split(/\s+/g).forEach(function(t5) {
          var e5;
          null === (e5 = i3[t5]) || void 0 === e5 || e5.forEach(function(e6) {
            return s3("remove", t5, e6);
          }), delete i3[t5];
        })), this;
      }, on: function(t4, e4) {
        return e4 && "function" == typeof e4 && (t4.split(/\s+/g).forEach(function(t5) {
          Array.isArray(i3[t5]) ? i3[t5].push(e4) : i3[t5] = [e4];
        }), s3("add", t4, e4)), this;
      }, trigger: function(i4, s4, a2) {
        var o2;
        if (a2 = a2 || { cloneData: true }, i4)
          if (t3.settings.isJQueryPlugin)
            "remove" == i4 && (i4 = "removeTag"), jQuery(t3.DOM.originalInput).triggerHandler(i4, [s4]);
          else {
            try {
              var r2 = "object" == typeof s4 ? s4 : { value: s4 };
              if ((r2 = a2.cloneData ? u({}, r2) : r2).tagify = this, s4.event && (r2.event = this.cloneEvent(s4.event)), V(s4, Object))
                for (var l2 in s4)
                  V(s4[l2], HTMLElement) && (r2[l2] = s4[l2]);
              o2 = new CustomEvent(i4, { detail: r2 });
            } catch (t4) {
              n.warn(t4);
            }
            e3.dispatchEvent(o2);
          }
      } };
    }(this)), this.isFirefox = /firefox|fxios/i.test(navigator.userAgent) && !/seamonkey/i.test(navigator.userAgent), this.isIE = window.document.documentMode, e2 = e2 || {}, this.getPersistedData = (s2 = e2.id, function(t3) {
      var e3, i3 = "/" + t3;
      if (1 == localStorage.getItem(k + s2 + "/v", 1))
        try {
          e3 = JSON.parse(localStorage[k + s2 + i3]);
        } catch (t4) {
        }
      return e3;
    }), this.setPersistedData = function(t3) {
      return t3 ? (localStorage.setItem(k + t3 + "/v", 1), function(e3, i3) {
        var n2 = "/" + i3, s3 = JSON.stringify(e3);
        e3 && i3 && (localStorage.setItem(k + t3 + n2, s3), dispatchEvent(new Event("storage")));
      }) : function() {
      };
    }(e2.id), this.clearPersistedData = function(t3) {
      return function(e3) {
        var i3 = k + "/" + t3 + "/";
        if (e3)
          localStorage.removeItem(i3 + e3);
        else
          for (var n2 in localStorage)
            n2.includes(i3) && localStorage.removeItem(n2);
      };
    }(e2.id), this.applySettings(t2, e2), this.state = { inputText: "", editing: false, composing: false, actions: {}, mixMode: {}, dropdown: {}, flaggedTags: {} }, this.value = [], this.listeners = {}, this.DOM = {}, this.build(t2), N.call(this), this.getCSSVars(), this.loadOriginalValues(), this.events.customBinding.call(this), this.events.binding.call(this), t2.autofocus && this.DOM.input.focus(), t2.__tagify = this;
  }
  $3.prototype = { _dropdown: C, placeCaretAfterNode: y, getSetTagData: w, helpers: { sameStr: s, removeCollectionProp: a, omit: o, isObject: c, parseHTML: r, escapeHTML: d, extend: u, concatWithoutDups: g, getUID: f, isNodeTag: m }, customEventsList: ["change", "add", "remove", "invalid", "input", "paste", "click", "keydown", "focus", "blur", "edit:input", "edit:beforeUpdate", "edit:updated", "edit:start", "edit:keydown", "dropdown:show", "dropdown:hide", "dropdown:select", "dropdown:updated", "dropdown:noMatch", "dropdown:scroll"], dataProps: ["__isValid", "__removed", "__originalData", "__originalHTML", "__tagId"], trim: function(t2) {
    return this.settings.trim && t2 && "string" == typeof t2 ? t2.trim() : t2;
  }, parseHTML: r, templates: j, parseTemplate: function(t2, e2) {
    return r((t2 = this.settings.templates[t2] || t2).apply(this, e2));
  }, set whitelist(t2) {
    var e2 = t2 && Array.isArray(t2);
    this.settings.whitelist = e2 ? t2 : [], this.setPersistedData(e2 ? t2 : [], "whitelist");
  }, get whitelist() {
    return this.settings.whitelist;
  }, set userInput(t2) {
    this.settings.userInput = !!t2, this.setContentEditable(!!t2);
  }, get userInput() {
    return this.settings.userInput;
  }, generateClassSelectors: function(t2) {
    var e2 = function(e3) {
      var i3 = e3;
      Object.defineProperty(t2, i3 + "Selector", { get: function() {
        return "." + this[i3].split(" ")[0];
      } });
    };
    for (var i2 in t2)
      e2(i2);
  }, applySettings: function(t2, e2) {
    var i2, n2;
    O.templates = this.templates;
    var s2 = u({}, O, "mix" == e2.mode ? { dropdown: { position: "text" } } : {}), a2 = this.settings = u({}, s2, e2);
    if (a2.disabled = t2.hasAttribute("disabled"), a2.readonly = a2.readonly || t2.hasAttribute("readonly"), a2.placeholder = d(t2.getAttribute("placeholder") || a2.placeholder || ""), a2.required = t2.hasAttribute("required"), this.generateClassSelectors(a2.classNames), void 0 === a2.dropdown.includeSelectedTags && (a2.dropdown.includeSelectedTags = a2.duplicates), this.isIE && (a2.autoComplete = false), ["whitelist", "blacklist"].forEach(function(e3) {
      var i3 = t2.getAttribute("data-" + e3);
      i3 && X(i3 = i3.split(a2.delimiters), Array) && (a2[e3] = i3);
    }), "autoComplete" in e2 && !c(e2.autoComplete) && (a2.autoComplete = O.autoComplete, a2.autoComplete.enabled = e2.autoComplete), "mix" == a2.mode && (a2.pattern = a2.pattern || /@/, a2.autoComplete.rightKey = true, a2.delimiters = e2.delimiters || null, a2.tagTextProp && !a2.dropdown.searchKeys.includes(a2.tagTextProp) && a2.dropdown.searchKeys.push(a2.tagTextProp)), t2.pattern)
      try {
        a2.pattern = new RegExp(t2.pattern);
      } catch (t3) {
      }
    if (a2.delimiters) {
      a2._delimiters = a2.delimiters;
      try {
        a2.delimiters = new RegExp(this.settings.delimiters, "g");
      } catch (t3) {
      }
    }
    a2.disabled && (a2.userInput = false), this.TEXTS = J({}, L, a2.texts || {}), ("select" != a2.mode || (null === (i2 = e2.dropdown) || void 0 === i2 ? void 0 : i2.enabled)) && a2.userInput || (a2.dropdown.enabled = 0), a2.dropdown.appendTarget = (null === (n2 = e2.dropdown) || void 0 === n2 ? void 0 : n2.appendTarget) || document.body;
    var o2 = this.getPersistedData("whitelist");
    Array.isArray(o2) && (this.whitelist = Array.isArray(a2.whitelist) ? g(a2.whitelist, o2) : o2);
  }, getAttributes: function(t2) {
    var e2, i2 = this.getCustomAttributes(t2), n2 = "";
    for (e2 in i2)
      n2 += " " + e2 + (void 0 !== t2[e2] ? '="'.concat(i2[e2], '"') : "");
    return n2;
  }, getCustomAttributes: function(t2) {
    if (!c(t2))
      return "";
    var e2, i2 = {};
    for (e2 in t2)
      "__" != e2.slice(0, 2) && "class" != e2 && t2.hasOwnProperty(e2) && void 0 !== t2[e2] && (i2[e2] = d(t2[e2]));
    return i2;
  }, setStateSelection: function() {
    var t2 = window.getSelection(), e2 = { anchorOffset: t2.anchorOffset, anchorNode: t2.anchorNode, range: t2.getRangeAt && t2.rangeCount && t2.getRangeAt(0) };
    return this.state.selection = e2, e2;
  }, getCSSVars: function() {
    var t2, e2, i2, n2 = getComputedStyle(this.DOM.scope, null);
    this.CSSVars = { tagHideTransition: (t2 = function(t3) {
      if (!t3)
        return {};
      var e3 = (t3 = t3.trim().split(" ")[0]).split(/\d+/g).filter(function(t4) {
        return t4;
      }).pop().trim();
      return { value: +t3.split(e3).filter(function(t4) {
        return t4;
      })[0].trim(), unit: e3 };
    }((i2 = "tag-hide-transition", n2.getPropertyValue("--" + i2))), e2 = t2.value, "s" == t2.unit ? 1e3 * e2 : e2) };
  }, build: function(t2) {
    var e2 = this.DOM, i2 = t2.closest("label");
    this.settings.mixMode.integrated ? (e2.originalInput = null, e2.scope = t2, e2.input = t2) : (e2.originalInput = t2, e2.originalInput_tabIndex = t2.tabIndex, e2.scope = this.parseTemplate("wrapper", [t2, this.settings]), e2.input = e2.scope.querySelector(this.settings.classNames.inputSelector), t2.parentNode.insertBefore(e2.scope, t2), t2.tabIndex = -1), i2 && i2.setAttribute("for", "");
  }, destroy: function() {
    this.events.unbindGlobal.call(this), this.DOM.scope.parentNode.removeChild(this.DOM.scope), this.DOM.originalInput.tabIndex = this.DOM.originalInput_tabIndex, delete this.DOM.originalInput.__tagify, this.dropdown.hide(true), this.removeAllCustomListeners(), clearTimeout(this.dropdownHide__bindEventsTimeout), clearInterval(this.listeners.main.originalInputValueObserverInterval);
  }, loadOriginalValues: function(t2) {
    var e2, i2 = this.settings;
    if (this.state.blockChangeEvent = true, void 0 === t2) {
      var n2 = this.getPersistedData("value");
      t2 = n2 && !this.DOM.originalInput.value ? n2 : i2.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value;
    }
    if (this.removeAllTags(), t2)
      if ("mix" == i2.mode)
        this.parseMixTags(t2), (e2 = this.DOM.input.lastChild) && "BR" == e2.tagName || this.DOM.input.insertAdjacentHTML("beforeend", "<br>");
      else {
        try {
          X(JSON.parse(t2), Array) && (t2 = JSON.parse(t2));
        } catch (t3) {
        }
        this.addTags(t2, true).forEach(function(t3) {
          return t3 && t3.classList.add(i2.classNames.tagNoAnimation);
        });
      }
    else
      this.postUpdate();
    this.state.lastOriginalValueReported = i2.mixMode.integrated ? "" : this.DOM.originalInput.value;
  }, cloneEvent: function(t2) {
    var e2 = {};
    for (var i2 in t2)
      "path" != i2 && (e2[i2] = t2[i2]);
    return e2;
  }, loading: function(t2) {
    return this.state.isLoading = t2, this.DOM.scope.classList[t2 ? "add" : "remove"](this.settings.classNames.scopeLoading), this;
  }, tagLoading: function(t2, e2) {
    return t2 && t2.classList[e2 ? "add" : "remove"](this.settings.classNames.tagLoading), this;
  }, toggleClass: function(t2, e2) {
    "string" == typeof t2 && this.DOM.scope.classList.toggle(t2, e2);
  }, toggleScopeValidation: function(t2) {
    var e2 = true === t2 || void 0 === t2;
    !this.settings.required && t2 && t2 === this.TEXTS.empty && (e2 = true), this.toggleClass(this.settings.classNames.tagInvalid, !e2), this.DOM.scope.title = e2 ? "" : t2;
  }, toggleFocusClass: function(t2) {
    this.toggleClass(this.settings.classNames.focus, !!t2);
  }, setPlaceholder: function(t2) {
    var e2 = this;
    ["data", "aria"].forEach(function(i2) {
      return e2.DOM.input.setAttribute("".concat(i2, "-placeholder"), t2);
    });
  }, triggerChangeEvent: function() {
    if (!this.settings.mixMode.integrated) {
      var t2 = this.DOM.originalInput, e2 = this.state.lastOriginalValueReported !== t2.value, i2 = new CustomEvent("change", { bubbles: true });
      e2 && (this.state.lastOriginalValueReported = t2.value, i2.simulated = true, t2._valueTracker && t2._valueTracker.setValue(Math.random()), t2.dispatchEvent(i2), this.trigger("change", this.state.lastOriginalValueReported), t2.value = this.state.lastOriginalValueReported);
    }
  }, events: U, fixFirefoxLastTagNoCaret: function() {
  }, setRangeAtStartEnd: function(t2, e2) {
    if (e2) {
      t2 = "number" == typeof t2 ? t2 : !!t2, e2 = e2.lastChild || e2;
      var i2 = document.getSelection();
      if (X(i2.focusNode, Element) && !this.DOM.input.contains(i2.focusNode))
        return true;
      try {
        i2.rangeCount >= 1 && ["Start", "End"].forEach(function(n2) {
          return i2.getRangeAt(0)["set" + n2](e2, t2 || e2.length);
        });
      } catch (t3) {
        console.warn(t3);
      }
    }
  }, insertAfterTag: function(t2, e2) {
    if (e2 = e2 || this.settings.mixMode.insertAfterTag, t2 && t2.parentNode && e2)
      return e2 = "string" == typeof e2 ? document.createTextNode(e2) : e2, t2.parentNode.insertBefore(e2, t2.nextSibling), e2;
  }, editTagChangeDetected: function(t2) {
    var e2 = t2.__originalData;
    for (var i2 in e2)
      if (!this.dataProps.includes(i2) && t2[i2] != e2[i2])
        return true;
    return false;
  }, getTagTextNode: function(t2) {
    return t2.querySelector(this.settings.classNames.tagTextSelector);
  }, setTagTextNode: function(t2, e2) {
    this.getTagTextNode(t2).innerHTML = d(e2);
  }, editTag: function(t2, e2) {
    var i2 = this;
    t2 = t2 || this.getLastTag(), e2 = e2 || {};
    var s2 = this.settings, a2 = this.getTagTextNode(t2), o2 = this.getNodeIndex(t2), r2 = w(t2), l2 = this.events.callbacks, d2 = true, c2 = "select" == s2.mode;
    if (!c2 && this.dropdown.hide(), a2) {
      if (!X(r2, Object) || !("editable" in r2) || r2.editable)
        return r2 = w(t2, { __originalData: u({}, r2), __originalHTML: t2.cloneNode(true) }), w(r2.__originalHTML, r2.__originalData), a2.setAttribute("contenteditable", true), t2.classList.add(s2.classNames.tagEditing), this.events.callbacks.onEditTagFocus.call(this, t2), a2.addEventListener("click", l2.onEditTagClick.bind(this, t2)), a2.addEventListener("blur", l2.onEditTagBlur.bind(this, this.getTagTextNode(t2))), a2.addEventListener("input", l2.onEditTagInput.bind(this, a2)), a2.addEventListener("paste", l2.onEditTagPaste.bind(this, a2)), a2.addEventListener("keydown", function(e3) {
          return l2.onEditTagkeydown.call(i2, e3, t2);
        }), a2.addEventListener("compositionstart", l2.onCompositionStart.bind(this)), a2.addEventListener("compositionend", l2.onCompositionEnd.bind(this)), e2.skipValidation || (d2 = this.editTagToggleValidity(t2)), a2.originalIsValid = d2, this.trigger("edit:start", { tag: t2, index: o2, data: r2, isValid: d2 }), a2.focus(), !c2 && this.setRangeAtStartEnd(false, a2), 0 === s2.dropdown.enabled && !c2 && this.dropdown.show(), this.state.hasFocus = true, this;
    } else
      n.warn("Cannot find element in Tag template: .", s2.classNames.tagTextSelector);
  }, editTagToggleValidity: function(t2, e2) {
    var i2;
    if (e2 = e2 || w(t2))
      return (i2 = !("__isValid" in e2) || true === e2.__isValid) || this.removeTagsFromValue(t2), this.update(), t2.classList.toggle(this.settings.classNames.tagNotAllowed, !i2), e2.__isValid = i2, e2.__isValid;
    n.warn("tag has no data: ", t2, e2);
  }, onEditTagDone: function(t2, e2) {
    t2 = t2 || this.state.editing.scope, e2 = e2 || {};
    var i2, n2, s2 = { tag: t2, index: this.getNodeIndex(t2), previousData: w(t2), data: e2 }, a2 = this.settings;
    this.trigger("edit:beforeUpdate", s2, { cloneData: false }), this.state.editing = false, delete e2.__originalData, delete e2.__originalHTML, t2 && (void 0 !== (n2 = e2[a2.tagTextProp]) ? null === (i2 = (n2 += "").trim) || void 0 === i2 ? void 0 : i2.call(n2) : a2.tagTextProp in e2 ? void 0 : e2.value) ? (t2 = this.replaceTag(t2, e2), this.editTagToggleValidity(t2, e2), a2.a11y.focusableTags ? t2.focus() : "select" != a2.mode && y(t2)) : t2 && this.removeTags(t2), this.trigger("edit:updated", s2), this.dropdown.hide(), this.settings.keepInvalidTags && this.reCheckInvalidTags();
  }, replaceTag: function(t2, e2) {
    e2 && "" !== e2.value && void 0 !== e2.value || (e2 = t2.__tagifyTagData), e2.__isValid && 1 != e2.__isValid && u(e2, this.getInvalidTagAttrs(e2, e2.__isValid));
    var i2 = this.createTagElem(e2);
    return t2.parentNode.replaceChild(i2, t2), this.updateValueByDOMTags(), i2;
  }, updateValueByDOMTags: function() {
    var t2 = this;
    this.value.length = 0;
    var e2 = this.settings.classNames, i2 = [e2.tagNotAllowed.split(" ")[0], e2.tagHide];
    [].forEach.call(this.getTagElms(), function(e3) {
      G(e3.classList).some(function(t3) {
        return i2.includes(t3);
      }) || t2.value.push(w(e3));
    }), this.update();
  }, injectAtCaret: function(t2, e2) {
    var i2;
    if (e2 = e2 || (null === (i2 = this.state.selection) || void 0 === i2 ? void 0 : i2.range), "string" == typeof t2 && (t2 = document.createTextNode(t2)), !e2 && t2)
      return this.appendMixTags(t2), this;
    var n2 = b(t2, e2);
    return this.setRangeAtStartEnd(false, n2), this.updateValueByDOMTags(), this.update(), this;
  }, input: { set: function() {
    var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = this.settings, n2 = i2.dropdown.closeOnSelect;
    this.state.inputText = t2, e2 && (this.DOM.input.innerHTML = d("" + t2), t2 && this.toggleClass(i2.classNames.empty, !this.DOM.input.innerHTML)), !t2 && n2 && this.dropdown.hide.bind(this), this.input.autocomplete.suggest.call(this), this.input.validate.call(this);
  }, raw: function() {
    return this.DOM.input.textContent;
  }, validate: function() {
    var t2 = !this.state.inputText || true === this.validateTag({ value: this.state.inputText });
    return this.DOM.input.classList.toggle(this.settings.classNames.inputInvalid, !t2), t2;
  }, normalize: function(t2, e2) {
    var i2 = t2 || this.DOM.input, n2 = [];
    i2.childNodes.forEach(function(t3) {
      return 3 == t3.nodeType && n2.push(t3.nodeValue);
    }), n2 = n2.join("\n");
    try {
      n2 = n2.replace(/(?:\r\n|\r|\n)/g, this.settings.delimiters.source.charAt(0));
    } catch (t3) {
    }
    return n2 = n2.replace(/\s/g, " "), (null == e2 ? void 0 : e2.trim) ? this.trim(n2) : n2;
  }, autocomplete: { suggest: function(t2) {
    if (this.settings.autoComplete.enabled) {
      "object" != typeof (t2 = t2 || { value: "" }) && (t2 = { value: t2 });
      var e2 = this.dropdown.getMappedValue(t2);
      if ("number" != typeof e2) {
        var i2 = this.state.inputText.toLowerCase(), n2 = e2.substr(0, this.state.inputText.length).toLowerCase(), s2 = e2.substring(this.state.inputText.length);
        e2 && this.state.inputText && n2 == i2 ? (this.DOM.input.setAttribute("data-suggest", s2), this.state.inputSuggestion = t2) : (this.DOM.input.removeAttribute("data-suggest"), delete this.state.inputSuggestion);
      }
    }
  }, set: function(t2) {
    var e2 = this.DOM.input.getAttribute("data-suggest"), i2 = t2 || (e2 ? this.state.inputText + e2 : null);
    return !!i2 && ("mix" == this.settings.mode ? this.replaceTextWithNode(document.createTextNode(this.state.tag.prefix + i2)) : (this.input.set.call(this, i2), this.setRangeAtStartEnd(false, this.DOM.input)), this.input.autocomplete.suggest.call(this), this.dropdown.hide(), true);
  } } }, getTagIdx: function(t2) {
    return this.value.findIndex(function(e2) {
      return e2.__tagId == (t2 || {}).__tagId;
    });
  }, getNodeIndex: function(t2) {
    var e2 = 0;
    if (t2)
      for (; t2 = t2.previousElementSibling; )
        e2++;
    return e2;
  }, getTagElms: function() {
    for (var t2 = arguments.length, e2 = new Array(t2), i2 = 0; i2 < t2; i2++)
      e2[i2] = arguments[i2];
    var n2 = "." + G(this.settings.classNames.tag.split(" ")).concat(G(e2)).join(".");
    return [].slice.call(this.DOM.scope.querySelectorAll(n2));
  }, getLastTag: function() {
    var t2 = this.settings.classNames, e2 = this.DOM.scope.querySelectorAll("".concat(t2.tagSelector, ":not(.").concat(t2.tagHide, "):not([readonly])"));
    return e2[e2.length - 1];
  }, isTagDuplicate: function(t2, e2, i2) {
    var n2 = 0, a2 = true, o2 = false, r2 = void 0;
    try {
      for (var l2, d2 = this.value[Symbol.iterator](); !(a2 = (l2 = d2.next()).done); a2 = true) {
        var c2 = l2.value;
        s(this.trim("" + t2), c2.value, e2) && i2 != c2.__tagId && n2++;
      }
    } catch (t3) {
      o2 = true, r2 = t3;
    } finally {
      try {
        a2 || null == d2.return || d2.return();
      } finally {
        if (o2)
          throw r2;
      }
    }
    return n2;
  }, getTagIndexByValue: function(t2) {
    var e2 = this, i2 = [], n2 = this.settings.dropdown.caseSensitive;
    return this.getTagElms().forEach(function(a2, o2) {
      a2.__tagifyTagData && s(e2.trim(a2.__tagifyTagData.value), t2, n2) && i2.push(o2);
    }), i2;
  }, getTagElmByValue: function(t2) {
    var e2 = this.getTagIndexByValue(t2)[0];
    return this.getTagElms()[e2];
  }, flashTag: function(t2) {
    var e2 = this;
    t2 && (t2.classList.add(this.settings.classNames.tagFlash), setTimeout(function() {
      t2.classList.remove(e2.settings.classNames.tagFlash);
    }, 100));
  }, isTagBlacklisted: function(t2) {
    return t2 = this.trim(t2.toLowerCase()), this.settings.blacklist.filter(function(e2) {
      return ("" + e2).toLowerCase() == t2;
    }).length;
  }, isTagWhitelisted: function(t2) {
    return !!this.getWhitelistItem(t2);
  }, getWhitelistItem: function(t2, e2, i2) {
    e2 = e2 || "value";
    var n2, a2 = this.settings;
    return (i2 = i2 || a2.whitelist).some(function(i3) {
      var o2 = "object" == typeof i3 ? i3[e2] || i3.value : i3;
      if (s(o2, t2, a2.dropdown.caseSensitive, a2.trim))
        return n2 = "object" == typeof i3 ? i3 : { value: i3 }, true;
    }), n2 || "value" != e2 || "value" == a2.tagTextProp || (n2 = this.getWhitelistItem(t2, a2.tagTextProp, i2)), n2;
  }, validateTag: function(t2) {
    var e2 = this.settings, i2 = "value" in t2 ? "value" : e2.tagTextProp, n2 = this.trim(t2[i2] + "");
    return (t2[i2] + "").trim() ? "mix" != e2.mode && e2.pattern && X(e2.pattern, RegExp) && !e2.pattern.test(n2) ? this.TEXTS.pattern : !e2.duplicates && this.isTagDuplicate(n2, e2.dropdown.caseSensitive, t2.__tagId) ? this.TEXTS.duplicate : this.isTagBlacklisted(n2) || e2.enforceWhitelist && !this.isTagWhitelisted(n2) ? this.TEXTS.notAllowed : !e2.validate || e2.validate(t2) : this.TEXTS.empty;
  }, getInvalidTagAttrs: function(t2, e2) {
    return { "aria-invalid": true, class: "".concat(t2.class || "", " ").concat(this.settings.classNames.tagNotAllowed).trim(), title: e2 };
  }, hasMaxTags: function() {
    return this.value.length >= this.settings.maxTags && this.TEXTS.exceed;
  }, setReadonly: function(t2, e2) {
    var i2 = this.settings;
    this.DOM.scope.contains(document.activeElement) && document.activeElement.blur(), i2[e2 || "readonly"] = t2, this.DOM.scope[(t2 ? "set" : "remove") + "Attribute"](e2 || "readonly", true), this.settings.userInput = true, this.setContentEditable(!t2);
  }, setContentEditable: function(t2) {
    this.DOM.input.contentEditable = t2, this.DOM.input.tabIndex = t2 ? 0 : -1;
  }, setDisabled: function(t2) {
    this.setReadonly(t2, "disabled");
  }, normalizeTags: function(t2) {
    var e2 = this, i2 = this.settings, n2 = i2.whitelist, s2 = i2.delimiters, a2 = i2.mode, o2 = i2.tagTextProp, r2 = [], l2 = !!n2 && X(n2[0], Object), d2 = Array.isArray(t2), g2 = d2 && t2[0].value, h2 = function(t3) {
      return (t3 + "").split(s2).reduce(function(t4, i3) {
        var n3, s3 = e2.trim(i3);
        return s3 && t4.push((z(n3 = {}, o2, s3), z(n3, "value", s3), n3)), t4;
      }, []);
    };
    if ("number" == typeof t2 && (t2 = t2.toString()), "string" == typeof t2) {
      if (!t2.trim())
        return [];
      t2 = h2(t2);
    } else
      d2 && (t2 = t2.reduce(function(t3, i3) {
        if (c(i3)) {
          var n3 = u({}, i3);
          o2 in n3 || (o2 = "value"), n3[o2] = e2.trim(n3[o2]), (n3[o2] || 0 === n3[o2]) && t3.push(n3);
        } else if (i3) {
          var s3;
          (s3 = t3).push.apply(s3, G(h2(i3)));
        }
        return t3;
      }, []));
    return l2 && !g2 && (t2.forEach(function(t3) {
      var i3 = r2.map(function(t4) {
        return t4.value;
      }), n3 = e2.dropdown.filterListItems.call(e2, t3[o2], { exact: true });
      e2.settings.duplicates || (n3 = n3.filter(function(t4) {
        return !i3.includes(t4.value);
      }));
      var s3 = n3.length > 1 ? e2.getWhitelistItem(t3[o2], o2, n3) : n3[0];
      s3 && X(s3, Object) ? r2.push(s3) : "mix" != a2 && (null == t3.value && (t3.value = t3[o2]), r2.push(t3));
    }), r2.length && (t2 = r2)), t2;
  }, parseMixTags: function(t2) {
    var e2 = this, i2 = this.settings, n2 = i2.mixTagsInterpolator, s2 = i2.duplicates, a2 = i2.transformTag, o2 = i2.enforceWhitelist, r2 = i2.maxTags, l2 = i2.tagTextProp, d2 = [];
    t2 = t2.split(n2[0]).map(function(t3, i3) {
      var c3, u2, g2, h2 = t3.split(n2[1]), p2 = h2[0], f2 = d2.length == r2;
      try {
        if (p2 == +p2)
          throw Error;
        u2 = JSON.parse(p2);
      } catch (t4) {
        u2 = e2.normalizeTags(p2)[0] || { value: p2 };
      }
      if (a2.call(e2, u2), f2 || !(h2.length > 1) || o2 && !e2.isTagWhitelisted(u2.value) || !s2 && e2.isTagDuplicate(u2.value)) {
        if (t3)
          return i3 ? n2[0] + t3 : t3;
      } else
        u2[c3 = u2[l2] ? l2 : "value"] = e2.trim(u2[c3]), g2 = e2.createTagElem(u2), d2.push(u2), g2.classList.add(e2.settings.classNames.tagNoAnimation), h2[0] = g2.outerHTML, e2.value.push(u2);
      return h2.join("");
    }).join(""), this.DOM.input.innerHTML = t2, this.DOM.input.appendChild(document.createTextNode("")), this.DOM.input.normalize();
    var c2 = this.getTagElms();
    return c2.forEach(function(t3, e3) {
      return w(t3, d2[e3]);
    }), this.update({ withoutChangeEvent: true }), T(c2, this.state.hasFocus), t2;
  }, replaceTextWithNode: function(t2, e2) {
    if (this.state.tag || e2) {
      e2 = e2 || this.state.tag.prefix + this.state.tag.value;
      var i2, n2, s2 = this.state.selection || window.getSelection(), a2 = s2.anchorNode, o2 = this.state.tag.delimiters ? this.state.tag.delimiters.length : 0;
      return a2.splitText(s2.anchorOffset - o2), -1 == (i2 = a2.nodeValue.lastIndexOf(e2)) ? true : (n2 = a2.splitText(i2), t2 && a2.parentNode.replaceChild(t2, n2), true);
    }
  }, prepareNewTagNode: function(t2, e2) {
    e2 = e2 || {};
    var i2 = this.settings, n2 = [], s2 = {}, a2 = Object.assign({}, t2, { value: t2.value + "" });
    if (t2 = Object.assign({}, a2), i2.transformTag.call(this, t2), t2.__isValid = this.hasMaxTags() || this.validateTag(t2), true !== t2.__isValid) {
      if (e2.skipInvalid)
        return;
      if (u(s2, this.getInvalidTagAttrs(t2, t2.__isValid), { __preInvalidData: a2 }), t2.__isValid == this.TEXTS.duplicate && this.flashTag(this.getTagElmByValue(t2.value)), !i2.createInvalidTags)
        return void n2.push(t2.value);
    }
    return "readonly" in t2 && (t2.readonly ? s2["aria-readonly"] = true : delete t2.readonly), { tagElm: this.createTagElem(t2, s2), tagData: t2, aggregatedInvalidInput: n2 };
  }, postProcessNewTagNode: function(t2, e2) {
    var i2 = this, n2 = this.settings, s2 = e2.__isValid;
    s2 && true === s2 ? this.value.push(e2) : (this.trigger("invalid", { data: e2, index: this.value.length, tag: t2, message: s2 }), n2.keepInvalidTags || setTimeout(function() {
      return i2.removeTags(t2, true);
    }, 1e3)), this.dropdown.position();
  }, selectTag: function(t2, e2) {
    var i2 = this;
    if (!this.settings.enforceWhitelist || this.isTagWhitelisted(e2.value)) {
      this.state.actions.selectOption && setTimeout(function() {
        return i2.setRangeAtStartEnd(false, i2.DOM.input);
      });
      var n2 = this.getLastTag();
      return n2 ? this.replaceTag(n2, e2) : this.appendTag(t2), this.value[0] = e2, this.update(), this.trigger("add", { tag: t2, data: e2 }), [t2];
    }
  }, addEmptyTag: function(t2) {
    var e2 = u({ value: "" }, t2 || {}), i2 = this.createTagElem(e2);
    w(i2, e2), this.appendTag(i2), this.editTag(i2, { skipValidation: true }), this.toggleFocusClass(true);
  }, addTags: function(t2, e2, i2) {
    var n2 = this, s2 = [], a2 = this.settings, o2 = [], r2 = document.createDocumentFragment(), l2 = [];
    if (!t2 || 0 == t2.length)
      return s2;
    switch (t2 = this.normalizeTags(t2), a2.mode) {
      case "mix":
        return this.addMixTags(t2);
      case "select":
        e2 = false, this.removeAllTags();
    }
    return this.DOM.input.removeAttribute("style"), t2.forEach(function(t3) {
      var e3 = n2.prepareNewTagNode(t3, { skipInvalid: i2 || a2.skipInvalid });
      if (e3) {
        var d2 = e3.tagElm;
        if (t3 = e3.tagData, o2 = e3.aggregatedInvalidInput, s2.push(d2), "select" == a2.mode)
          return n2.selectTag(d2, t3);
        r2.appendChild(d2), n2.postProcessNewTagNode(d2, t3), l2.push({ tagElm: d2, tagData: t3 });
      }
    }), this.appendTag(r2), l2.forEach(function(t3) {
      var e3 = t3.tagElm, i3 = t3.tagData;
      return n2.trigger("add", { tag: e3, index: n2.getTagIdx(i3), data: i3 });
    }), this.update(), t2.length && e2 && (this.input.set.call(this, a2.createInvalidTags ? "" : o2.join(a2._delimiters)), this.setRangeAtStartEnd(false, this.DOM.input)), this.dropdown.refilter(), s2;
  }, addMixTags: function(t2) {
    var e2 = this;
    if ((t2 = this.normalizeTags(t2))[0].prefix || this.state.tag)
      return this.prefixedTextToTag(t2[0]);
    var i2 = document.createDocumentFragment();
    return t2.forEach(function(t3) {
      var n2 = e2.prepareNewTagNode(t3);
      i2.appendChild(n2.tagElm), e2.insertAfterTag(n2.tagElm), e2.postProcessNewTagNode(n2.tagElm, n2.tagData);
    }), this.appendMixTags(i2), i2.children;
  }, appendMixTags: function(t2) {
    var e2 = !!this.state.selection;
    e2 ? this.injectAtCaret(t2) : (this.DOM.input.focus(), (e2 = this.setStateSelection()).range.setStart(this.DOM.input, e2.range.endOffset), e2.range.setEnd(this.DOM.input, e2.range.endOffset), this.DOM.input.appendChild(t2), this.updateValueByDOMTags(), this.update());
  }, prefixedTextToTag: function(t2) {
    var e2, i2, n2, s2 = this, a2 = this.settings, o2 = null === (e2 = this.state.tag) || void 0 === e2 ? void 0 : e2.delimiters;
    if (t2.prefix = t2.prefix || this.state.tag ? this.state.tag.prefix : (a2.pattern.source || a2.pattern)[0], n2 = this.prepareNewTagNode(t2), i2 = n2.tagElm, this.replaceTextWithNode(i2) || this.DOM.input.appendChild(i2), setTimeout(function() {
      return i2.classList.add(s2.settings.classNames.tagNoAnimation);
    }, 300), this.update(), !o2) {
      var r2 = this.insertAfterTag(i2) || i2;
      setTimeout(y, 0, r2);
    }
    return this.state.tag = null, this.postProcessNewTagNode(i2, n2.tagData), i2;
  }, appendTag: function(t2) {
    var e2 = this.DOM, i2 = e2.input;
    e2.scope.insertBefore(t2, i2);
  }, createTagElem: function(t2, e2) {
    t2.__tagId = f();
    var i2, n2 = u({}, t2, J({ value: d(t2.value + "") }, e2));
    return function(t3) {
      for (var e3, i3 = document.createNodeIterator(t3, NodeFilter.SHOW_TEXT, null, false); e3 = i3.nextNode(); )
        e3.textContent.trim() || e3.parentNode.removeChild(e3);
    }(i2 = this.parseTemplate("tag", [n2, this])), w(i2, t2), i2;
  }, reCheckInvalidTags: function() {
    var t2 = this, e2 = this.settings;
    this.getTagElms(e2.classNames.tagNotAllowed).forEach(function(i2, n2) {
      var s2 = w(i2), a2 = t2.hasMaxTags(), o2 = t2.validateTag(s2), r2 = true === o2 && !a2;
      if ("select" == e2.mode && t2.toggleScopeValidation(o2), r2)
        return s2 = s2.__preInvalidData ? s2.__preInvalidData : { value: s2.value }, t2.replaceTag(i2, s2);
      i2.title = a2 || o2;
    });
  }, removeTags: function(t2, e2, i2) {
    var n2, s2 = this, a2 = this.settings;
    if (t2 = t2 && X(t2, HTMLElement) ? [t2] : X(t2, Array) ? t2 : t2 ? [t2] : [this.getLastTag()].filter(function(t3) {
      return t3;
    }), n2 = t2.reduce(function(t3, e3) {
      e3 && "string" == typeof e3 && (e3 = s2.getTagElmByValue(e3));
      var i3 = w(e3);
      return e3 && i3 && !i3.readonly && t3.push({ node: e3, idx: s2.getTagIdx(i3), data: w(e3, { __removed: true }) }), t3;
    }, []), i2 = "number" == typeof i2 ? i2 : this.CSSVars.tagHideTransition, "select" == a2.mode && (i2 = 0, this.input.set.call(this)), 1 == n2.length && "select" != a2.mode && n2[0].node.classList.contains(a2.classNames.tagNotAllowed) && (e2 = true), n2.length)
      return a2.hooks.beforeRemoveTag(n2, { tagify: this }).then(function() {
        var t3 = function(t4) {
          t4.node.parentNode && (t4.node.parentNode.removeChild(t4.node), e2 ? a2.keepInvalidTags && this.trigger("remove", { tag: t4.node, index: t4.idx }) : (this.trigger("remove", { tag: t4.node, index: t4.idx, data: t4.data }), this.dropdown.refilter(), this.dropdown.position(), this.DOM.input.normalize(), a2.keepInvalidTags && this.reCheckInvalidTags()));
        };
        i2 && i2 > 10 && 1 == n2.length ? function(e3) {
          e3.node.style.width = parseFloat(window.getComputedStyle(e3.node).width) + "px", document.body.clientTop, e3.node.classList.add(a2.classNames.tagHide), setTimeout(t3.bind(this), i2, e3);
        }.call(s2, n2[0]) : n2.forEach(t3.bind(s2)), e2 || (s2.removeTagsFromValue(n2.map(function(t4) {
          return t4.node;
        })), s2.update(), "select" == a2.mode && a2.userInput && s2.setContentEditable(true));
      }).catch(function(t3) {
      });
  }, removeTagsFromDOM: function() {
    this.getTagElms().forEach(function(t2) {
      return t2.remove();
    });
  }, removeTagsFromValue: function(t2) {
    var e2 = this;
    (t2 = Array.isArray(t2) ? t2 : [t2]).forEach(function(t3) {
      var i2 = w(t3), n2 = e2.getTagIdx(i2);
      n2 > -1 && e2.value.splice(n2, 1);
    });
  }, removeAllTags: function(t2) {
    var e2 = this;
    t2 = t2 || {}, this.value = [], "mix" == this.settings.mode ? this.DOM.input.innerHTML = "" : this.removeTagsFromDOM(), this.dropdown.refilter(), this.dropdown.position(), this.state.dropdown.visible && setTimeout(function() {
      e2.DOM.input.focus();
    }), "select" == this.settings.mode && (this.input.set.call(this), this.settings.userInput && this.setContentEditable(true)), this.update(t2);
  }, postUpdate: function() {
    this.state.blockChangeEvent = false;
    var t2, e2, i2 = this.settings, n2 = i2.classNames, s2 = "mix" == i2.mode ? i2.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value.trim() : this.value.length + this.input.raw.call(this).length;
    (this.toggleClass(n2.hasMaxTags, this.value.length >= i2.maxTags), this.toggleClass(n2.hasNoTags, !this.value.length), this.toggleClass(n2.empty, !s2), "select" == i2.mode) && this.toggleScopeValidation(null === (e2 = this.value) || void 0 === e2 || null === (t2 = e2[0]) || void 0 === t2 ? void 0 : t2.__isValid);
  }, setOriginalInputValue: function(t2) {
    var e2 = this.DOM.originalInput;
    this.settings.mixMode.integrated || (e2.value = t2, e2.tagifyValue = e2.value, this.setPersistedData(t2, "value"));
  }, update: function(t2) {
    clearTimeout(this.debouncedUpdateTimeout), this.debouncedUpdateTimeout = setTimeout(function() {
      var e2 = this.getInputValue();
      this.setOriginalInputValue(e2), this.settings.onChangeAfterBlur && (t2 || {}).withoutChangeEvent || this.state.blockChangeEvent || this.triggerChangeEvent();
      this.postUpdate();
    }.bind(this), 100), this.events.bindOriginaInputListener.call(this, 100);
  }, getInputValue: function() {
    var t2 = this.getCleanValue();
    return "mix" == this.settings.mode ? this.getMixedTagsAsString(t2) : t2.length ? this.settings.originalInputValueFormat ? this.settings.originalInputValueFormat(t2) : JSON.stringify(t2) : "";
  }, getCleanValue: function(t2) {
    return a(t2 || this.value, this.dataProps);
  }, getMixedTagsAsString: function() {
    var t2 = "", e2 = this, i2 = this.settings, n2 = i2.originalInputValueFormat || JSON.stringify, s2 = i2.mixTagsInterpolator;
    return function i3(a2) {
      a2.childNodes.forEach(function(a3) {
        if (1 == a3.nodeType) {
          var r2 = w(a3);
          if ("BR" == a3.tagName && (t2 += "\r\n"), r2 && m.call(e2, a3)) {
            if (r2.__removed)
              return;
            t2 += s2[0] + n2(o(r2, e2.dataProps)) + s2[1];
          } else
            a3.getAttribute("style") || ["B", "I", "U"].includes(a3.tagName) ? t2 += a3.textContent : "DIV" != a3.tagName && "P" != a3.tagName || (t2 += "\r\n", i3(a3));
        } else
          t2 += a3.textContent;
      });
    }(this.DOM.input), t2;
  } }, $3.prototype.removeTag = $3.prototype.removeTags;

  // app/javascript/controllers/tagify_controller.js
  var tagify_controller_default = class extends Controller {
    connect() {
      new $3(this.element);
    }
  };

  // node_modules/@popperjs/core/lib/index.js
  var lib_exports = {};
  __export(lib_exports, {
    afterMain: () => afterMain,
    afterRead: () => afterRead,
    afterWrite: () => afterWrite,
    applyStyles: () => applyStyles_default,
    arrow: () => arrow_default,
    auto: () => auto,
    basePlacements: () => basePlacements,
    beforeMain: () => beforeMain,
    beforeRead: () => beforeRead,
    beforeWrite: () => beforeWrite,
    bottom: () => bottom,
    clippingParents: () => clippingParents,
    computeStyles: () => computeStyles_default,
    createPopper: () => createPopper3,
    createPopperBase: () => createPopper,
    createPopperLite: () => createPopper2,
    detectOverflow: () => detectOverflow,
    end: () => end,
    eventListeners: () => eventListeners_default,
    flip: () => flip_default,
    hide: () => hide_default,
    left: () => left,
    main: () => main,
    modifierPhases: () => modifierPhases,
    offset: () => offset_default,
    placements: () => placements,
    popper: () => popper,
    popperGenerator: () => popperGenerator,
    popperOffsets: () => popperOffsets_default,
    preventOverflow: () => preventOverflow_default,
    read: () => read,
    reference: () => reference,
    right: () => right,
    start: () => start,
    top: () => top,
    variationPlacements: () => variationPlacements,
    viewport: () => viewport,
    write: () => write
  });

  // node_modules/@popperjs/core/lib/enums.js
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  // node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindow.js
  function getWindow(node) {
    if (node == null) {
      return window;
    }
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }

  // node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot(node) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }

  // node_modules/@popperjs/core/lib/modifiers/applyStyles.js
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style = styleProperties.reduce(function(style2, property) {
          style2[property] = "";
          return style2;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles_default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect,
    requires: ["computeStyles"]
  };

  // node_modules/@popperjs/core/lib/utils/getBasePlacement.js
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }

  // node_modules/@popperjs/core/lib/utils/math.js
  var max = Math.max;
  var min = Math.min;
  var round = Math.round;

  // node_modules/@popperjs/core/lib/utils/userAgent.js
  function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
      return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
      }).join(" ");
    }
    return navigator.userAgent;
  }

  // node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }

  // node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement(element)) {
      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect.width / scaleX;
    var height = clientRect.height / scaleY;
    return {
      width,
      height,
      top: y2,
      right: x2 + width,
      bottom: y2 + height,
      left: x2,
      x: x2,
      y: y2
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }
    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width,
      height
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/contains.js
  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;
      do {
        if (next && parent.isSameNode(next)) {
          return true;
        }
        next = next.parentNode || next.host;
      } while (next);
    }
    return false;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
  function getComputedStyle2(element) {
    return getWindow(element).getComputedStyle(element);
  }

  // node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : (
      // $FlowFixMe[prop-missing]
      element.document
    )) || window.document).documentElement;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || // DOM Element detected
      (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element)
    );
  }

  // node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle2(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement(element)) {
      var elementCss = getComputedStyle2(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle2(currentNode);
      if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }

  // node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }

  // node_modules/@popperjs/core/lib/utils/within.js
  function within(min2, value, max2) {
    return max(min2, min(value, max2));
  }
  function withinMaxClamp(min2, value, max2) {
    var v2 = within(min2, value, max2);
    return v2 > max2 ? max2 : v2;
  }

  // node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  // node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  // node_modules/@popperjs/core/lib/utils/expandToHashMap.js
  function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  // node_modules/@popperjs/core/lib/modifiers/arrow.js
  var toPaddingObject = function toPaddingObject2(padding, state) {
    padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  };
  function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min2 = paddingObject[minProp];
    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset2 = within(min2, center, max2);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
  }
  function effect2(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      return;
    }
    state.elements.arrow = arrowElement;
  }
  var arrow_default = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect2,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };

  // node_modules/@popperjs/core/lib/utils/getVariation.js
  function getVariation(placement) {
    return placement.split("-")[1];
  }

  // node_modules/@popperjs/core/lib/modifiers/computeStyles.js
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref, win) {
    var x2 = _ref.x, y2 = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x2 * dpr) / dpr || 0,
      y: round(y2 * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x: x2,
      y: y2
    }) : {
      x: x2,
      y: y2
    };
    x2 = _ref3.x;
    y2 = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          offsetParent[heightProp]
        );
        y2 -= offsetY - popperRect.height;
        y2 *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          offsetParent[widthProp]
        );
        x2 -= offsetX - popperRect.width;
        x2 *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x: x2,
      y: y2
    }, getWindow(popper2)) : {
      x: x2,
      y: y2
    };
    x2 = _ref4.x;
    y2 = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var computeStyles_default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };

  // node_modules/@popperjs/core/lib/modifiers/eventListeners.js
  var passive = {
    passive: true
  };
  function effect3(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  var eventListeners_default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect: effect3,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
  var hash = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash[matched];
    });
  }

  // node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
  var hash2 = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash2[matched];
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x2 = 0;
    var y2 = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      var layoutViewport = isLayoutViewport();
      if (layoutViewport || !layoutViewport && strategy === "fixed") {
        x2 = visualViewport.offsetLeft;
        y2 = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x2 + getWindowScrollBarX(element),
      y: y2
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y2 = -winScroll.scrollTop;
    if (getComputedStyle2(body || html).direction === "rtl") {
      x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }
    return {
      width,
      height,
      x: x2,
      y: y2
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  // node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
  function getScrollParent(node) {
    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
      return node.ownerDocument.body;
    }
    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }
    return getScrollParent(getParentNode(node));
  }

  // node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)))
    );
  }

  // node_modules/@popperjs/core/lib/utils/rectToClientRect.js
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === "fixed");
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  // node_modules/@popperjs/core/lib/utils/computeOffsets.js
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
        default:
      }
    }
    return offsets;
  }

  // node_modules/@popperjs/core/lib/utils/detectOverflow.js
  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset2 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset2[axis] * multiply;
      });
    }
    return overflowOffsets;
  }

  // node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements2.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements2;
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a2, b2) {
      return overflows[a2] - overflows[b2];
    });
  }

  // node_modules/@popperjs/core/lib/modifiers/flip.js
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i2 = 0; i2 < placements2.length; i2++) {
      var placement = placements2[i2];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i2) {
        var fittingPlacement = placements2.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break")
          break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  var flip_default = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };

  // node_modules/@popperjs/core/lib/modifiers/hide.js
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  var hide_default = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };

  // node_modules/@popperjs/core/lib/modifiers/offset.js
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x2;
      state.modifiersData.popperOffsets.y += y2;
    }
    state.modifiersData[name] = data;
  }
  var offset_default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };

  // node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
  function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets_default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getAltAxis.js
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }

  // node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
  function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset2 = popperOffsets2[mainAxis];
      var min2 = offset2 + overflow[mainSide];
      var max2 = offset2 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset2 + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
      popperOffsets2[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
  }
  var preventOverflow_default = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };

  // node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  // node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  // node_modules/@popperjs/core/lib/utils/orderModifiers.js
  function order(modifiers) {
    var map = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  // node_modules/@popperjs/core/lib/utils/debounce.js
  function debounce(fn2) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve(fn2());
          });
        });
      }
      return pending;
    };
  }

  // node_modules/@popperjs/core/lib/utils/mergeByName.js
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }

  // node_modules/@popperjs/core/lib/createPopper.js
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper4(reference2, popper2, options) {
      if (options === void 0) {
        options = defaultOptions2;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions2, state.options, options2);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers3, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m2) {
            return m2.enabled;
          });
          runModifierEffects();
          return instance.update();
        },
        // Sync update  it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn2 === "function") {
              state = fn2({
                state,
                options: _options,
                name,
                instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update  it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function() {
          return new Promise(function(resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        return instance;
      }
      instance.setOptions(options).then(function(state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref) {
          var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
          if (typeof effect4 === "function") {
            var cleanupFn = effect4({
              state,
              name,
              instance,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn2) {
          return fn2();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }
  var createPopper = /* @__PURE__ */ popperGenerator();

  // node_modules/@popperjs/core/lib/popper-lite.js
  var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
  var createPopper2 = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });

  // node_modules/@popperjs/core/lib/popper.js
  var defaultModifiers2 = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
  var createPopper3 = /* @__PURE__ */ popperGenerator({
    defaultModifiers: defaultModifiers2
  });

  // node_modules/bootstrap/dist/js/bootstrap.esm.js
  var elementMap = /* @__PURE__ */ new Map();
  var Data = {
    set(element, key, instance) {
      if (!elementMap.has(element)) {
        elementMap.set(element, /* @__PURE__ */ new Map());
      }
      const instanceMap = elementMap.get(element);
      if (!instanceMap.has(key) && instanceMap.size !== 0) {
        console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
        return;
      }
      instanceMap.set(key, instance);
    },
    get(element, key) {
      if (elementMap.has(element)) {
        return elementMap.get(element).get(key) || null;
      }
      return null;
    },
    remove(element, key) {
      if (!elementMap.has(element)) {
        return;
      }
      const instanceMap = elementMap.get(element);
      instanceMap.delete(key);
      if (instanceMap.size === 0) {
        elementMap.delete(element);
      }
    }
  };
  var MAX_UID = 1e6;
  var MILLISECONDS_MULTIPLIER = 1e3;
  var TRANSITION_END = "transitionend";
  var parseSelector = (selector) => {
    if (selector && window.CSS && window.CSS.escape) {
      selector = selector.replace(/#([^\s"#']+)/g, (match, id) => `#${CSS.escape(id)}`);
    }
    return selector;
  };
  var toType = (object) => {
    if (object === null || object === void 0) {
      return `${object}`;
    }
    return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
  };
  var getUID = (prefix) => {
    do {
      prefix += Math.floor(Math.random() * MAX_UID);
    } while (document.getElementById(prefix));
    return prefix;
  };
  var getTransitionDurationFromElement = (element) => {
    if (!element) {
      return 0;
    }
    let {
      transitionDuration,
      transitionDelay
    } = window.getComputedStyle(element);
    const floatTransitionDuration = Number.parseFloat(transitionDuration);
    const floatTransitionDelay = Number.parseFloat(transitionDelay);
    if (!floatTransitionDuration && !floatTransitionDelay) {
      return 0;
    }
    transitionDuration = transitionDuration.split(",")[0];
    transitionDelay = transitionDelay.split(",")[0];
    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
  };
  var triggerTransitionEnd = (element) => {
    element.dispatchEvent(new Event(TRANSITION_END));
  };
  var isElement2 = (object) => {
    if (!object || typeof object !== "object") {
      return false;
    }
    if (typeof object.jquery !== "undefined") {
      object = object[0];
    }
    return typeof object.nodeType !== "undefined";
  };
  var getElement = (object) => {
    if (isElement2(object)) {
      return object.jquery ? object[0] : object;
    }
    if (typeof object === "string" && object.length > 0) {
      return document.querySelector(parseSelector(object));
    }
    return null;
  };
  var isVisible = (element) => {
    if (!isElement2(element) || element.getClientRects().length === 0) {
      return false;
    }
    const elementIsVisible = getComputedStyle(element).getPropertyValue("visibility") === "visible";
    const closedDetails = element.closest("details:not([open])");
    if (!closedDetails) {
      return elementIsVisible;
    }
    if (closedDetails !== element) {
      const summary = element.closest("summary");
      if (summary && summary.parentNode !== closedDetails) {
        return false;
      }
      if (summary === null) {
        return false;
      }
    }
    return elementIsVisible;
  };
  var isDisabled = (element) => {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }
    if (element.classList.contains("disabled")) {
      return true;
    }
    if (typeof element.disabled !== "undefined") {
      return element.disabled;
    }
    return element.hasAttribute("disabled") && element.getAttribute("disabled") !== "false";
  };
  var findShadowRoot = (element) => {
    if (!document.documentElement.attachShadow) {
      return null;
    }
    if (typeof element.getRootNode === "function") {
      const root = element.getRootNode();
      return root instanceof ShadowRoot ? root : null;
    }
    if (element instanceof ShadowRoot) {
      return element;
    }
    if (!element.parentNode) {
      return null;
    }
    return findShadowRoot(element.parentNode);
  };
  var noop = () => {
  };
  var reflow = (element) => {
    element.offsetHeight;
  };
  var getjQuery = () => {
    if (window.jQuery && !document.body.hasAttribute("data-bs-no-jquery")) {
      return window.jQuery;
    }
    return null;
  };
  var DOMContentLoadedCallbacks = [];
  var onDOMContentLoaded = (callback) => {
    if (document.readyState === "loading") {
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener("DOMContentLoaded", () => {
          for (const callback2 of DOMContentLoadedCallbacks) {
            callback2();
          }
        });
      }
      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };
  var isRTL = () => document.documentElement.dir === "rtl";
  var defineJQueryPlugin = (plugin) => {
    onDOMContentLoaded(() => {
      const $8 = getjQuery();
      if ($8) {
        const name = plugin.NAME;
        const JQUERY_NO_CONFLICT = $8.fn[name];
        $8.fn[name] = plugin.jQueryInterface;
        $8.fn[name].Constructor = plugin;
        $8.fn[name].noConflict = () => {
          $8.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  var execute = (possibleCallback, args = [], defaultValue = possibleCallback) => {
    return typeof possibleCallback === "function" ? possibleCallback(...args) : defaultValue;
  };
  var executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
    if (!waitForTransition) {
      execute(callback);
      return;
    }
    const durationPadding = 5;
    const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
    let called = false;
    const handler = ({
      target
    }) => {
      if (target !== transitionElement) {
        return;
      }
      called = true;
      transitionElement.removeEventListener(TRANSITION_END, handler);
      execute(callback);
    };
    transitionElement.addEventListener(TRANSITION_END, handler);
    setTimeout(() => {
      if (!called) {
        triggerTransitionEnd(transitionElement);
      }
    }, emulatedDuration);
  };
  var getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
    const listLength = list.length;
    let index = list.indexOf(activeElement);
    if (index === -1) {
      return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
    }
    index += shouldGetNext ? 1 : -1;
    if (isCycleAllowed) {
      index = (index + listLength) % listLength;
    }
    return list[Math.max(0, Math.min(index, listLength - 1))];
  };
  var namespaceRegex = /[^.]*(?=\..*)\.|.*/;
  var stripNameRegex = /\..*/;
  var stripUidRegex = /::\d+$/;
  var eventRegistry = {};
  var uidEvent = 1;
  var customEvents = {
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  };
  var nativeEvents = /* @__PURE__ */ new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
  function makeEventUid(element, uid) {
    return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
  }
  function getElementEvents(element) {
    const uid = makeEventUid(element);
    element.uidEvent = uid;
    eventRegistry[uid] = eventRegistry[uid] || {};
    return eventRegistry[uid];
  }
  function bootstrapHandler(element, fn2) {
    return function handler(event) {
      hydrateObj(event, {
        delegateTarget: element
      });
      if (handler.oneOff) {
        EventHandler.off(element, event.type, fn2);
      }
      return fn2.apply(element, [event]);
    };
  }
  function bootstrapDelegationHandler(element, selector, fn2) {
    return function handler(event) {
      const domElements = element.querySelectorAll(selector);
      for (let {
        target
      } = event; target && target !== this; target = target.parentNode) {
        for (const domElement of domElements) {
          if (domElement !== target) {
            continue;
          }
          hydrateObj(event, {
            delegateTarget: target
          });
          if (handler.oneOff) {
            EventHandler.off(element, event.type, selector, fn2);
          }
          return fn2.apply(target, [event]);
        }
      }
    };
  }
  function findHandler(events, callable, delegationSelector = null) {
    return Object.values(events).find((event) => event.callable === callable && event.delegationSelector === delegationSelector);
  }
  function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
    const isDelegated = typeof handler === "string";
    const callable = isDelegated ? delegationFunction : handler || delegationFunction;
    let typeEvent = getTypeEvent(originalTypeEvent);
    if (!nativeEvents.has(typeEvent)) {
      typeEvent = originalTypeEvent;
    }
    return [isDelegated, callable, typeEvent];
  }
  function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
    if (typeof originalTypeEvent !== "string" || !element) {
      return;
    }
    let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
    if (originalTypeEvent in customEvents) {
      const wrapFunction = (fn3) => {
        return function(event) {
          if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
            return fn3.call(this, event);
          }
        };
      };
      callable = wrapFunction(callable);
    }
    const events = getElementEvents(element);
    const handlers = events[typeEvent] || (events[typeEvent] = {});
    const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
    if (previousFunction) {
      previousFunction.oneOff = previousFunction.oneOff && oneOff;
      return;
    }
    const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ""));
    const fn2 = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
    fn2.delegationSelector = isDelegated ? handler : null;
    fn2.callable = callable;
    fn2.oneOff = oneOff;
    fn2.uidEvent = uid;
    handlers[uid] = fn2;
    element.addEventListener(typeEvent, fn2, isDelegated);
  }
  function removeHandler(element, events, typeEvent, handler, delegationSelector) {
    const fn2 = findHandler(events[typeEvent], handler, delegationSelector);
    if (!fn2) {
      return;
    }
    element.removeEventListener(typeEvent, fn2, Boolean(delegationSelector));
    delete events[typeEvent][fn2.uidEvent];
  }
  function removeNamespacedHandlers(element, events, typeEvent, namespace) {
    const storeElementEvent = events[typeEvent] || {};
    for (const [handlerKey, event] of Object.entries(storeElementEvent)) {
      if (handlerKey.includes(namespace)) {
        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
      }
    }
  }
  function getTypeEvent(event) {
    event = event.replace(stripNameRegex, "");
    return customEvents[event] || event;
  }
  var EventHandler = {
    on(element, event, handler, delegationFunction) {
      addHandler(element, event, handler, delegationFunction, false);
    },
    one(element, event, handler, delegationFunction) {
      addHandler(element, event, handler, delegationFunction, true);
    },
    off(element, originalTypeEvent, handler, delegationFunction) {
      if (typeof originalTypeEvent !== "string" || !element) {
        return;
      }
      const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
      const inNamespace = typeEvent !== originalTypeEvent;
      const events = getElementEvents(element);
      const storeElementEvent = events[typeEvent] || {};
      const isNamespace = originalTypeEvent.startsWith(".");
      if (typeof callable !== "undefined") {
        if (!Object.keys(storeElementEvent).length) {
          return;
        }
        removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
        return;
      }
      if (isNamespace) {
        for (const elementEvent of Object.keys(events)) {
          removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
        }
      }
      for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {
        const handlerKey = keyHandlers.replace(stripUidRegex, "");
        if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
          removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
        }
      }
    },
    trigger(element, event, args) {
      if (typeof event !== "string" || !element) {
        return null;
      }
      const $8 = getjQuery();
      const typeEvent = getTypeEvent(event);
      const inNamespace = event !== typeEvent;
      let jQueryEvent = null;
      let bubbles = true;
      let nativeDispatch = true;
      let defaultPrevented = false;
      if (inNamespace && $8) {
        jQueryEvent = $8.Event(event, args);
        $8(element).trigger(jQueryEvent);
        bubbles = !jQueryEvent.isPropagationStopped();
        nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
        defaultPrevented = jQueryEvent.isDefaultPrevented();
      }
      const evt = hydrateObj(new Event(event, {
        bubbles,
        cancelable: true
      }), args);
      if (defaultPrevented) {
        evt.preventDefault();
      }
      if (nativeDispatch) {
        element.dispatchEvent(evt);
      }
      if (evt.defaultPrevented && jQueryEvent) {
        jQueryEvent.preventDefault();
      }
      return evt;
    }
  };
  function hydrateObj(obj, meta = {}) {
    for (const [key, value] of Object.entries(meta)) {
      try {
        obj[key] = value;
      } catch (_unused) {
        Object.defineProperty(obj, key, {
          configurable: true,
          get() {
            return value;
          }
        });
      }
    }
    return obj;
  }
  function normalizeData(value) {
    if (value === "true") {
      return true;
    }
    if (value === "false") {
      return false;
    }
    if (value === Number(value).toString()) {
      return Number(value);
    }
    if (value === "" || value === "null") {
      return null;
    }
    if (typeof value !== "string") {
      return value;
    }
    try {
      return JSON.parse(decodeURIComponent(value));
    } catch (_unused) {
      return value;
    }
  }
  function normalizeDataKey(key) {
    return key.replace(/[A-Z]/g, (chr) => `-${chr.toLowerCase()}`);
  }
  var Manipulator = {
    setDataAttribute(element, key, value) {
      element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
    },
    removeDataAttribute(element, key) {
      element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
    },
    getDataAttributes(element) {
      if (!element) {
        return {};
      }
      const attributes = {};
      const bsKeys = Object.keys(element.dataset).filter((key) => key.startsWith("bs") && !key.startsWith("bsConfig"));
      for (const key of bsKeys) {
        let pureKey = key.replace(/^bs/, "");
        pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
        attributes[pureKey] = normalizeData(element.dataset[key]);
      }
      return attributes;
    },
    getDataAttribute(element, key) {
      return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
    }
  };
  var Config = class {
    // Getters
    static get Default() {
      return {};
    }
    static get DefaultType() {
      return {};
    }
    static get NAME() {
      throw new Error('You have to implement the static method "NAME", for each component!');
    }
    _getConfig(config) {
      config = this._mergeConfigObj(config);
      config = this._configAfterMerge(config);
      this._typeCheckConfig(config);
      return config;
    }
    _configAfterMerge(config) {
      return config;
    }
    _mergeConfigObj(config, element) {
      const jsonConfig = isElement2(element) ? Manipulator.getDataAttribute(element, "config") : {};
      return {
        ...this.constructor.Default,
        ...typeof jsonConfig === "object" ? jsonConfig : {},
        ...isElement2(element) ? Manipulator.getDataAttributes(element) : {},
        ...typeof config === "object" ? config : {}
      };
    }
    _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {
      for (const [property, expectedTypes] of Object.entries(configTypes)) {
        const value = config[property];
        const valueType = isElement2(value) ? "element" : toType(value);
        if (!new RegExp(expectedTypes).test(valueType)) {
          throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
        }
      }
    }
  };
  var VERSION = "5.3.3";
  var BaseComponent = class extends Config {
    constructor(element, config) {
      super();
      element = getElement(element);
      if (!element) {
        return;
      }
      this._element = element;
      this._config = this._getConfig(config);
      Data.set(this._element, this.constructor.DATA_KEY, this);
    }
    // Public
    dispose() {
      Data.remove(this._element, this.constructor.DATA_KEY);
      EventHandler.off(this._element, this.constructor.EVENT_KEY);
      for (const propertyName of Object.getOwnPropertyNames(this)) {
        this[propertyName] = null;
      }
    }
    _queueCallback(callback, element, isAnimated = true) {
      executeAfterTransition(callback, element, isAnimated);
    }
    _getConfig(config) {
      config = this._mergeConfigObj(config, this._element);
      config = this._configAfterMerge(config);
      this._typeCheckConfig(config);
      return config;
    }
    // Static
    static getInstance(element) {
      return Data.get(getElement(element), this.DATA_KEY);
    }
    static getOrCreateInstance(element, config = {}) {
      return this.getInstance(element) || new this(element, typeof config === "object" ? config : null);
    }
    static get VERSION() {
      return VERSION;
    }
    static get DATA_KEY() {
      return `bs.${this.NAME}`;
    }
    static get EVENT_KEY() {
      return `.${this.DATA_KEY}`;
    }
    static eventName(name) {
      return `${name}${this.EVENT_KEY}`;
    }
  };
  var getSelector = (element) => {
    let selector = element.getAttribute("data-bs-target");
    if (!selector || selector === "#") {
      let hrefAttribute = element.getAttribute("href");
      if (!hrefAttribute || !hrefAttribute.includes("#") && !hrefAttribute.startsWith(".")) {
        return null;
      }
      if (hrefAttribute.includes("#") && !hrefAttribute.startsWith("#")) {
        hrefAttribute = `#${hrefAttribute.split("#")[1]}`;
      }
      selector = hrefAttribute && hrefAttribute !== "#" ? hrefAttribute.trim() : null;
    }
    return selector ? selector.split(",").map((sel) => parseSelector(sel)).join(",") : null;
  };
  var SelectorEngine = {
    find(selector, element = document.documentElement) {
      return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
    },
    findOne(selector, element = document.documentElement) {
      return Element.prototype.querySelector.call(element, selector);
    },
    children(element, selector) {
      return [].concat(...element.children).filter((child) => child.matches(selector));
    },
    parents(element, selector) {
      const parents = [];
      let ancestor = element.parentNode.closest(selector);
      while (ancestor) {
        parents.push(ancestor);
        ancestor = ancestor.parentNode.closest(selector);
      }
      return parents;
    },
    prev(element, selector) {
      let previous = element.previousElementSibling;
      while (previous) {
        if (previous.matches(selector)) {
          return [previous];
        }
        previous = previous.previousElementSibling;
      }
      return [];
    },
    // TODO: this is now unused; remove later along with prev()
    next(element, selector) {
      let next = element.nextElementSibling;
      while (next) {
        if (next.matches(selector)) {
          return [next];
        }
        next = next.nextElementSibling;
      }
      return [];
    },
    focusableChildren(element) {
      const focusables = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((selector) => `${selector}:not([tabindex^="-"])`).join(",");
      return this.find(focusables, element).filter((el) => !isDisabled(el) && isVisible(el));
    },
    getSelectorFromElement(element) {
      const selector = getSelector(element);
      if (selector) {
        return SelectorEngine.findOne(selector) ? selector : null;
      }
      return null;
    },
    getElementFromSelector(element) {
      const selector = getSelector(element);
      return selector ? SelectorEngine.findOne(selector) : null;
    },
    getMultipleElementsFromSelector(element) {
      const selector = getSelector(element);
      return selector ? SelectorEngine.find(selector) : [];
    }
  };
  var enableDismissTrigger = (component, method = "hide") => {
    const clickEvent = `click.dismiss${component.EVENT_KEY}`;
    const name = component.NAME;
    EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function(event) {
      if (["A", "AREA"].includes(this.tagName)) {
        event.preventDefault();
      }
      if (isDisabled(this)) {
        return;
      }
      const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);
      const instance = component.getOrCreateInstance(target);
      instance[method]();
    });
  };
  var NAME$f = "alert";
  var DATA_KEY$a = "bs.alert";
  var EVENT_KEY$b = `.${DATA_KEY$a}`;
  var EVENT_CLOSE = `close${EVENT_KEY$b}`;
  var EVENT_CLOSED = `closed${EVENT_KEY$b}`;
  var CLASS_NAME_FADE$5 = "fade";
  var CLASS_NAME_SHOW$8 = "show";
  var Alert = class _Alert extends BaseComponent {
    // Getters
    static get NAME() {
      return NAME$f;
    }
    // Public
    close() {
      const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
      if (closeEvent.defaultPrevented) {
        return;
      }
      this._element.classList.remove(CLASS_NAME_SHOW$8);
      const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
      this._queueCallback(() => this._destroyElement(), this._element, isAnimated);
    }
    // Private
    _destroyElement() {
      this._element.remove();
      EventHandler.trigger(this._element, EVENT_CLOSED);
      this.dispose();
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = _Alert.getOrCreateInstance(this);
        if (typeof config !== "string") {
          return;
        }
        if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](this);
      });
    }
  };
  enableDismissTrigger(Alert, "close");
  defineJQueryPlugin(Alert);
  var NAME$e = "button";
  var DATA_KEY$9 = "bs.button";
  var EVENT_KEY$a = `.${DATA_KEY$9}`;
  var DATA_API_KEY$6 = ".data-api";
  var CLASS_NAME_ACTIVE$3 = "active";
  var SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
  var EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;
  var Button = class _Button extends BaseComponent {
    // Getters
    static get NAME() {
      return NAME$e;
    }
    // Public
    toggle() {
      this._element.setAttribute("aria-pressed", this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = _Button.getOrCreateInstance(this);
        if (config === "toggle") {
          data[config]();
        }
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event) => {
    event.preventDefault();
    const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
    const data = Button.getOrCreateInstance(button);
    data.toggle();
  });
  defineJQueryPlugin(Button);
  var NAME$d = "swipe";
  var EVENT_KEY$9 = ".bs.swipe";
  var EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
  var EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
  var EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
  var EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
  var EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
  var POINTER_TYPE_TOUCH = "touch";
  var POINTER_TYPE_PEN = "pen";
  var CLASS_NAME_POINTER_EVENT = "pointer-event";
  var SWIPE_THRESHOLD = 40;
  var Default$c = {
    endCallback: null,
    leftCallback: null,
    rightCallback: null
  };
  var DefaultType$c = {
    endCallback: "(function|null)",
    leftCallback: "(function|null)",
    rightCallback: "(function|null)"
  };
  var Swipe = class _Swipe extends Config {
    constructor(element, config) {
      super();
      this._element = element;
      if (!element || !_Swipe.isSupported()) {
        return;
      }
      this._config = this._getConfig(config);
      this._deltaX = 0;
      this._supportPointerEvents = Boolean(window.PointerEvent);
      this._initEvents();
    }
    // Getters
    static get Default() {
      return Default$c;
    }
    static get DefaultType() {
      return DefaultType$c;
    }
    static get NAME() {
      return NAME$d;
    }
    // Public
    dispose() {
      EventHandler.off(this._element, EVENT_KEY$9);
    }
    // Private
    _start(event) {
      if (!this._supportPointerEvents) {
        this._deltaX = event.touches[0].clientX;
        return;
      }
      if (this._eventIsPointerPenTouch(event)) {
        this._deltaX = event.clientX;
      }
    }
    _end(event) {
      if (this._eventIsPointerPenTouch(event)) {
        this._deltaX = event.clientX - this._deltaX;
      }
      this._handleSwipe();
      execute(this._config.endCallback);
    }
    _move(event) {
      this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
    }
    _handleSwipe() {
      const absDeltaX = Math.abs(this._deltaX);
      if (absDeltaX <= SWIPE_THRESHOLD) {
        return;
      }
      const direction = absDeltaX / this._deltaX;
      this._deltaX = 0;
      if (!direction) {
        return;
      }
      execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
    }
    _initEvents() {
      if (this._supportPointerEvents) {
        EventHandler.on(this._element, EVENT_POINTERDOWN, (event) => this._start(event));
        EventHandler.on(this._element, EVENT_POINTERUP, (event) => this._end(event));
        this._element.classList.add(CLASS_NAME_POINTER_EVENT);
      } else {
        EventHandler.on(this._element, EVENT_TOUCHSTART, (event) => this._start(event));
        EventHandler.on(this._element, EVENT_TOUCHMOVE, (event) => this._move(event));
        EventHandler.on(this._element, EVENT_TOUCHEND, (event) => this._end(event));
      }
    }
    _eventIsPointerPenTouch(event) {
      return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
    }
    // Static
    static isSupported() {
      return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
    }
  };
  var NAME$c = "carousel";
  var DATA_KEY$8 = "bs.carousel";
  var EVENT_KEY$8 = `.${DATA_KEY$8}`;
  var DATA_API_KEY$5 = ".data-api";
  var ARROW_LEFT_KEY$1 = "ArrowLeft";
  var ARROW_RIGHT_KEY$1 = "ArrowRight";
  var TOUCHEVENT_COMPAT_WAIT = 500;
  var ORDER_NEXT = "next";
  var ORDER_PREV = "prev";
  var DIRECTION_LEFT = "left";
  var DIRECTION_RIGHT = "right";
  var EVENT_SLIDE = `slide${EVENT_KEY$8}`;
  var EVENT_SLID = `slid${EVENT_KEY$8}`;
  var EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
  var EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
  var EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
  var EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
  var EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
  var EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
  var CLASS_NAME_CAROUSEL = "carousel";
  var CLASS_NAME_ACTIVE$2 = "active";
  var CLASS_NAME_SLIDE = "slide";
  var CLASS_NAME_END = "carousel-item-end";
  var CLASS_NAME_START = "carousel-item-start";
  var CLASS_NAME_NEXT = "carousel-item-next";
  var CLASS_NAME_PREV = "carousel-item-prev";
  var SELECTOR_ACTIVE = ".active";
  var SELECTOR_ITEM = ".carousel-item";
  var SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
  var SELECTOR_ITEM_IMG = ".carousel-item img";
  var SELECTOR_INDICATORS = ".carousel-indicators";
  var SELECTOR_DATA_SLIDE = "[data-bs-slide], [data-bs-slide-to]";
  var SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
  var KEY_TO_DIRECTION = {
    [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
    [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT
  };
  var Default$b = {
    interval: 5e3,
    keyboard: true,
    pause: "hover",
    ride: false,
    touch: true,
    wrap: true
  };
  var DefaultType$b = {
    interval: "(number|boolean)",
    // TODO:v6 remove boolean support
    keyboard: "boolean",
    pause: "(string|boolean)",
    ride: "(boolean|string)",
    touch: "boolean",
    wrap: "boolean"
  };
  var Carousel = class _Carousel extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._interval = null;
      this._activeElement = null;
      this._isSliding = false;
      this.touchTimeout = null;
      this._swipeHelper = null;
      this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
      this._addEventListeners();
      if (this._config.ride === CLASS_NAME_CAROUSEL) {
        this.cycle();
      }
    }
    // Getters
    static get Default() {
      return Default$b;
    }
    static get DefaultType() {
      return DefaultType$b;
    }
    static get NAME() {
      return NAME$c;
    }
    // Public
    next() {
      this._slide(ORDER_NEXT);
    }
    nextWhenVisible() {
      if (!document.hidden && isVisible(this._element)) {
        this.next();
      }
    }
    prev() {
      this._slide(ORDER_PREV);
    }
    pause() {
      if (this._isSliding) {
        triggerTransitionEnd(this._element);
      }
      this._clearInterval();
    }
    cycle() {
      this._clearInterval();
      this._updateInterval();
      this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
    }
    _maybeEnableCycle() {
      if (!this._config.ride) {
        return;
      }
      if (this._isSliding) {
        EventHandler.one(this._element, EVENT_SLID, () => this.cycle());
        return;
      }
      this.cycle();
    }
    to(index) {
      const items = this._getItems();
      if (index > items.length - 1 || index < 0) {
        return;
      }
      if (this._isSliding) {
        EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
        return;
      }
      const activeIndex = this._getItemIndex(this._getActive());
      if (activeIndex === index) {
        return;
      }
      const order2 = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
      this._slide(order2, items[index]);
    }
    dispose() {
      if (this._swipeHelper) {
        this._swipeHelper.dispose();
      }
      super.dispose();
    }
    // Private
    _configAfterMerge(config) {
      config.defaultInterval = config.interval;
      return config;
    }
    _addEventListeners() {
      if (this._config.keyboard) {
        EventHandler.on(this._element, EVENT_KEYDOWN$1, (event) => this._keydown(event));
      }
      if (this._config.pause === "hover") {
        EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());
        EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());
      }
      if (this._config.touch && Swipe.isSupported()) {
        this._addTouchEventListeners();
      }
    }
    _addTouchEventListeners() {
      for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {
        EventHandler.on(img, EVENT_DRAG_START, (event) => event.preventDefault());
      }
      const endCallBack = () => {
        if (this._config.pause !== "hover") {
          return;
        }
        this.pause();
        if (this.touchTimeout) {
          clearTimeout(this.touchTimeout);
        }
        this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
      };
      const swipeConfig = {
        leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),
        rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),
        endCallback: endCallBack
      };
      this._swipeHelper = new Swipe(this._element, swipeConfig);
    }
    _keydown(event) {
      if (/input|textarea/i.test(event.target.tagName)) {
        return;
      }
      const direction = KEY_TO_DIRECTION[event.key];
      if (direction) {
        event.preventDefault();
        this._slide(this._directionToOrder(direction));
      }
    }
    _getItemIndex(element) {
      return this._getItems().indexOf(element);
    }
    _setActiveIndicatorElement(index) {
      if (!this._indicatorsElement) {
        return;
      }
      const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
      activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
      activeIndicator.removeAttribute("aria-current");
      const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);
      if (newActiveIndicator) {
        newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
        newActiveIndicator.setAttribute("aria-current", "true");
      }
    }
    _updateInterval() {
      const element = this._activeElement || this._getActive();
      if (!element) {
        return;
      }
      const elementInterval = Number.parseInt(element.getAttribute("data-bs-interval"), 10);
      this._config.interval = elementInterval || this._config.defaultInterval;
    }
    _slide(order2, element = null) {
      if (this._isSliding) {
        return;
      }
      const activeElement = this._getActive();
      const isNext = order2 === ORDER_NEXT;
      const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);
      if (nextElement === activeElement) {
        return;
      }
      const nextElementIndex = this._getItemIndex(nextElement);
      const triggerEvent = (eventName) => {
        return EventHandler.trigger(this._element, eventName, {
          relatedTarget: nextElement,
          direction: this._orderToDirection(order2),
          from: this._getItemIndex(activeElement),
          to: nextElementIndex
        });
      };
      const slideEvent = triggerEvent(EVENT_SLIDE);
      if (slideEvent.defaultPrevented) {
        return;
      }
      if (!activeElement || !nextElement) {
        return;
      }
      const isCycling = Boolean(this._interval);
      this.pause();
      this._isSliding = true;
      this._setActiveIndicatorElement(nextElementIndex);
      this._activeElement = nextElement;
      const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
      const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
      nextElement.classList.add(orderClassName);
      reflow(nextElement);
      activeElement.classList.add(directionalClassName);
      nextElement.classList.add(directionalClassName);
      const completeCallBack = () => {
        nextElement.classList.remove(directionalClassName, orderClassName);
        nextElement.classList.add(CLASS_NAME_ACTIVE$2);
        activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
        this._isSliding = false;
        triggerEvent(EVENT_SLID);
      };
      this._queueCallback(completeCallBack, activeElement, this._isAnimated());
      if (isCycling) {
        this.cycle();
      }
    }
    _isAnimated() {
      return this._element.classList.contains(CLASS_NAME_SLIDE);
    }
    _getActive() {
      return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
    }
    _getItems() {
      return SelectorEngine.find(SELECTOR_ITEM, this._element);
    }
    _clearInterval() {
      if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
      }
    }
    _directionToOrder(direction) {
      if (isRTL()) {
        return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
      }
      return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
    }
    _orderToDirection(order2) {
      if (isRTL()) {
        return order2 === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
      }
      return order2 === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = _Carousel.getOrCreateInstance(this, config);
        if (typeof config === "number") {
          data.to(config);
          return;
        }
        if (typeof config === "string") {
          if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
            throw new TypeError(`No method named "${config}"`);
          }
          data[config]();
        }
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function(event) {
    const target = SelectorEngine.getElementFromSelector(this);
    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
      return;
    }
    event.preventDefault();
    const carousel = Carousel.getOrCreateInstance(target);
    const slideIndex = this.getAttribute("data-bs-slide-to");
    if (slideIndex) {
      carousel.to(slideIndex);
      carousel._maybeEnableCycle();
      return;
    }
    if (Manipulator.getDataAttribute(this, "slide") === "next") {
      carousel.next();
      carousel._maybeEnableCycle();
      return;
    }
    carousel.prev();
    carousel._maybeEnableCycle();
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {
    const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
    for (const carousel of carousels) {
      Carousel.getOrCreateInstance(carousel);
    }
  });
  defineJQueryPlugin(Carousel);
  var NAME$b = "collapse";
  var DATA_KEY$7 = "bs.collapse";
  var EVENT_KEY$7 = `.${DATA_KEY$7}`;
  var DATA_API_KEY$4 = ".data-api";
  var EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
  var EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
  var EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
  var EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
  var EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
  var CLASS_NAME_SHOW$7 = "show";
  var CLASS_NAME_COLLAPSE = "collapse";
  var CLASS_NAME_COLLAPSING = "collapsing";
  var CLASS_NAME_COLLAPSED = "collapsed";
  var CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
  var CLASS_NAME_HORIZONTAL = "collapse-horizontal";
  var WIDTH = "width";
  var HEIGHT = "height";
  var SELECTOR_ACTIVES = ".collapse.show, .collapse.collapsing";
  var SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
  var Default$a = {
    parent: null,
    toggle: true
  };
  var DefaultType$a = {
    parent: "(null|element)",
    toggle: "boolean"
  };
  var Collapse = class _Collapse extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._isTransitioning = false;
      this._triggerArray = [];
      const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
      for (const elem of toggleList) {
        const selector = SelectorEngine.getSelectorFromElement(elem);
        const filterElement = SelectorEngine.find(selector).filter((foundElement) => foundElement === this._element);
        if (selector !== null && filterElement.length) {
          this._triggerArray.push(elem);
        }
      }
      this._initializeChildren();
      if (!this._config.parent) {
        this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
      }
      if (this._config.toggle) {
        this.toggle();
      }
    }
    // Getters
    static get Default() {
      return Default$a;
    }
    static get DefaultType() {
      return DefaultType$a;
    }
    static get NAME() {
      return NAME$b;
    }
    // Public
    toggle() {
      if (this._isShown()) {
        this.hide();
      } else {
        this.show();
      }
    }
    show() {
      if (this._isTransitioning || this._isShown()) {
        return;
      }
      let activeChildren = [];
      if (this._config.parent) {
        activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter((element) => element !== this._element).map((element) => _Collapse.getOrCreateInstance(element, {
          toggle: false
        }));
      }
      if (activeChildren.length && activeChildren[0]._isTransitioning) {
        return;
      }
      const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);
      if (startEvent.defaultPrevented) {
        return;
      }
      for (const activeInstance of activeChildren) {
        activeInstance.hide();
      }
      const dimension = this._getDimension();
      this._element.classList.remove(CLASS_NAME_COLLAPSE);
      this._element.classList.add(CLASS_NAME_COLLAPSING);
      this._element.style[dimension] = 0;
      this._addAriaAndCollapsedClass(this._triggerArray, true);
      this._isTransitioning = true;
      const complete = () => {
        this._isTransitioning = false;
        this._element.classList.remove(CLASS_NAME_COLLAPSING);
        this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
        this._element.style[dimension] = "";
        EventHandler.trigger(this._element, EVENT_SHOWN$6);
      };
      const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
      const scrollSize = `scroll${capitalizedDimension}`;
      this._queueCallback(complete, this._element, true);
      this._element.style[dimension] = `${this._element[scrollSize]}px`;
    }
    hide() {
      if (this._isTransitioning || !this._isShown()) {
        return;
      }
      const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);
      if (startEvent.defaultPrevented) {
        return;
      }
      const dimension = this._getDimension();
      this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_COLLAPSING);
      this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
      for (const trigger of this._triggerArray) {
        const element = SelectorEngine.getElementFromSelector(trigger);
        if (element && !this._isShown(element)) {
          this._addAriaAndCollapsedClass([trigger], false);
        }
      }
      this._isTransitioning = true;
      const complete = () => {
        this._isTransitioning = false;
        this._element.classList.remove(CLASS_NAME_COLLAPSING);
        this._element.classList.add(CLASS_NAME_COLLAPSE);
        EventHandler.trigger(this._element, EVENT_HIDDEN$6);
      };
      this._element.style[dimension] = "";
      this._queueCallback(complete, this._element, true);
    }
    _isShown(element = this._element) {
      return element.classList.contains(CLASS_NAME_SHOW$7);
    }
    // Private
    _configAfterMerge(config) {
      config.toggle = Boolean(config.toggle);
      config.parent = getElement(config.parent);
      return config;
    }
    _getDimension() {
      return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
    }
    _initializeChildren() {
      if (!this._config.parent) {
        return;
      }
      const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
      for (const element of children) {
        const selected = SelectorEngine.getElementFromSelector(element);
        if (selected) {
          this._addAriaAndCollapsedClass([element], this._isShown(selected));
        }
      }
    }
    _getFirstLevelChildren(selector) {
      const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
      return SelectorEngine.find(selector, this._config.parent).filter((element) => !children.includes(element));
    }
    _addAriaAndCollapsedClass(triggerArray, isOpen) {
      if (!triggerArray.length) {
        return;
      }
      for (const element of triggerArray) {
        element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
        element.setAttribute("aria-expanded", isOpen);
      }
    }
    // Static
    static jQueryInterface(config) {
      const _config = {};
      if (typeof config === "string" && /show|hide/.test(config)) {
        _config.toggle = false;
      }
      return this.each(function() {
        const data = _Collapse.getOrCreateInstance(this, _config);
        if (typeof config === "string") {
          if (typeof data[config] === "undefined") {
            throw new TypeError(`No method named "${config}"`);
          }
          data[config]();
        }
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {
    if (event.target.tagName === "A" || event.delegateTarget && event.delegateTarget.tagName === "A") {
      event.preventDefault();
    }
    for (const element of SelectorEngine.getMultipleElementsFromSelector(this)) {
      Collapse.getOrCreateInstance(element, {
        toggle: false
      }).toggle();
    }
  });
  defineJQueryPlugin(Collapse);
  var NAME$a = "dropdown";
  var DATA_KEY$6 = "bs.dropdown";
  var EVENT_KEY$6 = `.${DATA_KEY$6}`;
  var DATA_API_KEY$3 = ".data-api";
  var ESCAPE_KEY$2 = "Escape";
  var TAB_KEY$1 = "Tab";
  var ARROW_UP_KEY$1 = "ArrowUp";
  var ARROW_DOWN_KEY$1 = "ArrowDown";
  var RIGHT_MOUSE_BUTTON = 2;
  var EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
  var EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
  var EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
  var EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
  var EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
  var EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
  var EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
  var CLASS_NAME_SHOW$6 = "show";
  var CLASS_NAME_DROPUP = "dropup";
  var CLASS_NAME_DROPEND = "dropend";
  var CLASS_NAME_DROPSTART = "dropstart";
  var CLASS_NAME_DROPUP_CENTER = "dropup-center";
  var CLASS_NAME_DROPDOWN_CENTER = "dropdown-center";
  var SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
  var SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
  var SELECTOR_MENU = ".dropdown-menu";
  var SELECTOR_NAVBAR = ".navbar";
  var SELECTOR_NAVBAR_NAV = ".navbar-nav";
  var SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
  var PLACEMENT_TOP = isRTL() ? "top-end" : "top-start";
  var PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end";
  var PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start";
  var PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end";
  var PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start";
  var PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start";
  var PLACEMENT_TOPCENTER = "top";
  var PLACEMENT_BOTTOMCENTER = "bottom";
  var Default$9 = {
    autoClose: true,
    boundary: "clippingParents",
    display: "dynamic",
    offset: [0, 2],
    popperConfig: null,
    reference: "toggle"
  };
  var DefaultType$9 = {
    autoClose: "(boolean|string)",
    boundary: "(string|element)",
    display: "string",
    offset: "(array|string|function)",
    popperConfig: "(null|object|function)",
    reference: "(string|element|object)"
  };
  var Dropdown = class _Dropdown extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._popper = null;
      this._parent = this._element.parentNode;
      this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);
      this._inNavbar = this._detectNavbar();
    }
    // Getters
    static get Default() {
      return Default$9;
    }
    static get DefaultType() {
      return DefaultType$9;
    }
    static get NAME() {
      return NAME$a;
    }
    // Public
    toggle() {
      return this._isShown() ? this.hide() : this.show();
    }
    show() {
      if (isDisabled(this._element) || this._isShown()) {
        return;
      }
      const relatedTarget = {
        relatedTarget: this._element
      };
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);
      if (showEvent.defaultPrevented) {
        return;
      }
      this._createPopper();
      if ("ontouchstart" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.on(element, "mouseover", noop);
        }
      }
      this._element.focus();
      this._element.setAttribute("aria-expanded", true);
      this._menu.classList.add(CLASS_NAME_SHOW$6);
      this._element.classList.add(CLASS_NAME_SHOW$6);
      EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
    }
    hide() {
      if (isDisabled(this._element) || !this._isShown()) {
        return;
      }
      const relatedTarget = {
        relatedTarget: this._element
      };
      this._completeHide(relatedTarget);
    }
    dispose() {
      if (this._popper) {
        this._popper.destroy();
      }
      super.dispose();
    }
    update() {
      this._inNavbar = this._detectNavbar();
      if (this._popper) {
        this._popper.update();
      }
    }
    // Private
    _completeHide(relatedTarget) {
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);
      if (hideEvent.defaultPrevented) {
        return;
      }
      if ("ontouchstart" in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.off(element, "mouseover", noop);
        }
      }
      if (this._popper) {
        this._popper.destroy();
      }
      this._menu.classList.remove(CLASS_NAME_SHOW$6);
      this._element.classList.remove(CLASS_NAME_SHOW$6);
      this._element.setAttribute("aria-expanded", "false");
      Manipulator.removeDataAttribute(this._menu, "popper");
      EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
    }
    _getConfig(config) {
      config = super._getConfig(config);
      if (typeof config.reference === "object" && !isElement2(config.reference) && typeof config.reference.getBoundingClientRect !== "function") {
        throw new TypeError(`${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
      }
      return config;
    }
    _createPopper() {
      if (typeof lib_exports === "undefined") {
        throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
      }
      let referenceElement = this._element;
      if (this._config.reference === "parent") {
        referenceElement = this._parent;
      } else if (isElement2(this._config.reference)) {
        referenceElement = getElement(this._config.reference);
      } else if (typeof this._config.reference === "object") {
        referenceElement = this._config.reference;
      }
      const popperConfig = this._getPopperConfig();
      this._popper = createPopper3(referenceElement, this._menu, popperConfig);
    }
    _isShown() {
      return this._menu.classList.contains(CLASS_NAME_SHOW$6);
    }
    _getPlacement() {
      const parentDropdown = this._parent;
      if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
        return PLACEMENT_RIGHT;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
        return PLACEMENT_LEFT;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
        return PLACEMENT_TOPCENTER;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
        return PLACEMENT_BOTTOMCENTER;
      }
      const isEnd = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
        return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
      }
      return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
    }
    _detectNavbar() {
      return this._element.closest(SELECTOR_NAVBAR) !== null;
    }
    _getOffset() {
      const {
        offset: offset2
      } = this._config;
      if (typeof offset2 === "string") {
        return offset2.split(",").map((value) => Number.parseInt(value, 10));
      }
      if (typeof offset2 === "function") {
        return (popperData) => offset2(popperData, this._element);
      }
      return offset2;
    }
    _getPopperConfig() {
      const defaultBsPopperConfig = {
        placement: this._getPlacement(),
        modifiers: [{
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }]
      };
      if (this._inNavbar || this._config.display === "static") {
        Manipulator.setDataAttribute(this._menu, "popper", "static");
        defaultBsPopperConfig.modifiers = [{
          name: "applyStyles",
          enabled: false
        }];
      }
      return {
        ...defaultBsPopperConfig,
        ...execute(this._config.popperConfig, [defaultBsPopperConfig])
      };
    }
    _selectMenuItem({
      key,
      target
    }) {
      const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter((element) => isVisible(element));
      if (!items.length) {
        return;
      }
      getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = _Dropdown.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
    static clearMenus(event) {
      if (event.button === RIGHT_MOUSE_BUTTON || event.type === "keyup" && event.key !== TAB_KEY$1) {
        return;
      }
      const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
      for (const toggle of openToggles) {
        const context = _Dropdown.getInstance(toggle);
        if (!context || context._config.autoClose === false) {
          continue;
        }
        const composedPath = event.composedPath();
        const isMenuTarget = composedPath.includes(context._menu);
        if (composedPath.includes(context._element) || context._config.autoClose === "inside" && !isMenuTarget || context._config.autoClose === "outside" && isMenuTarget) {
          continue;
        }
        if (context._menu.contains(event.target) && (event.type === "keyup" && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
          continue;
        }
        const relatedTarget = {
          relatedTarget: context._element
        };
        if (event.type === "click") {
          relatedTarget.clickEvent = event;
        }
        context._completeHide(relatedTarget);
      }
    }
    static dataApiKeydownHandler(event) {
      const isInput = /input|textarea/i.test(event.target.tagName);
      const isEscapeEvent = event.key === ESCAPE_KEY$2;
      const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);
      if (!isUpOrDownEvent && !isEscapeEvent) {
        return;
      }
      if (isInput && !isEscapeEvent) {
        return;
      }
      event.preventDefault();
      const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
      const instance = _Dropdown.getOrCreateInstance(getToggleButton);
      if (isUpOrDownEvent) {
        event.stopPropagation();
        instance.show();
        instance._selectMenuItem(event);
        return;
      }
      if (instance._isShown()) {
        event.stopPropagation();
        instance.hide();
        getToggleButton.focus();
      }
    }
  };
  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
  EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
  EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
  EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
    event.preventDefault();
    Dropdown.getOrCreateInstance(this).toggle();
  });
  defineJQueryPlugin(Dropdown);
  var NAME$9 = "backdrop";
  var CLASS_NAME_FADE$4 = "fade";
  var CLASS_NAME_SHOW$5 = "show";
  var EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
  var Default$8 = {
    className: "modal-backdrop",
    clickCallback: null,
    isAnimated: false,
    isVisible: true,
    // if false, we use the backdrop helper without adding any element to the dom
    rootElement: "body"
    // give the choice to place backdrop under different elements
  };
  var DefaultType$8 = {
    className: "string",
    clickCallback: "(function|null)",
    isAnimated: "boolean",
    isVisible: "boolean",
    rootElement: "(element|string)"
  };
  var Backdrop = class extends Config {
    constructor(config) {
      super();
      this._config = this._getConfig(config);
      this._isAppended = false;
      this._element = null;
    }
    // Getters
    static get Default() {
      return Default$8;
    }
    static get DefaultType() {
      return DefaultType$8;
    }
    static get NAME() {
      return NAME$9;
    }
    // Public
    show(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }
      this._append();
      const element = this._getElement();
      if (this._config.isAnimated) {
        reflow(element);
      }
      element.classList.add(CLASS_NAME_SHOW$5);
      this._emulateAnimation(() => {
        execute(callback);
      });
    }
    hide(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }
      this._getElement().classList.remove(CLASS_NAME_SHOW$5);
      this._emulateAnimation(() => {
        this.dispose();
        execute(callback);
      });
    }
    dispose() {
      if (!this._isAppended) {
        return;
      }
      EventHandler.off(this._element, EVENT_MOUSEDOWN);
      this._element.remove();
      this._isAppended = false;
    }
    // Private
    _getElement() {
      if (!this._element) {
        const backdrop = document.createElement("div");
        backdrop.className = this._config.className;
        if (this._config.isAnimated) {
          backdrop.classList.add(CLASS_NAME_FADE$4);
        }
        this._element = backdrop;
      }
      return this._element;
    }
    _configAfterMerge(config) {
      config.rootElement = getElement(config.rootElement);
      return config;
    }
    _append() {
      if (this._isAppended) {
        return;
      }
      const element = this._getElement();
      this._config.rootElement.append(element);
      EventHandler.on(element, EVENT_MOUSEDOWN, () => {
        execute(this._config.clickCallback);
      });
      this._isAppended = true;
    }
    _emulateAnimation(callback) {
      executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
    }
  };
  var NAME$8 = "focustrap";
  var DATA_KEY$5 = "bs.focustrap";
  var EVENT_KEY$5 = `.${DATA_KEY$5}`;
  var EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
  var EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
  var TAB_KEY = "Tab";
  var TAB_NAV_FORWARD = "forward";
  var TAB_NAV_BACKWARD = "backward";
  var Default$7 = {
    autofocus: true,
    trapElement: null
    // The element to trap focus inside of
  };
  var DefaultType$7 = {
    autofocus: "boolean",
    trapElement: "element"
  };
  var FocusTrap = class extends Config {
    constructor(config) {
      super();
      this._config = this._getConfig(config);
      this._isActive = false;
      this._lastTabNavDirection = null;
    }
    // Getters
    static get Default() {
      return Default$7;
    }
    static get DefaultType() {
      return DefaultType$7;
    }
    static get NAME() {
      return NAME$8;
    }
    // Public
    activate() {
      if (this._isActive) {
        return;
      }
      if (this._config.autofocus) {
        this._config.trapElement.focus();
      }
      EventHandler.off(document, EVENT_KEY$5);
      EventHandler.on(document, EVENT_FOCUSIN$2, (event) => this._handleFocusin(event));
      EventHandler.on(document, EVENT_KEYDOWN_TAB, (event) => this._handleKeydown(event));
      this._isActive = true;
    }
    deactivate() {
      if (!this._isActive) {
        return;
      }
      this._isActive = false;
      EventHandler.off(document, EVENT_KEY$5);
    }
    // Private
    _handleFocusin(event) {
      const {
        trapElement
      } = this._config;
      if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
        return;
      }
      const elements = SelectorEngine.focusableChildren(trapElement);
      if (elements.length === 0) {
        trapElement.focus();
      } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
        elements[elements.length - 1].focus();
      } else {
        elements[0].focus();
      }
    }
    _handleKeydown(event) {
      if (event.key !== TAB_KEY) {
        return;
      }
      this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
    }
  };
  var SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
  var SELECTOR_STICKY_CONTENT = ".sticky-top";
  var PROPERTY_PADDING = "padding-right";
  var PROPERTY_MARGIN = "margin-right";
  var ScrollBarHelper = class {
    constructor() {
      this._element = document.body;
    }
    // Public
    getWidth() {
      const documentWidth = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - documentWidth);
    }
    hide() {
      const width = this.getWidth();
      this._disableOverFlow();
      this._setElementAttributes(this._element, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
      this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
      this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, (calculatedValue) => calculatedValue - width);
    }
    reset() {
      this._resetElementAttributes(this._element, "overflow");
      this._resetElementAttributes(this._element, PROPERTY_PADDING);
      this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
      this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
    }
    isOverflowing() {
      return this.getWidth() > 0;
    }
    // Private
    _disableOverFlow() {
      this._saveInitialAttribute(this._element, "overflow");
      this._element.style.overflow = "hidden";
    }
    _setElementAttributes(selector, styleProperty, callback) {
      const scrollbarWidth = this.getWidth();
      const manipulationCallBack = (element) => {
        if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
          return;
        }
        this._saveInitialAttribute(element, styleProperty);
        const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
        element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
      };
      this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _saveInitialAttribute(element, styleProperty) {
      const actualValue = element.style.getPropertyValue(styleProperty);
      if (actualValue) {
        Manipulator.setDataAttribute(element, styleProperty, actualValue);
      }
    }
    _resetElementAttributes(selector, styleProperty) {
      const manipulationCallBack = (element) => {
        const value = Manipulator.getDataAttribute(element, styleProperty);
        if (value === null) {
          element.style.removeProperty(styleProperty);
          return;
        }
        Manipulator.removeDataAttribute(element, styleProperty);
        element.style.setProperty(styleProperty, value);
      };
      this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _applyManipulationCallback(selector, callBack) {
      if (isElement2(selector)) {
        callBack(selector);
        return;
      }
      for (const sel of SelectorEngine.find(selector, this._element)) {
        callBack(sel);
      }
    }
  };
  var NAME$7 = "modal";
  var DATA_KEY$4 = "bs.modal";
  var EVENT_KEY$4 = `.${DATA_KEY$4}`;
  var DATA_API_KEY$2 = ".data-api";
  var ESCAPE_KEY$1 = "Escape";
  var EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
  var EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
  var EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
  var EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
  var EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
  var EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
  var EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;
  var EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
  var EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
  var EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
  var CLASS_NAME_OPEN = "modal-open";
  var CLASS_NAME_FADE$3 = "fade";
  var CLASS_NAME_SHOW$4 = "show";
  var CLASS_NAME_STATIC = "modal-static";
  var OPEN_SELECTOR$1 = ".modal.show";
  var SELECTOR_DIALOG = ".modal-dialog";
  var SELECTOR_MODAL_BODY = ".modal-body";
  var SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
  var Default$6 = {
    backdrop: true,
    focus: true,
    keyboard: true
  };
  var DefaultType$6 = {
    backdrop: "(boolean|string)",
    focus: "boolean",
    keyboard: "boolean"
  };
  var Modal = class _Modal extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
      this._backdrop = this._initializeBackDrop();
      this._focustrap = this._initializeFocusTrap();
      this._isShown = false;
      this._isTransitioning = false;
      this._scrollBar = new ScrollBarHelper();
      this._addEventListeners();
    }
    // Getters
    static get Default() {
      return Default$6;
    }
    static get DefaultType() {
      return DefaultType$6;
    }
    static get NAME() {
      return NAME$7;
    }
    // Public
    toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
      if (this._isShown || this._isTransitioning) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
        relatedTarget
      });
      if (showEvent.defaultPrevented) {
        return;
      }
      this._isShown = true;
      this._isTransitioning = true;
      this._scrollBar.hide();
      document.body.classList.add(CLASS_NAME_OPEN);
      this._adjustDialog();
      this._backdrop.show(() => this._showElement(relatedTarget));
    }
    hide() {
      if (!this._isShown || this._isTransitioning) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);
      if (hideEvent.defaultPrevented) {
        return;
      }
      this._isShown = false;
      this._isTransitioning = true;
      this._focustrap.deactivate();
      this._element.classList.remove(CLASS_NAME_SHOW$4);
      this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());
    }
    dispose() {
      EventHandler.off(window, EVENT_KEY$4);
      EventHandler.off(this._dialog, EVENT_KEY$4);
      this._backdrop.dispose();
      this._focustrap.deactivate();
      super.dispose();
    }
    handleUpdate() {
      this._adjustDialog();
    }
    // Private
    _initializeBackDrop() {
      return new Backdrop({
        isVisible: Boolean(this._config.backdrop),
        // 'static' option will be translated to true, and booleans will keep their value,
        isAnimated: this._isAnimated()
      });
    }
    _initializeFocusTrap() {
      return new FocusTrap({
        trapElement: this._element
      });
    }
    _showElement(relatedTarget) {
      if (!document.body.contains(this._element)) {
        document.body.append(this._element);
      }
      this._element.style.display = "block";
      this._element.removeAttribute("aria-hidden");
      this._element.setAttribute("aria-modal", true);
      this._element.setAttribute("role", "dialog");
      this._element.scrollTop = 0;
      const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
      if (modalBody) {
        modalBody.scrollTop = 0;
      }
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_SHOW$4);
      const transitionComplete = () => {
        if (this._config.focus) {
          this._focustrap.activate();
        }
        this._isTransitioning = false;
        EventHandler.trigger(this._element, EVENT_SHOWN$4, {
          relatedTarget
        });
      };
      this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
    }
    _addEventListeners() {
      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event) => {
        if (event.key !== ESCAPE_KEY$1) {
          return;
        }
        if (this._config.keyboard) {
          this.hide();
          return;
        }
        this._triggerBackdropTransition();
      });
      EventHandler.on(window, EVENT_RESIZE$1, () => {
        if (this._isShown && !this._isTransitioning) {
          this._adjustDialog();
        }
      });
      EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, (event) => {
        EventHandler.one(this._element, EVENT_CLICK_DISMISS, (event2) => {
          if (this._element !== event.target || this._element !== event2.target) {
            return;
          }
          if (this._config.backdrop === "static") {
            this._triggerBackdropTransition();
            return;
          }
          if (this._config.backdrop) {
            this.hide();
          }
        });
      });
    }
    _hideModal() {
      this._element.style.display = "none";
      this._element.setAttribute("aria-hidden", true);
      this._element.removeAttribute("aria-modal");
      this._element.removeAttribute("role");
      this._isTransitioning = false;
      this._backdrop.hide(() => {
        document.body.classList.remove(CLASS_NAME_OPEN);
        this._resetAdjustments();
        this._scrollBar.reset();
        EventHandler.trigger(this._element, EVENT_HIDDEN$4);
      });
    }
    _isAnimated() {
      return this._element.classList.contains(CLASS_NAME_FADE$3);
    }
    _triggerBackdropTransition() {
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);
      if (hideEvent.defaultPrevented) {
        return;
      }
      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
      const initialOverflowY = this._element.style.overflowY;
      if (initialOverflowY === "hidden" || this._element.classList.contains(CLASS_NAME_STATIC)) {
        return;
      }
      if (!isModalOverflowing) {
        this._element.style.overflowY = "hidden";
      }
      this._element.classList.add(CLASS_NAME_STATIC);
      this._queueCallback(() => {
        this._element.classList.remove(CLASS_NAME_STATIC);
        this._queueCallback(() => {
          this._element.style.overflowY = initialOverflowY;
        }, this._dialog);
      }, this._dialog);
      this._element.focus();
    }
    /**
     * The following methods are used to handle overflowing modals
     */
    _adjustDialog() {
      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
      const scrollbarWidth = this._scrollBar.getWidth();
      const isBodyOverflowing = scrollbarWidth > 0;
      if (isBodyOverflowing && !isModalOverflowing) {
        const property = isRTL() ? "paddingLeft" : "paddingRight";
        this._element.style[property] = `${scrollbarWidth}px`;
      }
      if (!isBodyOverflowing && isModalOverflowing) {
        const property = isRTL() ? "paddingRight" : "paddingLeft";
        this._element.style[property] = `${scrollbarWidth}px`;
      }
    }
    _resetAdjustments() {
      this._element.style.paddingLeft = "";
      this._element.style.paddingRight = "";
    }
    // Static
    static jQueryInterface(config, relatedTarget) {
      return this.each(function() {
        const data = _Modal.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](relatedTarget);
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
    const target = SelectorEngine.getElementFromSelector(this);
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    EventHandler.one(target, EVENT_SHOW$4, (showEvent) => {
      if (showEvent.defaultPrevented) {
        return;
      }
      EventHandler.one(target, EVENT_HIDDEN$4, () => {
        if (isVisible(this)) {
          this.focus();
        }
      });
    });
    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
    if (alreadyOpen) {
      Modal.getInstance(alreadyOpen).hide();
    }
    const data = Modal.getOrCreateInstance(target);
    data.toggle(this);
  });
  enableDismissTrigger(Modal);
  defineJQueryPlugin(Modal);
  var NAME$6 = "offcanvas";
  var DATA_KEY$3 = "bs.offcanvas";
  var EVENT_KEY$3 = `.${DATA_KEY$3}`;
  var DATA_API_KEY$1 = ".data-api";
  var EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
  var ESCAPE_KEY = "Escape";
  var CLASS_NAME_SHOW$3 = "show";
  var CLASS_NAME_SHOWING$1 = "showing";
  var CLASS_NAME_HIDING = "hiding";
  var CLASS_NAME_BACKDROP = "offcanvas-backdrop";
  var OPEN_SELECTOR = ".offcanvas.show";
  var EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
  var EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
  var EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
  var EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
  var EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
  var EVENT_RESIZE = `resize${EVENT_KEY$3}`;
  var EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
  var EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
  var SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
  var Default$5 = {
    backdrop: true,
    keyboard: true,
    scroll: false
  };
  var DefaultType$5 = {
    backdrop: "(boolean|string)",
    keyboard: "boolean",
    scroll: "boolean"
  };
  var Offcanvas = class _Offcanvas extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._isShown = false;
      this._backdrop = this._initializeBackDrop();
      this._focustrap = this._initializeFocusTrap();
      this._addEventListeners();
    }
    // Getters
    static get Default() {
      return Default$5;
    }
    static get DefaultType() {
      return DefaultType$5;
    }
    static get NAME() {
      return NAME$6;
    }
    // Public
    toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
      if (this._isShown) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
        relatedTarget
      });
      if (showEvent.defaultPrevented) {
        return;
      }
      this._isShown = true;
      this._backdrop.show();
      if (!this._config.scroll) {
        new ScrollBarHelper().hide();
      }
      this._element.setAttribute("aria-modal", true);
      this._element.setAttribute("role", "dialog");
      this._element.classList.add(CLASS_NAME_SHOWING$1);
      const completeCallBack = () => {
        if (!this._config.scroll || this._config.backdrop) {
          this._focustrap.activate();
        }
        this._element.classList.add(CLASS_NAME_SHOW$3);
        this._element.classList.remove(CLASS_NAME_SHOWING$1);
        EventHandler.trigger(this._element, EVENT_SHOWN$3, {
          relatedTarget
        });
      };
      this._queueCallback(completeCallBack, this._element, true);
    }
    hide() {
      if (!this._isShown) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
      if (hideEvent.defaultPrevented) {
        return;
      }
      this._focustrap.deactivate();
      this._element.blur();
      this._isShown = false;
      this._element.classList.add(CLASS_NAME_HIDING);
      this._backdrop.hide();
      const completeCallback = () => {
        this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
        this._element.removeAttribute("aria-modal");
        this._element.removeAttribute("role");
        if (!this._config.scroll) {
          new ScrollBarHelper().reset();
        }
        EventHandler.trigger(this._element, EVENT_HIDDEN$3);
      };
      this._queueCallback(completeCallback, this._element, true);
    }
    dispose() {
      this._backdrop.dispose();
      this._focustrap.deactivate();
      super.dispose();
    }
    // Private
    _initializeBackDrop() {
      const clickCallback = () => {
        if (this._config.backdrop === "static") {
          EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
          return;
        }
        this.hide();
      };
      const isVisible2 = Boolean(this._config.backdrop);
      return new Backdrop({
        className: CLASS_NAME_BACKDROP,
        isVisible: isVisible2,
        isAnimated: true,
        rootElement: this._element.parentNode,
        clickCallback: isVisible2 ? clickCallback : null
      });
    }
    _initializeFocusTrap() {
      return new FocusTrap({
        trapElement: this._element
      });
    }
    _addEventListeners() {
      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event) => {
        if (event.key !== ESCAPE_KEY) {
          return;
        }
        if (this._config.keyboard) {
          this.hide();
          return;
        }
        EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
      });
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = _Offcanvas.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](this);
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
    const target = SelectorEngine.getElementFromSelector(this);
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    EventHandler.one(target, EVENT_HIDDEN$3, () => {
      if (isVisible(this)) {
        this.focus();
      }
    });
    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
    if (alreadyOpen && alreadyOpen !== target) {
      Offcanvas.getInstance(alreadyOpen).hide();
    }
    const data = Offcanvas.getOrCreateInstance(target);
    data.toggle(this);
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
    for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {
      Offcanvas.getOrCreateInstance(selector).show();
    }
  });
  EventHandler.on(window, EVENT_RESIZE, () => {
    for (const element of SelectorEngine.find("[aria-modal][class*=show][class*=offcanvas-]")) {
      if (getComputedStyle(element).position !== "fixed") {
        Offcanvas.getOrCreateInstance(element).hide();
      }
    }
  });
  enableDismissTrigger(Offcanvas);
  defineJQueryPlugin(Offcanvas);
  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
  var DefaultAllowlist = {
    // Global attributes allowed on any supplied element below.
    "*": ["class", "dir", "id", "lang", "role", ARIA_ATTRIBUTE_PATTERN],
    a: ["target", "href", "title", "rel"],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    dd: [],
    div: [],
    dl: [],
    dt: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ["src", "srcset", "alt", "title", "width", "height"],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
  };
  var uriAttributes = /* @__PURE__ */ new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]);
  var SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;
  var allowedAttribute = (attribute, allowedAttributeList) => {
    const attributeName = attribute.nodeName.toLowerCase();
    if (allowedAttributeList.includes(attributeName)) {
      if (uriAttributes.has(attributeName)) {
        return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));
      }
      return true;
    }
    return allowedAttributeList.filter((attributeRegex) => attributeRegex instanceof RegExp).some((regex) => regex.test(attributeName));
  };
  function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
    if (!unsafeHtml.length) {
      return unsafeHtml;
    }
    if (sanitizeFunction && typeof sanitizeFunction === "function") {
      return sanitizeFunction(unsafeHtml);
    }
    const domParser = new window.DOMParser();
    const createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
    const elements = [].concat(...createdDocument.body.querySelectorAll("*"));
    for (const element of elements) {
      const elementName = element.nodeName.toLowerCase();
      if (!Object.keys(allowList).includes(elementName)) {
        element.remove();
        continue;
      }
      const attributeList = [].concat(...element.attributes);
      const allowedAttributes = [].concat(allowList["*"] || [], allowList[elementName] || []);
      for (const attribute of attributeList) {
        if (!allowedAttribute(attribute, allowedAttributes)) {
          element.removeAttribute(attribute.nodeName);
        }
      }
    }
    return createdDocument.body.innerHTML;
  }
  var NAME$5 = "TemplateFactory";
  var Default$4 = {
    allowList: DefaultAllowlist,
    content: {},
    // { selector : text ,  selector2 : text2 , }
    extraClass: "",
    html: false,
    sanitize: true,
    sanitizeFn: null,
    template: "<div></div>"
  };
  var DefaultType$4 = {
    allowList: "object",
    content: "object",
    extraClass: "(string|function)",
    html: "boolean",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    template: "string"
  };
  var DefaultContentType = {
    entry: "(string|element|function|null)",
    selector: "(string|element)"
  };
  var TemplateFactory = class extends Config {
    constructor(config) {
      super();
      this._config = this._getConfig(config);
    }
    // Getters
    static get Default() {
      return Default$4;
    }
    static get DefaultType() {
      return DefaultType$4;
    }
    static get NAME() {
      return NAME$5;
    }
    // Public
    getContent() {
      return Object.values(this._config.content).map((config) => this._resolvePossibleFunction(config)).filter(Boolean);
    }
    hasContent() {
      return this.getContent().length > 0;
    }
    changeContent(content) {
      this._checkContent(content);
      this._config.content = {
        ...this._config.content,
        ...content
      };
      return this;
    }
    toHtml() {
      const templateWrapper = document.createElement("div");
      templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
      for (const [selector, text] of Object.entries(this._config.content)) {
        this._setContent(templateWrapper, text, selector);
      }
      const template = templateWrapper.children[0];
      const extraClass = this._resolvePossibleFunction(this._config.extraClass);
      if (extraClass) {
        template.classList.add(...extraClass.split(" "));
      }
      return template;
    }
    // Private
    _typeCheckConfig(config) {
      super._typeCheckConfig(config);
      this._checkContent(config.content);
    }
    _checkContent(arg) {
      for (const [selector, content] of Object.entries(arg)) {
        super._typeCheckConfig({
          selector,
          entry: content
        }, DefaultContentType);
      }
    }
    _setContent(template, content, selector) {
      const templateElement = SelectorEngine.findOne(selector, template);
      if (!templateElement) {
        return;
      }
      content = this._resolvePossibleFunction(content);
      if (!content) {
        templateElement.remove();
        return;
      }
      if (isElement2(content)) {
        this._putElementInTemplate(getElement(content), templateElement);
        return;
      }
      if (this._config.html) {
        templateElement.innerHTML = this._maybeSanitize(content);
        return;
      }
      templateElement.textContent = content;
    }
    _maybeSanitize(arg) {
      return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
    }
    _resolvePossibleFunction(arg) {
      return execute(arg, [this]);
    }
    _putElementInTemplate(element, templateElement) {
      if (this._config.html) {
        templateElement.innerHTML = "";
        templateElement.append(element);
        return;
      }
      templateElement.textContent = element.textContent;
    }
  };
  var NAME$4 = "tooltip";
  var DISALLOWED_ATTRIBUTES = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]);
  var CLASS_NAME_FADE$2 = "fade";
  var CLASS_NAME_MODAL = "modal";
  var CLASS_NAME_SHOW$2 = "show";
  var SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
  var SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
  var EVENT_MODAL_HIDE = "hide.bs.modal";
  var TRIGGER_HOVER = "hover";
  var TRIGGER_FOCUS = "focus";
  var TRIGGER_CLICK = "click";
  var TRIGGER_MANUAL = "manual";
  var EVENT_HIDE$2 = "hide";
  var EVENT_HIDDEN$2 = "hidden";
  var EVENT_SHOW$2 = "show";
  var EVENT_SHOWN$2 = "shown";
  var EVENT_INSERTED = "inserted";
  var EVENT_CLICK$1 = "click";
  var EVENT_FOCUSIN$1 = "focusin";
  var EVENT_FOCUSOUT$1 = "focusout";
  var EVENT_MOUSEENTER = "mouseenter";
  var EVENT_MOUSELEAVE = "mouseleave";
  var AttachmentMap = {
    AUTO: "auto",
    TOP: "top",
    RIGHT: isRTL() ? "left" : "right",
    BOTTOM: "bottom",
    LEFT: isRTL() ? "right" : "left"
  };
  var Default$3 = {
    allowList: DefaultAllowlist,
    animation: true,
    boundary: "clippingParents",
    container: false,
    customClass: "",
    delay: 0,
    fallbackPlacements: ["top", "right", "bottom", "left"],
    html: false,
    offset: [0, 6],
    placement: "top",
    popperConfig: null,
    sanitize: true,
    sanitizeFn: null,
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    title: "",
    trigger: "hover focus"
  };
  var DefaultType$3 = {
    allowList: "object",
    animation: "boolean",
    boundary: "(string|element)",
    container: "(string|element|boolean)",
    customClass: "(string|function)",
    delay: "(number|object)",
    fallbackPlacements: "array",
    html: "boolean",
    offset: "(array|string|function)",
    placement: "(string|function)",
    popperConfig: "(null|object|function)",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    selector: "(string|boolean)",
    template: "string",
    title: "(string|element|function)",
    trigger: "string"
  };
  var Tooltip = class _Tooltip extends BaseComponent {
    constructor(element, config) {
      if (typeof lib_exports === "undefined") {
        throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
      }
      super(element, config);
      this._isEnabled = true;
      this._timeout = 0;
      this._isHovered = null;
      this._activeTrigger = {};
      this._popper = null;
      this._templateFactory = null;
      this._newContent = null;
      this.tip = null;
      this._setListeners();
      if (!this._config.selector) {
        this._fixTitle();
      }
    }
    // Getters
    static get Default() {
      return Default$3;
    }
    static get DefaultType() {
      return DefaultType$3;
    }
    static get NAME() {
      return NAME$4;
    }
    // Public
    enable() {
      this._isEnabled = true;
    }
    disable() {
      this._isEnabled = false;
    }
    toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
    toggle() {
      if (!this._isEnabled) {
        return;
      }
      this._activeTrigger.click = !this._activeTrigger.click;
      if (this._isShown()) {
        this._leave();
        return;
      }
      this._enter();
    }
    dispose() {
      clearTimeout(this._timeout);
      EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
      if (this._element.getAttribute("data-bs-original-title")) {
        this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title"));
      }
      this._disposePopper();
      super.dispose();
    }
    show() {
      if (this._element.style.display === "none") {
        throw new Error("Please use show on visible elements");
      }
      if (!(this._isWithContent() && this._isEnabled)) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
      const shadowRoot = findShadowRoot(this._element);
      const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
      if (showEvent.defaultPrevented || !isInTheDom) {
        return;
      }
      this._disposePopper();
      const tip = this._getTipElement();
      this._element.setAttribute("aria-describedby", tip.getAttribute("id"));
      const {
        container
      } = this._config;
      if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
        container.append(tip);
        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
      }
      this._popper = this._createPopper(tip);
      tip.classList.add(CLASS_NAME_SHOW$2);
      if ("ontouchstart" in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.on(element, "mouseover", noop);
        }
      }
      const complete = () => {
        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));
        if (this._isHovered === false) {
          this._leave();
        }
        this._isHovered = false;
      };
      this._queueCallback(complete, this.tip, this._isAnimated());
    }
    hide() {
      if (!this._isShown()) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));
      if (hideEvent.defaultPrevented) {
        return;
      }
      const tip = this._getTipElement();
      tip.classList.remove(CLASS_NAME_SHOW$2);
      if ("ontouchstart" in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.off(element, "mouseover", noop);
        }
      }
      this._activeTrigger[TRIGGER_CLICK] = false;
      this._activeTrigger[TRIGGER_FOCUS] = false;
      this._activeTrigger[TRIGGER_HOVER] = false;
      this._isHovered = null;
      const complete = () => {
        if (this._isWithActiveTrigger()) {
          return;
        }
        if (!this._isHovered) {
          this._disposePopper();
        }
        this._element.removeAttribute("aria-describedby");
        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));
      };
      this._queueCallback(complete, this.tip, this._isAnimated());
    }
    update() {
      if (this._popper) {
        this._popper.update();
      }
    }
    // Protected
    _isWithContent() {
      return Boolean(this._getTitle());
    }
    _getTipElement() {
      if (!this.tip) {
        this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
      }
      return this.tip;
    }
    _createTipElement(content) {
      const tip = this._getTemplateFactory(content).toHtml();
      if (!tip) {
        return null;
      }
      tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
      tip.classList.add(`bs-${this.constructor.NAME}-auto`);
      const tipId = getUID(this.constructor.NAME).toString();
      tip.setAttribute("id", tipId);
      if (this._isAnimated()) {
        tip.classList.add(CLASS_NAME_FADE$2);
      }
      return tip;
    }
    setContent(content) {
      this._newContent = content;
      if (this._isShown()) {
        this._disposePopper();
        this.show();
      }
    }
    _getTemplateFactory(content) {
      if (this._templateFactory) {
        this._templateFactory.changeContent(content);
      } else {
        this._templateFactory = new TemplateFactory({
          ...this._config,
          // the `content` var has to be after `this._config`
          // to override config.content in case of popover
          content,
          extraClass: this._resolvePossibleFunction(this._config.customClass)
        });
      }
      return this._templateFactory;
    }
    _getContentForTemplate() {
      return {
        [SELECTOR_TOOLTIP_INNER]: this._getTitle()
      };
    }
    _getTitle() {
      return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
    }
    // Private
    _initializeOnDelegatedTarget(event) {
      return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
    }
    _isAnimated() {
      return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
    }
    _isShown() {
      return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
    }
    _createPopper(tip) {
      const placement = execute(this._config.placement, [this, tip, this._element]);
      const attachment = AttachmentMap[placement.toUpperCase()];
      return createPopper3(this._element, tip, this._getPopperConfig(attachment));
    }
    _getOffset() {
      const {
        offset: offset2
      } = this._config;
      if (typeof offset2 === "string") {
        return offset2.split(",").map((value) => Number.parseInt(value, 10));
      }
      if (typeof offset2 === "function") {
        return (popperData) => offset2(popperData, this._element);
      }
      return offset2;
    }
    _resolvePossibleFunction(arg) {
      return execute(arg, [this._element]);
    }
    _getPopperConfig(attachment) {
      const defaultBsPopperConfig = {
        placement: attachment,
        modifiers: [{
          name: "flip",
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }, {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "arrow",
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        }, {
          name: "preSetPlacement",
          enabled: true,
          phase: "beforeMain",
          fn: (data) => {
            this._getTipElement().setAttribute("data-popper-placement", data.state.placement);
          }
        }]
      };
      return {
        ...defaultBsPopperConfig,
        ...execute(this._config.popperConfig, [defaultBsPopperConfig])
      };
    }
    _setListeners() {
      const triggers = this._config.trigger.split(" ");
      for (const trigger of triggers) {
        if (trigger === "click") {
          EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, (event) => {
            const context = this._initializeOnDelegatedTarget(event);
            context.toggle();
          });
        } else if (trigger !== TRIGGER_MANUAL) {
          const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
          const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
          EventHandler.on(this._element, eventIn, this._config.selector, (event) => {
            const context = this._initializeOnDelegatedTarget(event);
            context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
            context._enter();
          });
          EventHandler.on(this._element, eventOut, this._config.selector, (event) => {
            const context = this._initializeOnDelegatedTarget(event);
            context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
            context._leave();
          });
        }
      }
      this._hideModalHandler = () => {
        if (this._element) {
          this.hide();
        }
      };
      EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
    }
    _fixTitle() {
      const title = this._element.getAttribute("title");
      if (!title) {
        return;
      }
      if (!this._element.getAttribute("aria-label") && !this._element.textContent.trim()) {
        this._element.setAttribute("aria-label", title);
      }
      this._element.setAttribute("data-bs-original-title", title);
      this._element.removeAttribute("title");
    }
    _enter() {
      if (this._isShown() || this._isHovered) {
        this._isHovered = true;
        return;
      }
      this._isHovered = true;
      this._setTimeout(() => {
        if (this._isHovered) {
          this.show();
        }
      }, this._config.delay.show);
    }
    _leave() {
      if (this._isWithActiveTrigger()) {
        return;
      }
      this._isHovered = false;
      this._setTimeout(() => {
        if (!this._isHovered) {
          this.hide();
        }
      }, this._config.delay.hide);
    }
    _setTimeout(handler, timeout) {
      clearTimeout(this._timeout);
      this._timeout = setTimeout(handler, timeout);
    }
    _isWithActiveTrigger() {
      return Object.values(this._activeTrigger).includes(true);
    }
    _getConfig(config) {
      const dataAttributes = Manipulator.getDataAttributes(this._element);
      for (const dataAttribute of Object.keys(dataAttributes)) {
        if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {
          delete dataAttributes[dataAttribute];
        }
      }
      config = {
        ...dataAttributes,
        ...typeof config === "object" && config ? config : {}
      };
      config = this._mergeConfigObj(config);
      config = this._configAfterMerge(config);
      this._typeCheckConfig(config);
      return config;
    }
    _configAfterMerge(config) {
      config.container = config.container === false ? document.body : getElement(config.container);
      if (typeof config.delay === "number") {
        config.delay = {
          show: config.delay,
          hide: config.delay
        };
      }
      if (typeof config.title === "number") {
        config.title = config.title.toString();
      }
      if (typeof config.content === "number") {
        config.content = config.content.toString();
      }
      return config;
    }
    _getDelegateConfig() {
      const config = {};
      for (const [key, value] of Object.entries(this._config)) {
        if (this.constructor.Default[key] !== value) {
          config[key] = value;
        }
      }
      config.selector = false;
      config.trigger = "manual";
      return config;
    }
    _disposePopper() {
      if (this._popper) {
        this._popper.destroy();
        this._popper = null;
      }
      if (this.tip) {
        this.tip.remove();
        this.tip = null;
      }
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = _Tooltip.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  };
  defineJQueryPlugin(Tooltip);
  var NAME$3 = "popover";
  var SELECTOR_TITLE = ".popover-header";
  var SELECTOR_CONTENT = ".popover-body";
  var Default$2 = {
    ...Tooltip.Default,
    content: "",
    offset: [0, 8],
    placement: "right",
    template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
    trigger: "click"
  };
  var DefaultType$2 = {
    ...Tooltip.DefaultType,
    content: "(null|string|element|function)"
  };
  var Popover = class _Popover extends Tooltip {
    // Getters
    static get Default() {
      return Default$2;
    }
    static get DefaultType() {
      return DefaultType$2;
    }
    static get NAME() {
      return NAME$3;
    }
    // Overrides
    _isWithContent() {
      return this._getTitle() || this._getContent();
    }
    // Private
    _getContentForTemplate() {
      return {
        [SELECTOR_TITLE]: this._getTitle(),
        [SELECTOR_CONTENT]: this._getContent()
      };
    }
    _getContent() {
      return this._resolvePossibleFunction(this._config.content);
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = _Popover.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  };
  defineJQueryPlugin(Popover);
  var NAME$2 = "scrollspy";
  var DATA_KEY$2 = "bs.scrollspy";
  var EVENT_KEY$2 = `.${DATA_KEY$2}`;
  var DATA_API_KEY = ".data-api";
  var EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
  var EVENT_CLICK = `click${EVENT_KEY$2}`;
  var EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
  var CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
  var CLASS_NAME_ACTIVE$1 = "active";
  var SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
  var SELECTOR_TARGET_LINKS = "[href]";
  var SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
  var SELECTOR_NAV_LINKS = ".nav-link";
  var SELECTOR_NAV_ITEMS = ".nav-item";
  var SELECTOR_LIST_ITEMS = ".list-group-item";
  var SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;
  var SELECTOR_DROPDOWN = ".dropdown";
  var SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
  var Default$1 = {
    offset: null,
    // TODO: v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: "0px 0px -25%",
    smoothScroll: false,
    target: null,
    threshold: [0.1, 0.5, 1]
  };
  var DefaultType$1 = {
    offset: "(number|null)",
    // TODO v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: "string",
    smoothScroll: "boolean",
    target: "element",
    threshold: "array"
  };
  var ScrollSpy = class _ScrollSpy extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._targetLinks = /* @__PURE__ */ new Map();
      this._observableSections = /* @__PURE__ */ new Map();
      this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element;
      this._activeTarget = null;
      this._observer = null;
      this._previousScrollData = {
        visibleEntryTop: 0,
        parentScrollTop: 0
      };
      this.refresh();
    }
    // Getters
    static get Default() {
      return Default$1;
    }
    static get DefaultType() {
      return DefaultType$1;
    }
    static get NAME() {
      return NAME$2;
    }
    // Public
    refresh() {
      this._initializeTargetsAndObservables();
      this._maybeEnableSmoothScroll();
      if (this._observer) {
        this._observer.disconnect();
      } else {
        this._observer = this._getNewObserver();
      }
      for (const section of this._observableSections.values()) {
        this._observer.observe(section);
      }
    }
    dispose() {
      this._observer.disconnect();
      super.dispose();
    }
    // Private
    _configAfterMerge(config) {
      config.target = getElement(config.target) || document.body;
      config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;
      if (typeof config.threshold === "string") {
        config.threshold = config.threshold.split(",").map((value) => Number.parseFloat(value));
      }
      return config;
    }
    _maybeEnableSmoothScroll() {
      if (!this._config.smoothScroll) {
        return;
      }
      EventHandler.off(this._config.target, EVENT_CLICK);
      EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, (event) => {
        const observableSection = this._observableSections.get(event.target.hash);
        if (observableSection) {
          event.preventDefault();
          const root = this._rootElement || window;
          const height = observableSection.offsetTop - this._element.offsetTop;
          if (root.scrollTo) {
            root.scrollTo({
              top: height,
              behavior: "smooth"
            });
            return;
          }
          root.scrollTop = height;
        }
      });
    }
    _getNewObserver() {
      const options = {
        root: this._rootElement,
        threshold: this._config.threshold,
        rootMargin: this._config.rootMargin
      };
      return new IntersectionObserver((entries) => this._observerCallback(entries), options);
    }
    // The logic of selection
    _observerCallback(entries) {
      const targetElement = (entry) => this._targetLinks.get(`#${entry.target.id}`);
      const activate = (entry) => {
        this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
        this._process(targetElement(entry));
      };
      const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
      const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
      this._previousScrollData.parentScrollTop = parentScrollTop;
      for (const entry of entries) {
        if (!entry.isIntersecting) {
          this._activeTarget = null;
          this._clearActiveClass(targetElement(entry));
          continue;
        }
        const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
        if (userScrollsDown && entryIsLowerThanPrevious) {
          activate(entry);
          if (!parentScrollTop) {
            return;
          }
          continue;
        }
        if (!userScrollsDown && !entryIsLowerThanPrevious) {
          activate(entry);
        }
      }
    }
    _initializeTargetsAndObservables() {
      this._targetLinks = /* @__PURE__ */ new Map();
      this._observableSections = /* @__PURE__ */ new Map();
      const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);
      for (const anchor of targetLinks) {
        if (!anchor.hash || isDisabled(anchor)) {
          continue;
        }
        const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);
        if (isVisible(observableSection)) {
          this._targetLinks.set(decodeURI(anchor.hash), anchor);
          this._observableSections.set(anchor.hash, observableSection);
        }
      }
    }
    _process(target) {
      if (this._activeTarget === target) {
        return;
      }
      this._clearActiveClass(this._config.target);
      this._activeTarget = target;
      target.classList.add(CLASS_NAME_ACTIVE$1);
      this._activateParents(target);
      EventHandler.trigger(this._element, EVENT_ACTIVATE, {
        relatedTarget: target
      });
    }
    _activateParents(target) {
      if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
        SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
        return;
      }
      for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {
        for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {
          item.classList.add(CLASS_NAME_ACTIVE$1);
        }
      }
    }
    _clearActiveClass(parent) {
      parent.classList.remove(CLASS_NAME_ACTIVE$1);
      const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);
      for (const node of activeNodes) {
        node.classList.remove(CLASS_NAME_ACTIVE$1);
      }
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = _ScrollSpy.getOrCreateInstance(this, config);
        if (typeof config !== "string") {
          return;
        }
        if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  };
  EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {
    for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {
      ScrollSpy.getOrCreateInstance(spy);
    }
  });
  defineJQueryPlugin(ScrollSpy);
  var NAME$1 = "tab";
  var DATA_KEY$1 = "bs.tab";
  var EVENT_KEY$1 = `.${DATA_KEY$1}`;
  var EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
  var EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
  var EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
  var EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
  var EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
  var EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
  var EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
  var ARROW_LEFT_KEY = "ArrowLeft";
  var ARROW_RIGHT_KEY = "ArrowRight";
  var ARROW_UP_KEY = "ArrowUp";
  var ARROW_DOWN_KEY = "ArrowDown";
  var HOME_KEY = "Home";
  var END_KEY = "End";
  var CLASS_NAME_ACTIVE = "active";
  var CLASS_NAME_FADE$1 = "fade";
  var CLASS_NAME_SHOW$1 = "show";
  var CLASS_DROPDOWN = "dropdown";
  var SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
  var SELECTOR_DROPDOWN_MENU = ".dropdown-menu";
  var NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;
  var SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
  var SELECTOR_OUTER = ".nav-item, .list-group-item";
  var SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
  var SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
  var SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
  var SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;
  var Tab = class _Tab extends BaseComponent {
    constructor(element) {
      super(element);
      this._parent = this._element.closest(SELECTOR_TAB_PANEL);
      if (!this._parent) {
        return;
      }
      this._setInitialAttributes(this._parent, this._getChildren());
      EventHandler.on(this._element, EVENT_KEYDOWN, (event) => this._keydown(event));
    }
    // Getters
    static get NAME() {
      return NAME$1;
    }
    // Public
    show() {
      const innerElem = this._element;
      if (this._elemIsActive(innerElem)) {
        return;
      }
      const active = this._getActiveElem();
      const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
        relatedTarget: innerElem
      }) : null;
      const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
        relatedTarget: active
      });
      if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
        return;
      }
      this._deactivate(active, innerElem);
      this._activate(innerElem, active);
    }
    // Private
    _activate(element, relatedElem) {
      if (!element) {
        return;
      }
      element.classList.add(CLASS_NAME_ACTIVE);
      this._activate(SelectorEngine.getElementFromSelector(element));
      const complete = () => {
        if (element.getAttribute("role") !== "tab") {
          element.classList.add(CLASS_NAME_SHOW$1);
          return;
        }
        element.removeAttribute("tabindex");
        element.setAttribute("aria-selected", true);
        this._toggleDropDown(element, true);
        EventHandler.trigger(element, EVENT_SHOWN$1, {
          relatedTarget: relatedElem
        });
      };
      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
    }
    _deactivate(element, relatedElem) {
      if (!element) {
        return;
      }
      element.classList.remove(CLASS_NAME_ACTIVE);
      element.blur();
      this._deactivate(SelectorEngine.getElementFromSelector(element));
      const complete = () => {
        if (element.getAttribute("role") !== "tab") {
          element.classList.remove(CLASS_NAME_SHOW$1);
          return;
        }
        element.setAttribute("aria-selected", false);
        element.setAttribute("tabindex", "-1");
        this._toggleDropDown(element, false);
        EventHandler.trigger(element, EVENT_HIDDEN$1, {
          relatedTarget: relatedElem
        });
      };
      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
    }
    _keydown(event) {
      if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY, HOME_KEY, END_KEY].includes(event.key)) {
        return;
      }
      event.stopPropagation();
      event.preventDefault();
      const children = this._getChildren().filter((element) => !isDisabled(element));
      let nextActiveElement;
      if ([HOME_KEY, END_KEY].includes(event.key)) {
        nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];
      } else {
        const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);
        nextActiveElement = getNextActiveElement(children, event.target, isNext, true);
      }
      if (nextActiveElement) {
        nextActiveElement.focus({
          preventScroll: true
        });
        _Tab.getOrCreateInstance(nextActiveElement).show();
      }
    }
    _getChildren() {
      return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
    }
    _getActiveElem() {
      return this._getChildren().find((child) => this._elemIsActive(child)) || null;
    }
    _setInitialAttributes(parent, children) {
      this._setAttributeIfNotExists(parent, "role", "tablist");
      for (const child of children) {
        this._setInitialAttributesOnChild(child);
      }
    }
    _setInitialAttributesOnChild(child) {
      child = this._getInnerElement(child);
      const isActive = this._elemIsActive(child);
      const outerElem = this._getOuterElement(child);
      child.setAttribute("aria-selected", isActive);
      if (outerElem !== child) {
        this._setAttributeIfNotExists(outerElem, "role", "presentation");
      }
      if (!isActive) {
        child.setAttribute("tabindex", "-1");
      }
      this._setAttributeIfNotExists(child, "role", "tab");
      this._setInitialAttributesOnTargetPanel(child);
    }
    _setInitialAttributesOnTargetPanel(child) {
      const target = SelectorEngine.getElementFromSelector(child);
      if (!target) {
        return;
      }
      this._setAttributeIfNotExists(target, "role", "tabpanel");
      if (child.id) {
        this._setAttributeIfNotExists(target, "aria-labelledby", `${child.id}`);
      }
    }
    _toggleDropDown(element, open) {
      const outerElem = this._getOuterElement(element);
      if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
        return;
      }
      const toggle = (selector, className) => {
        const element2 = SelectorEngine.findOne(selector, outerElem);
        if (element2) {
          element2.classList.toggle(className, open);
        }
      };
      toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
      toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
      outerElem.setAttribute("aria-expanded", open);
    }
    _setAttributeIfNotExists(element, attribute, value) {
      if (!element.hasAttribute(attribute)) {
        element.setAttribute(attribute, value);
      }
    }
    _elemIsActive(elem) {
      return elem.classList.contains(CLASS_NAME_ACTIVE);
    }
    // Try to get the inner element (usually the .nav-link)
    _getInnerElement(elem) {
      return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
    }
    // Try to get the outer element (usually the .nav-item)
    _getOuterElement(elem) {
      return elem.closest(SELECTOR_OUTER) || elem;
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = _Tab.getOrCreateInstance(this);
        if (typeof config !== "string") {
          return;
        }
        if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  };
  EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    Tab.getOrCreateInstance(this).show();
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
    for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {
      Tab.getOrCreateInstance(element);
    }
  });
  defineJQueryPlugin(Tab);
  var NAME = "toast";
  var DATA_KEY = "bs.toast";
  var EVENT_KEY = `.${DATA_KEY}`;
  var EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
  var EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
  var EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
  var EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
  var EVENT_HIDE = `hide${EVENT_KEY}`;
  var EVENT_HIDDEN = `hidden${EVENT_KEY}`;
  var EVENT_SHOW = `show${EVENT_KEY}`;
  var EVENT_SHOWN = `shown${EVENT_KEY}`;
  var CLASS_NAME_FADE = "fade";
  var CLASS_NAME_HIDE = "hide";
  var CLASS_NAME_SHOW = "show";
  var CLASS_NAME_SHOWING = "showing";
  var DefaultType = {
    animation: "boolean",
    autohide: "boolean",
    delay: "number"
  };
  var Default = {
    animation: true,
    autohide: true,
    delay: 5e3
  };
  var Toast = class _Toast extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._timeout = null;
      this._hasMouseInteraction = false;
      this._hasKeyboardInteraction = false;
      this._setListeners();
    }
    // Getters
    static get Default() {
      return Default;
    }
    static get DefaultType() {
      return DefaultType;
    }
    static get NAME() {
      return NAME;
    }
    // Public
    show() {
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
      if (showEvent.defaultPrevented) {
        return;
      }
      this._clearTimeout();
      if (this._config.animation) {
        this._element.classList.add(CLASS_NAME_FADE);
      }
      const complete = () => {
        this._element.classList.remove(CLASS_NAME_SHOWING);
        EventHandler.trigger(this._element, EVENT_SHOWN);
        this._maybeScheduleHide();
      };
      this._element.classList.remove(CLASS_NAME_HIDE);
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
      this._queueCallback(complete, this._element, this._config.animation);
    }
    hide() {
      if (!this.isShown()) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
      if (hideEvent.defaultPrevented) {
        return;
      }
      const complete = () => {
        this._element.classList.add(CLASS_NAME_HIDE);
        this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
        EventHandler.trigger(this._element, EVENT_HIDDEN);
      };
      this._element.classList.add(CLASS_NAME_SHOWING);
      this._queueCallback(complete, this._element, this._config.animation);
    }
    dispose() {
      this._clearTimeout();
      if (this.isShown()) {
        this._element.classList.remove(CLASS_NAME_SHOW);
      }
      super.dispose();
    }
    isShown() {
      return this._element.classList.contains(CLASS_NAME_SHOW);
    }
    // Private
    _maybeScheduleHide() {
      if (!this._config.autohide) {
        return;
      }
      if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
        return;
      }
      this._timeout = setTimeout(() => {
        this.hide();
      }, this._config.delay);
    }
    _onInteraction(event, isInteracting) {
      switch (event.type) {
        case "mouseover":
        case "mouseout": {
          this._hasMouseInteraction = isInteracting;
          break;
        }
        case "focusin":
        case "focusout": {
          this._hasKeyboardInteraction = isInteracting;
          break;
        }
      }
      if (isInteracting) {
        this._clearTimeout();
        return;
      }
      const nextElement = event.relatedTarget;
      if (this._element === nextElement || this._element.contains(nextElement)) {
        return;
      }
      this._maybeScheduleHide();
    }
    _setListeners() {
      EventHandler.on(this._element, EVENT_MOUSEOVER, (event) => this._onInteraction(event, true));
      EventHandler.on(this._element, EVENT_MOUSEOUT, (event) => this._onInteraction(event, false));
      EventHandler.on(this._element, EVENT_FOCUSIN, (event) => this._onInteraction(event, true));
      EventHandler.on(this._element, EVENT_FOCUSOUT, (event) => this._onInteraction(event, false));
    }
    _clearTimeout() {
      clearTimeout(this._timeout);
      this._timeout = null;
    }
    // Static
    static jQueryInterface(config) {
      return this.each(function() {
        const data = _Toast.getOrCreateInstance(this, config);
        if (typeof config === "string") {
          if (typeof data[config] === "undefined") {
            throw new TypeError(`No method named "${config}"`);
          }
          data[config](this);
        }
      });
    }
  };
  enableDismissTrigger(Toast);
  defineJQueryPlugin(Toast);

  // app/javascript/controllers/toast_controller.js
  var toast_controller_default = class extends Controller {
    connect() {
    }
    notify() {
      console.log("Click to notify...");
      var toastTrigger = document.getElementById("liveToast");
      var toast = new Toast(toastTrigger);
      toast.show();
    }
  };

  // node_modules/datatables.net/js/jquery.dataTables.mjs
  var import_jquery2 = __toESM(require_jquery(), 1);
  var $4 = import_jquery2.default;
  var DataTable = function(selector, options) {
    if (DataTable.factory(selector, options)) {
      return DataTable;
    }
    if (this instanceof DataTable) {
      return $4(selector).DataTable(options);
    } else {
      options = selector;
    }
    this.$ = function(sSelector, oOpts) {
      return this.api(true).$(sSelector, oOpts);
    };
    this._ = function(sSelector, oOpts) {
      return this.api(true).rows(sSelector, oOpts).data();
    };
    this.api = function(traditional) {
      return traditional ? new _Api(
        _fnSettingsFromNode(this[_ext.iApiIndex])
      ) : new _Api(this);
    };
    this.fnAddData = function(data, redraw) {
      var api = this.api(true);
      var rows = Array.isArray(data) && (Array.isArray(data[0]) || $4.isPlainObject(data[0])) ? api.rows.add(data) : api.row.add(data);
      if (redraw === void 0 || redraw) {
        api.draw();
      }
      return rows.flatten().toArray();
    };
    this.fnAdjustColumnSizing = function(bRedraw) {
      var api = this.api(true).columns.adjust();
      var settings = api.settings()[0];
      var scroll = settings.oScroll;
      if (bRedraw === void 0 || bRedraw) {
        api.draw(false);
      } else if (scroll.sX !== "" || scroll.sY !== "") {
        _fnScrollDraw(settings);
      }
    };
    this.fnClearTable = function(bRedraw) {
      var api = this.api(true).clear();
      if (bRedraw === void 0 || bRedraw) {
        api.draw();
      }
    };
    this.fnClose = function(nTr) {
      this.api(true).row(nTr).child.hide();
    };
    this.fnDeleteRow = function(target, callback, redraw) {
      var api = this.api(true);
      var rows = api.rows(target);
      var settings = rows.settings()[0];
      var data = settings.aoData[rows[0][0]];
      rows.remove();
      if (callback) {
        callback.call(this, settings, data);
      }
      if (redraw === void 0 || redraw) {
        api.draw();
      }
      return data;
    };
    this.fnDestroy = function(remove) {
      this.api(true).destroy(remove);
    };
    this.fnDraw = function(complete) {
      this.api(true).draw(complete);
    };
    this.fnFilter = function(sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {
      var api = this.api(true);
      if (iColumn === null || iColumn === void 0) {
        api.search(sInput, bRegex, bSmart, bCaseInsensitive);
      } else {
        api.column(iColumn).search(sInput, bRegex, bSmart, bCaseInsensitive);
      }
      api.draw();
    };
    this.fnGetData = function(src, col) {
      var api = this.api(true);
      if (src !== void 0) {
        var type = src.nodeName ? src.nodeName.toLowerCase() : "";
        return col !== void 0 || type == "td" || type == "th" ? api.cell(src, col).data() : api.row(src).data() || null;
      }
      return api.data().toArray();
    };
    this.fnGetNodes = function(iRow) {
      var api = this.api(true);
      return iRow !== void 0 ? api.row(iRow).node() : api.rows().nodes().flatten().toArray();
    };
    this.fnGetPosition = function(node) {
      var api = this.api(true);
      var nodeName = node.nodeName.toUpperCase();
      if (nodeName == "TR") {
        return api.row(node).index();
      } else if (nodeName == "TD" || nodeName == "TH") {
        var cell = api.cell(node).index();
        return [
          cell.row,
          cell.columnVisible,
          cell.column
        ];
      }
      return null;
    };
    this.fnIsOpen = function(nTr) {
      return this.api(true).row(nTr).child.isShown();
    };
    this.fnOpen = function(nTr, mHtml, sClass) {
      return this.api(true).row(nTr).child(mHtml, sClass).show().child()[0];
    };
    this.fnPageChange = function(mAction, bRedraw) {
      var api = this.api(true).page(mAction);
      if (bRedraw === void 0 || bRedraw) {
        api.draw(false);
      }
    };
    this.fnSetColumnVis = function(iCol, bShow, bRedraw) {
      var api = this.api(true).column(iCol).visible(bShow);
      if (bRedraw === void 0 || bRedraw) {
        api.columns.adjust().draw();
      }
    };
    this.fnSettings = function() {
      return _fnSettingsFromNode(this[_ext.iApiIndex]);
    };
    this.fnSort = function(aaSort) {
      this.api(true).order(aaSort).draw();
    };
    this.fnSortListener = function(nNode, iColumn, fnCallback) {
      this.api(true).order.listener(nNode, iColumn, fnCallback);
    };
    this.fnUpdate = function(mData, mRow, iColumn, bRedraw, bAction) {
      var api = this.api(true);
      if (iColumn === void 0 || iColumn === null) {
        api.row(mRow).data(mData);
      } else {
        api.cell(mRow, iColumn).data(mData);
      }
      if (bAction === void 0 || bAction) {
        api.columns.adjust();
      }
      if (bRedraw === void 0 || bRedraw) {
        api.draw();
      }
      return 0;
    };
    this.fnVersionCheck = _ext.fnVersionCheck;
    var _that = this;
    var emptyInit = options === void 0;
    var len = this.length;
    if (emptyInit) {
      options = {};
    }
    this.oApi = this.internal = _ext.internal;
    for (var fn2 in DataTable.ext.internal) {
      if (fn2) {
        this[fn2] = _fnExternApiFunc(fn2);
      }
    }
    this.each(function() {
      var o2 = {};
      var oInit = len > 1 ? (
        // optimisation for single table case
        _fnExtend(o2, options, true)
      ) : options;
      var i2 = 0, iLen, j2, jLen, k2, kLen;
      var sId = this.getAttribute("id");
      var bInitHandedOff = false;
      var defaults = DataTable.defaults;
      var $this = $4(this);
      if (this.nodeName.toLowerCase() != "table") {
        _fnLog(null, 0, "Non-table node initialisation (" + this.nodeName + ")", 2);
        return;
      }
      _fnCompatOpts(defaults);
      _fnCompatCols(defaults.column);
      _fnCamelToHungarian(defaults, defaults, true);
      _fnCamelToHungarian(defaults.column, defaults.column, true);
      _fnCamelToHungarian(defaults, $4.extend(oInit, $this.data()), true);
      var allSettings = DataTable.settings;
      for (i2 = 0, iLen = allSettings.length; i2 < iLen; i2++) {
        var s2 = allSettings[i2];
        if (s2.nTable == this || s2.nTHead && s2.nTHead.parentNode == this || s2.nTFoot && s2.nTFoot.parentNode == this) {
          var bRetrieve = oInit.bRetrieve !== void 0 ? oInit.bRetrieve : defaults.bRetrieve;
          var bDestroy = oInit.bDestroy !== void 0 ? oInit.bDestroy : defaults.bDestroy;
          if (emptyInit || bRetrieve) {
            return s2.oInstance;
          } else if (bDestroy) {
            s2.oInstance.fnDestroy();
            break;
          } else {
            _fnLog(s2, 0, "Cannot reinitialise DataTable", 3);
            return;
          }
        }
        if (s2.sTableId == this.id) {
          allSettings.splice(i2, 1);
          break;
        }
      }
      if (sId === null || sId === "") {
        sId = "DataTables_Table_" + DataTable.ext._unique++;
        this.id = sId;
      }
      var oSettings = $4.extend(true, {}, DataTable.models.oSettings, {
        "sDestroyWidth": $this[0].style.width,
        "sInstance": sId,
        "sTableId": sId
      });
      oSettings.nTable = this;
      oSettings.oApi = _that.internal;
      oSettings.oInit = oInit;
      allSettings.push(oSettings);
      oSettings.oInstance = _that.length === 1 ? _that : $this.dataTable();
      _fnCompatOpts(oInit);
      _fnLanguageCompat(oInit.oLanguage);
      if (oInit.aLengthMenu && !oInit.iDisplayLength) {
        oInit.iDisplayLength = Array.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];
      }
      oInit = _fnExtend($4.extend(true, {}, defaults), oInit);
      _fnMap(oSettings.oFeatures, oInit, [
        "bPaginate",
        "bLengthChange",
        "bFilter",
        "bSort",
        "bSortMulti",
        "bInfo",
        "bProcessing",
        "bAutoWidth",
        "bSortClasses",
        "bServerSide",
        "bDeferRender"
      ]);
      _fnMap(oSettings, oInit, [
        "asStripeClasses",
        "ajax",
        "fnServerData",
        "fnFormatNumber",
        "sServerMethod",
        "aaSorting",
        "aaSortingFixed",
        "aLengthMenu",
        "sPaginationType",
        "sAjaxSource",
        "sAjaxDataProp",
        "iStateDuration",
        "sDom",
        "bSortCellsTop",
        "iTabIndex",
        "fnStateLoadCallback",
        "fnStateSaveCallback",
        "renderer",
        "searchDelay",
        "rowId",
        ["iCookieDuration", "iStateDuration"],
        // backwards compat
        ["oSearch", "oPreviousSearch"],
        ["aoSearchCols", "aoPreSearchCols"],
        ["iDisplayLength", "_iDisplayLength"]
      ]);
      _fnMap(oSettings.oScroll, oInit, [
        ["sScrollX", "sX"],
        ["sScrollXInner", "sXInner"],
        ["sScrollY", "sY"],
        ["bScrollCollapse", "bCollapse"]
      ]);
      _fnMap(oSettings.oLanguage, oInit, "fnInfoCallback");
      _fnCallbackReg(oSettings, "aoDrawCallback", oInit.fnDrawCallback, "user");
      _fnCallbackReg(oSettings, "aoServerParams", oInit.fnServerParams, "user");
      _fnCallbackReg(oSettings, "aoStateSaveParams", oInit.fnStateSaveParams, "user");
      _fnCallbackReg(oSettings, "aoStateLoadParams", oInit.fnStateLoadParams, "user");
      _fnCallbackReg(oSettings, "aoStateLoaded", oInit.fnStateLoaded, "user");
      _fnCallbackReg(oSettings, "aoRowCallback", oInit.fnRowCallback, "user");
      _fnCallbackReg(oSettings, "aoRowCreatedCallback", oInit.fnCreatedRow, "user");
      _fnCallbackReg(oSettings, "aoHeaderCallback", oInit.fnHeaderCallback, "user");
      _fnCallbackReg(oSettings, "aoFooterCallback", oInit.fnFooterCallback, "user");
      _fnCallbackReg(oSettings, "aoInitComplete", oInit.fnInitComplete, "user");
      _fnCallbackReg(oSettings, "aoPreDrawCallback", oInit.fnPreDrawCallback, "user");
      oSettings.rowIdFn = _fnGetObjectDataFn(oInit.rowId);
      _fnBrowserDetect(oSettings);
      var oClasses = oSettings.oClasses;
      $4.extend(oClasses, DataTable.ext.classes, oInit.oClasses);
      $this.addClass(oClasses.sTable);
      if (oSettings.iInitDisplayStart === void 0) {
        oSettings.iInitDisplayStart = oInit.iDisplayStart;
        oSettings._iDisplayStart = oInit.iDisplayStart;
      }
      if (oInit.iDeferLoading !== null) {
        oSettings.bDeferLoading = true;
        var tmp = Array.isArray(oInit.iDeferLoading);
        oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;
        oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;
      }
      var oLanguage = oSettings.oLanguage;
      $4.extend(true, oLanguage, oInit.oLanguage);
      if (oLanguage.sUrl) {
        $4.ajax({
          dataType: "json",
          url: oLanguage.sUrl,
          success: function(json) {
            _fnCamelToHungarian(defaults.oLanguage, json);
            _fnLanguageCompat(json);
            $4.extend(true, oLanguage, json, oSettings.oInit.oLanguage);
            _fnCallbackFire(oSettings, null, "i18n", [oSettings]);
            _fnInitialise(oSettings);
          },
          error: function() {
            _fnInitialise(oSettings);
          }
        });
        bInitHandedOff = true;
      } else {
        _fnCallbackFire(oSettings, null, "i18n", [oSettings]);
      }
      if (oInit.asStripeClasses === null) {
        oSettings.asStripeClasses = [
          oClasses.sStripeOdd,
          oClasses.sStripeEven
        ];
      }
      var stripeClasses = oSettings.asStripeClasses;
      var rowOne = $this.children("tbody").find("tr").eq(0);
      if ($4.inArray(true, $4.map(stripeClasses, function(el, i3) {
        return rowOne.hasClass(el);
      })) !== -1) {
        $4("tbody tr", this).removeClass(stripeClasses.join(" "));
        oSettings.asDestroyStripes = stripeClasses.slice();
      }
      var anThs = [];
      var aoColumnsInit;
      var nThead = this.getElementsByTagName("thead");
      if (nThead.length !== 0) {
        _fnDetectHeader(oSettings.aoHeader, nThead[0]);
        anThs = _fnGetUniqueThs(oSettings);
      }
      if (oInit.aoColumns === null) {
        aoColumnsInit = [];
        for (i2 = 0, iLen = anThs.length; i2 < iLen; i2++) {
          aoColumnsInit.push(null);
        }
      } else {
        aoColumnsInit = oInit.aoColumns;
      }
      for (i2 = 0, iLen = aoColumnsInit.length; i2 < iLen; i2++) {
        _fnAddColumn(oSettings, anThs ? anThs[i2] : null);
      }
      _fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, function(iCol, oDef) {
        _fnColumnOptions(oSettings, iCol, oDef);
      });
      if (rowOne.length) {
        var a2 = function(cell, name) {
          return cell.getAttribute("data-" + name) !== null ? name : null;
        };
        $4(rowOne[0]).children("th, td").each(function(i3, cell) {
          var col = oSettings.aoColumns[i3];
          if (!col) {
            _fnLog(oSettings, 0, "Incorrect column count", 18);
          }
          if (col.mData === i3) {
            var sort = a2(cell, "sort") || a2(cell, "order");
            var filter = a2(cell, "filter") || a2(cell, "search");
            if (sort !== null || filter !== null) {
              col.mData = {
                _: i3 + ".display",
                sort: sort !== null ? i3 + ".@data-" + sort : void 0,
                type: sort !== null ? i3 + ".@data-" + sort : void 0,
                filter: filter !== null ? i3 + ".@data-" + filter : void 0
              };
              col._isArrayHost = true;
              _fnColumnOptions(oSettings, i3);
            }
          }
        });
      }
      var features = oSettings.oFeatures;
      var loadedInit = function() {
        if (oInit.aaSorting === void 0) {
          var sorting = oSettings.aaSorting;
          for (i2 = 0, iLen = sorting.length; i2 < iLen; i2++) {
            sorting[i2][1] = oSettings.aoColumns[i2].asSorting[0];
          }
        }
        _fnSortingClasses(oSettings);
        if (features.bSort) {
          _fnCallbackReg(oSettings, "aoDrawCallback", function() {
            if (oSettings.bSorted) {
              var aSort = _fnSortFlatten(oSettings);
              var sortedColumns = {};
              $4.each(aSort, function(i3, val) {
                sortedColumns[val.src] = val.dir;
              });
              _fnCallbackFire(oSettings, null, "order", [oSettings, aSort, sortedColumns]);
              _fnSortAria(oSettings);
            }
          });
        }
        _fnCallbackReg(oSettings, "aoDrawCallback", function() {
          if (oSettings.bSorted || _fnDataSource(oSettings) === "ssp" || features.bDeferRender) {
            _fnSortingClasses(oSettings);
          }
        }, "sc");
        var captions = $this.children("caption").each(function() {
          this._captionSide = $4(this).css("caption-side");
        });
        var thead = $this.children("thead");
        if (thead.length === 0) {
          thead = $4("<thead/>").appendTo($this);
        }
        oSettings.nTHead = thead[0];
        var tbody = $this.children("tbody");
        if (tbody.length === 0) {
          tbody = $4("<tbody/>").insertAfter(thead);
        }
        oSettings.nTBody = tbody[0];
        var tfoot = $this.children("tfoot");
        if (tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "")) {
          tfoot = $4("<tfoot/>").appendTo($this);
        }
        if (tfoot.length === 0 || tfoot.children().length === 0) {
          $this.addClass(oClasses.sNoFooter);
        } else if (tfoot.length > 0) {
          oSettings.nTFoot = tfoot[0];
          _fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot);
        }
        if (oInit.aaData) {
          for (i2 = 0; i2 < oInit.aaData.length; i2++) {
            _fnAddData(oSettings, oInit.aaData[i2]);
          }
        } else if (oSettings.bDeferLoading || _fnDataSource(oSettings) == "dom") {
          _fnAddTr(oSettings, $4(oSettings.nTBody).children("tr"));
        }
        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
        oSettings.bInitialised = true;
        if (bInitHandedOff === false) {
          _fnInitialise(oSettings);
        }
      };
      _fnCallbackReg(oSettings, "aoDrawCallback", _fnSaveState, "state_save");
      if (oInit.bStateSave) {
        features.bStateSave = true;
        _fnLoadState(oSettings, oInit, loadedInit);
      } else {
        loadedInit();
      }
    });
    _that = null;
    return this;
  };
  var _ext;
  var _Api;
  var _api_register;
  var _api_registerPlural;
  var _re_dic = {};
  var _re_new_lines = /[\r\n\u2028]/g;
  var _re_html = /<.*?>/g;
  var _re_date = /^\d{2,4}[\.\/\-]\d{1,2}[\.\/\-]\d{1,2}([T ]{1}\d{1,2}[:\.]\d{2}([\.:]\d{2})?)?$/;
  var _re_escape_regex = new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^", "-"].join("|\\") + ")", "g");
  var _re_formatted_numeric = /['\u00A0,$%\u2009\u202F\u20BD\u20a9\u20BArfk]/gi;
  var _empty = function(d2) {
    return !d2 || d2 === true || d2 === "-" ? true : false;
  };
  var _intVal = function(s2) {
    var integer = parseInt(s2, 10);
    return !isNaN(integer) && isFinite(s2) ? integer : null;
  };
  var _numToDecimal = function(num, decimalPoint) {
    if (!_re_dic[decimalPoint]) {
      _re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), "g");
    }
    return typeof num === "string" && decimalPoint !== "." ? num.replace(/\./g, "").replace(_re_dic[decimalPoint], ".") : num;
  };
  var _isNumber = function(d2, decimalPoint, formatted) {
    var type = typeof d2;
    var strType = type === "string";
    if (type === "number" || type === "bigint") {
      return true;
    }
    if (_empty(d2)) {
      return true;
    }
    if (decimalPoint && strType) {
      d2 = _numToDecimal(d2, decimalPoint);
    }
    if (formatted && strType) {
      d2 = d2.replace(_re_formatted_numeric, "");
    }
    return !isNaN(parseFloat(d2)) && isFinite(d2);
  };
  var _isHtml = function(d2) {
    return _empty(d2) || typeof d2 === "string";
  };
  var _htmlNumeric = function(d2, decimalPoint, formatted) {
    if (_empty(d2)) {
      return true;
    }
    var html = _isHtml(d2);
    return !html ? null : _isNumber(_stripHtml(d2), decimalPoint, formatted) ? true : null;
  };
  var _pluck = function(a2, prop, prop2) {
    var out = [];
    var i2 = 0, ien = a2.length;
    if (prop2 !== void 0) {
      for (; i2 < ien; i2++) {
        if (a2[i2] && a2[i2][prop]) {
          out.push(a2[i2][prop][prop2]);
        }
      }
    } else {
      for (; i2 < ien; i2++) {
        if (a2[i2]) {
          out.push(a2[i2][prop]);
        }
      }
    }
    return out;
  };
  var _pluck_order = function(a2, order2, prop, prop2) {
    var out = [];
    var i2 = 0, ien = order2.length;
    if (prop2 !== void 0) {
      for (; i2 < ien; i2++) {
        if (a2[order2[i2]][prop]) {
          out.push(a2[order2[i2]][prop][prop2]);
        }
      }
    } else {
      for (; i2 < ien; i2++) {
        out.push(a2[order2[i2]][prop]);
      }
    }
    return out;
  };
  var _range = function(len, start3) {
    var out = [];
    var end2;
    if (start3 === void 0) {
      start3 = 0;
      end2 = len;
    } else {
      end2 = start3;
      start3 = len;
    }
    for (var i2 = start3; i2 < end2; i2++) {
      out.push(i2);
    }
    return out;
  };
  var _removeEmpty = function(a2) {
    var out = [];
    for (var i2 = 0, ien = a2.length; i2 < ien; i2++) {
      if (a2[i2]) {
        out.push(a2[i2]);
      }
    }
    return out;
  };
  var _stripHtml = function(d2) {
    return d2.replace(_re_html, "").replace(/<script/i, "");
  };
  var _areAllUnique = function(src) {
    if (src.length < 2) {
      return true;
    }
    var sorted = src.slice().sort();
    var last = sorted[0];
    for (var i2 = 1, ien = sorted.length; i2 < ien; i2++) {
      if (sorted[i2] === last) {
        return false;
      }
      last = sorted[i2];
    }
    return true;
  };
  var _unique = function(src) {
    if (_areAllUnique(src)) {
      return src.slice();
    }
    var out = [], val, i2, ien = src.length, j2, k2 = 0;
    again:
      for (i2 = 0; i2 < ien; i2++) {
        val = src[i2];
        for (j2 = 0; j2 < k2; j2++) {
          if (out[j2] === val) {
            continue again;
          }
        }
        out.push(val);
        k2++;
      }
    return out;
  };
  var _flatten = function(out, val) {
    if (Array.isArray(val)) {
      for (var i2 = 0; i2 < val.length; i2++) {
        _flatten(out, val[i2]);
      }
    } else {
      out.push(val);
    }
    return out;
  };
  var _includes = function(search, start3) {
    if (start3 === void 0) {
      start3 = 0;
    }
    return this.indexOf(search, start3) !== -1;
  };
  if (!Array.isArray) {
    Array.isArray = function(arg) {
      return Object.prototype.toString.call(arg) === "[object Array]";
    };
  }
  if (!Array.prototype.includes) {
    Array.prototype.includes = _includes;
  }
  if (!String.prototype.trim) {
    String.prototype.trim = function() {
      return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    };
  }
  if (!String.prototype.includes) {
    String.prototype.includes = _includes;
  }
  DataTable.util = {
    /**
     * Throttle the calls to a function. Arguments and context are maintained
     * for the throttled function.
     *
     * @param {function} fn Function to be called
     * @param {integer} freq Call frequency in mS
     * @return {function} Wrapped function
     */
    throttle: function(fn2, freq) {
      var frequency = freq !== void 0 ? freq : 200, last, timer;
      return function() {
        var that = this, now2 = +/* @__PURE__ */ new Date(), args = arguments;
        if (last && now2 < last + frequency) {
          clearTimeout(timer);
          timer = setTimeout(function() {
            last = void 0;
            fn2.apply(that, args);
          }, frequency);
        } else {
          last = now2;
          fn2.apply(that, args);
        }
      };
    },
    /**
     * Escape a string such that it can be used in a regular expression
     *
     *  @param {string} val string to escape
     *  @returns {string} escaped string
     */
    escapeRegex: function(val) {
      return val.replace(_re_escape_regex, "\\$1");
    },
    /**
     * Create a function that will write to a nested object or array
     * @param {*} source JSON notation string
     * @returns Write function
     */
    set: function(source) {
      if ($4.isPlainObject(source)) {
        return DataTable.util.set(source._);
      } else if (source === null) {
        return function() {
        };
      } else if (typeof source === "function") {
        return function(data, val, meta) {
          source(data, "set", val, meta);
        };
      } else if (typeof source === "string" && (source.indexOf(".") !== -1 || source.indexOf("[") !== -1 || source.indexOf("(") !== -1)) {
        var setData = function(data, val, src) {
          var a2 = _fnSplitObjNotation(src), b2;
          var aLast = a2[a2.length - 1];
          var arrayNotation, funcNotation, o2, innerSrc;
          for (var i2 = 0, iLen = a2.length - 1; i2 < iLen; i2++) {
            if (a2[i2] === "__proto__" || a2[i2] === "constructor") {
              throw new Error("Cannot set prototype values");
            }
            arrayNotation = a2[i2].match(__reArray);
            funcNotation = a2[i2].match(__reFn);
            if (arrayNotation) {
              a2[i2] = a2[i2].replace(__reArray, "");
              data[a2[i2]] = [];
              b2 = a2.slice();
              b2.splice(0, i2 + 1);
              innerSrc = b2.join(".");
              if (Array.isArray(val)) {
                for (var j2 = 0, jLen = val.length; j2 < jLen; j2++) {
                  o2 = {};
                  setData(o2, val[j2], innerSrc);
                  data[a2[i2]].push(o2);
                }
              } else {
                data[a2[i2]] = val;
              }
              return;
            } else if (funcNotation) {
              a2[i2] = a2[i2].replace(__reFn, "");
              data = data[a2[i2]](val);
            }
            if (data[a2[i2]] === null || data[a2[i2]] === void 0) {
              data[a2[i2]] = {};
            }
            data = data[a2[i2]];
          }
          if (aLast.match(__reFn)) {
            data = data[aLast.replace(__reFn, "")](val);
          } else {
            data[aLast.replace(__reArray, "")] = val;
          }
        };
        return function(data, val) {
          return setData(data, val, source);
        };
      } else {
        return function(data, val) {
          data[source] = val;
        };
      }
    },
    /**
     * Create a function that will read nested objects from arrays, based on JSON notation
     * @param {*} source JSON notation string
     * @returns Value read
     */
    get: function(source) {
      if ($4.isPlainObject(source)) {
        var o2 = {};
        $4.each(source, function(key, val) {
          if (val) {
            o2[key] = DataTable.util.get(val);
          }
        });
        return function(data, type, row, meta) {
          var t2 = o2[type] || o2._;
          return t2 !== void 0 ? t2(data, type, row, meta) : data;
        };
      } else if (source === null) {
        return function(data) {
          return data;
        };
      } else if (typeof source === "function") {
        return function(data, type, row, meta) {
          return source(data, type, row, meta);
        };
      } else if (typeof source === "string" && (source.indexOf(".") !== -1 || source.indexOf("[") !== -1 || source.indexOf("(") !== -1)) {
        var fetchData = function(data, type, src) {
          var arrayNotation, funcNotation, out, innerSrc;
          if (src !== "") {
            var a2 = _fnSplitObjNotation(src);
            for (var i2 = 0, iLen = a2.length; i2 < iLen; i2++) {
              arrayNotation = a2[i2].match(__reArray);
              funcNotation = a2[i2].match(__reFn);
              if (arrayNotation) {
                a2[i2] = a2[i2].replace(__reArray, "");
                if (a2[i2] !== "") {
                  data = data[a2[i2]];
                }
                out = [];
                a2.splice(0, i2 + 1);
                innerSrc = a2.join(".");
                if (Array.isArray(data)) {
                  for (var j2 = 0, jLen = data.length; j2 < jLen; j2++) {
                    out.push(fetchData(data[j2], type, innerSrc));
                  }
                }
                var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
                data = join === "" ? out : out.join(join);
                break;
              } else if (funcNotation) {
                a2[i2] = a2[i2].replace(__reFn, "");
                data = data[a2[i2]]();
                continue;
              }
              if (data === null || data[a2[i2]] === null) {
                return null;
              } else if (data === void 0 || data[a2[i2]] === void 0) {
                return void 0;
              }
              data = data[a2[i2]];
            }
          }
          return data;
        };
        return function(data, type) {
          return fetchData(data, type, source);
        };
      } else {
        return function(data, type) {
          return data[source];
        };
      }
    }
  };
  function _fnHungarianMap(o2) {
    var hungarian = "a aa ai ao as b fn i m o s ", match, newKey, map = {};
    $4.each(o2, function(key, val) {
      match = key.match(/^([^A-Z]+?)([A-Z])/);
      if (match && hungarian.indexOf(match[1] + " ") !== -1) {
        newKey = key.replace(match[0], match[2].toLowerCase());
        map[newKey] = key;
        if (match[1] === "o") {
          _fnHungarianMap(o2[key]);
        }
      }
    });
    o2._hungarianMap = map;
  }
  function _fnCamelToHungarian(src, user, force) {
    if (!src._hungarianMap) {
      _fnHungarianMap(src);
    }
    var hungarianKey;
    $4.each(user, function(key, val) {
      hungarianKey = src._hungarianMap[key];
      if (hungarianKey !== void 0 && (force || user[hungarianKey] === void 0)) {
        if (hungarianKey.charAt(0) === "o") {
          if (!user[hungarianKey]) {
            user[hungarianKey] = {};
          }
          $4.extend(true, user[hungarianKey], user[key]);
          _fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force);
        } else {
          user[hungarianKey] = user[key];
        }
      }
    });
  }
  function _fnLanguageCompat(lang) {
    var defaults = DataTable.defaults.oLanguage;
    var defaultDecimal = defaults.sDecimal;
    if (defaultDecimal) {
      _addNumericSort(defaultDecimal);
    }
    if (lang) {
      var zeroRecords = lang.sZeroRecords;
      if (!lang.sEmptyTable && zeroRecords && defaults.sEmptyTable === "No data available in table") {
        _fnMap(lang, lang, "sZeroRecords", "sEmptyTable");
      }
      if (!lang.sLoadingRecords && zeroRecords && defaults.sLoadingRecords === "Loading...") {
        _fnMap(lang, lang, "sZeroRecords", "sLoadingRecords");
      }
      if (lang.sInfoThousands) {
        lang.sThousands = lang.sInfoThousands;
      }
      var decimal = lang.sDecimal;
      if (decimal && defaultDecimal !== decimal) {
        _addNumericSort(decimal);
      }
    }
  }
  var _fnCompatMap = function(o2, knew, old) {
    if (o2[knew] !== void 0) {
      o2[old] = o2[knew];
    }
  };
  function _fnCompatOpts(init) {
    _fnCompatMap(init, "ordering", "bSort");
    _fnCompatMap(init, "orderMulti", "bSortMulti");
    _fnCompatMap(init, "orderClasses", "bSortClasses");
    _fnCompatMap(init, "orderCellsTop", "bSortCellsTop");
    _fnCompatMap(init, "order", "aaSorting");
    _fnCompatMap(init, "orderFixed", "aaSortingFixed");
    _fnCompatMap(init, "paging", "bPaginate");
    _fnCompatMap(init, "pagingType", "sPaginationType");
    _fnCompatMap(init, "pageLength", "iDisplayLength");
    _fnCompatMap(init, "searching", "bFilter");
    if (typeof init.sScrollX === "boolean") {
      init.sScrollX = init.sScrollX ? "100%" : "";
    }
    if (typeof init.scrollX === "boolean") {
      init.scrollX = init.scrollX ? "100%" : "";
    }
    var searchCols = init.aoSearchCols;
    if (searchCols) {
      for (var i2 = 0, ien = searchCols.length; i2 < ien; i2++) {
        if (searchCols[i2]) {
          _fnCamelToHungarian(DataTable.models.oSearch, searchCols[i2]);
        }
      }
    }
  }
  function _fnCompatCols(init) {
    _fnCompatMap(init, "orderable", "bSortable");
    _fnCompatMap(init, "orderData", "aDataSort");
    _fnCompatMap(init, "orderSequence", "asSorting");
    _fnCompatMap(init, "orderDataType", "sortDataType");
    var dataSort = init.aDataSort;
    if (typeof dataSort === "number" && !Array.isArray(dataSort)) {
      init.aDataSort = [dataSort];
    }
  }
  function _fnBrowserDetect(settings) {
    if (!DataTable.__browser) {
      var browser = {};
      DataTable.__browser = browser;
      var n2 = $4("<div/>").css({
        position: "fixed",
        top: 0,
        left: $4(window).scrollLeft() * -1,
        // allow for scrolling
        height: 1,
        width: 1,
        overflow: "hidden"
      }).append(
        $4("<div/>").css({
          position: "absolute",
          top: 1,
          left: 1,
          width: 100,
          overflow: "scroll"
        }).append(
          $4("<div/>").css({
            width: "100%",
            height: 10
          })
        )
      ).appendTo("body");
      var outer = n2.children();
      var inner = outer.children();
      browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;
      browser.bScrollOversize = inner[0].offsetWidth === 100 && outer[0].clientWidth !== 100;
      browser.bScrollbarLeft = Math.round(inner.offset().left) !== 1;
      browser.bBounding = n2[0].getBoundingClientRect().width ? true : false;
      n2.remove();
    }
    $4.extend(settings.oBrowser, DataTable.__browser);
    settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
  }
  function _fnReduce(that, fn2, init, start3, end2, inc) {
    var i2 = start3, value, isSet = false;
    if (init !== void 0) {
      value = init;
      isSet = true;
    }
    while (i2 !== end2) {
      if (!that.hasOwnProperty(i2)) {
        continue;
      }
      value = isSet ? fn2(value, that[i2], i2, that) : that[i2];
      isSet = true;
      i2 += inc;
    }
    return value;
  }
  function _fnAddColumn(oSettings, nTh) {
    var oDefaults = DataTable.defaults.column;
    var iCol = oSettings.aoColumns.length;
    var oCol = $4.extend({}, DataTable.models.oColumn, oDefaults, {
      "nTh": nTh ? nTh : document.createElement("th"),
      "sTitle": oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : "",
      "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
      "mData": oDefaults.mData ? oDefaults.mData : iCol,
      idx: iCol
    });
    oSettings.aoColumns.push(oCol);
    var searchCols = oSettings.aoPreSearchCols;
    searchCols[iCol] = $4.extend({}, DataTable.models.oSearch, searchCols[iCol]);
    _fnColumnOptions(oSettings, iCol, $4(nTh).data());
  }
  function _fnColumnOptions(oSettings, iCol, oOptions) {
    var oCol = oSettings.aoColumns[iCol];
    var oClasses = oSettings.oClasses;
    var th = $4(oCol.nTh);
    if (!oCol.sWidthOrig) {
      oCol.sWidthOrig = th.attr("width") || null;
      var t2 = (th.attr("style") || "").match(/width:\s*(\d+[pxem%]+)/);
      if (t2) {
        oCol.sWidthOrig = t2[1];
      }
    }
    if (oOptions !== void 0 && oOptions !== null) {
      _fnCompatCols(oOptions);
      _fnCamelToHungarian(DataTable.defaults.column, oOptions, true);
      if (oOptions.mDataProp !== void 0 && !oOptions.mData) {
        oOptions.mData = oOptions.mDataProp;
      }
      if (oOptions.sType) {
        oCol._sManualType = oOptions.sType;
      }
      if (oOptions.className && !oOptions.sClass) {
        oOptions.sClass = oOptions.className;
      }
      if (oOptions.sClass) {
        th.addClass(oOptions.sClass);
      }
      var origClass = oCol.sClass;
      $4.extend(oCol, oOptions);
      _fnMap(oCol, oOptions, "sWidth", "sWidthOrig");
      if (origClass !== oCol.sClass) {
        oCol.sClass = origClass + " " + oCol.sClass;
      }
      if (oOptions.iDataSort !== void 0) {
        oCol.aDataSort = [oOptions.iDataSort];
      }
      _fnMap(oCol, oOptions, "aDataSort");
      if (!oCol.ariaTitle) {
        oCol.ariaTitle = th.attr("aria-label");
      }
    }
    var mDataSrc = oCol.mData;
    var mData = _fnGetObjectDataFn(mDataSrc);
    var mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null;
    var attrTest = function(src) {
      return typeof src === "string" && src.indexOf("@") !== -1;
    };
    oCol._bAttrSrc = $4.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter));
    oCol._setter = null;
    oCol.fnGetData = function(rowData, type, meta) {
      var innerData = mData(rowData, type, void 0, meta);
      return mRender && type ? mRender(innerData, type, rowData, meta) : innerData;
    };
    oCol.fnSetData = function(rowData, val, meta) {
      return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta);
    };
    if (typeof mDataSrc !== "number" && !oCol._isArrayHost) {
      oSettings._rowReadObject = true;
    }
    if (!oSettings.oFeatures.bSort) {
      oCol.bSortable = false;
      th.addClass(oClasses.sSortableNone);
    }
    var bAsc = $4.inArray("asc", oCol.asSorting) !== -1;
    var bDesc = $4.inArray("desc", oCol.asSorting) !== -1;
    if (!oCol.bSortable || !bAsc && !bDesc) {
      oCol.sSortingClass = oClasses.sSortableNone;
      oCol.sSortingClassJUI = "";
    } else if (bAsc && !bDesc) {
      oCol.sSortingClass = oClasses.sSortableAsc;
      oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;
    } else if (!bAsc && bDesc) {
      oCol.sSortingClass = oClasses.sSortableDesc;
      oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;
    } else {
      oCol.sSortingClass = oClasses.sSortable;
      oCol.sSortingClassJUI = oClasses.sSortJUI;
    }
  }
  function _fnAdjustColumnSizing(settings) {
    if (settings.oFeatures.bAutoWidth !== false) {
      var columns = settings.aoColumns;
      _fnCalculateColumnWidths(settings);
      for (var i2 = 0, iLen = columns.length; i2 < iLen; i2++) {
        columns[i2].nTh.style.width = columns[i2].sWidth;
      }
    }
    var scroll = settings.oScroll;
    if (scroll.sY !== "" || scroll.sX !== "") {
      _fnScrollDraw(settings);
    }
    _fnCallbackFire(settings, null, "column-sizing", [settings]);
  }
  function _fnVisibleToColumnIndex(oSettings, iMatch) {
    var aiVis = _fnGetColumns(oSettings, "bVisible");
    return typeof aiVis[iMatch] === "number" ? aiVis[iMatch] : null;
  }
  function _fnColumnIndexToVisible(oSettings, iMatch) {
    var aiVis = _fnGetColumns(oSettings, "bVisible");
    var iPos = $4.inArray(iMatch, aiVis);
    return iPos !== -1 ? iPos : null;
  }
  function _fnVisbleColumns(oSettings) {
    var vis = 0;
    $4.each(oSettings.aoColumns, function(i2, col) {
      if (col.bVisible && $4(col.nTh).css("display") !== "none") {
        vis++;
      }
    });
    return vis;
  }
  function _fnGetColumns(oSettings, sParam) {
    var a2 = [];
    $4.map(oSettings.aoColumns, function(val, i2) {
      if (val[sParam]) {
        a2.push(i2);
      }
    });
    return a2;
  }
  function _fnColumnTypes(settings) {
    var columns = settings.aoColumns;
    var data = settings.aoData;
    var types = DataTable.ext.type.detect;
    var i2, ien, j2, jen, k2, ken;
    var col, cell, detectedType, cache2;
    for (i2 = 0, ien = columns.length; i2 < ien; i2++) {
      col = columns[i2];
      cache2 = [];
      if (!col.sType && col._sManualType) {
        col.sType = col._sManualType;
      } else if (!col.sType) {
        for (j2 = 0, jen = types.length; j2 < jen; j2++) {
          for (k2 = 0, ken = data.length; k2 < ken; k2++) {
            if (cache2[k2] === void 0) {
              cache2[k2] = _fnGetCellData(settings, k2, i2, "type");
            }
            detectedType = types[j2](cache2[k2], settings);
            if (!detectedType && j2 !== types.length - 1) {
              break;
            }
            if (detectedType === "html" && !_empty(cache2[k2])) {
              break;
            }
          }
          if (detectedType) {
            col.sType = detectedType;
            break;
          }
        }
        if (!col.sType) {
          col.sType = "string";
        }
      }
    }
  }
  function _fnApplyColumnDefs(oSettings, aoColDefs, aoCols, fn2) {
    var i2, iLen, j2, jLen, k2, kLen, def;
    var columns = oSettings.aoColumns;
    if (aoColDefs) {
      for (i2 = aoColDefs.length - 1; i2 >= 0; i2--) {
        def = aoColDefs[i2];
        var aTargets = def.target !== void 0 ? def.target : def.targets !== void 0 ? def.targets : def.aTargets;
        if (!Array.isArray(aTargets)) {
          aTargets = [aTargets];
        }
        for (j2 = 0, jLen = aTargets.length; j2 < jLen; j2++) {
          if (typeof aTargets[j2] === "number" && aTargets[j2] >= 0) {
            while (columns.length <= aTargets[j2]) {
              _fnAddColumn(oSettings);
            }
            fn2(aTargets[j2], def);
          } else if (typeof aTargets[j2] === "number" && aTargets[j2] < 0) {
            fn2(columns.length + aTargets[j2], def);
          } else if (typeof aTargets[j2] === "string") {
            for (k2 = 0, kLen = columns.length; k2 < kLen; k2++) {
              if (aTargets[j2] == "_all" || $4(columns[k2].nTh).hasClass(aTargets[j2])) {
                fn2(k2, def);
              }
            }
          }
        }
      }
    }
    if (aoCols) {
      for (i2 = 0, iLen = aoCols.length; i2 < iLen; i2++) {
        fn2(i2, aoCols[i2]);
      }
    }
  }
  function _fnAddData(oSettings, aDataIn, nTr, anTds) {
    var iRow = oSettings.aoData.length;
    var oData = $4.extend(true, {}, DataTable.models.oRow, {
      src: nTr ? "dom" : "data",
      idx: iRow
    });
    oData._aData = aDataIn;
    oSettings.aoData.push(oData);
    var nTd, sThisType;
    var columns = oSettings.aoColumns;
    for (var i2 = 0, iLen = columns.length; i2 < iLen; i2++) {
      columns[i2].sType = null;
    }
    oSettings.aiDisplayMaster.push(iRow);
    var id = oSettings.rowIdFn(aDataIn);
    if (id !== void 0) {
      oSettings.aIds[id] = oData;
    }
    if (nTr || !oSettings.oFeatures.bDeferRender) {
      _fnCreateTr(oSettings, iRow, nTr, anTds);
    }
    return iRow;
  }
  function _fnAddTr(settings, trs) {
    var row;
    if (!(trs instanceof $4)) {
      trs = $4(trs);
    }
    return trs.map(function(i2, el) {
      row = _fnGetRowElements(settings, el);
      return _fnAddData(settings, row.data, el, row.cells);
    });
  }
  function _fnNodeToDataIndex(oSettings, n2) {
    return n2._DT_RowIndex !== void 0 ? n2._DT_RowIndex : null;
  }
  function _fnNodeToColumnIndex(oSettings, iRow, n2) {
    return $4.inArray(n2, oSettings.aoData[iRow].anCells);
  }
  function _fnGetCellData(settings, rowIdx, colIdx, type) {
    if (type === "search") {
      type = "filter";
    } else if (type === "order") {
      type = "sort";
    }
    var draw = settings.iDraw;
    var col = settings.aoColumns[colIdx];
    var rowData = settings.aoData[rowIdx]._aData;
    var defaultContent = col.sDefaultContent;
    var cellData = col.fnGetData(rowData, type, {
      settings,
      row: rowIdx,
      col: colIdx
    });
    if (cellData === void 0) {
      if (settings.iDrawError != draw && defaultContent === null) {
        _fnLog(settings, 0, "Requested unknown parameter " + (typeof col.mData == "function" ? "{function}" : "'" + col.mData + "'") + " for row " + rowIdx + ", column " + colIdx, 4);
        settings.iDrawError = draw;
      }
      return defaultContent;
    }
    if ((cellData === rowData || cellData === null) && defaultContent !== null && type !== void 0) {
      cellData = defaultContent;
    } else if (typeof cellData === "function") {
      return cellData.call(rowData);
    }
    if (cellData === null && type === "display") {
      return "";
    }
    if (type === "filter") {
      var fomatters = DataTable.ext.type.search;
      if (fomatters[col.sType]) {
        cellData = fomatters[col.sType](cellData);
      }
    }
    return cellData;
  }
  function _fnSetCellData(settings, rowIdx, colIdx, val) {
    var col = settings.aoColumns[colIdx];
    var rowData = settings.aoData[rowIdx]._aData;
    col.fnSetData(rowData, val, {
      settings,
      row: rowIdx,
      col: colIdx
    });
  }
  var __reArray = /\[.*?\]$/;
  var __reFn = /\(\)$/;
  function _fnSplitObjNotation(str) {
    return $4.map(str.match(/(\\.|[^\.])+/g) || [""], function(s2) {
      return s2.replace(/\\\./g, ".");
    });
  }
  var _fnGetObjectDataFn = DataTable.util.get;
  var _fnSetObjectDataFn = DataTable.util.set;
  function _fnGetDataMaster(settings) {
    return _pluck(settings.aoData, "_aData");
  }
  function _fnClearTable(settings) {
    settings.aoData.length = 0;
    settings.aiDisplayMaster.length = 0;
    settings.aiDisplay.length = 0;
    settings.aIds = {};
  }
  function _fnDeleteIndex(a2, iTarget, splice) {
    var iTargetIndex = -1;
    for (var i2 = 0, iLen = a2.length; i2 < iLen; i2++) {
      if (a2[i2] == iTarget) {
        iTargetIndex = i2;
      } else if (a2[i2] > iTarget) {
        a2[i2]--;
      }
    }
    if (iTargetIndex != -1 && splice === void 0) {
      a2.splice(iTargetIndex, 1);
    }
  }
  function _fnInvalidate(settings, rowIdx, src, colIdx) {
    var row = settings.aoData[rowIdx];
    var i2, ien;
    var cellWrite = function(cell, col) {
      while (cell.childNodes.length) {
        cell.removeChild(cell.firstChild);
      }
      cell.innerHTML = _fnGetCellData(settings, rowIdx, col, "display");
    };
    if (src === "dom" || (!src || src === "auto") && row.src === "dom") {
      row._aData = _fnGetRowElements(
        settings,
        row,
        colIdx,
        colIdx === void 0 ? void 0 : row._aData
      ).data;
    } else {
      var cells = row.anCells;
      if (cells) {
        if (colIdx !== void 0) {
          cellWrite(cells[colIdx], colIdx);
        } else {
          for (i2 = 0, ien = cells.length; i2 < ien; i2++) {
            cellWrite(cells[i2], i2);
          }
        }
      }
    }
    row._aSortData = null;
    row._aFilterData = null;
    var cols = settings.aoColumns;
    if (colIdx !== void 0) {
      cols[colIdx].sType = null;
    } else {
      for (i2 = 0, ien = cols.length; i2 < ien; i2++) {
        cols[i2].sType = null;
      }
      _fnRowAttributes(settings, row);
    }
  }
  function _fnGetRowElements(settings, row, colIdx, d2) {
    var tds = [], td = row.firstChild, name, col, o2, i2 = 0, contents, columns = settings.aoColumns, objectRead = settings._rowReadObject;
    d2 = d2 !== void 0 ? d2 : objectRead ? {} : [];
    var attr = function(str, td2) {
      if (typeof str === "string") {
        var idx = str.indexOf("@");
        if (idx !== -1) {
          var attr2 = str.substring(idx + 1);
          var setter = _fnSetObjectDataFn(str);
          setter(d2, td2.getAttribute(attr2));
        }
      }
    };
    var cellProcess = function(cell) {
      if (colIdx === void 0 || colIdx === i2) {
        col = columns[i2];
        contents = cell.innerHTML.trim();
        if (col && col._bAttrSrc) {
          var setter = _fnSetObjectDataFn(col.mData._);
          setter(d2, contents);
          attr(col.mData.sort, cell);
          attr(col.mData.type, cell);
          attr(col.mData.filter, cell);
        } else {
          if (objectRead) {
            if (!col._setter) {
              col._setter = _fnSetObjectDataFn(col.mData);
            }
            col._setter(d2, contents);
          } else {
            d2[i2] = contents;
          }
        }
      }
      i2++;
    };
    if (td) {
      while (td) {
        name = td.nodeName.toUpperCase();
        if (name == "TD" || name == "TH") {
          cellProcess(td);
          tds.push(td);
        }
        td = td.nextSibling;
      }
    } else {
      tds = row.anCells;
      for (var j2 = 0, jen = tds.length; j2 < jen; j2++) {
        cellProcess(tds[j2]);
      }
    }
    var rowNode = row.firstChild ? row : row.nTr;
    if (rowNode) {
      var id = rowNode.getAttribute("id");
      if (id) {
        _fnSetObjectDataFn(settings.rowId)(d2, id);
      }
    }
    return {
      data: d2,
      cells: tds
    };
  }
  function _fnCreateTr(oSettings, iRow, nTrIn, anTds) {
    var row = oSettings.aoData[iRow], rowData = row._aData, cells = [], nTr, nTd, oCol, i2, iLen, create;
    if (row.nTr === null) {
      nTr = nTrIn || document.createElement("tr");
      row.nTr = nTr;
      row.anCells = cells;
      nTr._DT_RowIndex = iRow;
      _fnRowAttributes(oSettings, row);
      for (i2 = 0, iLen = oSettings.aoColumns.length; i2 < iLen; i2++) {
        oCol = oSettings.aoColumns[i2];
        create = nTrIn ? false : true;
        nTd = create ? document.createElement(oCol.sCellType) : anTds[i2];
        if (!nTd) {
          _fnLog(oSettings, 0, "Incorrect column count", 18);
        }
        nTd._DT_CellIndex = {
          row: iRow,
          column: i2
        };
        cells.push(nTd);
        if (create || (oCol.mRender || oCol.mData !== i2) && (!$4.isPlainObject(oCol.mData) || oCol.mData._ !== i2 + ".display")) {
          nTd.innerHTML = _fnGetCellData(oSettings, iRow, i2, "display");
        }
        if (oCol.sClass) {
          nTd.className += " " + oCol.sClass;
        }
        if (oCol.bVisible && !nTrIn) {
          nTr.appendChild(nTd);
        } else if (!oCol.bVisible && nTrIn) {
          nTd.parentNode.removeChild(nTd);
        }
        if (oCol.fnCreatedCell) {
          oCol.fnCreatedCell.call(
            oSettings.oInstance,
            nTd,
            _fnGetCellData(oSettings, iRow, i2),
            rowData,
            iRow,
            i2
          );
        }
      }
      _fnCallbackFire(oSettings, "aoRowCreatedCallback", null, [nTr, rowData, iRow, cells]);
    }
  }
  function _fnRowAttributes(settings, row) {
    var tr = row.nTr;
    var data = row._aData;
    if (tr) {
      var id = settings.rowIdFn(data);
      if (id) {
        tr.id = id;
      }
      if (data.DT_RowClass) {
        var a2 = data.DT_RowClass.split(" ");
        row.__rowc = row.__rowc ? _unique(row.__rowc.concat(a2)) : a2;
        $4(tr).removeClass(row.__rowc.join(" ")).addClass(data.DT_RowClass);
      }
      if (data.DT_RowAttr) {
        $4(tr).attr(data.DT_RowAttr);
      }
      if (data.DT_RowData) {
        $4(tr).data(data.DT_RowData);
      }
    }
  }
  function _fnBuildHead(oSettings) {
    var i2, ien, cell, row, column;
    var thead = oSettings.nTHead;
    var tfoot = oSettings.nTFoot;
    var createHeader = $4("th, td", thead).length === 0;
    var classes = oSettings.oClasses;
    var columns = oSettings.aoColumns;
    if (createHeader) {
      row = $4("<tr/>").appendTo(thead);
    }
    for (i2 = 0, ien = columns.length; i2 < ien; i2++) {
      column = columns[i2];
      cell = $4(column.nTh).addClass(column.sClass);
      if (createHeader) {
        cell.appendTo(row);
      }
      if (oSettings.oFeatures.bSort) {
        cell.addClass(column.sSortingClass);
        if (column.bSortable !== false) {
          cell.attr("tabindex", oSettings.iTabIndex).attr("aria-controls", oSettings.sTableId);
          _fnSortAttachListener(oSettings, column.nTh, i2);
        }
      }
      if (column.sTitle != cell[0].innerHTML) {
        cell.html(column.sTitle);
      }
      _fnRenderer(oSettings, "header")(
        oSettings,
        cell,
        column,
        classes
      );
    }
    if (createHeader) {
      _fnDetectHeader(oSettings.aoHeader, thead);
    }
    $4(thead).children("tr").children("th, td").addClass(classes.sHeaderTH);
    $4(tfoot).children("tr").children("th, td").addClass(classes.sFooterTH);
    if (tfoot !== null) {
      var cells = oSettings.aoFooter[0];
      for (i2 = 0, ien = cells.length; i2 < ien; i2++) {
        column = columns[i2];
        if (column) {
          column.nTf = cells[i2].cell;
          if (column.sClass) {
            $4(column.nTf).addClass(column.sClass);
          }
        } else {
          _fnLog(oSettings, 0, "Incorrect column count", 18);
        }
      }
    }
  }
  function _fnDrawHead(oSettings, aoSource, bIncludeHidden) {
    var i2, iLen, j2, jLen, k2, kLen, n2, nLocalTr;
    var aoLocal = [];
    var aApplied = [];
    var iColumns = oSettings.aoColumns.length;
    var iRowspan, iColspan;
    if (!aoSource) {
      return;
    }
    if (bIncludeHidden === void 0) {
      bIncludeHidden = false;
    }
    for (i2 = 0, iLen = aoSource.length; i2 < iLen; i2++) {
      aoLocal[i2] = aoSource[i2].slice();
      aoLocal[i2].nTr = aoSource[i2].nTr;
      for (j2 = iColumns - 1; j2 >= 0; j2--) {
        if (!oSettings.aoColumns[j2].bVisible && !bIncludeHidden) {
          aoLocal[i2].splice(j2, 1);
        }
      }
      aApplied.push([]);
    }
    for (i2 = 0, iLen = aoLocal.length; i2 < iLen; i2++) {
      nLocalTr = aoLocal[i2].nTr;
      if (nLocalTr) {
        while (n2 = nLocalTr.firstChild) {
          nLocalTr.removeChild(n2);
        }
      }
      for (j2 = 0, jLen = aoLocal[i2].length; j2 < jLen; j2++) {
        iRowspan = 1;
        iColspan = 1;
        if (aApplied[i2][j2] === void 0) {
          nLocalTr.appendChild(aoLocal[i2][j2].cell);
          aApplied[i2][j2] = 1;
          while (aoLocal[i2 + iRowspan] !== void 0 && aoLocal[i2][j2].cell == aoLocal[i2 + iRowspan][j2].cell) {
            aApplied[i2 + iRowspan][j2] = 1;
            iRowspan++;
          }
          while (aoLocal[i2][j2 + iColspan] !== void 0 && aoLocal[i2][j2].cell == aoLocal[i2][j2 + iColspan].cell) {
            for (k2 = 0; k2 < iRowspan; k2++) {
              aApplied[i2 + k2][j2 + iColspan] = 1;
            }
            iColspan++;
          }
          $4(aoLocal[i2][j2].cell).attr("rowspan", iRowspan).attr("colspan", iColspan);
        }
      }
    }
  }
  function _fnDraw(oSettings, ajaxComplete) {
    _fnStart(oSettings);
    var aPreDraw = _fnCallbackFire(oSettings, "aoPreDrawCallback", "preDraw", [oSettings]);
    if ($4.inArray(false, aPreDraw) !== -1) {
      _fnProcessingDisplay(oSettings, false);
      return;
    }
    var anRows = [];
    var iRowCount = 0;
    var asStripeClasses = oSettings.asStripeClasses;
    var iStripes = asStripeClasses.length;
    var oLang = oSettings.oLanguage;
    var bServerSide = _fnDataSource(oSettings) == "ssp";
    var aiDisplay = oSettings.aiDisplay;
    var iDisplayStart = oSettings._iDisplayStart;
    var iDisplayEnd = oSettings.fnDisplayEnd();
    oSettings.bDrawing = true;
    if (oSettings.bDeferLoading) {
      oSettings.bDeferLoading = false;
      oSettings.iDraw++;
      _fnProcessingDisplay(oSettings, false);
    } else if (!bServerSide) {
      oSettings.iDraw++;
    } else if (!oSettings.bDestroying && !ajaxComplete) {
      _fnAjaxUpdate(oSettings);
      return;
    }
    if (aiDisplay.length !== 0) {
      var iStart = bServerSide ? 0 : iDisplayStart;
      var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
      for (var j2 = iStart; j2 < iEnd; j2++) {
        var iDataIndex = aiDisplay[j2];
        var aoData = oSettings.aoData[iDataIndex];
        if (aoData.nTr === null) {
          _fnCreateTr(oSettings, iDataIndex);
        }
        var nRow = aoData.nTr;
        if (iStripes !== 0) {
          var sStripe = asStripeClasses[iRowCount % iStripes];
          if (aoData._sRowStripe != sStripe) {
            $4(nRow).removeClass(aoData._sRowStripe).addClass(sStripe);
            aoData._sRowStripe = sStripe;
          }
        }
        _fnCallbackFire(
          oSettings,
          "aoRowCallback",
          null,
          [nRow, aoData._aData, iRowCount, j2, iDataIndex]
        );
        anRows.push(nRow);
        iRowCount++;
      }
    } else {
      var sZero = oLang.sZeroRecords;
      if (oSettings.iDraw == 1 && _fnDataSource(oSettings) == "ajax") {
        sZero = oLang.sLoadingRecords;
      } else if (oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0) {
        sZero = oLang.sEmptyTable;
      }
      anRows[0] = $4("<tr/>", { "class": iStripes ? asStripeClasses[0] : "" }).append($4("<td />", {
        "valign": "top",
        "colSpan": _fnVisbleColumns(oSettings),
        "class": oSettings.oClasses.sRowEmpty
      }).html(sZero))[0];
    }
    _fnCallbackFire(oSettings, "aoHeaderCallback", "header", [
      $4(oSettings.nTHead).children("tr")[0],
      _fnGetDataMaster(oSettings),
      iDisplayStart,
      iDisplayEnd,
      aiDisplay
    ]);
    _fnCallbackFire(oSettings, "aoFooterCallback", "footer", [
      $4(oSettings.nTFoot).children("tr")[0],
      _fnGetDataMaster(oSettings),
      iDisplayStart,
      iDisplayEnd,
      aiDisplay
    ]);
    var body = $4(oSettings.nTBody);
    body.children().detach();
    body.append($4(anRows));
    _fnCallbackFire(oSettings, "aoDrawCallback", "draw", [oSettings]);
    oSettings.bSorted = false;
    oSettings.bFiltered = false;
    oSettings.bDrawing = false;
  }
  function _fnReDraw(settings, holdPosition) {
    var features = settings.oFeatures, sort = features.bSort, filter = features.bFilter;
    if (sort) {
      _fnSort(settings);
    }
    if (filter) {
      _fnFilterComplete(settings, settings.oPreviousSearch);
    } else {
      settings.aiDisplay = settings.aiDisplayMaster.slice();
    }
    if (holdPosition !== true) {
      settings._iDisplayStart = 0;
    }
    settings._drawHold = holdPosition;
    _fnDraw(settings);
    settings._drawHold = false;
  }
  function _fnAddOptionsHtml(oSettings) {
    var classes = oSettings.oClasses;
    var table = $4(oSettings.nTable);
    var holding = $4("<div/>").insertBefore(table);
    var features = oSettings.oFeatures;
    var insert = $4("<div/>", {
      id: oSettings.sTableId + "_wrapper",
      "class": classes.sWrapper + (oSettings.nTFoot ? "" : " " + classes.sNoFooter)
    });
    oSettings.nHolding = holding[0];
    oSettings.nTableWrapper = insert[0];
    oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
    var aDom = oSettings.sDom.split("");
    var featureNode, cOption, nNewNode, cNext, sAttr, j2;
    for (var i2 = 0; i2 < aDom.length; i2++) {
      featureNode = null;
      cOption = aDom[i2];
      if (cOption == "<") {
        nNewNode = $4("<div/>")[0];
        cNext = aDom[i2 + 1];
        if (cNext == "'" || cNext == '"') {
          sAttr = "";
          j2 = 2;
          while (aDom[i2 + j2] != cNext) {
            sAttr += aDom[i2 + j2];
            j2++;
          }
          if (sAttr == "H") {
            sAttr = classes.sJUIHeader;
          } else if (sAttr == "F") {
            sAttr = classes.sJUIFooter;
          }
          if (sAttr.indexOf(".") != -1) {
            var aSplit = sAttr.split(".");
            nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1);
            nNewNode.className = aSplit[1];
          } else if (sAttr.charAt(0) == "#") {
            nNewNode.id = sAttr.substr(1, sAttr.length - 1);
          } else {
            nNewNode.className = sAttr;
          }
          i2 += j2;
        }
        insert.append(nNewNode);
        insert = $4(nNewNode);
      } else if (cOption == ">") {
        insert = insert.parent();
      } else if (cOption == "l" && features.bPaginate && features.bLengthChange) {
        featureNode = _fnFeatureHtmlLength(oSettings);
      } else if (cOption == "f" && features.bFilter) {
        featureNode = _fnFeatureHtmlFilter(oSettings);
      } else if (cOption == "r" && features.bProcessing) {
        featureNode = _fnFeatureHtmlProcessing(oSettings);
      } else if (cOption == "t") {
        featureNode = _fnFeatureHtmlTable(oSettings);
      } else if (cOption == "i" && features.bInfo) {
        featureNode = _fnFeatureHtmlInfo(oSettings);
      } else if (cOption == "p" && features.bPaginate) {
        featureNode = _fnFeatureHtmlPaginate(oSettings);
      } else if (DataTable.ext.feature.length !== 0) {
        var aoFeatures = DataTable.ext.feature;
        for (var k2 = 0, kLen = aoFeatures.length; k2 < kLen; k2++) {
          if (cOption == aoFeatures[k2].cFeature) {
            featureNode = aoFeatures[k2].fnInit(oSettings);
            break;
          }
        }
      }
      if (featureNode) {
        var aanFeatures = oSettings.aanFeatures;
        if (!aanFeatures[cOption]) {
          aanFeatures[cOption] = [];
        }
        aanFeatures[cOption].push(featureNode);
        insert.append(featureNode);
      }
    }
    holding.replaceWith(insert);
    oSettings.nHolding = null;
  }
  function _fnDetectHeader(aLayout, nThead) {
    var nTrs = $4(nThead).children("tr");
    var nTr, nCell;
    var i2, k2, l2, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;
    var bUnique;
    var fnShiftCol = function(a2, i3, j2) {
      var k3 = a2[i3];
      while (k3[j2]) {
        j2++;
      }
      return j2;
    };
    aLayout.splice(0, aLayout.length);
    for (i2 = 0, iLen = nTrs.length; i2 < iLen; i2++) {
      aLayout.push([]);
    }
    for (i2 = 0, iLen = nTrs.length; i2 < iLen; i2++) {
      nTr = nTrs[i2];
      iColumn = 0;
      nCell = nTr.firstChild;
      while (nCell) {
        if (nCell.nodeName.toUpperCase() == "TD" || nCell.nodeName.toUpperCase() == "TH") {
          iColspan = nCell.getAttribute("colspan") * 1;
          iRowspan = nCell.getAttribute("rowspan") * 1;
          iColspan = !iColspan || iColspan === 0 || iColspan === 1 ? 1 : iColspan;
          iRowspan = !iRowspan || iRowspan === 0 || iRowspan === 1 ? 1 : iRowspan;
          iColShifted = fnShiftCol(aLayout, i2, iColumn);
          bUnique = iColspan === 1 ? true : false;
          for (l2 = 0; l2 < iColspan; l2++) {
            for (k2 = 0; k2 < iRowspan; k2++) {
              aLayout[i2 + k2][iColShifted + l2] = {
                "cell": nCell,
                "unique": bUnique
              };
              aLayout[i2 + k2].nTr = nTr;
            }
          }
        }
        nCell = nCell.nextSibling;
      }
    }
  }
  function _fnGetUniqueThs(oSettings, nHeader, aLayout) {
    var aReturn = [];
    if (!aLayout) {
      aLayout = oSettings.aoHeader;
      if (nHeader) {
        aLayout = [];
        _fnDetectHeader(aLayout, nHeader);
      }
    }
    for (var i2 = 0, iLen = aLayout.length; i2 < iLen; i2++) {
      for (var j2 = 0, jLen = aLayout[i2].length; j2 < jLen; j2++) {
        if (aLayout[i2][j2].unique && (!aReturn[j2] || !oSettings.bSortCellsTop)) {
          aReturn[j2] = aLayout[i2][j2].cell;
        }
      }
    }
    return aReturn;
  }
  function _fnStart(oSettings) {
    var bServerSide = _fnDataSource(oSettings) == "ssp";
    var iInitDisplayStart = oSettings.iInitDisplayStart;
    if (iInitDisplayStart !== void 0 && iInitDisplayStart !== -1) {
      oSettings._iDisplayStart = bServerSide ? iInitDisplayStart : iInitDisplayStart >= oSettings.fnRecordsDisplay() ? 0 : iInitDisplayStart;
      oSettings.iInitDisplayStart = -1;
    }
  }
  function _fnBuildAjax(oSettings, data, fn2) {
    _fnCallbackFire(oSettings, "aoServerParams", "serverParams", [data]);
    if (data && Array.isArray(data)) {
      var tmp = {};
      var rbracket = /(.*?)\[\]$/;
      $4.each(data, function(key, val) {
        var match = val.name.match(rbracket);
        if (match) {
          var name = match[0];
          if (!tmp[name]) {
            tmp[name] = [];
          }
          tmp[name].push(val.value);
        } else {
          tmp[val.name] = val.value;
        }
      });
      data = tmp;
    }
    var ajaxData;
    var ajax = oSettings.ajax;
    var instance = oSettings.oInstance;
    var callback = function(json) {
      var status = oSettings.jqXHR ? oSettings.jqXHR.status : null;
      if (json === null || typeof status === "number" && status == 204) {
        json = {};
        _fnAjaxDataSrc(oSettings, json, []);
      }
      var error2 = json.error || json.sError;
      if (error2) {
        _fnLog(oSettings, 0, error2);
      }
      oSettings.json = json;
      _fnCallbackFire(oSettings, null, "xhr", [oSettings, json, oSettings.jqXHR]);
      fn2(json);
    };
    if ($4.isPlainObject(ajax) && ajax.data) {
      ajaxData = ajax.data;
      var newData = typeof ajaxData === "function" ? ajaxData(data, oSettings) : (
        // fn can manipulate data or return
        ajaxData
      );
      data = typeof ajaxData === "function" && newData ? newData : $4.extend(true, data, newData);
      delete ajax.data;
    }
    var baseAjax = {
      "data": data,
      "success": callback,
      "dataType": "json",
      "cache": false,
      "type": oSettings.sServerMethod,
      "error": function(xhr, error2, thrown) {
        var ret = _fnCallbackFire(oSettings, null, "xhr", [oSettings, null, oSettings.jqXHR]);
        if ($4.inArray(true, ret) === -1) {
          if (error2 == "parsererror") {
            _fnLog(oSettings, 0, "Invalid JSON response", 1);
          } else if (xhr.readyState === 4) {
            _fnLog(oSettings, 0, "Ajax error", 7);
          }
        }
        _fnProcessingDisplay(oSettings, false);
      }
    };
    oSettings.oAjaxData = data;
    _fnCallbackFire(oSettings, null, "preXhr", [oSettings, data]);
    if (oSettings.fnServerData) {
      oSettings.fnServerData.call(
        instance,
        oSettings.sAjaxSource,
        $4.map(data, function(val, key) {
          return { name: key, value: val };
        }),
        callback,
        oSettings
      );
    } else if (oSettings.sAjaxSource || typeof ajax === "string") {
      oSettings.jqXHR = $4.ajax($4.extend(baseAjax, {
        url: ajax || oSettings.sAjaxSource
      }));
    } else if (typeof ajax === "function") {
      oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);
    } else {
      oSettings.jqXHR = $4.ajax($4.extend(baseAjax, ajax));
      ajax.data = ajaxData;
    }
  }
  function _fnAjaxUpdate(settings) {
    settings.iDraw++;
    _fnProcessingDisplay(settings, true);
    var drawHold = settings._drawHold;
    _fnBuildAjax(
      settings,
      _fnAjaxParameters(settings),
      function(json) {
        settings._drawHold = drawHold;
        _fnAjaxUpdateDraw(settings, json);
        settings._drawHold = false;
      }
    );
  }
  function _fnAjaxParameters(settings) {
    var columns = settings.aoColumns, columnCount = columns.length, features = settings.oFeatures, preSearch = settings.oPreviousSearch, preColSearch = settings.aoPreSearchCols, i2, data = [], dataProp, column, columnSearch, sort = _fnSortFlatten(settings), displayStart = settings._iDisplayStart, displayLength = features.bPaginate !== false ? settings._iDisplayLength : -1;
    var param = function(name, value) {
      data.push({ "name": name, "value": value });
    };
    param("sEcho", settings.iDraw);
    param("iColumns", columnCount);
    param("sColumns", _pluck(columns, "sName").join(","));
    param("iDisplayStart", displayStart);
    param("iDisplayLength", displayLength);
    var d2 = {
      draw: settings.iDraw,
      columns: [],
      order: [],
      start: displayStart,
      length: displayLength,
      search: {
        value: preSearch.sSearch,
        regex: preSearch.bRegex
      }
    };
    for (i2 = 0; i2 < columnCount; i2++) {
      column = columns[i2];
      columnSearch = preColSearch[i2];
      dataProp = typeof column.mData == "function" ? "function" : column.mData;
      d2.columns.push({
        data: dataProp,
        name: column.sName,
        searchable: column.bSearchable,
        orderable: column.bSortable,
        search: {
          value: columnSearch.sSearch,
          regex: columnSearch.bRegex
        }
      });
      param("mDataProp_" + i2, dataProp);
      if (features.bFilter) {
        param("sSearch_" + i2, columnSearch.sSearch);
        param("bRegex_" + i2, columnSearch.bRegex);
        param("bSearchable_" + i2, column.bSearchable);
      }
      if (features.bSort) {
        param("bSortable_" + i2, column.bSortable);
      }
    }
    if (features.bFilter) {
      param("sSearch", preSearch.sSearch);
      param("bRegex", preSearch.bRegex);
    }
    if (features.bSort) {
      $4.each(sort, function(i3, val) {
        d2.order.push({ column: val.col, dir: val.dir });
        param("iSortCol_" + i3, val.col);
        param("sSortDir_" + i3, val.dir);
      });
      param("iSortingCols", sort.length);
    }
    var legacy = DataTable.ext.legacy.ajax;
    if (legacy === null) {
      return settings.sAjaxSource ? data : d2;
    }
    return legacy ? data : d2;
  }
  function _fnAjaxUpdateDraw(settings, json) {
    var compat = function(old, modern) {
      return json[old] !== void 0 ? json[old] : json[modern];
    };
    var data = _fnAjaxDataSrc(settings, json);
    var draw = compat("sEcho", "draw");
    var recordsTotal = compat("iTotalRecords", "recordsTotal");
    var recordsFiltered = compat("iTotalDisplayRecords", "recordsFiltered");
    if (draw !== void 0) {
      if (draw * 1 < settings.iDraw) {
        return;
      }
      settings.iDraw = draw * 1;
    }
    if (!data) {
      data = [];
    }
    _fnClearTable(settings);
    settings._iRecordsTotal = parseInt(recordsTotal, 10);
    settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
    for (var i2 = 0, ien = data.length; i2 < ien; i2++) {
      _fnAddData(settings, data[i2]);
    }
    settings.aiDisplay = settings.aiDisplayMaster.slice();
    _fnDraw(settings, true);
    if (!settings._bInitComplete) {
      _fnInitComplete(settings, json);
    }
    _fnProcessingDisplay(settings, false);
  }
  function _fnAjaxDataSrc(oSettings, json, write2) {
    var dataSrc = $4.isPlainObject(oSettings.ajax) && oSettings.ajax.dataSrc !== void 0 ? oSettings.ajax.dataSrc : oSettings.sAjaxDataProp;
    if (!write2) {
      if (dataSrc === "data") {
        return json.aaData || json[dataSrc];
      }
      return dataSrc !== "" ? _fnGetObjectDataFn(dataSrc)(json) : json;
    }
    _fnSetObjectDataFn(dataSrc)(json, write2);
  }
  function _fnFeatureHtmlFilter(settings) {
    var classes = settings.oClasses;
    var tableId = settings.sTableId;
    var language = settings.oLanguage;
    var previousSearch = settings.oPreviousSearch;
    var features = settings.aanFeatures;
    var input = '<input type="search" class="' + classes.sFilterInput + '"/>';
    var str = language.sSearch;
    str = str.match(/_INPUT_/) ? str.replace("_INPUT_", input) : str + input;
    var filter = $4("<div/>", {
      "id": !features.f ? tableId + "_filter" : null,
      "class": classes.sFilter
    }).append($4("<label/>").append(str));
    var searchFn = function(event) {
      var n2 = features.f;
      var val = !this.value ? "" : this.value;
      if (previousSearch["return"] && event.key !== "Enter") {
        return;
      }
      if (val != previousSearch.sSearch) {
        _fnFilterComplete(settings, {
          "sSearch": val,
          "bRegex": previousSearch.bRegex,
          "bSmart": previousSearch.bSmart,
          "bCaseInsensitive": previousSearch.bCaseInsensitive,
          "return": previousSearch["return"]
        });
        settings._iDisplayStart = 0;
        _fnDraw(settings);
      }
    };
    var searchDelay = settings.searchDelay !== null ? settings.searchDelay : _fnDataSource(settings) === "ssp" ? 400 : 0;
    var jqFilter = $4("input", filter).val(previousSearch.sSearch).attr("placeholder", language.sSearchPlaceholder).on(
      "keyup.DT search.DT input.DT paste.DT cut.DT",
      searchDelay ? _fnThrottle(searchFn, searchDelay) : searchFn
    ).on("mouseup.DT", function(e2) {
      setTimeout(function() {
        searchFn.call(jqFilter[0], e2);
      }, 10);
    }).on("keypress.DT", function(e2) {
      if (e2.keyCode == 13) {
        return false;
      }
    }).attr("aria-controls", tableId);
    $4(settings.nTable).on("search.dt.DT", function(ev, s2) {
      if (settings === s2) {
        try {
          if (jqFilter[0] !== document.activeElement) {
            jqFilter.val(previousSearch.sSearch);
          }
        } catch (e2) {
        }
      }
    });
    return filter[0];
  }
  function _fnFilterComplete(oSettings, oInput, iForce) {
    var oPrevSearch = oSettings.oPreviousSearch;
    var aoPrevSearch = oSettings.aoPreSearchCols;
    var fnSaveFilter = function(oFilter) {
      oPrevSearch.sSearch = oFilter.sSearch;
      oPrevSearch.bRegex = oFilter.bRegex;
      oPrevSearch.bSmart = oFilter.bSmart;
      oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
      oPrevSearch["return"] = oFilter["return"];
    };
    var fnRegex = function(o2) {
      return o2.bEscapeRegex !== void 0 ? !o2.bEscapeRegex : o2.bRegex;
    };
    _fnColumnTypes(oSettings);
    if (_fnDataSource(oSettings) != "ssp") {
      _fnFilter(oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive);
      fnSaveFilter(oInput);
      for (var i2 = 0; i2 < aoPrevSearch.length; i2++) {
        _fnFilterColumn(
          oSettings,
          aoPrevSearch[i2].sSearch,
          i2,
          fnRegex(aoPrevSearch[i2]),
          aoPrevSearch[i2].bSmart,
          aoPrevSearch[i2].bCaseInsensitive
        );
      }
      _fnFilterCustom(oSettings);
    } else {
      fnSaveFilter(oInput);
    }
    oSettings.bFiltered = true;
    _fnCallbackFire(oSettings, null, "search", [oSettings]);
  }
  function _fnFilterCustom(settings) {
    var filters = DataTable.ext.search;
    var displayRows = settings.aiDisplay;
    var row, rowIdx;
    for (var i2 = 0, ien = filters.length; i2 < ien; i2++) {
      var rows = [];
      for (var j2 = 0, jen = displayRows.length; j2 < jen; j2++) {
        rowIdx = displayRows[j2];
        row = settings.aoData[rowIdx];
        if (filters[i2](settings, row._aFilterData, rowIdx, row._aData, j2)) {
          rows.push(rowIdx);
        }
      }
      displayRows.length = 0;
      $4.merge(displayRows, rows);
    }
  }
  function _fnFilterColumn(settings, searchStr, colIdx, regex, smart, caseInsensitive) {
    if (searchStr === "") {
      return;
    }
    var data;
    var out = [];
    var display = settings.aiDisplay;
    var rpSearch = _fnFilterCreateSearch(searchStr, regex, smart, caseInsensitive);
    for (var i2 = 0; i2 < display.length; i2++) {
      data = settings.aoData[display[i2]]._aFilterData[colIdx];
      if (rpSearch.test(data)) {
        out.push(display[i2]);
      }
    }
    settings.aiDisplay = out;
  }
  function _fnFilter(settings, input, force, regex, smart, caseInsensitive) {
    var rpSearch = _fnFilterCreateSearch(input, regex, smart, caseInsensitive);
    var prevSearch = settings.oPreviousSearch.sSearch;
    var displayMaster = settings.aiDisplayMaster;
    var display, invalidated, i2;
    var filtered = [];
    if (DataTable.ext.search.length !== 0) {
      force = true;
    }
    invalidated = _fnFilterData(settings);
    if (input.length <= 0) {
      settings.aiDisplay = displayMaster.slice();
    } else {
      if (invalidated || force || regex || prevSearch.length > input.length || input.indexOf(prevSearch) !== 0 || settings.bSorted) {
        settings.aiDisplay = displayMaster.slice();
      }
      display = settings.aiDisplay;
      for (i2 = 0; i2 < display.length; i2++) {
        if (rpSearch.test(settings.aoData[display[i2]]._sFilterRow)) {
          filtered.push(display[i2]);
        }
      }
      settings.aiDisplay = filtered;
    }
  }
  function _fnFilterCreateSearch(search, regex, smart, caseInsensitive) {
    search = regex ? search : _fnEscapeRegex(search);
    if (smart) {
      var a2 = $4.map(search.match(/["\u201C][^"\u201D]+["\u201D]|[^ ]+/g) || [""], function(word) {
        if (word.charAt(0) === '"') {
          var m2 = word.match(/^"(.*)"$/);
          word = m2 ? m2[1] : word;
        } else if (word.charAt(0) === "\u201C") {
          var m2 = word.match(/^\u201C(.*)\u201D$/);
          word = m2 ? m2[1] : word;
        }
        return word.replace('"', "");
      });
      search = "^(?=.*?" + a2.join(")(?=.*?") + ").*$";
    }
    return new RegExp(search, caseInsensitive ? "i" : "");
  }
  var _fnEscapeRegex = DataTable.util.escapeRegex;
  var __filter_div = $4("<div>")[0];
  var __filter_div_textContent = __filter_div.textContent !== void 0;
  function _fnFilterData(settings) {
    var columns = settings.aoColumns;
    var column;
    var i2, j2, ien, jen, filterData, cellData, row;
    var wasInvalidated = false;
    for (i2 = 0, ien = settings.aoData.length; i2 < ien; i2++) {
      row = settings.aoData[i2];
      if (!row._aFilterData) {
        filterData = [];
        for (j2 = 0, jen = columns.length; j2 < jen; j2++) {
          column = columns[j2];
          if (column.bSearchable) {
            cellData = _fnGetCellData(settings, i2, j2, "filter");
            if (cellData === null) {
              cellData = "";
            }
            if (typeof cellData !== "string" && cellData.toString) {
              cellData = cellData.toString();
            }
          } else {
            cellData = "";
          }
          if (cellData.indexOf && cellData.indexOf("&") !== -1) {
            __filter_div.innerHTML = cellData;
            cellData = __filter_div_textContent ? __filter_div.textContent : __filter_div.innerText;
          }
          if (cellData.replace) {
            cellData = cellData.replace(/[\r\n\u2028]/g, "");
          }
          filterData.push(cellData);
        }
        row._aFilterData = filterData;
        row._sFilterRow = filterData.join("  ");
        wasInvalidated = true;
      }
    }
    return wasInvalidated;
  }
  function _fnSearchToCamel(obj) {
    return {
      search: obj.sSearch,
      smart: obj.bSmart,
      regex: obj.bRegex,
      caseInsensitive: obj.bCaseInsensitive
    };
  }
  function _fnSearchToHung(obj) {
    return {
      sSearch: obj.search,
      bSmart: obj.smart,
      bRegex: obj.regex,
      bCaseInsensitive: obj.caseInsensitive
    };
  }
  function _fnFeatureHtmlInfo(settings) {
    var tid = settings.sTableId, nodes = settings.aanFeatures.i, n2 = $4("<div/>", {
      "class": settings.oClasses.sInfo,
      "id": !nodes ? tid + "_info" : null
    });
    if (!nodes) {
      settings.aoDrawCallback.push({
        "fn": _fnUpdateInfo,
        "sName": "information"
      });
      n2.attr("role", "status").attr("aria-live", "polite");
      $4(settings.nTable).attr("aria-describedby", tid + "_info");
    }
    return n2[0];
  }
  function _fnUpdateInfo(settings) {
    var nodes = settings.aanFeatures.i;
    if (nodes.length === 0) {
      return;
    }
    var lang = settings.oLanguage, start3 = settings._iDisplayStart + 1, end2 = settings.fnDisplayEnd(), max2 = settings.fnRecordsTotal(), total = settings.fnRecordsDisplay(), out = total ? lang.sInfo : lang.sInfoEmpty;
    if (total !== max2) {
      out += " " + lang.sInfoFiltered;
    }
    out += lang.sInfoPostFix;
    out = _fnInfoMacros(settings, out);
    var callback = lang.fnInfoCallback;
    if (callback !== null) {
      out = callback.call(
        settings.oInstance,
        settings,
        start3,
        end2,
        max2,
        total,
        out
      );
    }
    $4(nodes).html(out);
  }
  function _fnInfoMacros(settings, str) {
    var formatter = settings.fnFormatNumber, start3 = settings._iDisplayStart + 1, len = settings._iDisplayLength, vis = settings.fnRecordsDisplay(), all = len === -1;
    return str.replace(/_START_/g, formatter.call(settings, start3)).replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).replace(/_MAX_/g, formatter.call(settings, settings.fnRecordsTotal())).replace(/_TOTAL_/g, formatter.call(settings, vis)).replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start3 / len))).replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len)));
  }
  function _fnInitialise(settings) {
    var i2, iLen, iAjaxStart = settings.iInitDisplayStart;
    var columns = settings.aoColumns, column;
    var features = settings.oFeatures;
    var deferLoading = settings.bDeferLoading;
    if (!settings.bInitialised) {
      setTimeout(function() {
        _fnInitialise(settings);
      }, 200);
      return;
    }
    _fnAddOptionsHtml(settings);
    _fnBuildHead(settings);
    _fnDrawHead(settings, settings.aoHeader);
    _fnDrawHead(settings, settings.aoFooter);
    _fnProcessingDisplay(settings, true);
    if (features.bAutoWidth) {
      _fnCalculateColumnWidths(settings);
    }
    for (i2 = 0, iLen = columns.length; i2 < iLen; i2++) {
      column = columns[i2];
      if (column.sWidth) {
        column.nTh.style.width = _fnStringToCss(column.sWidth);
      }
    }
    _fnCallbackFire(settings, null, "preInit", [settings]);
    _fnReDraw(settings);
    var dataSrc = _fnDataSource(settings);
    if (dataSrc != "ssp" || deferLoading) {
      if (dataSrc == "ajax") {
        _fnBuildAjax(settings, [], function(json) {
          var aData = _fnAjaxDataSrc(settings, json);
          for (i2 = 0; i2 < aData.length; i2++) {
            _fnAddData(settings, aData[i2]);
          }
          settings.iInitDisplayStart = iAjaxStart;
          _fnReDraw(settings);
          _fnProcessingDisplay(settings, false);
          _fnInitComplete(settings, json);
        }, settings);
      } else {
        _fnProcessingDisplay(settings, false);
        _fnInitComplete(settings);
      }
    }
  }
  function _fnInitComplete(settings, json) {
    settings._bInitComplete = true;
    if (json || settings.oInit.aaData) {
      _fnAdjustColumnSizing(settings);
    }
    _fnCallbackFire(settings, null, "plugin-init", [settings, json]);
    _fnCallbackFire(settings, "aoInitComplete", "init", [settings, json]);
  }
  function _fnLengthChange(settings, val) {
    var len = parseInt(val, 10);
    settings._iDisplayLength = len;
    _fnLengthOverflow(settings);
    _fnCallbackFire(settings, null, "length", [settings, len]);
  }
  function _fnFeatureHtmlLength(settings) {
    var classes = settings.oClasses, tableId = settings.sTableId, menu = settings.aLengthMenu, d2 = Array.isArray(menu[0]), lengths = d2 ? menu[0] : menu, language = d2 ? menu[1] : menu;
    var select = $4("<select/>", {
      "name": tableId + "_length",
      "aria-controls": tableId,
      "class": classes.sLengthSelect
    });
    for (var i2 = 0, ien = lengths.length; i2 < ien; i2++) {
      select[0][i2] = new Option(
        typeof language[i2] === "number" ? settings.fnFormatNumber(language[i2]) : language[i2],
        lengths[i2]
      );
    }
    var div = $4("<div><label/></div>").addClass(classes.sLength);
    if (!settings.aanFeatures.l) {
      div[0].id = tableId + "_length";
    }
    div.children().append(
      settings.oLanguage.sLengthMenu.replace("_MENU_", select[0].outerHTML)
    );
    $4("select", div).val(settings._iDisplayLength).on("change.DT", function(e2) {
      _fnLengthChange(settings, $4(this).val());
      _fnDraw(settings);
    });
    $4(settings.nTable).on("length.dt.DT", function(e2, s2, len) {
      if (settings === s2) {
        $4("select", div).val(len);
      }
    });
    return div[0];
  }
  function _fnFeatureHtmlPaginate(settings) {
    var type = settings.sPaginationType, plugin = DataTable.ext.pager[type], modern = typeof plugin === "function", redraw = function(settings2) {
      _fnDraw(settings2);
    }, node = $4("<div/>").addClass(settings.oClasses.sPaging + type)[0], features = settings.aanFeatures;
    if (!modern) {
      plugin.fnInit(settings, node, redraw);
    }
    if (!features.p) {
      node.id = settings.sTableId + "_paginate";
      settings.aoDrawCallback.push({
        "fn": function(settings2) {
          if (modern) {
            var start3 = settings2._iDisplayStart, len = settings2._iDisplayLength, visRecords = settings2.fnRecordsDisplay(), all = len === -1, page = all ? 0 : Math.ceil(start3 / len), pages = all ? 1 : Math.ceil(visRecords / len), buttons = plugin(page, pages), i2, ien;
            for (i2 = 0, ien = features.p.length; i2 < ien; i2++) {
              _fnRenderer(settings2, "pageButton")(
                settings2,
                features.p[i2],
                i2,
                buttons,
                page,
                pages
              );
            }
          } else {
            plugin.fnUpdate(settings2, redraw);
          }
        },
        "sName": "pagination"
      });
    }
    return node;
  }
  function _fnPageChange(settings, action, redraw) {
    var start3 = settings._iDisplayStart, len = settings._iDisplayLength, records = settings.fnRecordsDisplay();
    if (records === 0 || len === -1) {
      start3 = 0;
    } else if (typeof action === "number") {
      start3 = action * len;
      if (start3 > records) {
        start3 = 0;
      }
    } else if (action == "first") {
      start3 = 0;
    } else if (action == "previous") {
      start3 = len >= 0 ? start3 - len : 0;
      if (start3 < 0) {
        start3 = 0;
      }
    } else if (action == "next") {
      if (start3 + len < records) {
        start3 += len;
      }
    } else if (action == "last") {
      start3 = Math.floor((records - 1) / len) * len;
    } else {
      _fnLog(settings, 0, "Unknown paging action: " + action, 5);
    }
    var changed = settings._iDisplayStart !== start3;
    settings._iDisplayStart = start3;
    if (changed) {
      _fnCallbackFire(settings, null, "page", [settings]);
      if (redraw) {
        _fnDraw(settings);
      }
    } else {
      _fnCallbackFire(settings, null, "page-nc", [settings]);
    }
    return changed;
  }
  function _fnFeatureHtmlProcessing(settings) {
    return $4("<div/>", {
      "id": !settings.aanFeatures.r ? settings.sTableId + "_processing" : null,
      "class": settings.oClasses.sProcessing,
      "role": "status"
    }).html(settings.oLanguage.sProcessing).append("<div><div></div><div></div><div></div><div></div></div>").insertBefore(settings.nTable)[0];
  }
  function _fnProcessingDisplay(settings, show) {
    if (settings.oFeatures.bProcessing) {
      $4(settings.aanFeatures.r).css("display", show ? "block" : "none");
    }
    _fnCallbackFire(settings, null, "processing", [settings, show]);
  }
  function _fnFeatureHtmlTable(settings) {
    var table = $4(settings.nTable);
    var scroll = settings.oScroll;
    if (scroll.sX === "" && scroll.sY === "") {
      return settings.nTable;
    }
    var scrollX = scroll.sX;
    var scrollY = scroll.sY;
    var classes = settings.oClasses;
    var caption = table.children("caption");
    var captionSide = caption.length ? caption[0]._captionSide : null;
    var headerClone = $4(table[0].cloneNode(false));
    var footerClone = $4(table[0].cloneNode(false));
    var footer = table.children("tfoot");
    var _div = "<div/>";
    var size = function(s2) {
      return !s2 ? null : _fnStringToCss(s2);
    };
    if (!footer.length) {
      footer = null;
    }
    var scroller = $4(_div, { "class": classes.sScrollWrapper }).append(
      $4(_div, { "class": classes.sScrollHead }).css({
        overflow: "hidden",
        position: "relative",
        border: 0,
        width: scrollX ? size(scrollX) : "100%"
      }).append(
        $4(_div, { "class": classes.sScrollHeadInner }).css({
          "box-sizing": "content-box",
          width: scroll.sXInner || "100%"
        }).append(
          headerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "top" ? caption : null).append(
            table.children("thead")
          )
        )
      )
    ).append(
      $4(_div, { "class": classes.sScrollBody }).css({
        position: "relative",
        overflow: "auto",
        width: size(scrollX)
      }).append(table)
    );
    if (footer) {
      scroller.append(
        $4(_div, { "class": classes.sScrollFoot }).css({
          overflow: "hidden",
          border: 0,
          width: scrollX ? size(scrollX) : "100%"
        }).append(
          $4(_div, { "class": classes.sScrollFootInner }).append(
            footerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "bottom" ? caption : null).append(
              table.children("tfoot")
            )
          )
        )
      );
    }
    var children = scroller.children();
    var scrollHead = children[0];
    var scrollBody = children[1];
    var scrollFoot = footer ? children[2] : null;
    if (scrollX) {
      $4(scrollBody).on("scroll.DT", function(e2) {
        var scrollLeft = this.scrollLeft;
        scrollHead.scrollLeft = scrollLeft;
        if (footer) {
          scrollFoot.scrollLeft = scrollLeft;
        }
      });
    }
    $4(scrollBody).css("max-height", scrollY);
    if (!scroll.bCollapse) {
      $4(scrollBody).css("height", scrollY);
    }
    settings.nScrollHead = scrollHead;
    settings.nScrollBody = scrollBody;
    settings.nScrollFoot = scrollFoot;
    settings.aoDrawCallback.push({
      "fn": _fnScrollDraw,
      "sName": "scrolling"
    });
    return scroller[0];
  }
  function _fnScrollDraw(settings) {
    var scroll = settings.oScroll, scrollX = scroll.sX, scrollXInner = scroll.sXInner, scrollY = scroll.sY, barWidth = scroll.iBarWidth, divHeader = $4(settings.nScrollHead), divHeaderStyle = divHeader[0].style, divHeaderInner = divHeader.children("div"), divHeaderInnerStyle = divHeaderInner[0].style, divHeaderTable = divHeaderInner.children("table"), divBodyEl = settings.nScrollBody, divBody = $4(divBodyEl), divBodyStyle = divBodyEl.style, divFooter = $4(settings.nScrollFoot), divFooterInner = divFooter.children("div"), divFooterTable = divFooterInner.children("table"), header = $4(settings.nTHead), table = $4(settings.nTable), tableEl = table[0], tableStyle = tableEl.style, footer = settings.nTFoot ? $4(settings.nTFoot) : null, browser = settings.oBrowser, ie67 = browser.bScrollOversize, dtHeaderCells = _pluck(settings.aoColumns, "nTh"), headerTrgEls, footerTrgEls, headerSrcEls, footerSrcEls, headerCopy, footerCopy, headerWidths = [], footerWidths = [], headerContent = [], footerContent = [], idx, correction, sanityWidth, zeroOut = function(nSizer) {
      var style = nSizer.style;
      style.paddingTop = "0";
      style.paddingBottom = "0";
      style.borderTopWidth = "0";
      style.borderBottomWidth = "0";
      style.height = 0;
    };
    var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
    if (settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== void 0) {
      settings.scrollBarVis = scrollBarVis;
      _fnAdjustColumnSizing(settings);
      return;
    } else {
      settings.scrollBarVis = scrollBarVis;
    }
    table.children("thead, tfoot").remove();
    if (footer) {
      footerCopy = footer.clone().prependTo(table);
      footerTrgEls = footer.find("tr");
      footerSrcEls = footerCopy.find("tr");
      footerCopy.find("[id]").removeAttr("id");
    }
    headerCopy = header.clone().prependTo(table);
    headerTrgEls = header.find("tr");
    headerSrcEls = headerCopy.find("tr");
    headerCopy.find("th, td").removeAttr("tabindex");
    headerCopy.find("[id]").removeAttr("id");
    if (!scrollX) {
      divBodyStyle.width = "100%";
      divHeader[0].style.width = "100%";
    }
    $4.each(_fnGetUniqueThs(settings, headerCopy), function(i2, el) {
      idx = _fnVisibleToColumnIndex(settings, i2);
      el.style.width = settings.aoColumns[idx].sWidth;
    });
    if (footer) {
      _fnApplyToChildren(function(n2) {
        n2.style.width = "";
      }, footerSrcEls);
    }
    sanityWidth = table.outerWidth();
    if (scrollX === "") {
      tableStyle.width = "100%";
      if (ie67 && (table.find("tbody").height() > divBodyEl.offsetHeight || divBody.css("overflow-y") == "scroll")) {
        tableStyle.width = _fnStringToCss(table.outerWidth() - barWidth);
      }
      sanityWidth = table.outerWidth();
    } else if (scrollXInner !== "") {
      tableStyle.width = _fnStringToCss(scrollXInner);
      sanityWidth = table.outerWidth();
    }
    _fnApplyToChildren(zeroOut, headerSrcEls);
    _fnApplyToChildren(function(nSizer) {
      var style = window.getComputedStyle ? window.getComputedStyle(nSizer).width : _fnStringToCss($4(nSizer).width());
      headerContent.push(nSizer.innerHTML);
      headerWidths.push(style);
    }, headerSrcEls);
    _fnApplyToChildren(function(nToSize, i2) {
      nToSize.style.width = headerWidths[i2];
    }, headerTrgEls);
    $4(headerSrcEls).css("height", 0);
    if (footer) {
      _fnApplyToChildren(zeroOut, footerSrcEls);
      _fnApplyToChildren(function(nSizer) {
        footerContent.push(nSizer.innerHTML);
        footerWidths.push(_fnStringToCss($4(nSizer).css("width")));
      }, footerSrcEls);
      _fnApplyToChildren(function(nToSize, i2) {
        nToSize.style.width = footerWidths[i2];
      }, footerTrgEls);
      $4(footerSrcEls).height(0);
    }
    _fnApplyToChildren(function(nSizer, i2) {
      nSizer.innerHTML = '<div class="dataTables_sizing">' + headerContent[i2] + "</div>";
      nSizer.childNodes[0].style.height = "0";
      nSizer.childNodes[0].style.overflow = "hidden";
      nSizer.style.width = headerWidths[i2];
    }, headerSrcEls);
    if (footer) {
      _fnApplyToChildren(function(nSizer, i2) {
        nSizer.innerHTML = '<div class="dataTables_sizing">' + footerContent[i2] + "</div>";
        nSizer.childNodes[0].style.height = "0";
        nSizer.childNodes[0].style.overflow = "hidden";
        nSizer.style.width = footerWidths[i2];
      }, footerSrcEls);
    }
    if (Math.round(table.outerWidth()) < Math.round(sanityWidth)) {
      correction = divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css("overflow-y") == "scroll" ? sanityWidth + barWidth : sanityWidth;
      if (ie67 && (divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css("overflow-y") == "scroll")) {
        tableStyle.width = _fnStringToCss(correction - barWidth);
      }
      if (scrollX === "" || scrollXInner !== "") {
        _fnLog(settings, 1, "Possible column misalignment", 6);
      }
    } else {
      correction = "100%";
    }
    divBodyStyle.width = _fnStringToCss(correction);
    divHeaderStyle.width = _fnStringToCss(correction);
    if (footer) {
      settings.nScrollFoot.style.width = _fnStringToCss(correction);
    }
    if (!scrollY) {
      if (ie67) {
        divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + barWidth);
      }
    }
    var iOuterWidth = table.outerWidth();
    divHeaderTable[0].style.width = _fnStringToCss(iOuterWidth);
    divHeaderInnerStyle.width = _fnStringToCss(iOuterWidth);
    var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css("overflow-y") == "scroll";
    var padding = "padding" + (browser.bScrollbarLeft ? "Left" : "Right");
    divHeaderInnerStyle[padding] = bScrolling ? barWidth + "px" : "0px";
    if (footer) {
      divFooterTable[0].style.width = _fnStringToCss(iOuterWidth);
      divFooterInner[0].style.width = _fnStringToCss(iOuterWidth);
      divFooterInner[0].style[padding] = bScrolling ? barWidth + "px" : "0px";
    }
    table.children("colgroup").insertBefore(table.children("thead"));
    divBody.trigger("scroll");
    if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
      divBodyEl.scrollTop = 0;
    }
  }
  function _fnApplyToChildren(fn2, an1, an2) {
    var index = 0, i2 = 0, iLen = an1.length;
    var nNode1, nNode2;
    while (i2 < iLen) {
      nNode1 = an1[i2].firstChild;
      nNode2 = an2 ? an2[i2].firstChild : null;
      while (nNode1) {
        if (nNode1.nodeType === 1) {
          if (an2) {
            fn2(nNode1, nNode2, index);
          } else {
            fn2(nNode1, index);
          }
          index++;
        }
        nNode1 = nNode1.nextSibling;
        nNode2 = an2 ? nNode2.nextSibling : null;
      }
      i2++;
    }
  }
  var __re_html_remove = /<.*?>/g;
  function _fnCalculateColumnWidths(oSettings) {
    var table = oSettings.nTable, columns = oSettings.aoColumns, scroll = oSettings.oScroll, scrollY = scroll.sY, scrollX = scroll.sX, scrollXInner = scroll.sXInner, columnCount = columns.length, visibleColumns = _fnGetColumns(oSettings, "bVisible"), headerCells = $4("th", oSettings.nTHead), tableWidthAttr = table.getAttribute("width"), tableContainer = table.parentNode, userInputs = false, i2, column, columnIdx, width, outerWidth, browser = oSettings.oBrowser, ie67 = browser.bScrollOversize;
    var styleWidth = table.style.width;
    if (styleWidth && styleWidth.indexOf("%") !== -1) {
      tableWidthAttr = styleWidth;
    }
    var sizes = _fnConvertToWidth(_pluck(columns, "sWidthOrig"), tableContainer);
    for (i2 = 0; i2 < visibleColumns.length; i2++) {
      column = columns[visibleColumns[i2]];
      if (column.sWidth !== null) {
        column.sWidth = sizes[i2];
        userInputs = true;
      }
    }
    if (ie67 || !userInputs && !scrollX && !scrollY && columnCount == _fnVisbleColumns(oSettings) && columnCount == headerCells.length) {
      for (i2 = 0; i2 < columnCount; i2++) {
        var colIdx = _fnVisibleToColumnIndex(oSettings, i2);
        if (colIdx !== null) {
          columns[colIdx].sWidth = _fnStringToCss(headerCells.eq(i2).width());
        }
      }
    } else {
      var tmpTable = $4(table).clone().css("visibility", "hidden").removeAttr("id");
      tmpTable.find("tbody tr").remove();
      var tr = $4("<tr/>").appendTo(tmpTable.find("tbody"));
      tmpTable.find("thead, tfoot").remove();
      tmpTable.append($4(oSettings.nTHead).clone()).append($4(oSettings.nTFoot).clone());
      tmpTable.find("tfoot th, tfoot td").css("width", "");
      headerCells = _fnGetUniqueThs(oSettings, tmpTable.find("thead")[0]);
      for (i2 = 0; i2 < visibleColumns.length; i2++) {
        column = columns[visibleColumns[i2]];
        headerCells[i2].style.width = column.sWidthOrig !== null && column.sWidthOrig !== "" ? _fnStringToCss(column.sWidthOrig) : "";
        if (column.sWidthOrig && scrollX) {
          $4(headerCells[i2]).append($4("<div/>").css({
            width: column.sWidthOrig,
            margin: 0,
            padding: 0,
            border: 0,
            height: 1
          }));
        }
      }
      if (oSettings.aoData.length) {
        for (i2 = 0; i2 < visibleColumns.length; i2++) {
          columnIdx = visibleColumns[i2];
          column = columns[columnIdx];
          $4(_fnGetWidestNode(oSettings, columnIdx)).clone(false).append(column.sContentPadding).appendTo(tr);
        }
      }
      $4("[name]", tmpTable).removeAttr("name");
      var holder = $4("<div/>").css(
        scrollX || scrollY ? {
          position: "absolute",
          top: 0,
          left: 0,
          height: 1,
          right: 0,
          overflow: "hidden"
        } : {}
      ).append(tmpTable).appendTo(tableContainer);
      if (scrollX && scrollXInner) {
        tmpTable.width(scrollXInner);
      } else if (scrollX) {
        tmpTable.css("width", "auto");
        tmpTable.removeAttr("width");
        if (tmpTable.width() < tableContainer.clientWidth && tableWidthAttr) {
          tmpTable.width(tableContainer.clientWidth);
        }
      } else if (scrollY) {
        tmpTable.width(tableContainer.clientWidth);
      } else if (tableWidthAttr) {
        tmpTable.width(tableWidthAttr);
      }
      var total = 0;
      for (i2 = 0; i2 < visibleColumns.length; i2++) {
        var cell = $4(headerCells[i2]);
        var border = cell.outerWidth() - cell.width();
        var bounding = browser.bBounding ? Math.ceil(headerCells[i2].getBoundingClientRect().width) : cell.outerWidth();
        total += bounding;
        columns[visibleColumns[i2]].sWidth = _fnStringToCss(bounding - border);
      }
      table.style.width = _fnStringToCss(total);
      holder.remove();
    }
    if (tableWidthAttr) {
      table.style.width = _fnStringToCss(tableWidthAttr);
    }
    if ((tableWidthAttr || scrollX) && !oSettings._reszEvt) {
      var bindResize = function() {
        $4(window).on("resize.DT-" + oSettings.sInstance, _fnThrottle(function() {
          _fnAdjustColumnSizing(oSettings);
        }));
      };
      if (ie67) {
        setTimeout(bindResize, 1e3);
      } else {
        bindResize();
      }
      oSettings._reszEvt = true;
    }
  }
  var _fnThrottle = DataTable.util.throttle;
  function _fnConvertToWidth(widths, parent) {
    var els = [];
    var results = [];
    for (var i2 = 0; i2 < widths.length; i2++) {
      if (widths[i2]) {
        els.push(
          $4("<div/>").css("width", _fnStringToCss(widths[i2])).appendTo(parent || document.body)
        );
      } else {
        els.push(null);
      }
    }
    for (var i2 = 0; i2 < widths.length; i2++) {
      results.push(els[i2] ? els[i2][0].offsetWidth : null);
    }
    $4(els).remove();
    return results;
  }
  function _fnGetWidestNode(settings, colIdx) {
    var idx = _fnGetMaxLenString(settings, colIdx);
    if (idx < 0) {
      return null;
    }
    var data = settings.aoData[idx];
    return !data.nTr ? (
      // Might not have been created when deferred rendering
      $4("<td/>").html(_fnGetCellData(settings, idx, colIdx, "display"))[0]
    ) : data.anCells[colIdx];
  }
  function _fnGetMaxLenString(settings, colIdx) {
    var s2, max2 = -1, maxIdx = -1;
    for (var i2 = 0, ien = settings.aoData.length; i2 < ien; i2++) {
      s2 = _fnGetCellData(settings, i2, colIdx, "display") + "";
      s2 = s2.replace(__re_html_remove, "");
      s2 = s2.replace(/&nbsp;/g, " ");
      if (s2.length > max2) {
        max2 = s2.length;
        maxIdx = i2;
      }
    }
    return maxIdx;
  }
  function _fnStringToCss(s2) {
    if (s2 === null) {
      return "0px";
    }
    if (typeof s2 == "number") {
      return s2 < 0 ? "0px" : s2 + "px";
    }
    return s2.match(/\d$/) ? s2 + "px" : s2;
  }
  function _fnSortFlatten(settings) {
    var i2, iLen, k2, kLen, aSort = [], aiOrig = [], aoColumns = settings.aoColumns, aDataSort, iCol, sType, srcCol, fixed = settings.aaSortingFixed, fixedObj = $4.isPlainObject(fixed), nestedSort = [], add2 = function(a2) {
      if (a2.length && !Array.isArray(a2[0])) {
        nestedSort.push(a2);
      } else {
        $4.merge(nestedSort, a2);
      }
    };
    if (Array.isArray(fixed)) {
      add2(fixed);
    }
    if (fixedObj && fixed.pre) {
      add2(fixed.pre);
    }
    add2(settings.aaSorting);
    if (fixedObj && fixed.post) {
      add2(fixed.post);
    }
    for (i2 = 0; i2 < nestedSort.length; i2++) {
      srcCol = nestedSort[i2][0];
      aDataSort = aoColumns[srcCol].aDataSort;
      for (k2 = 0, kLen = aDataSort.length; k2 < kLen; k2++) {
        iCol = aDataSort[k2];
        sType = aoColumns[iCol].sType || "string";
        if (nestedSort[i2]._idx === void 0) {
          nestedSort[i2]._idx = $4.inArray(nestedSort[i2][1], aoColumns[iCol].asSorting);
        }
        aSort.push({
          src: srcCol,
          col: iCol,
          dir: nestedSort[i2][1],
          index: nestedSort[i2]._idx,
          type: sType,
          formatter: DataTable.ext.type.order[sType + "-pre"]
        });
      }
    }
    return aSort;
  }
  function _fnSort(oSettings) {
    var i2, ien, iLen, j2, jLen, k2, kLen, sDataType, nTh, aiOrig = [], oExtSort = DataTable.ext.type.order, aoData = oSettings.aoData, aoColumns = oSettings.aoColumns, aDataSort, data, iCol, sType, oSort, formatters = 0, sortCol, displayMaster = oSettings.aiDisplayMaster, aSort;
    _fnColumnTypes(oSettings);
    aSort = _fnSortFlatten(oSettings);
    for (i2 = 0, ien = aSort.length; i2 < ien; i2++) {
      sortCol = aSort[i2];
      if (sortCol.formatter) {
        formatters++;
      }
      _fnSortData(oSettings, sortCol.col);
    }
    if (_fnDataSource(oSettings) != "ssp" && aSort.length !== 0) {
      for (i2 = 0, iLen = displayMaster.length; i2 < iLen; i2++) {
        aiOrig[displayMaster[i2]] = i2;
      }
      if (formatters === aSort.length) {
        displayMaster.sort(function(a2, b2) {
          var x2, y2, k3, test, sort, len = aSort.length, dataA = aoData[a2]._aSortData, dataB = aoData[b2]._aSortData;
          for (k3 = 0; k3 < len; k3++) {
            sort = aSort[k3];
            x2 = dataA[sort.col];
            y2 = dataB[sort.col];
            test = x2 < y2 ? -1 : x2 > y2 ? 1 : 0;
            if (test !== 0) {
              return sort.dir === "asc" ? test : -test;
            }
          }
          x2 = aiOrig[a2];
          y2 = aiOrig[b2];
          return x2 < y2 ? -1 : x2 > y2 ? 1 : 0;
        });
      } else {
        displayMaster.sort(function(a2, b2) {
          var x2, y2, k3, l2, test, sort, fn2, len = aSort.length, dataA = aoData[a2]._aSortData, dataB = aoData[b2]._aSortData;
          for (k3 = 0; k3 < len; k3++) {
            sort = aSort[k3];
            x2 = dataA[sort.col];
            y2 = dataB[sort.col];
            fn2 = oExtSort[sort.type + "-" + sort.dir] || oExtSort["string-" + sort.dir];
            test = fn2(x2, y2);
            if (test !== 0) {
              return test;
            }
          }
          x2 = aiOrig[a2];
          y2 = aiOrig[b2];
          return x2 < y2 ? -1 : x2 > y2 ? 1 : 0;
        });
      }
    }
    oSettings.bSorted = true;
  }
  function _fnSortAria(settings) {
    var label;
    var nextSort;
    var columns = settings.aoColumns;
    var aSort = _fnSortFlatten(settings);
    var oAria = settings.oLanguage.oAria;
    for (var i2 = 0, iLen = columns.length; i2 < iLen; i2++) {
      var col = columns[i2];
      var asSorting = col.asSorting;
      var sTitle = col.ariaTitle || col.sTitle.replace(/<.*?>/g, "");
      var th = col.nTh;
      th.removeAttribute("aria-sort");
      if (col.bSortable) {
        if (aSort.length > 0 && aSort[0].col == i2) {
          th.setAttribute("aria-sort", aSort[0].dir == "asc" ? "ascending" : "descending");
          nextSort = asSorting[aSort[0].index + 1] || asSorting[0];
        } else {
          nextSort = asSorting[0];
        }
        label = sTitle + (nextSort === "asc" ? oAria.sSortAscending : oAria.sSortDescending);
      } else {
        label = sTitle;
      }
      th.setAttribute("aria-label", label);
    }
  }
  function _fnSortListener(settings, colIdx, append, callback) {
    var col = settings.aoColumns[colIdx];
    var sorting = settings.aaSorting;
    var asSorting = col.asSorting;
    var nextSortIdx;
    var next = function(a2, overflow) {
      var idx = a2._idx;
      if (idx === void 0) {
        idx = $4.inArray(a2[1], asSorting);
      }
      return idx + 1 < asSorting.length ? idx + 1 : overflow ? null : 0;
    };
    if (typeof sorting[0] === "number") {
      sorting = settings.aaSorting = [sorting];
    }
    if (append && settings.oFeatures.bSortMulti) {
      var sortIdx = $4.inArray(colIdx, _pluck(sorting, "0"));
      if (sortIdx !== -1) {
        nextSortIdx = next(sorting[sortIdx], true);
        if (nextSortIdx === null && sorting.length === 1) {
          nextSortIdx = 0;
        }
        if (nextSortIdx === null) {
          sorting.splice(sortIdx, 1);
        } else {
          sorting[sortIdx][1] = asSorting[nextSortIdx];
          sorting[sortIdx]._idx = nextSortIdx;
        }
      } else {
        sorting.push([colIdx, asSorting[0], 0]);
        sorting[sorting.length - 1]._idx = 0;
      }
    } else if (sorting.length && sorting[0][0] == colIdx) {
      nextSortIdx = next(sorting[0]);
      sorting.length = 1;
      sorting[0][1] = asSorting[nextSortIdx];
      sorting[0]._idx = nextSortIdx;
    } else {
      sorting.length = 0;
      sorting.push([colIdx, asSorting[0]]);
      sorting[0]._idx = 0;
    }
    _fnReDraw(settings);
    if (typeof callback == "function") {
      callback(settings);
    }
  }
  function _fnSortAttachListener(settings, attachTo, colIdx, callback) {
    var col = settings.aoColumns[colIdx];
    _fnBindAction(attachTo, {}, function(e2) {
      if (col.bSortable === false) {
        return;
      }
      if (settings.oFeatures.bProcessing) {
        _fnProcessingDisplay(settings, true);
        setTimeout(function() {
          _fnSortListener(settings, colIdx, e2.shiftKey, callback);
          if (_fnDataSource(settings) !== "ssp") {
            _fnProcessingDisplay(settings, false);
          }
        }, 0);
      } else {
        _fnSortListener(settings, colIdx, e2.shiftKey, callback);
      }
    });
  }
  function _fnSortingClasses(settings) {
    var oldSort = settings.aLastSort;
    var sortClass = settings.oClasses.sSortColumn;
    var sort = _fnSortFlatten(settings);
    var features = settings.oFeatures;
    var i2, ien, colIdx;
    if (features.bSort && features.bSortClasses) {
      for (i2 = 0, ien = oldSort.length; i2 < ien; i2++) {
        colIdx = oldSort[i2].src;
        $4(_pluck(settings.aoData, "anCells", colIdx)).removeClass(sortClass + (i2 < 2 ? i2 + 1 : 3));
      }
      for (i2 = 0, ien = sort.length; i2 < ien; i2++) {
        colIdx = sort[i2].src;
        $4(_pluck(settings.aoData, "anCells", colIdx)).addClass(sortClass + (i2 < 2 ? i2 + 1 : 3));
      }
    }
    settings.aLastSort = sort;
  }
  function _fnSortData(settings, idx) {
    var column = settings.aoColumns[idx];
    var customSort = DataTable.ext.order[column.sSortDataType];
    var customData;
    if (customSort) {
      customData = customSort.call(
        settings.oInstance,
        settings,
        idx,
        _fnColumnIndexToVisible(settings, idx)
      );
    }
    var row, cellData;
    var formatter = DataTable.ext.type.order[column.sType + "-pre"];
    for (var i2 = 0, ien = settings.aoData.length; i2 < ien; i2++) {
      row = settings.aoData[i2];
      if (!row._aSortData) {
        row._aSortData = [];
      }
      if (!row._aSortData[idx] || customSort) {
        cellData = customSort ? customData[i2] : (
          // If there was a custom sort function, use data from there
          _fnGetCellData(settings, i2, idx, "sort")
        );
        row._aSortData[idx] = formatter ? formatter(cellData) : cellData;
      }
    }
  }
  function _fnSaveState(settings) {
    if (settings._bLoadingState) {
      return;
    }
    var state = {
      time: +/* @__PURE__ */ new Date(),
      start: settings._iDisplayStart,
      length: settings._iDisplayLength,
      order: $4.extend(true, [], settings.aaSorting),
      search: _fnSearchToCamel(settings.oPreviousSearch),
      columns: $4.map(settings.aoColumns, function(col, i2) {
        return {
          visible: col.bVisible,
          search: _fnSearchToCamel(settings.aoPreSearchCols[i2])
        };
      })
    };
    settings.oSavedState = state;
    _fnCallbackFire(settings, "aoStateSaveParams", "stateSaveParams", [settings, state]);
    if (settings.oFeatures.bStateSave && !settings.bDestroying) {
      settings.fnStateSaveCallback.call(settings.oInstance, settings, state);
    }
  }
  function _fnLoadState(settings, oInit, callback) {
    if (!settings.oFeatures.bStateSave) {
      callback();
      return;
    }
    var loaded = function(state2) {
      _fnImplementState(settings, state2, callback);
    };
    var state = settings.fnStateLoadCallback.call(settings.oInstance, settings, loaded);
    if (state !== void 0) {
      _fnImplementState(settings, state, callback);
    }
    return true;
  }
  function _fnImplementState(settings, s2, callback) {
    var i2, ien;
    var columns = settings.aoColumns;
    settings._bLoadingState = true;
    var api = settings._bInitComplete ? new DataTable.Api(settings) : null;
    if (!s2 || !s2.time) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    var abStateLoad = _fnCallbackFire(settings, "aoStateLoadParams", "stateLoadParams", [settings, s2]);
    if ($4.inArray(false, abStateLoad) !== -1) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    var duration = settings.iStateDuration;
    if (duration > 0 && s2.time < +/* @__PURE__ */ new Date() - duration * 1e3) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    if (s2.columns && columns.length !== s2.columns.length) {
      settings._bLoadingState = false;
      callback();
      return;
    }
    settings.oLoadedState = $4.extend(true, {}, s2);
    if (s2.length !== void 0) {
      if (api) {
        api.page.len(s2.length);
      } else {
        settings._iDisplayLength = s2.length;
      }
    }
    if (s2.start !== void 0) {
      if (api === null) {
        settings._iDisplayStart = s2.start;
        settings.iInitDisplayStart = s2.start;
      } else {
        _fnPageChange(settings, s2.start / settings._iDisplayLength);
      }
    }
    if (s2.order !== void 0) {
      settings.aaSorting = [];
      $4.each(s2.order, function(i3, col2) {
        settings.aaSorting.push(
          col2[0] >= columns.length ? [0, col2[1]] : col2
        );
      });
    }
    if (s2.search !== void 0) {
      $4.extend(settings.oPreviousSearch, _fnSearchToHung(s2.search));
    }
    if (s2.columns) {
      for (i2 = 0, ien = s2.columns.length; i2 < ien; i2++) {
        var col = s2.columns[i2];
        if (col.visible !== void 0) {
          if (api) {
            api.column(i2).visible(col.visible, false);
          } else {
            columns[i2].bVisible = col.visible;
          }
        }
        if (col.search !== void 0) {
          $4.extend(settings.aoPreSearchCols[i2], _fnSearchToHung(col.search));
        }
      }
      if (api) {
        api.columns.adjust();
      }
    }
    settings._bLoadingState = false;
    _fnCallbackFire(settings, "aoStateLoaded", "stateLoaded", [settings, s2]);
    callback();
  }
  function _fnSettingsFromNode(table) {
    var settings = DataTable.settings;
    var idx = $4.inArray(table, _pluck(settings, "nTable"));
    return idx !== -1 ? settings[idx] : null;
  }
  function _fnLog(settings, level, msg, tn) {
    msg = "DataTables warning: " + (settings ? "table id=" + settings.sTableId + " - " : "") + msg;
    if (tn) {
      msg += ". For more information about this error, please see https://datatables.net/tn/" + tn;
    }
    if (!level) {
      var ext = DataTable.ext;
      var type = ext.sErrMode || ext.errMode;
      if (settings) {
        _fnCallbackFire(settings, null, "error", [settings, tn, msg]);
      }
      if (type == "alert") {
        alert(msg);
      } else if (type == "throw") {
        throw new Error(msg);
      } else if (typeof type == "function") {
        type(settings, tn, msg);
      }
    } else if (window.console && console.log) {
      console.log(msg);
    }
  }
  function _fnMap(ret, src, name, mappedName) {
    if (Array.isArray(name)) {
      $4.each(name, function(i2, val) {
        if (Array.isArray(val)) {
          _fnMap(ret, src, val[0], val[1]);
        } else {
          _fnMap(ret, src, val);
        }
      });
      return;
    }
    if (mappedName === void 0) {
      mappedName = name;
    }
    if (src[name] !== void 0) {
      ret[mappedName] = src[name];
    }
  }
  function _fnExtend(out, extender, breakRefs) {
    var val;
    for (var prop in extender) {
      if (extender.hasOwnProperty(prop)) {
        val = extender[prop];
        if ($4.isPlainObject(val)) {
          if (!$4.isPlainObject(out[prop])) {
            out[prop] = {};
          }
          $4.extend(true, out[prop], val);
        } else if (breakRefs && prop !== "data" && prop !== "aaData" && Array.isArray(val)) {
          out[prop] = val.slice();
        } else {
          out[prop] = val;
        }
      }
    }
    return out;
  }
  function _fnBindAction(n2, oData, fn2) {
    $4(n2).on("click.DT", oData, function(e2) {
      $4(n2).trigger("blur");
      fn2(e2);
    }).on("keypress.DT", oData, function(e2) {
      if (e2.which === 13) {
        e2.preventDefault();
        fn2(e2);
      }
    }).on("selectstart.DT", function() {
      return false;
    });
  }
  function _fnCallbackReg(oSettings, sStore, fn2, sName) {
    if (fn2) {
      oSettings[sStore].push({
        "fn": fn2,
        "sName": sName
      });
    }
  }
  function _fnCallbackFire(settings, callbackArr, eventName, args) {
    var ret = [];
    if (callbackArr) {
      ret = $4.map(settings[callbackArr].slice().reverse(), function(val, i2) {
        return val.fn.apply(settings.oInstance, args);
      });
    }
    if (eventName !== null) {
      var e2 = $4.Event(eventName + ".dt");
      var table = $4(settings.nTable);
      table.trigger(e2, args);
      if (table.parents("body").length === 0) {
        $4("body").trigger(e2, args);
      }
      ret.push(e2.result);
    }
    return ret;
  }
  function _fnLengthOverflow(settings) {
    var start3 = settings._iDisplayStart, end2 = settings.fnDisplayEnd(), len = settings._iDisplayLength;
    if (start3 >= end2) {
      start3 = end2 - len;
    }
    start3 -= start3 % len;
    if (len === -1 || start3 < 0) {
      start3 = 0;
    }
    settings._iDisplayStart = start3;
  }
  function _fnRenderer(settings, type) {
    var renderer = settings.renderer;
    var host = DataTable.ext.renderer[type];
    if ($4.isPlainObject(renderer) && renderer[type]) {
      return host[renderer[type]] || host._;
    } else if (typeof renderer === "string") {
      return host[renderer] || host._;
    }
    return host._;
  }
  function _fnDataSource(settings) {
    if (settings.oFeatures.bServerSide) {
      return "ssp";
    } else if (settings.ajax || settings.sAjaxSource) {
      return "ajax";
    }
    return "dom";
  }
  var __apiStruct = [];
  var __arrayProto = Array.prototype;
  var _toSettings = function(mixed) {
    var idx, jq;
    var settings = DataTable.settings;
    var tables = $4.map(settings, function(el, i2) {
      return el.nTable;
    });
    if (!mixed) {
      return [];
    } else if (mixed.nTable && mixed.oApi) {
      return [mixed];
    } else if (mixed.nodeName && mixed.nodeName.toLowerCase() === "table") {
      idx = $4.inArray(mixed, tables);
      return idx !== -1 ? [settings[idx]] : null;
    } else if (mixed && typeof mixed.settings === "function") {
      return mixed.settings().toArray();
    } else if (typeof mixed === "string") {
      jq = $4(mixed);
    } else if (mixed instanceof $4) {
      jq = mixed;
    }
    if (jq) {
      return jq.map(function(i2) {
        idx = $4.inArray(this, tables);
        return idx !== -1 ? settings[idx] : null;
      }).toArray();
    }
  };
  _Api = function(context, data) {
    if (!(this instanceof _Api)) {
      return new _Api(context, data);
    }
    var settings = [];
    var ctxSettings = function(o2) {
      var a2 = _toSettings(o2);
      if (a2) {
        settings.push.apply(settings, a2);
      }
    };
    if (Array.isArray(context)) {
      for (var i2 = 0, ien = context.length; i2 < ien; i2++) {
        ctxSettings(context[i2]);
      }
    } else {
      ctxSettings(context);
    }
    this.context = _unique(settings);
    if (data) {
      $4.merge(this, data);
    }
    this.selector = {
      rows: null,
      cols: null,
      opts: null
    };
    _Api.extend(this, this, __apiStruct);
  };
  DataTable.Api = _Api;
  $4.extend(_Api.prototype, {
    any: function() {
      return this.count() !== 0;
    },
    concat: __arrayProto.concat,
    context: [],
    // array of table settings objects
    count: function() {
      return this.flatten().length;
    },
    each: function(fn2) {
      for (var i2 = 0, ien = this.length; i2 < ien; i2++) {
        fn2.call(this, this[i2], i2, this);
      }
      return this;
    },
    eq: function(idx) {
      var ctx = this.context;
      return ctx.length > idx ? new _Api(ctx[idx], this[idx]) : null;
    },
    filter: function(fn2) {
      var a2 = [];
      if (__arrayProto.filter) {
        a2 = __arrayProto.filter.call(this, fn2, this);
      } else {
        for (var i2 = 0, ien = this.length; i2 < ien; i2++) {
          if (fn2.call(this, this[i2], i2, this)) {
            a2.push(this[i2]);
          }
        }
      }
      return new _Api(this.context, a2);
    },
    flatten: function() {
      var a2 = [];
      return new _Api(this.context, a2.concat.apply(a2, this.toArray()));
    },
    join: __arrayProto.join,
    indexOf: __arrayProto.indexOf || function(obj, start3) {
      for (var i2 = start3 || 0, ien = this.length; i2 < ien; i2++) {
        if (this[i2] === obj) {
          return i2;
        }
      }
      return -1;
    },
    iterator: function(flatten, type, fn2, alwaysNew) {
      var a2 = [], ret, i2, ien, j2, jen, context = this.context, rows, items, item, selector = this.selector;
      if (typeof flatten === "string") {
        alwaysNew = fn2;
        fn2 = type;
        type = flatten;
        flatten = false;
      }
      for (i2 = 0, ien = context.length; i2 < ien; i2++) {
        var apiInst = new _Api(context[i2]);
        if (type === "table") {
          ret = fn2.call(apiInst, context[i2], i2);
          if (ret !== void 0) {
            a2.push(ret);
          }
        } else if (type === "columns" || type === "rows") {
          ret = fn2.call(apiInst, context[i2], this[i2], i2);
          if (ret !== void 0) {
            a2.push(ret);
          }
        } else if (type === "column" || type === "column-rows" || type === "row" || type === "cell") {
          items = this[i2];
          if (type === "column-rows") {
            rows = _selector_row_indexes(context[i2], selector.opts);
          }
          for (j2 = 0, jen = items.length; j2 < jen; j2++) {
            item = items[j2];
            if (type === "cell") {
              ret = fn2.call(apiInst, context[i2], item.row, item.column, i2, j2);
            } else {
              ret = fn2.call(apiInst, context[i2], item, i2, j2, rows);
            }
            if (ret !== void 0) {
              a2.push(ret);
            }
          }
        }
      }
      if (a2.length || alwaysNew) {
        var api = new _Api(context, flatten ? a2.concat.apply([], a2) : a2);
        var apiSelector = api.selector;
        apiSelector.rows = selector.rows;
        apiSelector.cols = selector.cols;
        apiSelector.opts = selector.opts;
        return api;
      }
      return this;
    },
    lastIndexOf: __arrayProto.lastIndexOf || function(obj, start3) {
      return this.indexOf.apply(this.toArray.reverse(), arguments);
    },
    length: 0,
    map: function(fn2) {
      var a2 = [];
      if (__arrayProto.map) {
        a2 = __arrayProto.map.call(this, fn2, this);
      } else {
        for (var i2 = 0, ien = this.length; i2 < ien; i2++) {
          a2.push(fn2.call(this, this[i2], i2));
        }
      }
      return new _Api(this.context, a2);
    },
    pluck: function(prop) {
      var fn2 = DataTable.util.get(prop);
      return this.map(function(el) {
        return fn2(el);
      });
    },
    pop: __arrayProto.pop,
    push: __arrayProto.push,
    // Does not return an API instance
    reduce: __arrayProto.reduce || function(fn2, init) {
      return _fnReduce(this, fn2, init, 0, this.length, 1);
    },
    reduceRight: __arrayProto.reduceRight || function(fn2, init) {
      return _fnReduce(this, fn2, init, this.length - 1, -1, -1);
    },
    reverse: __arrayProto.reverse,
    // Object with rows, columns and opts
    selector: null,
    shift: __arrayProto.shift,
    slice: function() {
      return new _Api(this.context, this);
    },
    sort: __arrayProto.sort,
    // ? name - order?
    splice: __arrayProto.splice,
    toArray: function() {
      return __arrayProto.slice.call(this);
    },
    to$: function() {
      return $4(this);
    },
    toJQuery: function() {
      return $4(this);
    },
    unique: function() {
      return new _Api(this.context, _unique(this));
    },
    unshift: __arrayProto.unshift
  });
  _Api.extend = function(scope, obj, ext) {
    if (!ext.length || !obj || !(obj instanceof _Api) && !obj.__dt_wrapper) {
      return;
    }
    var i2, ien, struct, methodScoping = function(scope2, fn2, struc) {
      return function() {
        var ret = fn2.apply(scope2, arguments);
        _Api.extend(ret, ret, struc.methodExt);
        return ret;
      };
    };
    for (i2 = 0, ien = ext.length; i2 < ien; i2++) {
      struct = ext[i2];
      obj[struct.name] = struct.type === "function" ? methodScoping(scope, struct.val, struct) : struct.type === "object" ? {} : struct.val;
      obj[struct.name].__dt_wrapper = true;
      _Api.extend(scope, obj[struct.name], struct.propExt);
    }
  };
  _Api.register = _api_register = function(name, val) {
    if (Array.isArray(name)) {
      for (var j2 = 0, jen = name.length; j2 < jen; j2++) {
        _Api.register(name[j2], val);
      }
      return;
    }
    var i2, ien, heir = name.split("."), struct = __apiStruct, key, method;
    var find = function(src2, name2) {
      for (var i3 = 0, ien2 = src2.length; i3 < ien2; i3++) {
        if (src2[i3].name === name2) {
          return src2[i3];
        }
      }
      return null;
    };
    for (i2 = 0, ien = heir.length; i2 < ien; i2++) {
      method = heir[i2].indexOf("()") !== -1;
      key = method ? heir[i2].replace("()", "") : heir[i2];
      var src = find(struct, key);
      if (!src) {
        src = {
          name: key,
          val: {},
          methodExt: [],
          propExt: [],
          type: "object"
        };
        struct.push(src);
      }
      if (i2 === ien - 1) {
        src.val = val;
        src.type = typeof val === "function" ? "function" : $4.isPlainObject(val) ? "object" : "other";
      } else {
        struct = method ? src.methodExt : src.propExt;
      }
    }
  };
  _Api.registerPlural = _api_registerPlural = function(pluralName, singularName, val) {
    _Api.register(pluralName, val);
    _Api.register(singularName, function() {
      var ret = val.apply(this, arguments);
      if (ret === this) {
        return this;
      } else if (ret instanceof _Api) {
        return ret.length ? Array.isArray(ret[0]) ? new _Api(ret.context, ret[0]) : (
          // Array results are 'enhanced'
          ret[0]
        ) : void 0;
      }
      return ret;
    });
  };
  var __table_selector = function(selector, a2) {
    if (Array.isArray(selector)) {
      return $4.map(selector, function(item) {
        return __table_selector(item, a2);
      });
    }
    if (typeof selector === "number") {
      return [a2[selector]];
    }
    var nodes = $4.map(a2, function(el, i2) {
      return el.nTable;
    });
    return $4(nodes).filter(selector).map(function(i2) {
      var idx = $4.inArray(this, nodes);
      return a2[idx];
    }).toArray();
  };
  _api_register("tables()", function(selector) {
    return selector !== void 0 && selector !== null ? new _Api(__table_selector(selector, this.context)) : this;
  });
  _api_register("table()", function(selector) {
    var tables = this.tables(selector);
    var ctx = tables.context;
    return ctx.length ? new _Api(ctx[0]) : tables;
  });
  _api_registerPlural("tables().nodes()", "table().node()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTable;
    }, 1);
  });
  _api_registerPlural("tables().body()", "table().body()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTBody;
    }, 1);
  });
  _api_registerPlural("tables().header()", "table().header()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTHead;
    }, 1);
  });
  _api_registerPlural("tables().footer()", "table().footer()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTFoot;
    }, 1);
  });
  _api_registerPlural("tables().containers()", "table().container()", function() {
    return this.iterator("table", function(ctx) {
      return ctx.nTableWrapper;
    }, 1);
  });
  _api_register("draw()", function(paging) {
    return this.iterator("table", function(settings) {
      if (paging === "page") {
        _fnDraw(settings);
      } else {
        if (typeof paging === "string") {
          paging = paging === "full-hold" ? false : true;
        }
        _fnReDraw(settings, paging === false);
      }
    });
  });
  _api_register("page()", function(action) {
    if (action === void 0) {
      return this.page.info().page;
    }
    return this.iterator("table", function(settings) {
      _fnPageChange(settings, action);
    });
  });
  _api_register("page.info()", function(action) {
    if (this.context.length === 0) {
      return void 0;
    }
    var settings = this.context[0], start3 = settings._iDisplayStart, len = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1, visRecords = settings.fnRecordsDisplay(), all = len === -1;
    return {
      "page": all ? 0 : Math.floor(start3 / len),
      "pages": all ? 1 : Math.ceil(visRecords / len),
      "start": start3,
      "end": settings.fnDisplayEnd(),
      "length": len,
      "recordsTotal": settings.fnRecordsTotal(),
      "recordsDisplay": visRecords,
      "serverSide": _fnDataSource(settings) === "ssp"
    };
  });
  _api_register("page.len()", function(len) {
    if (len === void 0) {
      return this.context.length !== 0 ? this.context[0]._iDisplayLength : void 0;
    }
    return this.iterator("table", function(settings) {
      _fnLengthChange(settings, len);
    });
  });
  var __reload = function(settings, holdPosition, callback) {
    if (callback) {
      var api = new _Api(settings);
      api.one("draw", function() {
        callback(api.ajax.json());
      });
    }
    if (_fnDataSource(settings) == "ssp") {
      _fnReDraw(settings, holdPosition);
    } else {
      _fnProcessingDisplay(settings, true);
      var xhr = settings.jqXHR;
      if (xhr && xhr.readyState !== 4) {
        xhr.abort();
      }
      _fnBuildAjax(settings, [], function(json) {
        _fnClearTable(settings);
        var data = _fnAjaxDataSrc(settings, json);
        for (var i2 = 0, ien = data.length; i2 < ien; i2++) {
          _fnAddData(settings, data[i2]);
        }
        _fnReDraw(settings, holdPosition);
        _fnProcessingDisplay(settings, false);
      });
    }
  };
  _api_register("ajax.json()", function() {
    var ctx = this.context;
    if (ctx.length > 0) {
      return ctx[0].json;
    }
  });
  _api_register("ajax.params()", function() {
    var ctx = this.context;
    if (ctx.length > 0) {
      return ctx[0].oAjaxData;
    }
  });
  _api_register("ajax.reload()", function(callback, resetPaging) {
    return this.iterator("table", function(settings) {
      __reload(settings, resetPaging === false, callback);
    });
  });
  _api_register("ajax.url()", function(url) {
    var ctx = this.context;
    if (url === void 0) {
      if (ctx.length === 0) {
        return void 0;
      }
      ctx = ctx[0];
      return ctx.ajax ? $4.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax : ctx.sAjaxSource;
    }
    return this.iterator("table", function(settings) {
      if ($4.isPlainObject(settings.ajax)) {
        settings.ajax.url = url;
      } else {
        settings.ajax = url;
      }
    });
  });
  _api_register("ajax.url().load()", function(callback, resetPaging) {
    return this.iterator("table", function(ctx) {
      __reload(ctx, resetPaging === false, callback);
    });
  });
  var _selector_run = function(type, selector, selectFn, settings, opts) {
    var out = [], res, a2, i2, ien, j2, jen, selectorType = typeof selector;
    if (!selector || selectorType === "string" || selectorType === "function" || selector.length === void 0) {
      selector = [selector];
    }
    for (i2 = 0, ien = selector.length; i2 < ien; i2++) {
      a2 = selector[i2] && selector[i2].split && !selector[i2].match(/[\[\(:]/) ? selector[i2].split(",") : [selector[i2]];
      for (j2 = 0, jen = a2.length; j2 < jen; j2++) {
        res = selectFn(typeof a2[j2] === "string" ? a2[j2].trim() : a2[j2]);
        if (res && res.length) {
          out = out.concat(res);
        }
      }
    }
    var ext = _ext.selector[type];
    if (ext.length) {
      for (i2 = 0, ien = ext.length; i2 < ien; i2++) {
        out = ext[i2](settings, opts, out);
      }
    }
    return _unique(out);
  };
  var _selector_opts = function(opts) {
    if (!opts) {
      opts = {};
    }
    if (opts.filter && opts.search === void 0) {
      opts.search = opts.filter;
    }
    return $4.extend({
      search: "none",
      order: "current",
      page: "all"
    }, opts);
  };
  var _selector_first = function(inst) {
    for (var i2 = 0, ien = inst.length; i2 < ien; i2++) {
      if (inst[i2].length > 0) {
        inst[0] = inst[i2];
        inst[0].length = 1;
        inst.length = 1;
        inst.context = [inst.context[i2]];
        return inst;
      }
    }
    inst.length = 0;
    return inst;
  };
  var _selector_row_indexes = function(settings, opts) {
    var i2, ien, tmp, a2 = [], displayFiltered = settings.aiDisplay, displayMaster = settings.aiDisplayMaster;
    var search = opts.search, order2 = opts.order, page = opts.page;
    if (_fnDataSource(settings) == "ssp") {
      return search === "removed" ? [] : _range(0, displayMaster.length);
    } else if (page == "current") {
      for (i2 = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i2 < ien; i2++) {
        a2.push(displayFiltered[i2]);
      }
    } else if (order2 == "current" || order2 == "applied") {
      if (search == "none") {
        a2 = displayMaster.slice();
      } else if (search == "applied") {
        a2 = displayFiltered.slice();
      } else if (search == "removed") {
        var displayFilteredMap = {};
        for (var i2 = 0, ien = displayFiltered.length; i2 < ien; i2++) {
          displayFilteredMap[displayFiltered[i2]] = null;
        }
        a2 = $4.map(displayMaster, function(el) {
          return !displayFilteredMap.hasOwnProperty(el) ? el : null;
        });
      }
    } else if (order2 == "index" || order2 == "original") {
      for (i2 = 0, ien = settings.aoData.length; i2 < ien; i2++) {
        if (search == "none") {
          a2.push(i2);
        } else {
          tmp = $4.inArray(i2, displayFiltered);
          if (tmp === -1 && search == "removed" || tmp >= 0 && search == "applied") {
            a2.push(i2);
          }
        }
      }
    }
    return a2;
  };
  var __row_selector = function(settings, selector, opts) {
    var rows;
    var run = function(sel) {
      var selInt = _intVal(sel);
      var i2, ien;
      var aoData = settings.aoData;
      if (selInt !== null && !opts) {
        return [selInt];
      }
      if (!rows) {
        rows = _selector_row_indexes(settings, opts);
      }
      if (selInt !== null && $4.inArray(selInt, rows) !== -1) {
        return [selInt];
      } else if (sel === null || sel === void 0 || sel === "") {
        return rows;
      }
      if (typeof sel === "function") {
        return $4.map(rows, function(idx) {
          var row = aoData[idx];
          return sel(idx, row._aData, row.nTr) ? idx : null;
        });
      }
      if (sel.nodeName) {
        var rowIdx = sel._DT_RowIndex;
        var cellIdx = sel._DT_CellIndex;
        if (rowIdx !== void 0) {
          return aoData[rowIdx] && aoData[rowIdx].nTr === sel ? [rowIdx] : [];
        } else if (cellIdx) {
          return aoData[cellIdx.row] && aoData[cellIdx.row].nTr === sel.parentNode ? [cellIdx.row] : [];
        } else {
          var host = $4(sel).closest("*[data-dt-row]");
          return host.length ? [host.data("dt-row")] : [];
        }
      }
      if (typeof sel === "string" && sel.charAt(0) === "#") {
        var rowObj = settings.aIds[sel.replace(/^#/, "")];
        if (rowObj !== void 0) {
          return [rowObj.idx];
        }
      }
      var nodes = _removeEmpty(
        _pluck_order(settings.aoData, rows, "nTr")
      );
      return $4(nodes).filter(sel).map(function() {
        return this._DT_RowIndex;
      }).toArray();
    };
    return _selector_run("row", selector, run, settings, opts);
  };
  _api_register("rows()", function(selector, opts) {
    if (selector === void 0) {
      selector = "";
    } else if ($4.isPlainObject(selector)) {
      opts = selector;
      selector = "";
    }
    opts = _selector_opts(opts);
    var inst = this.iterator("table", function(settings) {
      return __row_selector(settings, selector, opts);
    }, 1);
    inst.selector.rows = selector;
    inst.selector.opts = opts;
    return inst;
  });
  _api_register("rows().nodes()", function() {
    return this.iterator("row", function(settings, row) {
      return settings.aoData[row].nTr || void 0;
    }, 1);
  });
  _api_register("rows().data()", function() {
    return this.iterator(true, "rows", function(settings, rows) {
      return _pluck_order(settings.aoData, rows, "_aData");
    }, 1);
  });
  _api_registerPlural("rows().cache()", "row().cache()", function(type) {
    return this.iterator("row", function(settings, row) {
      var r2 = settings.aoData[row];
      return type === "search" ? r2._aFilterData : r2._aSortData;
    }, 1);
  });
  _api_registerPlural("rows().invalidate()", "row().invalidate()", function(src) {
    return this.iterator("row", function(settings, row) {
      _fnInvalidate(settings, row, src);
    });
  });
  _api_registerPlural("rows().indexes()", "row().index()", function() {
    return this.iterator("row", function(settings, row) {
      return row;
    }, 1);
  });
  _api_registerPlural("rows().ids()", "row().id()", function(hash3) {
    var a2 = [];
    var context = this.context;
    for (var i2 = 0, ien = context.length; i2 < ien; i2++) {
      for (var j2 = 0, jen = this[i2].length; j2 < jen; j2++) {
        var id = context[i2].rowIdFn(context[i2].aoData[this[i2][j2]]._aData);
        a2.push((hash3 === true ? "#" : "") + id);
      }
    }
    return new _Api(context, a2);
  });
  _api_registerPlural("rows().remove()", "row().remove()", function() {
    var that = this;
    this.iterator("row", function(settings, row, thatIdx) {
      var data = settings.aoData;
      var rowData = data[row];
      var i2, ien, j2, jen;
      var loopRow, loopCells;
      data.splice(row, 1);
      for (i2 = 0, ien = data.length; i2 < ien; i2++) {
        loopRow = data[i2];
        loopCells = loopRow.anCells;
        if (loopRow.nTr !== null) {
          loopRow.nTr._DT_RowIndex = i2;
        }
        if (loopCells !== null) {
          for (j2 = 0, jen = loopCells.length; j2 < jen; j2++) {
            loopCells[j2]._DT_CellIndex.row = i2;
          }
        }
      }
      _fnDeleteIndex(settings.aiDisplayMaster, row);
      _fnDeleteIndex(settings.aiDisplay, row);
      _fnDeleteIndex(that[thatIdx], row, false);
      if (settings._iRecordsDisplay > 0) {
        settings._iRecordsDisplay--;
      }
      _fnLengthOverflow(settings);
      var id = settings.rowIdFn(rowData._aData);
      if (id !== void 0) {
        delete settings.aIds[id];
      }
    });
    this.iterator("table", function(settings) {
      for (var i2 = 0, ien = settings.aoData.length; i2 < ien; i2++) {
        settings.aoData[i2].idx = i2;
      }
    });
    return this;
  });
  _api_register("rows.add()", function(rows) {
    var newRows = this.iterator("table", function(settings) {
      var row, i2, ien;
      var out = [];
      for (i2 = 0, ien = rows.length; i2 < ien; i2++) {
        row = rows[i2];
        if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
          out.push(_fnAddTr(settings, row)[0]);
        } else {
          out.push(_fnAddData(settings, row));
        }
      }
      return out;
    }, 1);
    var modRows = this.rows(-1);
    modRows.pop();
    $4.merge(modRows, newRows);
    return modRows;
  });
  _api_register("row()", function(selector, opts) {
    return _selector_first(this.rows(selector, opts));
  });
  _api_register("row().data()", function(data) {
    var ctx = this.context;
    if (data === void 0) {
      return ctx.length && this.length ? ctx[0].aoData[this[0]]._aData : void 0;
    }
    var row = ctx[0].aoData[this[0]];
    row._aData = data;
    if (Array.isArray(data) && row.nTr && row.nTr.id) {
      _fnSetObjectDataFn(ctx[0].rowId)(data, row.nTr.id);
    }
    _fnInvalidate(ctx[0], this[0], "data");
    return this;
  });
  _api_register("row().node()", function() {
    var ctx = this.context;
    return ctx.length && this.length ? ctx[0].aoData[this[0]].nTr || null : null;
  });
  _api_register("row.add()", function(row) {
    if (row instanceof $4 && row.length) {
      row = row[0];
    }
    var rows = this.iterator("table", function(settings) {
      if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
        return _fnAddTr(settings, row)[0];
      }
      return _fnAddData(settings, row);
    });
    return this.row(rows[0]);
  });
  $4(document).on("plugin-init.dt", function(e2, context) {
    var api = new _Api(context);
    var namespace = "on-plugin-init";
    var stateSaveParamsEvent = "stateSaveParams." + namespace;
    var destroyEvent = "destroy. " + namespace;
    api.on(stateSaveParamsEvent, function(e3, settings, d2) {
      var idFn = settings.rowIdFn;
      var data = settings.aoData;
      var ids = [];
      for (var i2 = 0; i2 < data.length; i2++) {
        if (data[i2]._detailsShow) {
          ids.push("#" + idFn(data[i2]._aData));
        }
      }
      d2.childRows = ids;
    });
    api.on(destroyEvent, function() {
      api.off(stateSaveParamsEvent + " " + destroyEvent);
    });
    var loaded = api.state.loaded();
    if (loaded && loaded.childRows) {
      api.rows($4.map(loaded.childRows, function(id) {
        return id.replace(/:/g, "\\:");
      })).every(function() {
        _fnCallbackFire(context, null, "requestChild", [this]);
      });
    }
  });
  var __details_add = function(ctx, row, data, klass) {
    var rows = [];
    var addRow = function(r2, k2) {
      if (Array.isArray(r2) || r2 instanceof $4) {
        for (var i2 = 0, ien = r2.length; i2 < ien; i2++) {
          addRow(r2[i2], k2);
        }
        return;
      }
      if (r2.nodeName && r2.nodeName.toLowerCase() === "tr") {
        rows.push(r2);
      } else {
        var created = $4("<tr><td></td></tr>").addClass(k2);
        $4("td", created).addClass(k2).html(r2)[0].colSpan = _fnVisbleColumns(ctx);
        rows.push(created[0]);
      }
    };
    addRow(data, klass);
    if (row._details) {
      row._details.detach();
    }
    row._details = $4(rows);
    if (row._detailsShow) {
      row._details.insertAfter(row.nTr);
    }
  };
  var __details_state = DataTable.util.throttle(
    function(ctx) {
      _fnSaveState(ctx[0]);
    },
    500
  );
  var __details_remove = function(api, idx) {
    var ctx = api.context;
    if (ctx.length) {
      var row = ctx[0].aoData[idx !== void 0 ? idx : api[0]];
      if (row && row._details) {
        row._details.remove();
        row._detailsShow = void 0;
        row._details = void 0;
        $4(row.nTr).removeClass("dt-hasChild");
        __details_state(ctx);
      }
    }
  };
  var __details_display = function(api, show) {
    var ctx = api.context;
    if (ctx.length && api.length) {
      var row = ctx[0].aoData[api[0]];
      if (row._details) {
        row._detailsShow = show;
        if (show) {
          row._details.insertAfter(row.nTr);
          $4(row.nTr).addClass("dt-hasChild");
        } else {
          row._details.detach();
          $4(row.nTr).removeClass("dt-hasChild");
        }
        _fnCallbackFire(ctx[0], null, "childRow", [show, api.row(api[0])]);
        __details_events(ctx[0]);
        __details_state(ctx);
      }
    }
  };
  var __details_events = function(settings) {
    var api = new _Api(settings);
    var namespace = ".dt.DT_details";
    var drawEvent = "draw" + namespace;
    var colvisEvent = "column-sizing" + namespace;
    var destroyEvent = "destroy" + namespace;
    var data = settings.aoData;
    api.off(drawEvent + " " + colvisEvent + " " + destroyEvent);
    if (_pluck(data, "_details").length > 0) {
      api.on(drawEvent, function(e2, ctx) {
        if (settings !== ctx) {
          return;
        }
        api.rows({ page: "current" }).eq(0).each(function(idx) {
          var row = data[idx];
          if (row._detailsShow) {
            row._details.insertAfter(row.nTr);
          }
        });
      });
      api.on(colvisEvent, function(e2, ctx, idx, vis) {
        if (settings !== ctx) {
          return;
        }
        var row, visible = _fnVisbleColumns(ctx);
        for (var i2 = 0, ien = data.length; i2 < ien; i2++) {
          row = data[i2];
          if (row._details) {
            row._details.each(function() {
              var el = $4(this).children("td");
              if (el.length == 1) {
                el.attr("colspan", visible);
              }
            });
          }
        }
      });
      api.on(destroyEvent, function(e2, ctx) {
        if (settings !== ctx) {
          return;
        }
        for (var i2 = 0, ien = data.length; i2 < ien; i2++) {
          if (data[i2]._details) {
            __details_remove(api, i2);
          }
        }
      });
    }
  };
  var _emp = "";
  var _child_obj = _emp + "row().child";
  var _child_mth = _child_obj + "()";
  _api_register(_child_mth, function(data, klass) {
    var ctx = this.context;
    if (data === void 0) {
      return ctx.length && this.length ? ctx[0].aoData[this[0]]._details : void 0;
    } else if (data === true) {
      this.child.show();
    } else if (data === false) {
      __details_remove(this);
    } else if (ctx.length && this.length) {
      __details_add(ctx[0], ctx[0].aoData[this[0]], data, klass);
    }
    return this;
  });
  _api_register([
    _child_obj + ".show()",
    _child_mth + ".show()"
    // only when `child()` was called with parameters (without
  ], function(show) {
    __details_display(this, true);
    return this;
  });
  _api_register([
    _child_obj + ".hide()",
    _child_mth + ".hide()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_display(this, false);
    return this;
  });
  _api_register([
    _child_obj + ".remove()",
    _child_mth + ".remove()"
    // only when `child()` was called with parameters (without
  ], function() {
    __details_remove(this);
    return this;
  });
  _api_register(_child_obj + ".isShown()", function() {
    var ctx = this.context;
    if (ctx.length && this.length) {
      return ctx[0].aoData[this[0]]._detailsShow || false;
    }
    return false;
  });
  var __re_column_selector = /^([^:]+):(name|visIdx|visible)$/;
  var __columnData = function(settings, column, r1, r2, rows) {
    var a2 = [];
    for (var row = 0, ien = rows.length; row < ien; row++) {
      a2.push(_fnGetCellData(settings, rows[row], column));
    }
    return a2;
  };
  var __column_selector = function(settings, selector, opts) {
    var columns = settings.aoColumns, names = _pluck(columns, "sName"), nodes = _pluck(columns, "nTh");
    var run = function(s2) {
      var selInt = _intVal(s2);
      if (s2 === "") {
        return _range(columns.length);
      }
      if (selInt !== null) {
        return [
          selInt >= 0 ? selInt : (
            // Count from left
            columns.length + selInt
          )
          // Count from right (+ because its a negative value)
        ];
      }
      if (typeof s2 === "function") {
        var rows = _selector_row_indexes(settings, opts);
        return $4.map(columns, function(col, idx2) {
          return s2(
            idx2,
            __columnData(settings, idx2, 0, 0, rows),
            nodes[idx2]
          ) ? idx2 : null;
        });
      }
      var match = typeof s2 === "string" ? s2.match(__re_column_selector) : "";
      if (match) {
        switch (match[2]) {
          case "visIdx":
          case "visible":
            var idx = parseInt(match[1], 10);
            if (idx < 0) {
              var visColumns = $4.map(columns, function(col, i2) {
                return col.bVisible ? i2 : null;
              });
              return [visColumns[visColumns.length + idx]];
            }
            return [_fnVisibleToColumnIndex(settings, idx)];
          case "name":
            return $4.map(names, function(name, i2) {
              return name === match[1] ? i2 : null;
            });
          default:
            return [];
        }
      }
      if (s2.nodeName && s2._DT_CellIndex) {
        return [s2._DT_CellIndex.column];
      }
      var jqResult = $4(nodes).filter(s2).map(function() {
        return $4.inArray(this, nodes);
      }).toArray();
      if (jqResult.length || !s2.nodeName) {
        return jqResult;
      }
      var host = $4(s2).closest("*[data-dt-column]");
      return host.length ? [host.data("dt-column")] : [];
    };
    return _selector_run("column", selector, run, settings, opts);
  };
  var __setColumnVis = function(settings, column, vis) {
    var cols = settings.aoColumns, col = cols[column], data = settings.aoData, row, cells, i2, ien, tr;
    if (vis === void 0) {
      return col.bVisible;
    }
    if (col.bVisible === vis) {
      return;
    }
    if (vis) {
      var insertBefore = $4.inArray(true, _pluck(cols, "bVisible"), column + 1);
      for (i2 = 0, ien = data.length; i2 < ien; i2++) {
        tr = data[i2].nTr;
        cells = data[i2].anCells;
        if (tr) {
          tr.insertBefore(cells[column], cells[insertBefore] || null);
        }
      }
    } else {
      $4(_pluck(settings.aoData, "anCells", column)).detach();
    }
    col.bVisible = vis;
  };
  _api_register("columns()", function(selector, opts) {
    if (selector === void 0) {
      selector = "";
    } else if ($4.isPlainObject(selector)) {
      opts = selector;
      selector = "";
    }
    opts = _selector_opts(opts);
    var inst = this.iterator("table", function(settings) {
      return __column_selector(settings, selector, opts);
    }, 1);
    inst.selector.cols = selector;
    inst.selector.opts = opts;
    return inst;
  });
  _api_registerPlural("columns().header()", "column().header()", function(selector, opts) {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column].nTh;
    }, 1);
  });
  _api_registerPlural("columns().footer()", "column().footer()", function(selector, opts) {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column].nTf;
    }, 1);
  });
  _api_registerPlural("columns().data()", "column().data()", function() {
    return this.iterator("column-rows", __columnData, 1);
  });
  _api_registerPlural("columns().dataSrc()", "column().dataSrc()", function() {
    return this.iterator("column", function(settings, column) {
      return settings.aoColumns[column].mData;
    }, 1);
  });
  _api_registerPlural("columns().cache()", "column().cache()", function(type) {
    return this.iterator("column-rows", function(settings, column, i2, j2, rows) {
      return _pluck_order(
        settings.aoData,
        rows,
        type === "search" ? "_aFilterData" : "_aSortData",
        column
      );
    }, 1);
  });
  _api_registerPlural("columns().nodes()", "column().nodes()", function() {
    return this.iterator("column-rows", function(settings, column, i2, j2, rows) {
      return _pluck_order(settings.aoData, rows, "anCells", column);
    }, 1);
  });
  _api_registerPlural("columns().visible()", "column().visible()", function(vis, calc) {
    var that = this;
    var ret = this.iterator("column", function(settings, column) {
      if (vis === void 0) {
        return settings.aoColumns[column].bVisible;
      }
      __setColumnVis(settings, column, vis);
    });
    if (vis !== void 0) {
      this.iterator("table", function(settings) {
        _fnDrawHead(settings, settings.aoHeader);
        _fnDrawHead(settings, settings.aoFooter);
        if (!settings.aiDisplay.length) {
          $4(settings.nTBody).find("td[colspan]").attr("colspan", _fnVisbleColumns(settings));
        }
        _fnSaveState(settings);
        that.iterator("column", function(settings2, column) {
          _fnCallbackFire(settings2, null, "column-visibility", [settings2, column, vis, calc]);
        });
        if (calc === void 0 || calc) {
          that.columns.adjust();
        }
      });
    }
    return ret;
  });
  _api_registerPlural("columns().indexes()", "column().index()", function(type) {
    return this.iterator("column", function(settings, column) {
      return type === "visible" ? _fnColumnIndexToVisible(settings, column) : column;
    }, 1);
  });
  _api_register("columns.adjust()", function() {
    return this.iterator("table", function(settings) {
      _fnAdjustColumnSizing(settings);
    }, 1);
  });
  _api_register("column.index()", function(type, idx) {
    if (this.context.length !== 0) {
      var ctx = this.context[0];
      if (type === "fromVisible" || type === "toData") {
        return _fnVisibleToColumnIndex(ctx, idx);
      } else if (type === "fromData" || type === "toVisible") {
        return _fnColumnIndexToVisible(ctx, idx);
      }
    }
  });
  _api_register("column()", function(selector, opts) {
    return _selector_first(this.columns(selector, opts));
  });
  var __cell_selector = function(settings, selector, opts) {
    var data = settings.aoData;
    var rows = _selector_row_indexes(settings, opts);
    var cells = _removeEmpty(_pluck_order(data, rows, "anCells"));
    var allCells = $4(_flatten([], cells));
    var row;
    var columns = settings.aoColumns.length;
    var a2, i2, ien, j2, o2, host;
    var run = function(s2) {
      var fnSelector = typeof s2 === "function";
      if (s2 === null || s2 === void 0 || fnSelector) {
        a2 = [];
        for (i2 = 0, ien = rows.length; i2 < ien; i2++) {
          row = rows[i2];
          for (j2 = 0; j2 < columns; j2++) {
            o2 = {
              row,
              column: j2
            };
            if (fnSelector) {
              host = data[row];
              if (s2(o2, _fnGetCellData(settings, row, j2), host.anCells ? host.anCells[j2] : null)) {
                a2.push(o2);
              }
            } else {
              a2.push(o2);
            }
          }
        }
        return a2;
      }
      if ($4.isPlainObject(s2)) {
        return s2.column !== void 0 && s2.row !== void 0 && $4.inArray(s2.row, rows) !== -1 ? [s2] : [];
      }
      var jqResult = allCells.filter(s2).map(function(i3, el) {
        return {
          // use a new object, in case someone changes the values
          row: el._DT_CellIndex.row,
          column: el._DT_CellIndex.column
        };
      }).toArray();
      if (jqResult.length || !s2.nodeName) {
        return jqResult;
      }
      host = $4(s2).closest("*[data-dt-row]");
      return host.length ? [{
        row: host.data("dt-row"),
        column: host.data("dt-column")
      }] : [];
    };
    return _selector_run("cell", selector, run, settings, opts);
  };
  _api_register("cells()", function(rowSelector, columnSelector, opts) {
    if ($4.isPlainObject(rowSelector)) {
      if (rowSelector.row === void 0) {
        opts = rowSelector;
        rowSelector = null;
      } else {
        opts = columnSelector;
        columnSelector = null;
      }
    }
    if ($4.isPlainObject(columnSelector)) {
      opts = columnSelector;
      columnSelector = null;
    }
    if (columnSelector === null || columnSelector === void 0) {
      return this.iterator("table", function(settings) {
        return __cell_selector(settings, rowSelector, _selector_opts(opts));
      });
    }
    var internalOpts = opts ? {
      page: opts.page,
      order: opts.order,
      search: opts.search
    } : {};
    var columns = this.columns(columnSelector, internalOpts);
    var rows = this.rows(rowSelector, internalOpts);
    var i2, ien, j2, jen;
    var cellsNoOpts = this.iterator("table", function(settings, idx) {
      var a2 = [];
      for (i2 = 0, ien = rows[idx].length; i2 < ien; i2++) {
        for (j2 = 0, jen = columns[idx].length; j2 < jen; j2++) {
          a2.push({
            row: rows[idx][i2],
            column: columns[idx][j2]
          });
        }
      }
      return a2;
    }, 1);
    var cells = opts && opts.selected ? this.cells(cellsNoOpts, opts) : cellsNoOpts;
    $4.extend(cells.selector, {
      cols: columnSelector,
      rows: rowSelector,
      opts
    });
    return cells;
  });
  _api_registerPlural("cells().nodes()", "cell().node()", function() {
    return this.iterator("cell", function(settings, row, column) {
      var data = settings.aoData[row];
      return data && data.anCells ? data.anCells[column] : void 0;
    }, 1);
  });
  _api_register("cells().data()", function() {
    return this.iterator("cell", function(settings, row, column) {
      return _fnGetCellData(settings, row, column);
    }, 1);
  });
  _api_registerPlural("cells().cache()", "cell().cache()", function(type) {
    type = type === "search" ? "_aFilterData" : "_aSortData";
    return this.iterator("cell", function(settings, row, column) {
      return settings.aoData[row][type][column];
    }, 1);
  });
  _api_registerPlural("cells().render()", "cell().render()", function(type) {
    return this.iterator("cell", function(settings, row, column) {
      return _fnGetCellData(settings, row, column, type);
    }, 1);
  });
  _api_registerPlural("cells().indexes()", "cell().index()", function() {
    return this.iterator("cell", function(settings, row, column) {
      return {
        row,
        column,
        columnVisible: _fnColumnIndexToVisible(settings, column)
      };
    }, 1);
  });
  _api_registerPlural("cells().invalidate()", "cell().invalidate()", function(src) {
    return this.iterator("cell", function(settings, row, column) {
      _fnInvalidate(settings, row, src, column);
    });
  });
  _api_register("cell()", function(rowSelector, columnSelector, opts) {
    return _selector_first(this.cells(rowSelector, columnSelector, opts));
  });
  _api_register("cell().data()", function(data) {
    var ctx = this.context;
    var cell = this[0];
    if (data === void 0) {
      return ctx.length && cell.length ? _fnGetCellData(ctx[0], cell[0].row, cell[0].column) : void 0;
    }
    _fnSetCellData(ctx[0], cell[0].row, cell[0].column, data);
    _fnInvalidate(ctx[0], cell[0].row, "data", cell[0].column);
    return this;
  });
  _api_register("order()", function(order2, dir) {
    var ctx = this.context;
    if (order2 === void 0) {
      return ctx.length !== 0 ? ctx[0].aaSorting : void 0;
    }
    if (typeof order2 === "number") {
      order2 = [[order2, dir]];
    } else if (order2.length && !Array.isArray(order2[0])) {
      order2 = Array.prototype.slice.call(arguments);
    }
    return this.iterator("table", function(settings) {
      settings.aaSorting = order2.slice();
    });
  });
  _api_register("order.listener()", function(node, column, callback) {
    return this.iterator("table", function(settings) {
      _fnSortAttachListener(settings, node, column, callback);
    });
  });
  _api_register("order.fixed()", function(set) {
    if (!set) {
      var ctx = this.context;
      var fixed = ctx.length ? ctx[0].aaSortingFixed : void 0;
      return Array.isArray(fixed) ? { pre: fixed } : fixed;
    }
    return this.iterator("table", function(settings) {
      settings.aaSortingFixed = $4.extend(true, {}, set);
    });
  });
  _api_register([
    "columns().order()",
    "column().order()"
  ], function(dir) {
    var that = this;
    return this.iterator("table", function(settings, i2) {
      var sort = [];
      $4.each(that[i2], function(j2, col) {
        sort.push([col, dir]);
      });
      settings.aaSorting = sort;
    });
  });
  _api_register("search()", function(input, regex, smart, caseInsen) {
    var ctx = this.context;
    if (input === void 0) {
      return ctx.length !== 0 ? ctx[0].oPreviousSearch.sSearch : void 0;
    }
    return this.iterator("table", function(settings) {
      if (!settings.oFeatures.bFilter) {
        return;
      }
      _fnFilterComplete(settings, $4.extend({}, settings.oPreviousSearch, {
        "sSearch": input + "",
        "bRegex": regex === null ? false : regex,
        "bSmart": smart === null ? true : smart,
        "bCaseInsensitive": caseInsen === null ? true : caseInsen
      }), 1);
    });
  });
  _api_registerPlural(
    "columns().search()",
    "column().search()",
    function(input, regex, smart, caseInsen) {
      return this.iterator("column", function(settings, column) {
        var preSearch = settings.aoPreSearchCols;
        if (input === void 0) {
          return preSearch[column].sSearch;
        }
        if (!settings.oFeatures.bFilter) {
          return;
        }
        $4.extend(preSearch[column], {
          "sSearch": input + "",
          "bRegex": regex === null ? false : regex,
          "bSmart": smart === null ? true : smart,
          "bCaseInsensitive": caseInsen === null ? true : caseInsen
        });
        _fnFilterComplete(settings, settings.oPreviousSearch, 1);
      });
    }
  );
  _api_register("state()", function() {
    return this.context.length ? this.context[0].oSavedState : null;
  });
  _api_register("state.clear()", function() {
    return this.iterator("table", function(settings) {
      settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
    });
  });
  _api_register("state.loaded()", function() {
    return this.context.length ? this.context[0].oLoadedState : null;
  });
  _api_register("state.save()", function() {
    return this.iterator("table", function(settings) {
      _fnSaveState(settings);
    });
  });
  DataTable.use = function(module, type) {
    if (type === "lib" || module.fn) {
      $4 = module;
    } else if (type == "win" || module.document) {
      window = module;
      document = module.document;
    } else if (type === "datetime" || module.type === "DateTime") {
      DataTable.DateTime = module;
    }
  };
  DataTable.factory = function(root, jq) {
    var is = false;
    if (root && root.document) {
      window = root;
      document = root.document;
    }
    if (jq && jq.fn && jq.fn.jquery) {
      $4 = jq;
      is = true;
    }
    return is;
  };
  DataTable.versionCheck = DataTable.fnVersionCheck = function(version) {
    var aThis = DataTable.version.split(".");
    var aThat = version.split(".");
    var iThis, iThat;
    for (var i2 = 0, iLen = aThat.length; i2 < iLen; i2++) {
      iThis = parseInt(aThis[i2], 10) || 0;
      iThat = parseInt(aThat[i2], 10) || 0;
      if (iThis === iThat) {
        continue;
      }
      return iThis > iThat;
    }
    return true;
  };
  DataTable.isDataTable = DataTable.fnIsDataTable = function(table) {
    var t2 = $4(table).get(0);
    var is = false;
    if (table instanceof DataTable.Api) {
      return true;
    }
    $4.each(DataTable.settings, function(i2, o2) {
      var head = o2.nScrollHead ? $4("table", o2.nScrollHead)[0] : null;
      var foot = o2.nScrollFoot ? $4("table", o2.nScrollFoot)[0] : null;
      if (o2.nTable === t2 || head === t2 || foot === t2) {
        is = true;
      }
    });
    return is;
  };
  DataTable.tables = DataTable.fnTables = function(visible) {
    var api = false;
    if ($4.isPlainObject(visible)) {
      api = visible.api;
      visible = visible.visible;
    }
    var a2 = $4.map(DataTable.settings, function(o2) {
      if (!visible || visible && $4(o2.nTable).is(":visible")) {
        return o2.nTable;
      }
    });
    return api ? new _Api(a2) : a2;
  };
  DataTable.camelToHungarian = _fnCamelToHungarian;
  _api_register("$()", function(selector, opts) {
    var rows = this.rows(opts).nodes(), jqRows = $4(rows);
    return $4([].concat(
      jqRows.filter(selector).toArray(),
      jqRows.find(selector).toArray()
    ));
  });
  $4.each(["on", "one", "off"], function(i2, key) {
    _api_register(key + "()", function() {
      var args = Array.prototype.slice.call(arguments);
      args[0] = $4.map(args[0].split(/\s/), function(e2) {
        return !e2.match(/\.dt\b/) ? e2 + ".dt" : e2;
      }).join(" ");
      var inst = $4(this.tables().nodes());
      inst[key].apply(inst, args);
      return this;
    });
  });
  _api_register("clear()", function() {
    return this.iterator("table", function(settings) {
      _fnClearTable(settings);
    });
  });
  _api_register("settings()", function() {
    return new _Api(this.context, this.context);
  });
  _api_register("init()", function() {
    var ctx = this.context;
    return ctx.length ? ctx[0].oInit : null;
  });
  _api_register("data()", function() {
    return this.iterator("table", function(settings) {
      return _pluck(settings.aoData, "_aData");
    }).flatten();
  });
  _api_register("destroy()", function(remove) {
    remove = remove || false;
    return this.iterator("table", function(settings) {
      var classes = settings.oClasses;
      var table = settings.nTable;
      var tbody = settings.nTBody;
      var thead = settings.nTHead;
      var tfoot = settings.nTFoot;
      var jqTable = $4(table);
      var jqTbody = $4(tbody);
      var jqWrapper = $4(settings.nTableWrapper);
      var rows = $4.map(settings.aoData, function(r2) {
        return r2.nTr;
      });
      var i2, ien;
      settings.bDestroying = true;
      _fnCallbackFire(settings, "aoDestroyCallback", "destroy", [settings]);
      if (!remove) {
        new _Api(settings).columns().visible(true);
      }
      jqWrapper.off(".DT").find(":not(tbody *)").off(".DT");
      $4(window).off(".DT-" + settings.sInstance);
      if (table != thead.parentNode) {
        jqTable.children("thead").detach();
        jqTable.append(thead);
      }
      if (tfoot && table != tfoot.parentNode) {
        jqTable.children("tfoot").detach();
        jqTable.append(tfoot);
      }
      settings.aaSorting = [];
      settings.aaSortingFixed = [];
      _fnSortingClasses(settings);
      $4(rows).removeClass(settings.asStripeClasses.join(" "));
      $4("th, td", thead).removeClass(
        classes.sSortable + " " + classes.sSortableAsc + " " + classes.sSortableDesc + " " + classes.sSortableNone
      );
      jqTbody.children().detach();
      jqTbody.append(rows);
      var orig = settings.nTableWrapper.parentNode;
      var removedMethod = remove ? "remove" : "detach";
      jqTable[removedMethod]();
      jqWrapper[removedMethod]();
      if (!remove && orig) {
        orig.insertBefore(table, settings.nTableReinsertBefore);
        jqTable.css("width", settings.sDestroyWidth).removeClass(classes.sTable);
        ien = settings.asDestroyStripes.length;
        if (ien) {
          jqTbody.children().each(function(i3) {
            $4(this).addClass(settings.asDestroyStripes[i3 % ien]);
          });
        }
      }
      var idx = $4.inArray(settings, DataTable.settings);
      if (idx !== -1) {
        DataTable.settings.splice(idx, 1);
      }
    });
  });
  $4.each(["column", "row", "cell"], function(i2, type) {
    _api_register(type + "s().every()", function(fn2) {
      var opts = this.selector.opts;
      var api = this;
      return this.iterator(type, function(settings, arg1, arg2, arg3, arg4) {
        fn2.call(
          api[type](
            arg1,
            type === "cell" ? arg2 : opts,
            type === "cell" ? opts : void 0
          ),
          arg1,
          arg2,
          arg3,
          arg4
        );
      });
    });
  });
  _api_register("i18n()", function(token, def, plural) {
    var ctx = this.context[0];
    var resolved = _fnGetObjectDataFn(token)(ctx.oLanguage);
    if (resolved === void 0) {
      resolved = def;
    }
    if (plural !== void 0 && $4.isPlainObject(resolved)) {
      resolved = resolved[plural] !== void 0 ? resolved[plural] : resolved._;
    }
    return typeof resolved === "string" ? resolved.replace("%d", plural) : resolved;
  });
  DataTable.version = "1.13.11";
  DataTable.settings = [];
  DataTable.models = {};
  DataTable.models.oSearch = {
    /**
     * Flag to indicate if the filtering should be case insensitive or not
     *  @type boolean
     *  @default true
     */
    "bCaseInsensitive": true,
    /**
     * Applied search term
     *  @type string
     *  @default <i>Empty string</i>
     */
    "sSearch": "",
    /**
     * Flag to indicate if the search term should be interpreted as a
     * regular expression (true) or not (false) and therefore and special
     * regex characters escaped.
     *  @type boolean
     *  @default false
     */
    "bRegex": false,
    /**
     * Flag to indicate if DataTables is to use its smart filtering or not.
     *  @type boolean
     *  @default true
     */
    "bSmart": true,
    /**
     * Flag to indicate if DataTables should only trigger a search when
     * the return key is pressed.
     *  @type boolean
     *  @default false
     */
    "return": false
  };
  DataTable.models.oRow = {
    /**
     * TR element for the row
     *  @type node
     *  @default null
     */
    "nTr": null,
    /**
     * Array of TD elements for each row. This is null until the row has been
     * created.
     *  @type array nodes
     *  @default []
     */
    "anCells": null,
    /**
     * Data object from the original data source for the row. This is either
     * an array if using the traditional form of DataTables, or an object if
     * using mData options. The exact type will depend on the passed in
     * data from the data source, or will be an array if using DOM a data
     * source.
     *  @type array|object
     *  @default []
     */
    "_aData": [],
    /**
     * Sorting data cache - this array is ostensibly the same length as the
     * number of columns (although each index is generated only as it is
     * needed), and holds the data that is used for sorting each column in the
     * row. We do this cache generation at the start of the sort in order that
     * the formatting of the sort data need be done only once for each cell
     * per sort. This array should not be read from or written to by anything
     * other than the master sorting methods.
     *  @type array
     *  @default null
     *  @private
     */
    "_aSortData": null,
    /**
     * Per cell filtering data cache. As per the sort data cache, used to
     * increase the performance of the filtering in DataTables
     *  @type array
     *  @default null
     *  @private
     */
    "_aFilterData": null,
    /**
     * Filtering data cache. This is the same as the cell filtering cache, but
     * in this case a string rather than an array. This is easily computed with
     * a join on `_aFilterData`, but is provided as a cache so the join isn't
     * needed on every search (memory traded for performance)
     *  @type array
     *  @default null
     *  @private
     */
    "_sFilterRow": null,
    /**
     * Cache of the class name that DataTables has applied to the row, so we
     * can quickly look at this variable rather than needing to do a DOM check
     * on className for the nTr property.
     *  @type string
     *  @default <i>Empty string</i>
     *  @private
     */
    "_sRowStripe": "",
    /**
     * Denote if the original data source was from the DOM, or the data source
     * object. This is used for invalidating data, so DataTables can
     * automatically read data from the original source, unless uninstructed
     * otherwise.
     *  @type string
     *  @default null
     *  @private
     */
    "src": null,
    /**
     * Index in the aoData array. This saves an indexOf lookup when we have the
     * object, but want to know the index
     *  @type integer
     *  @default -1
     *  @private
     */
    "idx": -1
  };
  DataTable.models.oColumn = {
    /**
     * Column index. This could be worked out on-the-fly with $.inArray, but it
     * is faster to just hold it as a variable
     *  @type integer
     *  @default null
     */
    "idx": null,
    /**
     * A list of the columns that sorting should occur on when this column
     * is sorted. That this property is an array allows multi-column sorting
     * to be defined for a column (for example first name / last name columns
     * would benefit from this). The values are integers pointing to the
     * columns to be sorted on (typically it will be a single integer pointing
     * at itself, but that doesn't need to be the case).
     *  @type array
     */
    "aDataSort": null,
    /**
     * Define the sorting directions that are applied to the column, in sequence
     * as the column is repeatedly sorted upon - i.e. the first value is used
     * as the sorting direction when the column if first sorted (clicked on).
     * Sort it again (click again) and it will move on to the next index.
     * Repeat until loop.
     *  @type array
     */
    "asSorting": null,
    /**
     * Flag to indicate if the column is searchable, and thus should be included
     * in the filtering or not.
     *  @type boolean
     */
    "bSearchable": null,
    /**
     * Flag to indicate if the column is sortable or not.
     *  @type boolean
     */
    "bSortable": null,
    /**
     * Flag to indicate if the column is currently visible in the table or not
     *  @type boolean
     */
    "bVisible": null,
    /**
     * Store for manual type assignment using the `column.type` option. This
     * is held in store so we can manipulate the column's `sType` property.
     *  @type string
     *  @default null
     *  @private
     */
    "_sManualType": null,
    /**
     * Flag to indicate if HTML5 data attributes should be used as the data
     * source for filtering or sorting. True is either are.
     *  @type boolean
     *  @default false
     *  @private
     */
    "_bAttrSrc": false,
    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     *  @type function
     *  @param {element} nTd The TD node that has been created
     *  @param {*} sData The Data for the cell
     *  @param {array|object} oData The data for the whole row
     *  @param {int} iRow The row index for the aoData data store
     *  @default null
     */
    "fnCreatedCell": null,
    /**
     * Function to get data from a cell in a column. You should <b>never</b>
     * access data directly through _aData internally in DataTables - always use
     * the method attached to this property. It allows mData to function as
     * required. This function is automatically assigned by the column
     * initialisation method
     *  @type function
     *  @param {array|object} oData The data array/object for the array
     *    (i.e. aoData[]._aData)
     *  @param {string} sSpecific The specific data type you want to get -
     *    'display', 'type' 'filter' 'sort'
     *  @returns {*} The data for the cell from the given row's data
     *  @default null
     */
    "fnGetData": null,
    /**
     * Function to set data for a cell in the column. You should <b>never</b>
     * set the data directly to _aData internally in DataTables - always use
     * this method. It allows mData to function as required. This function
     * is automatically assigned by the column initialisation method
     *  @type function
     *  @param {array|object} oData The data array/object for the array
     *    (i.e. aoData[]._aData)
     *  @param {*} sValue Value to set
     *  @default null
     */
    "fnSetData": null,
    /**
     * Property to read the value for the cells in the column from the data
     * source array / object. If null, then the default content is used, if a
     * function is given then the return from the function is used.
     *  @type function|int|string|null
     *  @default null
     */
    "mData": null,
    /**
     * Partner property to mData which is used (only when defined) to get
     * the data - i.e. it is basically the same as mData, but without the
     * 'set' option, and also the data fed to it is the result from mData.
     * This is the rendering method to match the data method of mData.
     *  @type function|int|string|null
     *  @default null
     */
    "mRender": null,
    /**
     * Unique header TH/TD element for this column - this is what the sorting
     * listener is attached to (if sorting is enabled.)
     *  @type node
     *  @default null
     */
    "nTh": null,
    /**
     * Unique footer TH/TD element for this column (if there is one). Not used
     * in DataTables as such, but can be used for plug-ins to reference the
     * footer for each column.
     *  @type node
     *  @default null
     */
    "nTf": null,
    /**
     * The class to apply to all TD elements in the table's TBODY for the column
     *  @type string
     *  @default null
     */
    "sClass": null,
    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     *  @type string
     */
    "sContentPadding": null,
    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because mData
     * is set to null, or because the data source itself is null).
     *  @type string
     *  @default null
     */
    "sDefaultContent": null,
    /**
     * Name for the column, allowing reference to the column by name as well as
     * by index (needs a lookup to work by name).
     *  @type string
     */
    "sName": null,
    /**
     * Custom sorting data type - defines which of the available plug-ins in
     * afnSortData the custom sorting will use - if any is defined.
     *  @type string
     *  @default std
     */
    "sSortDataType": "std",
    /**
     * Class to be applied to the header element when sorting on this column
     *  @type string
     *  @default null
     */
    "sSortingClass": null,
    /**
     * Class to be applied to the header element when sorting on this column -
     * when jQuery UI theming is used.
     *  @type string
     *  @default null
     */
    "sSortingClassJUI": null,
    /**
     * Title of the column - what is seen in the TH element (nTh).
     *  @type string
     */
    "sTitle": null,
    /**
     * Column sorting and filtering type
     *  @type string
     *  @default null
     */
    "sType": null,
    /**
     * Width of the column
     *  @type string
     *  @default null
     */
    "sWidth": null,
    /**
     * Width of the column when it was first "encountered"
     *  @type string
     *  @default null
     */
    "sWidthOrig": null
  };
  DataTable.defaults = {
    /**
     * An array of data to use for the table, passed in at initialisation which
     * will be used in preference to any data which is already in the DOM. This is
     * particularly useful for constructing tables purely in Javascript, for
     * example with a custom Ajax call.
     *  @type array
     *  @default null
     *
     *  @dtopt Option
     *  @name DataTable.defaults.data
     *
     *  @example
     *    // Using a 2D array data source
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "data": [
     *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
     *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
     *        ],
     *        "columns": [
     *          { "title": "Engine" },
     *          { "title": "Browser" },
     *          { "title": "Platform" },
     *          { "title": "Version" },
     *          { "title": "Grade" }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using an array of objects as a data source (`data`)
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "data": [
     *          {
     *            "engine":   "Trident",
     *            "browser":  "Internet Explorer 4.0",
     *            "platform": "Win 95+",
     *            "version":  4,
     *            "grade":    "X"
     *          },
     *          {
     *            "engine":   "Trident",
     *            "browser":  "Internet Explorer 5.0",
     *            "platform": "Win 95+",
     *            "version":  5,
     *            "grade":    "C"
     *          }
     *        ],
     *        "columns": [
     *          { "title": "Engine",   "data": "engine" },
     *          { "title": "Browser",  "data": "browser" },
     *          { "title": "Platform", "data": "platform" },
     *          { "title": "Version",  "data": "version" },
     *          { "title": "Grade",    "data": "grade" }
     *        ]
     *      } );
     *    } );
     */
    "aaData": null,
    /**
     * If ordering is enabled, then DataTables will perform a first pass sort on
     * initialisation. You can define which column(s) the sort is performed
     * upon, and the sorting direction, with this variable. The `sorting` array
     * should contain an array for each column to be sorted initially containing
     * the column's index and a direction string ('asc' or 'desc').
     *  @type array
     *  @default [[0,'asc']]
     *
     *  @dtopt Option
     *  @name DataTable.defaults.order
     *
     *  @example
     *    // Sort by 3rd column first, and then 4th column
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "order": [[2,'asc'], [3,'desc']]
     *      } );
     *    } );
     *
     *    // No initial sorting
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "order": []
     *      } );
     *    } );
     */
    "aaSorting": [[0, "asc"]],
    /**
     * This parameter is basically identical to the `sorting` parameter, but
     * cannot be overridden by user interaction with the table. What this means
     * is that you could have a column (visible or hidden) which the sorting
     * will always be forced on first - any sorting after that (from the user)
     * will then be performed as required. This can be useful for grouping rows
     * together.
     *  @type array
     *  @default null
     *
     *  @dtopt Option
     *  @name DataTable.defaults.orderFixed
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "orderFixed": [[0,'asc']]
     *      } );
     *    } )
     */
    "aaSortingFixed": [],
    /**
     * DataTables can be instructed to load data to display in the table from a
     * Ajax source. This option defines how that Ajax call is made and where to.
     *
     * The `ajax` property has three different modes of operation, depending on
     * how it is defined. These are:
     *
     * * `string` - Set the URL from where the data should be loaded from.
     * * `object` - Define properties for `jQuery.ajax`.
     * * `function` - Custom data get function
     *
     * `string`
     * --------
     *
     * As a string, the `ajax` property simply defines the URL from which
     * DataTables will load data.
     *
     * `object`
     * --------
     *
     * As an object, the parameters in the object are passed to
     * [jQuery.ajax](https://api.jquery.com/jQuery.ajax/) allowing fine control
     * of the Ajax request. DataTables has a number of default parameters which
     * you can override using this option. Please refer to the jQuery
     * documentation for a full description of the options available, although
     * the following parameters provide additional options in DataTables or
     * require special consideration:
     *
     * * `data` - As with jQuery, `data` can be provided as an object, but it
     *   can also be used as a function to manipulate the data DataTables sends
     *   to the server. The function takes a single parameter, an object of
     *   parameters with the values that DataTables has readied for sending. An
     *   object may be returned which will be merged into the DataTables
     *   defaults, or you can add the items to the object that was passed in and
     *   not return anything from the function. This supersedes `fnServerParams`
     *   from DataTables 1.9-.
     *
     * * `dataSrc` - By default DataTables will look for the property `data` (or
     *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
     *   from an Ajax source or for server-side processing - this parameter
     *   allows that property to be changed. You can use Javascript dotted
     *   object notation to get a data source for multiple levels of nesting, or
     *   it my be used as a function. As a function it takes a single parameter,
     *   the JSON returned from the server, which can be manipulated as
     *   required, with the returned value being that used by DataTables as the
     *   data source for the table. This supersedes `sAjaxDataProp` from
     *   DataTables 1.9-.
     *
     * * `success` - Should not be overridden it is used internally in
     *   DataTables. To manipulate / transform the data returned by the server
     *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
     *
     * `function`
     * ----------
     *
     * As a function, making the Ajax call is left up to yourself allowing
     * complete control of the Ajax request. Indeed, if desired, a method other
     * than Ajax could be used to obtain the required data, such as Web storage
     * or an AIR database.
     *
     * The function is given four parameters and no return is required. The
     * parameters are:
     *
     * 1. _object_ - Data to send to the server
     * 2. _function_ - Callback function that must be executed when the required
     *    data has been obtained. That data should be passed into the callback
     *    as the only parameter
     * 3. _object_ - DataTables settings object for the table
     *
     * Note that this supersedes `fnServerData` from DataTables 1.9-.
     *
     *  @type string|object|function
     *  @default null
     *
     *  @dtopt Option
     *  @name DataTable.defaults.ajax
     *  @since 1.10.0
     *
     * @example
     *   // Get JSON data from a file via Ajax.
     *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).
     *   $('#example').dataTable( {
     *     "ajax": "data.json"
     *   } );
     *
     * @example
     *   // Get JSON data from a file via Ajax, using `dataSrc` to change
     *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "dataSrc": "tableData"
     *     }
     *   } );
     *
     * @example
     *   // Get JSON data from a file via Ajax, using `dataSrc` to read data
     *   // from a plain array rather than an array in an object
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "dataSrc": ""
     *     }
     *   } );
     *
     * @example
     *   // Manipulate the data returned from the server - add a link to data
     *   // (note this can, should, be done using `render` for the column - this
     *   // is just a simple example of how the data can be manipulated).
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "dataSrc": function ( json ) {
     *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {
     *           json[i][0] = '<a href="/message/'+json[i][0]+'>View message</a>';
     *         }
     *         return json;
     *       }
     *     }
     *   } );
     *
     * @example
     *   // Add data to the request
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "data": function ( d ) {
     *         return {
     *           "extra_search": $('#extra').val()
     *         };
     *       }
     *     }
     *   } );
     *
     * @example
     *   // Send request as POST
     *   $('#example').dataTable( {
     *     "ajax": {
     *       "url": "data.json",
     *       "type": "POST"
     *     }
     *   } );
     *
     * @example
     *   // Get the data from localStorage (could interface with a form for
     *   // adding, editing and removing rows).
     *   $('#example').dataTable( {
     *     "ajax": function (data, callback, settings) {
     *       callback(
     *         JSON.parse( localStorage.getItem('dataTablesData') )
     *       );
     *     }
     *   } );
     */
    "ajax": null,
    /**
     * This parameter allows you to readily specify the entries in the length drop
     * down menu that DataTables shows when pagination is enabled. It can be
     * either a 1D array of options which will be used for both the displayed
     * option and the value, or a 2D array which will use the array in the first
     * position as the value, and the array in the second position as the
     * displayed options (useful for language strings such as 'All').
     *
     * Note that the `pageLength` property will be automatically set to the
     * first value given in this array, unless `pageLength` is also provided.
     *  @type array
     *  @default [ 10, 25, 50, 100 ]
     *
     *  @dtopt Option
     *  @name DataTable.defaults.lengthMenu
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "lengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
     *      } );
     *    } );
     */
    "aLengthMenu": [10, 25, 50, 100],
    /**
     * The `columns` option in the initialisation parameter allows you to define
     * details about the way individual columns behave. For a full list of
     * column options that can be set, please see
     * {@link DataTable.defaults.column}. Note that if you use `columns` to
     * define your columns, you must have an entry in the array for every single
     * column that you have in your table (these can be null if you don't which
     * to specify any options).
     *  @member
     *
     *  @name DataTable.defaults.column
     */
    "aoColumns": null,
    /**
     * Very similar to `columns`, `columnDefs` allows you to target a specific
     * column, multiple columns, or all columns, using the `targets` property of
     * each object in the array. This allows great flexibility when creating
     * tables, as the `columnDefs` arrays can be of any length, targeting the
     * columns you specifically want. `columnDefs` may use any of the column
     * options available: {@link DataTable.defaults.column}, but it _must_
     * have `targets` defined in each object in the array. Values in the `targets`
     * array may be:
     *   <ul>
     *     <li>a string - class name will be matched on the TH for the column</li>
     *     <li>0 or a positive integer - column index counting from the left</li>
     *     <li>a negative integer - column index counting from the right</li>
     *     <li>the string "_all" - all columns (i.e. assign a default)</li>
     *   </ul>
     *  @member
     *
     *  @name DataTable.defaults.columnDefs
     */
    "aoColumnDefs": null,
    /**
     * Basically the same as `search`, this parameter defines the individual column
     * filtering state at initialisation time. The array must be of the same size
     * as the number of columns, and each element be an object with the parameters
     * `search` and `escapeRegex` (the latter is optional). 'null' is also
     * accepted and the default will be used.
     *  @type array
     *  @default []
     *
     *  @dtopt Option
     *  @name DataTable.defaults.searchCols
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "searchCols": [
     *          null,
     *          { "search": "My filter" },
     *          null,
     *          { "search": "^[0-9]", "escapeRegex": false }
     *        ]
     *      } );
     *    } )
     */
    "aoSearchCols": [],
    /**
     * An array of CSS classes that should be applied to displayed rows. This
     * array may be of any length, and DataTables will apply each class
     * sequentially, looping when required.
     *  @type array
     *  @default null <i>Will take the values determined by the `oClasses.stripe*`
     *    options</i>
     *
     *  @dtopt Option
     *  @name DataTable.defaults.stripeClasses
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stripeClasses": [ 'strip1', 'strip2', 'strip3' ]
     *      } );
     *    } )
     */
    "asStripeClasses": null,
    /**
     * Enable or disable automatic column width calculation. This can be disabled
     * as an optimisation (it takes some time to calculate the widths) if the
     * tables widths are passed in using `columns`.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.autoWidth
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "autoWidth": false
     *      } );
     *    } );
     */
    "bAutoWidth": true,
    /**
     * Deferred rendering can provide DataTables with a huge speed boost when you
     * are using an Ajax or JS data source for the table. This option, when set to
     * true, will cause DataTables to defer the creation of the table elements for
     * each row until they are needed for a draw - saving a significant amount of
     * time.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.deferRender
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajax": "sources/arrays.txt",
     *        "deferRender": true
     *      } );
     *    } );
     */
    "bDeferRender": false,
    /**
     * Replace a DataTable which matches the given selector and replace it with
     * one which has the properties of the new initialisation object passed. If no
     * table matches the selector, then the new DataTable will be constructed as
     * per normal.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.destroy
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "srollY": "200px",
     *        "paginate": false
     *      } );
     *
     *      // Some time later....
     *      $('#example').dataTable( {
     *        "filter": false,
     *        "destroy": true
     *      } );
     *    } );
     */
    "bDestroy": false,
    /**
     * Enable or disable filtering of data. Filtering in DataTables is "smart" in
     * that it allows the end user to input multiple words (space separated) and
     * will match a row containing those words, even if not in the order that was
     * specified (this allow matching across multiple columns). Note that if you
     * wish to use filtering in DataTables this must remain 'true' - to remove the
     * default filtering input box and retain filtering abilities, please use
     * {@link DataTable.defaults.dom}.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.searching
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "searching": false
     *      } );
     *    } );
     */
    "bFilter": true,
    /**
     * Enable or disable the table information display. This shows information
     * about the data that is currently visible on the page, including information
     * about filtered data if that action is being performed.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.info
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "info": false
     *      } );
     *    } );
     */
    "bInfo": true,
    /**
     * Allows the end user to select the size of a formatted page from a select
     * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.lengthChange
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "lengthChange": false
     *      } );
     *    } );
     */
    "bLengthChange": true,
    /**
     * Enable or disable pagination.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.paging
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "paging": false
     *      } );
     *    } );
     */
    "bPaginate": true,
    /**
     * Enable or disable the display of a 'processing' indicator when the table is
     * being processed (e.g. a sort). This is particularly useful for tables with
     * large amounts of data where it can take a noticeable amount of time to sort
     * the entries.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.processing
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "processing": true
     *      } );
     *    } );
     */
    "bProcessing": false,
    /**
     * Retrieve the DataTables object for the given selector. Note that if the
     * table has already been initialised, this parameter will cause DataTables
     * to simply return the object that has already been set up - it will not take
     * account of any changes you might have made to the initialisation object
     * passed to DataTables (setting this parameter to true is an acknowledgement
     * that you understand this). `destroy` can be used to reinitialise a table if
     * you need.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.retrieve
     *
     *  @example
     *    $(document).ready( function() {
     *      initTable();
     *      tableActions();
     *    } );
     *
     *    function initTable ()
     *    {
     *      return $('#example').dataTable( {
     *        "scrollY": "200px",
     *        "paginate": false,
     *        "retrieve": true
     *      } );
     *    }
     *
     *    function tableActions ()
     *    {
     *      var table = initTable();
     *      // perform API operations with oTable
     *    }
     */
    "bRetrieve": false,
    /**
     * When vertical (y) scrolling is enabled, DataTables will force the height of
     * the table's viewport to the given height at all times (useful for layout).
     * However, this can look odd when filtering data down to a small data set,
     * and the footer is left "floating" further down. This parameter (when
     * enabled) will cause DataTables to collapse the table's viewport down when
     * the result set will fit within the given Y height.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.scrollCollapse
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollY": "200",
     *        "scrollCollapse": true
     *      } );
     *    } );
     */
    "bScrollCollapse": false,
    /**
     * Configure DataTables to use server-side processing. Note that the
     * `ajax` parameter must also be given in order to give DataTables a
     * source to obtain the required data for each draw.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverSide
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "serverSide": true,
     *        "ajax": "xhr.php"
     *      } );
     *    } );
     */
    "bServerSide": false,
    /**
     * Enable or disable sorting of columns. Sorting of individual columns can be
     * disabled by the `sortable` option for each column.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.ordering
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "ordering": false
     *      } );
     *    } );
     */
    "bSort": true,
    /**
     * Enable or display DataTables' ability to sort multiple columns at the
     * same time (activated by shift-click by the user).
     *  @type boolean
     *  @default true
     *
     *  @dtopt Options
     *  @name DataTable.defaults.orderMulti
     *
     *  @example
     *    // Disable multiple column sorting ability
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "orderMulti": false
     *      } );
     *    } );
     */
    "bSortMulti": true,
    /**
     * Allows control over whether DataTables should use the top (true) unique
     * cell that is found for a single column, or the bottom (false - default).
     * This is useful when using complex headers.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Options
     *  @name DataTable.defaults.orderCellsTop
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "orderCellsTop": true
     *      } );
     *    } );
     */
    "bSortCellsTop": false,
    /**
     * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
     * `sorting\_3` to the columns which are currently being sorted on. This is
     * presented as a feature switch as it can increase processing time (while
     * classes are removed and added) so for large data sets you might want to
     * turn this off.
     *  @type boolean
     *  @default true
     *
     *  @dtopt Features
     *  @name DataTable.defaults.orderClasses
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "orderClasses": false
     *      } );
     *    } );
     */
    "bSortClasses": true,
    /**
     * Enable or disable state saving. When enabled HTML5 `localStorage` will be
     * used to save table display information such as pagination information,
     * display length, filtering and sorting. As such when the end user reloads
     * the page the display display will match what thy had previously set up.
     *
     * Due to the use of `localStorage` the default state saving is not supported
     * in IE6 or 7. If state saving is required in those browsers, use
     * `stateSaveCallback` to provide a storage solution such as cookies.
     *  @type boolean
     *  @default false
     *
     *  @dtopt Features
     *  @name DataTable.defaults.stateSave
     *
     *  @example
     *    $(document).ready( function () {
     *      $('#example').dataTable( {
     *        "stateSave": true
     *      } );
     *    } );
     */
    "bStateSave": false,
    /**
     * This function is called when a TR element is created (and all TD child
     * elements have been inserted), or registered if using a DOM source, allowing
     * manipulation of the TR element (adding classes etc).
     *  @type function
     *  @param {node} row "TR" element for the current row
     *  @param {array} data Raw data array for this row
     *  @param {int} dataIndex The index of this row in the internal aoData array
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.createdRow
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "createdRow": function( row, data, dataIndex ) {
     *          // Bold the grade for all 'A' grade browsers
     *          if ( data[4] == "A" )
     *          {
     *            $('td:eq(4)', row).html( '<b>A</b>' );
     *          }
     *        }
     *      } );
     *    } );
     */
    "fnCreatedRow": null,
    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify any aspect you want about the created DOM.
     *  @type function
     *  @param {object} settings DataTables settings object
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.drawCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "drawCallback": function( settings ) {
     *          alert( 'DataTables has redrawn the table' );
     *        }
     *      } );
     *    } );
     */
    "fnDrawCallback": null,
    /**
     * Identical to fnHeaderCallback() but for the table footer this function
     * allows you to modify the table footer on every 'draw' event.
     *  @type function
     *  @param {node} foot "TR" element for the footer
     *  @param {array} data Full table data (as derived from the original HTML)
     *  @param {int} start Index for the current display starting point in the
     *    display array
     *  @param {int} end Index for the current display ending point in the
     *    display array
     *  @param {array int} display Index array to translate the visual position
     *    to the full data array
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.footerCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "footerCallback": function( tfoot, data, start, end, display ) {
     *          tfoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+start;
     *        }
     *      } );
     *    } )
     */
    "fnFooterCallback": null,
    /**
     * When rendering large numbers in the information element for the table
     * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
     * to have a comma separator for the 'thousands' units (e.g. 1 million is
     * rendered as "1,000,000") to help readability for the end user. This
     * function will override the default method DataTables uses.
     *  @type function
     *  @member
     *  @param {int} toFormat number to be formatted
     *  @returns {string} formatted string for DataTables to show the number
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.formatNumber
     *
     *  @example
     *    // Format a number using a single quote for the separator (note that
     *    // this can also be done with the language.thousands option)
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "formatNumber": function ( toFormat ) {
     *          return toFormat.toString().replace(
     *            /\B(?=(\d{3})+(?!\d))/g, "'"
     *          );
     *        };
     *      } );
     *    } );
     */
    "fnFormatNumber": function(toFormat) {
      return toFormat.toString().replace(
        /\B(?=(\d{3})+(?!\d))/g,
        this.oLanguage.sThousands
      );
    },
    /**
     * This function is called on every 'draw' event, and allows you to
     * dynamically modify the header row. This can be used to calculate and
     * display useful information about the table.
     *  @type function
     *  @param {node} head "TR" element for the header
     *  @param {array} data Full table data (as derived from the original HTML)
     *  @param {int} start Index for the current display starting point in the
     *    display array
     *  @param {int} end Index for the current display ending point in the
     *    display array
     *  @param {array int} display Index array to translate the visual position
     *    to the full data array
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.headerCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "fheaderCallback": function( head, data, start, end, display ) {
     *          head.getElementsByTagName('th')[0].innerHTML = "Displaying "+(end-start)+" records";
     *        }
     *      } );
     *    } )
     */
    "fnHeaderCallback": null,
    /**
     * The information element can be used to convey information about the current
     * state of the table. Although the internationalisation options presented by
     * DataTables are quite capable of dealing with most customisations, there may
     * be times where you wish to customise the string further. This callback
     * allows you to do exactly that.
     *  @type function
     *  @param {object} oSettings DataTables settings object
     *  @param {int} start Starting position in data for the draw
     *  @param {int} end End position in data for the draw
     *  @param {int} max Total number of rows in the table (regardless of
     *    filtering)
     *  @param {int} total Total number of rows in the data set, after filtering
     *  @param {string} pre The string that DataTables has formatted using it's
     *    own rules
     *  @returns {string} The string to be displayed in the information element.
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.infoCallback
     *
     *  @example
     *    $('#example').dataTable( {
     *      "infoCallback": function( settings, start, end, max, total, pre ) {
     *        return start +" to "+ end;
     *      }
     *    } );
     */
    "fnInfoCallback": null,
    /**
     * Called when the table has been initialised. Normally DataTables will
     * initialise sequentially and there will be no need for this function,
     * however, this does not hold true when using external language information
     * since that is obtained using an async XHR call.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} json The JSON object request from the server - only
     *    present if client-side Ajax sourced data is used
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.initComplete
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "initComplete": function(settings, json) {
     *          alert( 'DataTables has finished its initialisation.' );
     *        }
     *      } );
     *    } )
     */
    "fnInitComplete": null,
    /**
     * Called at the very start of each table draw and can be used to cancel the
     * draw by returning false, any other return (including undefined) results in
     * the full draw occurring).
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @returns {boolean} False will cancel the draw, anything else (including no
     *    return) will allow it to complete.
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.preDrawCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "preDrawCallback": function( settings ) {
     *          if ( $('#test').val() == 1 ) {
     *            return false;
     *          }
     *        }
     *      } );
     *    } );
     */
    "fnPreDrawCallback": null,
    /**
     * This function allows you to 'post process' each row after it have been
     * generated for each table draw, but before it is rendered on screen. This
     * function might be used for setting the row class name etc.
     *  @type function
     *  @param {node} row "TR" element for the current row
     *  @param {array} data Raw data array for this row
     *  @param {int} displayIndex The display index for the current table draw
     *  @param {int} displayIndexFull The index of the data in the full list of
     *    rows (after filtering)
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.rowCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "rowCallback": function( row, data, displayIndex, displayIndexFull ) {
     *          // Bold the grade for all 'A' grade browsers
     *          if ( data[4] == "A" ) {
     *            $('td:eq(4)', row).html( '<b>A</b>' );
     *          }
     *        }
     *      } );
     *    } );
     */
    "fnRowCallback": null,
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * This parameter allows you to override the default function which obtains
     * the data from the server so something more suitable for your application.
     * For example you could use POST data, or pull information from a Gears or
     * AIR database.
     *  @type function
     *  @member
     *  @param {string} source HTTP source to obtain the data from (`ajax`)
     *  @param {array} data A key/value pair object containing the data to send
     *    to the server
     *  @param {function} callback to be called on completion of the data get
     *    process that will draw the data on the page.
     *  @param {object} settings DataTables settings object
     *
     *  @dtopt Callbacks
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverData
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "fnServerData": null,
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     *  It is often useful to send extra data to the server when making an Ajax
     * request - for example custom filtering information, and this callback
     * function makes it trivial to send extra information to the server. The
     * passed in parameter is the data set that has been constructed by
     * DataTables, and you can add to this or modify it as you require.
     *  @type function
     *  @param {array} data Data array (array of objects which are name/value
     *    pairs) that has been constructed by DataTables and will be sent to the
     *    server. In the case of Ajax sourced data with server-side processing
     *    this will be an empty array, for server-side processing there will be a
     *    significant number of parameters!
     *  @returns {undefined} Ensure that you modify the data array passed in,
     *    as this is passed by reference.
     *
     *  @dtopt Callbacks
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverParams
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "fnServerParams": null,
    /**
     * Load the table state. With this function you can define from where, and how, the
     * state of a table is loaded. By default DataTables will load from `localStorage`
     * but you might wish to use a server-side database or cookies.
     *  @type function
     *  @member
     *  @param {object} settings DataTables settings object
     *  @param {object} callback Callback that can be executed when done. It
     *    should be passed the loaded state object.
     *  @return {object} The DataTables state object to be loaded
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateLoadCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoadCallback": function (settings, callback) {
     *          $.ajax( {
     *            "url": "/state_load",
     *            "dataType": "json",
     *            "success": function (json) {
     *              callback( json );
     *            }
     *          } );
     *        }
     *      } );
     *    } );
     */
    "fnStateLoadCallback": function(settings) {
      try {
        return JSON.parse(
          (settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
            "DataTables_" + settings.sInstance + "_" + location.pathname
          )
        );
      } catch (e2) {
        return {};
      }
    },
    /**
     * Callback which allows modification of the saved state prior to loading that state.
     * This callback is called when the table is loading state from the stored data, but
     * prior to the settings object being modified by the saved state. Note that for
     * plug-in authors, you should use the `stateLoadParams` event to load parameters for
     * a plug-in.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object that is to be loaded
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateLoadParams
     *
     *  @example
     *    // Remove a saved filter, so filtering is never loaded
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoadParams": function (settings, data) {
     *          data.oSearch.sSearch = "";
     *        }
     *      } );
     *    } );
     *
     *  @example
     *    // Disallow state loading by returning false
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoadParams": function (settings, data) {
     *          return false;
     *        }
     *      } );
     *    } );
     */
    "fnStateLoadParams": null,
    /**
     * Callback that is called when the state has been loaded from the state saving method
     * and the DataTables settings object has been modified as a result of the loaded state.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object that was loaded
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateLoaded
     *
     *  @example
     *    // Show an alert with the filtering value that was saved
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateLoaded": function (settings, data) {
     *          alert( 'Saved filter was: '+data.oSearch.sSearch );
     *        }
     *      } );
     *    } );
     */
    "fnStateLoaded": null,
    /**
     * Save the table state. This function allows you to define where and how the state
     * information for the table is stored By default DataTables will use `localStorage`
     * but you might wish to use a server-side database or cookies.
     *  @type function
     *  @member
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object to be saved
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateSaveCallback
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateSaveCallback": function (settings, data) {
     *          // Send an Ajax request to the server with the state object
     *          $.ajax( {
     *            "url": "/state_save",
     *            "data": data,
     *            "dataType": "json",
     *            "method": "POST"
     *            "success": function () {}
     *          } );
     *        }
     *      } );
     *    } );
     */
    "fnStateSaveCallback": function(settings, data) {
      try {
        (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
          "DataTables_" + settings.sInstance + "_" + location.pathname,
          JSON.stringify(data)
        );
      } catch (e2) {
      }
    },
    /**
     * Callback which allows modification of the state to be saved. Called when the table
     * has changed state a new state save is required. This method allows modification of
     * the state saving object prior to actually doing the save, including addition or
     * other state properties or modification. Note that for plug-in authors, you should
     * use the `stateSaveParams` event to save parameters for a plug-in.
     *  @type function
     *  @param {object} settings DataTables settings object
     *  @param {object} data The state object to be saved
     *
     *  @dtopt Callbacks
     *  @name DataTable.defaults.stateSaveParams
     *
     *  @example
     *    // Remove a saved filter, so filtering is never saved
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateSave": true,
     *        "stateSaveParams": function (settings, data) {
     *          data.oSearch.sSearch = "";
     *        }
     *      } );
     *    } );
     */
    "fnStateSaveParams": null,
    /**
     * Duration for which the saved state information is considered valid. After this period
     * has elapsed the state will be returned to the default.
     * Value is given in seconds.
     *  @type int
     *  @default 7200 <i>(2 hours)</i>
     *
     *  @dtopt Options
     *  @name DataTable.defaults.stateDuration
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "stateDuration": 60*60*24; // 1 day
     *      } );
     *    } )
     */
    "iStateDuration": 7200,
    /**
     * When enabled DataTables will not make a request to the server for the first
     * page draw - rather it will use the data already on the page (no sorting etc
     * will be applied to it), thus saving on an XHR at load time. `deferLoading`
     * is used to indicate that deferred loading is required, but it is also used
     * to tell DataTables how many records there are in the full table (allowing
     * the information element and pagination to be displayed correctly). In the case
     * where a filtering is applied to the table on initial load, this can be
     * indicated by giving the parameter as an array, where the first element is
     * the number of records available after filtering and the second element is the
     * number of records without filtering (allowing the table information element
     * to be shown correctly).
     *  @type int | array
     *  @default null
     *
     *  @dtopt Options
     *  @name DataTable.defaults.deferLoading
     *
     *  @example
     *    // 57 records available in the table, no filtering applied
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "serverSide": true,
     *        "ajax": "scripts/server_processing.php",
     *        "deferLoading": 57
     *      } );
     *    } );
     *
     *  @example
     *    // 57 records after filtering, 100 without filtering (an initial filter applied)
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "serverSide": true,
     *        "ajax": "scripts/server_processing.php",
     *        "deferLoading": [ 57, 100 ],
     *        "search": {
     *          "search": "my_filter"
     *        }
     *      } );
     *    } );
     */
    "iDeferLoading": null,
    /**
     * Number of rows to display on a single page when using pagination. If
     * feature enabled (`lengthChange`) then the end user will be able to override
     * this to a custom setting using a pop-up menu.
     *  @type int
     *  @default 10
     *
     *  @dtopt Options
     *  @name DataTable.defaults.pageLength
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "pageLength": 50
     *      } );
     *    } )
     */
    "iDisplayLength": 10,
    /**
     * Define the starting point for data display when using DataTables with
     * pagination. Note that this parameter is the number of records, rather than
     * the page number, so if you have 10 records per page and want to start on
     * the third page, it should be "20".
     *  @type int
     *  @default 0
     *
     *  @dtopt Options
     *  @name DataTable.defaults.displayStart
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "displayStart": 20
     *      } );
     *    } )
     */
    "iDisplayStart": 0,
    /**
     * By default DataTables allows keyboard navigation of the table (sorting, paging,
     * and filtering) by adding a `tabindex` attribute to the required elements. This
     * allows you to tab through the controls and press the enter key to activate them.
     * The tabindex is default 0, meaning that the tab follows the flow of the document.
     * You can overrule this using this parameter if you wish. Use a value of -1 to
     * disable built-in keyboard navigation.
     *  @type int
     *  @default 0
     *
     *  @dtopt Options
     *  @name DataTable.defaults.tabIndex
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "tabIndex": 1
     *      } );
     *    } );
     */
    "iTabIndex": 0,
    /**
     * Classes that DataTables assigns to the various components and features
     * that it adds to the HTML table. This allows classes to be configured
     * during initialisation in addition to through the static
     * {@link DataTable.ext.oStdClasses} object).
     *  @namespace
     *  @name DataTable.defaults.classes
     */
    "oClasses": {},
    /**
     * All strings that DataTables uses in the user interface that it creates
     * are defined in this object, allowing you to modified them individually or
     * completely replace them all as required.
     *  @namespace
     *  @name DataTable.defaults.language
     */
    "oLanguage": {
      /**
       * Strings that are used for WAI-ARIA labels and controls only (these are not
       * actually visible on the page, but will be read by screenreaders, and thus
       * must be internationalised as well).
       *  @namespace
       *  @name DataTable.defaults.language.aria
       */
      "oAria": {
        /**
         * ARIA label that is added to the table headers when the column may be
         * sorted ascending by activing the column (click or return when focused).
         * Note that the column header is prefixed to this string.
         *  @type string
         *  @default : activate to sort column ascending
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.aria.sortAscending
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "aria": {
         *            "sortAscending": " - click/return to sort ascending"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sSortAscending": ": activate to sort column ascending",
        /**
         * ARIA label that is added to the table headers when the column may be
         * sorted descending by activing the column (click or return when focused).
         * Note that the column header is prefixed to this string.
         *  @type string
         *  @default : activate to sort column ascending
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.aria.sortDescending
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "aria": {
         *            "sortDescending": " - click/return to sort descending"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sSortDescending": ": activate to sort column descending"
      },
      /**
       * Pagination string used by DataTables for the built-in pagination
       * control types.
       *  @namespace
       *  @name DataTable.defaults.language.paginate
       */
      "oPaginate": {
        /**
         * Text to use when using the 'full_numbers' type of pagination for the
         * button to take the user to the first page.
         *  @type string
         *  @default First
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.first
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "first": "First page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sFirst": "First",
        /**
         * Text to use when using the 'full_numbers' type of pagination for the
         * button to take the user to the last page.
         *  @type string
         *  @default Last
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.last
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "last": "Last page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sLast": "Last",
        /**
         * Text to use for the 'next' pagination button (to take the user to the
         * next page).
         *  @type string
         *  @default Next
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.next
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "next": "Next page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sNext": "Next",
        /**
         * Text to use for the 'previous' pagination button (to take the user to
         * the previous page).
         *  @type string
         *  @default Previous
         *
         *  @dtopt Language
         *  @name DataTable.defaults.language.paginate.previous
         *
         *  @example
         *    $(document).ready( function() {
         *      $('#example').dataTable( {
         *        "language": {
         *          "paginate": {
         *            "previous": "Previous page"
         *          }
         *        }
         *      } );
         *    } );
         */
        "sPrevious": "Previous"
      },
      /**
       * This string is shown in preference to `zeroRecords` when the table is
       * empty of data (regardless of filtering). Note that this is an optional
       * parameter - if it is not given, the value of `zeroRecords` will be used
       * instead (either the default or given value).
       *  @type string
       *  @default No data available in table
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.emptyTable
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "emptyTable": "No data available in table"
       *        }
       *      } );
       *    } );
       */
      "sEmptyTable": "No data available in table",
      /**
       * This string gives information to the end user about the information
       * that is current on display on the page. The following tokens can be
       * used in the string and will be dynamically replaced as the table
       * display updates. This tokens can be placed anywhere in the string, or
       * removed as needed by the language requires:
       *
       * * `\_START\_` - Display index of the first record on the current page
       * * `\_END\_` - Display index of the last record on the current page
       * * `\_TOTAL\_` - Number of records in the table after filtering
       * * `\_MAX\_` - Number of records in the table without filtering
       * * `\_PAGE\_` - Current page number
       * * `\_PAGES\_` - Total number of pages of data in the table
       *
       *  @type string
       *  @default Showing _START_ to _END_ of _TOTAL_ entries
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.info
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "info": "Showing page _PAGE_ of _PAGES_"
       *        }
       *      } );
       *    } );
       */
      "sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",
      /**
       * Display information string for when the table is empty. Typically the
       * format of this string should match `info`.
       *  @type string
       *  @default Showing 0 to 0 of 0 entries
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.infoEmpty
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "infoEmpty": "No entries to show"
       *        }
       *      } );
       *    } );
       */
      "sInfoEmpty": "Showing 0 to 0 of 0 entries",
      /**
       * When a user filters the information in a table, this string is appended
       * to the information (`info`) to give an idea of how strong the filtering
       * is. The variable _MAX_ is dynamically updated.
       *  @type string
       *  @default (filtered from _MAX_ total entries)
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.infoFiltered
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "infoFiltered": " - filtering from _MAX_ records"
       *        }
       *      } );
       *    } );
       */
      "sInfoFiltered": "(filtered from _MAX_ total entries)",
      /**
       * If can be useful to append extra information to the info string at times,
       * and this variable does exactly that. This information will be appended to
       * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
       * being used) at all times.
       *  @type string
       *  @default <i>Empty string</i>
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.infoPostFix
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "infoPostFix": "All records shown are derived from real information."
       *        }
       *      } );
       *    } );
       */
      "sInfoPostFix": "",
      /**
       * This decimal place operator is a little different from the other
       * language options since DataTables doesn't output floating point
       * numbers, so it won't ever use this for display of a number. Rather,
       * what this parameter does is modify the sort methods of the table so
       * that numbers which are in a format which has a character other than
       * a period (`.`) as a decimal place will be sorted numerically.
       *
       * Note that numbers with different decimal places cannot be shown in
       * the same table and still be sortable, the table must be consistent.
       * However, multiple different tables on the page can use different
       * decimal place characters.
       *  @type string
       *  @default 
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.decimal
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "decimal": ","
       *          "thousands": "."
       *        }
       *      } );
       *    } );
       */
      "sDecimal": "",
      /**
       * DataTables has a build in number formatter (`formatNumber`) which is
       * used to format large numbers that are used in the table information.
       * By default a comma is used, but this can be trivially changed to any
       * character you wish with this parameter.
       *  @type string
       *  @default ,
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.thousands
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "thousands": "'"
       *        }
       *      } );
       *    } );
       */
      "sThousands": ",",
      /**
       * Detail the action that will be taken when the drop down menu for the
       * pagination length option is changed. The '_MENU_' variable is replaced
       * with a default select list of 10, 25, 50 and 100, and can be replaced
       * with a custom select box if required.
       *  @type string
       *  @default Show _MENU_ entries
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.lengthMenu
       *
       *  @example
       *    // Language change only
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "lengthMenu": "Display _MENU_ records"
       *        }
       *      } );
       *    } );
       *
       *  @example
       *    // Language and options change
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "lengthMenu": 'Display <select>'+
       *            '<option value="10">10</option>'+
       *            '<option value="20">20</option>'+
       *            '<option value="30">30</option>'+
       *            '<option value="40">40</option>'+
       *            '<option value="50">50</option>'+
       *            '<option value="-1">All</option>'+
       *            '</select> records'
       *        }
       *      } );
       *    } );
       */
      "sLengthMenu": "Show _MENU_ entries",
      /**
       * When using Ajax sourced data and during the first draw when DataTables is
       * gathering the data, this message is shown in an empty row in the table to
       * indicate to the end user the the data is being loaded. Note that this
       * parameter is not used when loading data by server-side processing, just
       * Ajax sourced data with client-side processing.
       *  @type string
       *  @default Loading...
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.loadingRecords
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "loadingRecords": "Please wait - loading..."
       *        }
       *      } );
       *    } );
       */
      "sLoadingRecords": "Loading...",
      /**
       * Text which is displayed when the table is processing a user action
       * (usually a sort command or similar).
       *  @type string
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.processing
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "processing": "DataTables is currently busy"
       *        }
       *      } );
       *    } );
       */
      "sProcessing": "",
      /**
       * Details the actions that will be taken when the user types into the
       * filtering input text box. The variable "_INPUT_", if used in the string,
       * is replaced with the HTML text box for the filtering input allowing
       * control over where it appears in the string. If "_INPUT_" is not given
       * then the input box is appended to the string automatically.
       *  @type string
       *  @default Search:
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.search
       *
       *  @example
       *    // Input text box will be appended at the end automatically
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "search": "Filter records:"
       *        }
       *      } );
       *    } );
       *
       *  @example
       *    // Specify where the filter should appear
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "search": "Apply filter _INPUT_ to table"
       *        }
       *      } );
       *    } );
       */
      "sSearch": "Search:",
      /**
       * Assign a `placeholder` attribute to the search `input` element
       *  @type string
       *  @default 
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.searchPlaceholder
       */
      "sSearchPlaceholder": "",
      /**
       * All of the language information can be stored in a file on the
       * server-side, which DataTables will look up if this parameter is passed.
       * It must store the URL of the language file, which is in a JSON format,
       * and the object has the same properties as the oLanguage object in the
       * initialiser object (i.e. the above parameters). Please refer to one of
       * the example language files to see how this works in action.
       *  @type string
       *  @default <i>Empty string - i.e. disabled</i>
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.url
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "url": "https://www.sprymedia.co.uk/dataTables/lang.txt"
       *        }
       *      } );
       *    } );
       */
      "sUrl": "",
      /**
       * Text shown inside the table records when the is no information to be
       * displayed after filtering. `emptyTable` is shown when there is simply no
       * information in the table at all (regardless of filtering).
       *  @type string
       *  @default No matching records found
       *
       *  @dtopt Language
       *  @name DataTable.defaults.language.zeroRecords
       *
       *  @example
       *    $(document).ready( function() {
       *      $('#example').dataTable( {
       *        "language": {
       *          "zeroRecords": "No records to display"
       *        }
       *      } );
       *    } );
       */
      "sZeroRecords": "No matching records found"
    },
    /**
     * This parameter allows you to have define the global filtering state at
     * initialisation time. As an object the `search` parameter must be
     * defined, but all other parameters are optional. When `regex` is true,
     * the search string will be treated as a regular expression, when false
     * (default) it will be treated as a straight string. When `smart`
     * DataTables will use it's smart filtering methods (to word match at
     * any point in the data), when false this will not be done.
     *  @namespace
     *  @extends DataTable.models.oSearch
     *
     *  @dtopt Options
     *  @name DataTable.defaults.search
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "search": {"search": "Initial search"}
     *      } );
     *    } )
     */
    "oSearch": $4.extend({}, DataTable.models.oSearch),
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * By default DataTables will look for the property `data` (or `aaData` for
     * compatibility with DataTables 1.9-) when obtaining data from an Ajax
     * source or for server-side processing - this parameter allows that
     * property to be changed. You can use Javascript dotted object notation to
     * get a data source for multiple levels of nesting.
     *  @type string
     *  @default data
     *
     *  @dtopt Options
     *  @dtopt Server-side
     *  @name DataTable.defaults.ajaxDataProp
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "sAjaxDataProp": "data",
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * You can instruct DataTables to load data from an external
     * source using this parameter (use aData if you want to pass data in you
     * already have). Simply provide a url a JSON object can be obtained from.
     *  @type string
     *  @default null
     *
     *  @dtopt Options
     *  @dtopt Server-side
     *  @name DataTable.defaults.ajaxSource
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "sAjaxSource": null,
    /**
     * This initialisation variable allows you to specify exactly where in the
     * DOM you want DataTables to inject the various controls it adds to the page
     * (for example you might want the pagination controls at the top of the
     * table). DIV elements (with or without a custom class) can also be added to
     * aid styling. The follow syntax is used:
     *   <ul>
     *     <li>The following options are allowed:
     *       <ul>
     *         <li>'l' - Length changing</li>
     *         <li>'f' - Filtering input</li>
     *         <li>'t' - The table!</li>
     *         <li>'i' - Information</li>
     *         <li>'p' - Pagination</li>
     *         <li>'r' - pRocessing</li>
     *       </ul>
     *     </li>
     *     <li>The following constants are allowed:
     *       <ul>
     *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
     *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
     *       </ul>
     *     </li>
     *     <li>The following syntax is expected:
     *       <ul>
     *         <li>'&lt;' and '&gt;' - div elements</li>
     *         <li>'&lt;"class" and '&gt;' - div with a class</li>
     *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
     *       </ul>
     *     </li>
     *     <li>Examples:
     *       <ul>
     *         <li>'&lt;"wrapper"flipt&gt;'</li>
     *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
     *       </ul>
     *     </li>
     *   </ul>
     *  @type string
     *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>
     *    <"H"lfr>t<"F"ip> <i>(when `jQueryUI` is true)</i>
     *
     *  @dtopt Options
     *  @name DataTable.defaults.dom
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "dom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&gt;'
     *      } );
     *    } );
     */
    "sDom": "lfrtip",
    /**
     * Search delay option. This will throttle full table searches that use the
     * DataTables provided search input element (it does not effect calls to
     * `dt-api search()`, providing a delay before the search is made.
     *  @type integer
     *  @default 0
     *
     *  @dtopt Options
     *  @name DataTable.defaults.searchDelay
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "searchDelay": 200
     *      } );
     *    } )
     */
    "searchDelay": null,
    /**
     * DataTables features six different built-in options for the buttons to
     * display for pagination control:
     *
     * * `numbers` - Page number buttons only
     * * `simple` - 'Previous' and 'Next' buttons only
     * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
     * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
     * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
     * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
     *  
     * Further methods can be added using {@link DataTable.ext.oPagination}.
     *  @type string
     *  @default simple_numbers
     *
     *  @dtopt Options
     *  @name DataTable.defaults.pagingType
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "pagingType": "full_numbers"
     *      } );
     *    } )
     */
    "sPaginationType": "simple_numbers",
    /**
     * Enable horizontal scrolling. When a table is too wide to fit into a
     * certain layout, or you have a large number of columns in the table, you
     * can enable x-scrolling to show the table in a viewport, which can be
     * scrolled. This property can be `true` which will allow the table to
     * scroll horizontally when needed, or any CSS unit, or a number (in which
     * case it will be treated as a pixel measurement). Setting as simply `true`
     * is recommended.
     *  @type boolean|string
     *  @default <i>blank string - i.e. disabled</i>
     *
     *  @dtopt Features
     *  @name DataTable.defaults.scrollX
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollX": true,
     *        "scrollCollapse": true
     *      } );
     *    } );
     */
    "sScrollX": "",
    /**
     * This property can be used to force a DataTable to use more width than it
     * might otherwise do when x-scrolling is enabled. For example if you have a
     * table which requires to be well spaced, this parameter is useful for
     * "over-sizing" the table, and thus forcing scrolling. This property can by
     * any CSS unit, or a number (in which case it will be treated as a pixel
     * measurement).
     *  @type string
     *  @default <i>blank string - i.e. disabled</i>
     *
     *  @dtopt Options
     *  @name DataTable.defaults.scrollXInner
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollX": "100%",
     *        "scrollXInner": "110%"
     *      } );
     *    } );
     */
    "sScrollXInner": "",
    /**
     * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
     * to the given height, and enable scrolling for any data which overflows the
     * current viewport. This can be used as an alternative to paging to display
     * a lot of data in a small area (although paging and scrolling can both be
     * enabled at the same time). This property can be any CSS unit, or a number
     * (in which case it will be treated as a pixel measurement).
     *  @type string
     *  @default <i>blank string - i.e. disabled</i>
     *
     *  @dtopt Features
     *  @name DataTable.defaults.scrollY
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "scrollY": "200px",
     *        "paginate": false
     *      } );
     *    } );
     */
    "sScrollY": "",
    /**
     * __Deprecated__ The functionality provided by this parameter has now been
     * superseded by that provided through `ajax`, which should be used instead.
     *
     * Set the HTTP method that is used to make the Ajax call for server-side
     * processing or Ajax sourced data.
     *  @type string
     *  @default GET
     *
     *  @dtopt Options
     *  @dtopt Server-side
     *  @name DataTable.defaults.serverMethod
     *
     *  @deprecated 1.10. Please use `ajax` for this functionality now.
     */
    "sServerMethod": "GET",
    /**
     * DataTables makes use of renderers when displaying HTML elements for
     * a table. These renderers can be added or modified by plug-ins to
     * generate suitable mark-up for a site. For example the Bootstrap
     * integration plug-in for DataTables uses a paging button renderer to
     * display pagination buttons in the mark-up required by Bootstrap.
     *
     * For further information about the renderers available see
     * DataTable.ext.renderer
     *  @type string|object
     *  @default null
     *
     *  @name DataTable.defaults.renderer
     *
     */
    "renderer": null,
    /**
     * Set the data property name that DataTables should use to get a row's id
     * to set as the `id` property in the node.
     *  @type string
     *  @default DT_RowId
     *
     *  @name DataTable.defaults.rowId
     */
    "rowId": "DT_RowId"
  };
  _fnHungarianMap(DataTable.defaults);
  DataTable.defaults.column = {
    /**
     * Define which column(s) an order will occur on for this column. This
     * allows a column's ordering to take multiple columns into account when
     * doing a sort or use the data from a different column. For example first
     * name / last name columns make sense to do a multi-column sort over the
     * two columns.
     *  @type array|int
     *  @default null <i>Takes the value of the column index automatically</i>
     *
     *  @name DataTable.defaults.column.orderData
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderData": [ 0, 1 ], "targets": [ 0 ] },
     *          { "orderData": [ 1, 0 ], "targets": [ 1 ] },
     *          { "orderData": 2, "targets": [ 2 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "orderData": [ 0, 1 ] },
     *          { "orderData": [ 1, 0 ] },
     *          { "orderData": 2 },
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "aDataSort": null,
    "iDataSort": -1,
    /**
     * You can control the default ordering direction, and even alter the
     * behaviour of the sort handler (i.e. only allow ascending ordering etc)
     * using this parameter.
     *  @type array
     *  @default [ 'asc', 'desc' ]
     *
     *  @name DataTable.defaults.column.orderSequence
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderSequence": [ "asc" ], "targets": [ 1 ] },
     *          { "orderSequence": [ "desc", "asc", "asc" ], "targets": [ 2 ] },
     *          { "orderSequence": [ "desc" ], "targets": [ 3 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          { "orderSequence": [ "asc" ] },
     *          { "orderSequence": [ "desc", "asc", "asc" ] },
     *          { "orderSequence": [ "desc" ] },
     *          null
     *        ]
     *      } );
     *    } );
     */
    "asSorting": ["asc", "desc"],
    /**
     * Enable or disable filtering on the data in this column.
     *  @type boolean
     *  @default true
     *
     *  @name DataTable.defaults.column.searchable
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "searchable": false, "targets": [ 0 ] }
     *        ] } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "searchable": false },
     *          null,
     *          null,
     *          null,
     *          null
     *        ] } );
     *    } );
     */
    "bSearchable": true,
    /**
     * Enable or disable ordering on this column.
     *  @type boolean
     *  @default true
     *
     *  @name DataTable.defaults.column.orderable
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderable": false, "targets": [ 0 ] }
     *        ] } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "orderable": false },
     *          null,
     *          null,
     *          null,
     *          null
     *        ] } );
     *    } );
     */
    "bSortable": true,
    /**
     * Enable or disable the display of this column.
     *  @type boolean
     *  @default true
     *
     *  @name DataTable.defaults.column.visible
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "visible": false, "targets": [ 0 ] }
     *        ] } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "visible": false },
     *          null,
     *          null,
     *          null,
     *          null
     *        ] } );
     *    } );
     */
    "bVisible": true,
    /**
     * Developer definable function that is called whenever a cell is created (Ajax source,
     * etc) or processed for input (DOM source). This can be used as a compliment to mRender
     * allowing you to modify the DOM element (add background colour for example) when the
     * element is available.
     *  @type function
     *  @param {element} td The TD node that has been created
     *  @param {*} cellData The Data for the cell
     *  @param {array|object} rowData The data for the whole row
     *  @param {int} row The row index for the aoData data store
     *  @param {int} col The column index for aoColumns
     *
     *  @name DataTable.defaults.column.createdCell
     *  @dtopt Columns
     *
     *  @example
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [3],
     *          "createdCell": function (td, cellData, rowData, row, col) {
     *            if ( cellData == "1.7" ) {
     *              $(td).css('color', 'blue')
     *            }
     *          }
     *        } ]
     *      });
     *    } );
     */
    "fnCreatedCell": null,
    /**
     * This parameter has been replaced by `data` in DataTables to ensure naming
     * consistency. `dataProp` can still be used, as there is backwards
     * compatibility in DataTables for this option, but it is strongly
     * recommended that you use `data` in preference to `dataProp`.
     *  @name DataTable.defaults.column.dataProp
     */
    /**
     * This property can be used to read data from any data source property,
     * including deeply nested objects / properties. `data` can be given in a
     * number of different ways which effect its behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object. Note that
     *      function notation is recommended for use in `render` rather than
     *      `data` as it is much simpler to use as a renderer.
     * * `null` - use the original data source for the row rather than plucking
     *   data directly from it. This action has effects on two other
     *   initialisation options:
     *    * `defaultContent` - When null is given as the `data` option and
     *      `defaultContent` is specified for the column, the value defined by
     *      `defaultContent` will be used for the cell.
     *    * `render` - When null is used for the `data` option and the `render`
     *      option is specified for the column, the whole data source for the
     *      row is used for the renderer.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * `{array|object}` The data source for the row
     *      * `{string}` The type call data requested - this will be 'set' when
     *        setting data or 'filter', 'display', 'type', 'sort' or undefined
     *        when gathering data. Note that when `undefined` is given for the
     *        type DataTables expects to get the raw data for the object back<
     *      * `{*}` Data to set when the second parameter is 'set'.
     *    * Return:
     *      * The return value from the function is not required when 'set' is
     *        the type of call, but otherwise the return is what will be used
     *        for the data requested.
     *
     * Note that `data` is a getter and setter option. If you just require
     * formatting of data for output, you will likely want to use `render` which
     * is simply a getter and thus simpler to use.
     *
     * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
     * name change reflects the flexibility of this property and is consistent
     * with the naming of mRender. If 'mDataProp' is given, then it will still
     * be used by DataTables, as it automatically maps the old name to the new
     * if required.
     *
     *  @type string|int|function|null
     *  @default null <i>Use automatically calculated column index</i>
     *
     *  @name DataTable.defaults.column.data
     *  @dtopt Columns
     *
     *  @example
     *    // Read table data from objects
     *    // JSON structure for each row:
     *    //   {
     *    //      "engine": {value},
     *    //      "browser": {value},
     *    //      "platform": {value},
     *    //      "version": {value},
     *    //      "grade": {value}
     *    //   }
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajaxSource": "sources/objects.txt",
     *        "columns": [
     *          { "data": "engine" },
     *          { "data": "browser" },
     *          { "data": "platform" },
     *          { "data": "version" },
     *          { "data": "grade" }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Read information from deeply nested objects
     *    // JSON structure for each row:
     *    //   {
     *    //      "engine": {value},
     *    //      "browser": {value},
     *    //      "platform": {
     *    //         "inner": {value}
     *    //      },
     *    //      "details": [
     *    //         {value}, {value}
     *    //      ]
     *    //   }
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajaxSource": "sources/deep.txt",
     *        "columns": [
     *          { "data": "engine" },
     *          { "data": "browser" },
     *          { "data": "platform.inner" },
     *          { "data": "details.0" },
     *          { "data": "details.1" }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `data` as a function to provide different information for
     *    // sorting, filtering and display. In this case, currency (price)
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": function ( source, type, val ) {
     *            if (type === 'set') {
     *              source.price = val;
     *              // Store the computed display and filter values for efficiency
     *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
     *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
     *              return;
     *            }
     *            else if (type === 'display') {
     *              return source.price_display;
     *            }
     *            else if (type === 'filter') {
     *              return source.price_filter;
     *            }
     *            // 'sort', 'type' and undefined all just use the integer
     *            return source.price;
     *          }
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using default content
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": null,
     *          "defaultContent": "Click to edit"
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using array notation - outputting a list from an array
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": "name[, ]"
     *        } ]
     *      } );
     *    } );
     *
     */
    "mData": null,
    /**
     * This property is the rendering partner to `data` and it is suggested that
     * when you want to manipulate data for display (including filtering,
     * sorting etc) without altering the underlying data for the table, use this
     * property. `render` can be considered to be the the read only companion to
     * `data` which is read / write (then as such more complex). Like `data`
     * this option can be given in a number of different ways to effect its
     * behaviour:
     *
     * * `integer` - treated as an array index for the data source. This is the
     *   default that DataTables uses (incrementally increased for each column).
     * * `string` - read an object property from the data source. There are
     *   three 'special' options that can be used in the string to alter how
     *   DataTables reads the data from the source object:
     *    * `.` - Dotted Javascript notation. Just as you use a `.` in
     *      Javascript to read from nested objects, so to can the options
     *      specified in `data`. For example: `browser.version` or
     *      `browser.name`. If your object parameter name contains a period, use
     *      `\\` to escape it - i.e. `first\\.name`.
     *    * `[]` - Array notation. DataTables can automatically combine data
     *      from and array source, joining the data with the characters provided
     *      between the two brackets. For example: `name[, ]` would provide a
     *      comma-space separated list from the source array. If no characters
     *      are provided between the brackets, the original array source is
     *      returned.
     *    * `()` - Function notation. Adding `()` to the end of a parameter will
     *      execute a function of the name given. For example: `browser()` for a
     *      simple function on the data source, `browser.version()` for a
     *      function in a nested property or even `browser().version` to get an
     *      object property if the function called returns an object.
     * * `object` - use different data for the different data types requested by
     *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
     *   of the object is the data type the property refers to and the value can
     *   defined using an integer, string or function using the same rules as
     *   `render` normally does. Note that an `_` option _must_ be specified.
     *   This is the default value to use if you haven't specified a value for
     *   the data type requested by DataTables.
     * * `function` - the function given will be executed whenever DataTables
     *   needs to set or get the data for a cell in the column. The function
     *   takes three parameters:
     *    * Parameters:
     *      * {array|object} The data source for the row (based on `data`)
     *      * {string} The type call data requested - this will be 'filter',
     *        'display', 'type' or 'sort'.
     *      * {array|object} The full data source for the row (not based on
     *        `data`)
     *    * Return:
     *      * The return value from the function is what will be used for the
     *        data requested.
     *
     *  @type string|int|function|object|null
     *  @default null Use the data source value.
     *
     *  @name DataTable.defaults.column.render
     *  @dtopt Columns
     *
     *  @example
     *    // Create a comma separated list from an array of objects
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "ajaxSource": "sources/deep.txt",
     *        "columns": [
     *          { "data": "engine" },
     *          { "data": "browser" },
     *          {
     *            "data": "platform",
     *            "render": "[, ].name"
     *          }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Execute a function to obtain data
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": null, // Use the full data source object for the renderer's source
     *          "render": "browserName()"
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // As an object, extracting different data for the different types
     *    // This would be used with a data source such as:
     *    //   { "phone": 5552368, "phone_filter": "5552368 555-2368", "phone_display": "555-2368" }
     *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`
     *    // (which has both forms) is used for filtering for if a user inputs either format, while
     *    // the formatted phone number is the one that is shown in the table.
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": null, // Use the full data source object for the renderer's source
     *          "render": {
     *            "_": "phone",
     *            "filter": "phone_filter",
     *            "display": "phone_display"
     *          }
     *        } ]
     *      } );
     *    } );
     *
     *  @example
     *    // Use as a function to create a link from the data source
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "data": "download_link",
     *          "render": function ( data, type, full ) {
     *            return '<a href="'+data+'">Download</a>';
     *          }
     *        } ]
     *      } );
     *    } );
     */
    "mRender": null,
    /**
     * Change the cell type created for the column - either TD cells or TH cells. This
     * can be useful as TH cells have semantic meaning in the table body, allowing them
     * to act as a header for a row (you may wish to add scope='row' to the TH elements).
     *  @type string
     *  @default td
     *
     *  @name DataTable.defaults.column.cellType
     *  @dtopt Columns
     *
     *  @example
     *    // Make the first column use TH cells
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [ {
     *          "targets": [ 0 ],
     *          "cellType": "th"
     *        } ]
     *      } );
     *    } );
     */
    "sCellType": "td",
    /**
     * Class to give to each cell in this column.
     *  @type string
     *  @default <i>Empty string</i>
     *
     *  @name DataTable.defaults.column.class
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "class": "my_class", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "class": "my_class" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sClass": "",
    /**
     * When DataTables calculates the column widths to assign to each column,
     * it finds the longest string in each column and then constructs a
     * temporary table and reads the widths from that. The problem with this
     * is that "mmm" is much wider then "iiii", but the latter is a longer
     * string - thus the calculation can go wrong (doing it properly and putting
     * it into an DOM object and measuring that is horribly(!) slow). Thus as
     * a "work around" we provide this option. It will append its value to the
     * text that is found to be the longest string for the column - i.e. padding.
     * Generally you shouldn't need this!
     *  @type string
     *  @default <i>Empty string<i>
     *
     *  @name DataTable.defaults.column.contentPadding
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          null,
     *          null,
     *          {
     *            "contentPadding": "mmm"
     *          }
     *        ]
     *      } );
     *    } );
     */
    "sContentPadding": "",
    /**
     * Allows a default value to be given for a column's data, and will be used
     * whenever a null data source is encountered (this can be because `data`
     * is set to null, or because the data source itself is null).
     *  @type string
     *  @default null
     *
     *  @name DataTable.defaults.column.defaultContent
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          {
     *            "data": null,
     *            "defaultContent": "Edit",
     *            "targets": [ -1 ]
     *          }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          null,
     *          null,
     *          {
     *            "data": null,
     *            "defaultContent": "Edit"
     *          }
     *        ]
     *      } );
     *    } );
     */
    "sDefaultContent": null,
    /**
     * This parameter is only used in DataTables' server-side processing. It can
     * be exceptionally useful to know what columns are being displayed on the
     * client side, and to map these to database fields. When defined, the names
     * also allow DataTables to reorder information from the server if it comes
     * back in an unexpected order (i.e. if you switch your columns around on the
     * client-side, your server-side code does not also need updating).
     *  @type string
     *  @default <i>Empty string</i>
     *
     *  @name DataTable.defaults.column.name
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "name": "engine", "targets": [ 0 ] },
     *          { "name": "browser", "targets": [ 1 ] },
     *          { "name": "platform", "targets": [ 2 ] },
     *          { "name": "version", "targets": [ 3 ] },
     *          { "name": "grade", "targets": [ 4 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "name": "engine" },
     *          { "name": "browser" },
     *          { "name": "platform" },
     *          { "name": "version" },
     *          { "name": "grade" }
     *        ]
     *      } );
     *    } );
     */
    "sName": "",
    /**
     * Defines a data source type for the ordering which can be used to read
     * real-time information from the table (updating the internally cached
     * version) prior to ordering. This allows ordering to occur on user
     * editable elements such as form inputs.
     *  @type string
     *  @default std
     *
     *  @name DataTable.defaults.column.orderDataType
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "orderDataType": "dom-text", "targets": [ 2, 3 ] },
     *          { "type": "numeric", "targets": [ 3 ] },
     *          { "orderDataType": "dom-select", "targets": [ 4 ] },
     *          { "orderDataType": "dom-checkbox", "targets": [ 5 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          null,
     *          null,
     *          { "orderDataType": "dom-text" },
     *          { "orderDataType": "dom-text", "type": "numeric" },
     *          { "orderDataType": "dom-select" },
     *          { "orderDataType": "dom-checkbox" }
     *        ]
     *      } );
     *    } );
     */
    "sSortDataType": "std",
    /**
     * The title of this column.
     *  @type string
     *  @default null <i>Derived from the 'TH' value for this column in the
     *    original HTML table.</i>
     *
     *  @name DataTable.defaults.column.title
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "title": "My column title", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "title": "My column title" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sTitle": null,
    /**
     * The type allows you to specify how the data for this column will be
     * ordered. Four types (string, numeric, date and html (which will strip
     * HTML tags before ordering)) are currently available. Note that only date
     * formats understood by Javascript's Date() object will be accepted as type
     * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
     * 'numeric', 'date' or 'html' (by default). Further types can be adding
     * through plug-ins.
     *  @type string
     *  @default null <i>Auto-detected from raw data</i>
     *
     *  @name DataTable.defaults.column.type
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "type": "html", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "type": "html" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sType": null,
    /**
     * Defining the width of the column, this parameter may take any CSS value
     * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
     * been given a specific width through this interface ensuring that the table
     * remains readable.
     *  @type string
     *  @default null <i>Automatic</i>
     *
     *  @name DataTable.defaults.column.width
     *  @dtopt Columns
     *
     *  @example
     *    // Using `columnDefs`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columnDefs": [
     *          { "width": "20%", "targets": [ 0 ] }
     *        ]
     *      } );
     *    } );
     *
     *  @example
     *    // Using `columns`
     *    $(document).ready( function() {
     *      $('#example').dataTable( {
     *        "columns": [
     *          { "width": "20%" },
     *          null,
     *          null,
     *          null,
     *          null
     *        ]
     *      } );
     *    } );
     */
    "sWidth": null
  };
  _fnHungarianMap(DataTable.defaults.column);
  DataTable.models.oSettings = {
    /**
     * Primary features of DataTables and their enablement state.
     *  @namespace
     */
    "oFeatures": {
      /**
       * Flag to say if DataTables should automatically try to calculate the
       * optimum table and columns widths (true) or not (false).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bAutoWidth": null,
      /**
       * Delay the creation of TR and TD elements until they are actually
       * needed by a driven page draw. This can give a significant speed
       * increase for Ajax source and Javascript source data, but makes no
       * difference at all for DOM and server-side processing tables.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bDeferRender": null,
      /**
       * Enable filtering on the table or not. Note that if this is disabled
       * then there is no filtering at all on the table, including fnFilter.
       * To just remove the filtering input use sDom and remove the 'f' option.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bFilter": null,
      /**
       * Table information element (the 'Showing x of y records' div) enable
       * flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bInfo": null,
      /**
       * Present a user control allowing the end user to change the page size
       * when pagination is enabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bLengthChange": null,
      /**
       * Pagination enabled or not. Note that if this is disabled then length
       * changing must also be disabled.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bPaginate": null,
      /**
       * Processing indicator enable flag whenever DataTables is enacting a
       * user request - typically an Ajax request for server-side processing.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bProcessing": null,
      /**
       * Server-side processing enabled flag - when enabled DataTables will
       * get all data from the server for every draw - there is no filtering,
       * sorting or paging done on the client-side.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bServerSide": null,
      /**
       * Sorting enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSort": null,
      /**
       * Multi-column sorting
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSortMulti": null,
      /**
       * Apply a class to the columns which are being sorted to provide a
       * visual highlight or not. This can slow things down when enabled since
       * there is a lot of DOM interaction.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bSortClasses": null,
      /**
       * State saving enablement flag.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bStateSave": null
    },
    /**
     * Scrolling settings for a table.
     *  @namespace
     */
    "oScroll": {
      /**
       * When the table is shorter in height than sScrollY, collapse the
       * table container down to the height of the table (when true).
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type boolean
       */
      "bCollapse": null,
      /**
       * Width of the scrollbar for the web-browser's platform. Calculated
       * during table initialisation.
       *  @type int
       *  @default 0
       */
      "iBarWidth": 0,
      /**
       * Viewport width for horizontal scrolling. Horizontal scrolling is
       * disabled if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       */
      "sX": null,
      /**
       * Width to expand the table to when using x-scrolling. Typically you
       * should not need to use this.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       *  @deprecated
       */
      "sXInner": null,
      /**
       * Viewport height for vertical scrolling. Vertical scrolling is disabled
       * if an empty string.
       * Note that this parameter will be set by the initialisation routine. To
       * set a default use {@link DataTable.defaults}.
       *  @type string
       */
      "sY": null
    },
    /**
     * Language information for the table.
     *  @namespace
     *  @extends DataTable.defaults.oLanguage
     */
    "oLanguage": {
      /**
       * Information callback function. See
       * {@link DataTable.defaults.fnInfoCallback}
       *  @type function
       *  @default null
       */
      "fnInfoCallback": null
    },
    /**
     * Browser support parameters
     *  @namespace
     */
    "oBrowser": {
      /**
       * Indicate if the browser incorrectly calculates width:100% inside a
       * scrolling element (IE6/7)
       *  @type boolean
       *  @default false
       */
      "bScrollOversize": false,
      /**
       * Determine if the vertical scrollbar is on the right or left of the
       * scrolling container - needed for rtl language layout, although not
       * all browsers move the scrollbar (Safari).
       *  @type boolean
       *  @default false
       */
      "bScrollbarLeft": false,
      /**
       * Flag for if `getBoundingClientRect` is fully supported or not
       *  @type boolean
       *  @default false
       */
      "bBounding": false,
      /**
       * Browser scrollbar width
       *  @type integer
       *  @default 0
       */
      "barWidth": 0
    },
    "ajax": null,
    /**
     * Array referencing the nodes which are used for the features. The
     * parameters of this object match what is allowed by sDom - i.e.
     *   <ul>
     *     <li>'l' - Length changing</li>
     *     <li>'f' - Filtering input</li>
     *     <li>'t' - The table!</li>
     *     <li>'i' - Information</li>
     *     <li>'p' - Pagination</li>
     *     <li>'r' - pRocessing</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aanFeatures": [],
    /**
     * Store data information - see {@link DataTable.models.oRow} for detailed
     * information.
     *  @type array
     *  @default []
     */
    "aoData": [],
    /**
     * Array of indexes which are in the current display (after filtering etc)
     *  @type array
     *  @default []
     */
    "aiDisplay": [],
    /**
     * Array of indexes for display - no filtering
     *  @type array
     *  @default []
     */
    "aiDisplayMaster": [],
    /**
     * Map of row ids to data indexes
     *  @type object
     *  @default {}
     */
    "aIds": {},
    /**
     * Store information about each column that is in use
     *  @type array
     *  @default []
     */
    "aoColumns": [],
    /**
     * Store information about the table's header
     *  @type array
     *  @default []
     */
    "aoHeader": [],
    /**
     * Store information about the table's footer
     *  @type array
     *  @default []
     */
    "aoFooter": [],
    /**
     * Store the applied global search information in case we want to force a
     * research or compare the old search to a new one.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @namespace
     *  @extends DataTable.models.oSearch
     */
    "oPreviousSearch": {},
    /**
     * Store the applied search for each column - see
     * {@link DataTable.models.oSearch} for the format that is used for the
     * filtering information for each column.
     *  @type array
     *  @default []
     */
    "aoPreSearchCols": [],
    /**
     * Sorting that is applied to the table. Note that the inner arrays are
     * used in the following manner:
     * <ul>
     *   <li>Index 0 - column number</li>
     *   <li>Index 1 - current sorting direction</li>
     * </ul>
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @todo These inner arrays should really be objects
     */
    "aaSorting": null,
    /**
     * Sorting that is always applied to the table (i.e. prefixed in front of
     * aaSorting).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "aaSortingFixed": [],
    /**
     * Classes to use for the striping of a table.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "asStripeClasses": null,
    /**
     * If restoring a table - we should restore its striping classes as well
     *  @type array
     *  @default []
     */
    "asDestroyStripes": [],
    /**
     * If restoring a table - we should restore its width
     *  @type int
     *  @default 0
     */
    "sDestroyWidth": 0,
    /**
     * Callback functions array for every time a row is inserted (i.e. on a draw).
     *  @type array
     *  @default []
     */
    "aoRowCallback": [],
    /**
     * Callback functions for the header on each draw.
     *  @type array
     *  @default []
     */
    "aoHeaderCallback": [],
    /**
     * Callback function for the footer on each draw.
     *  @type array
     *  @default []
     */
    "aoFooterCallback": [],
    /**
     * Array of callback functions for draw callback functions
     *  @type array
     *  @default []
     */
    "aoDrawCallback": [],
    /**
     * Array of callback functions for row created function
     *  @type array
     *  @default []
     */
    "aoRowCreatedCallback": [],
    /**
     * Callback functions for just before the table is redrawn. A return of
     * false will be used to cancel the draw.
     *  @type array
     *  @default []
     */
    "aoPreDrawCallback": [],
    /**
     * Callback functions for when the table has been initialised.
     *  @type array
     *  @default []
     */
    "aoInitComplete": [],
    /**
     * Callbacks for modifying the settings to be stored for state saving, prior to
     * saving state.
     *  @type array
     *  @default []
     */
    "aoStateSaveParams": [],
    /**
     * Callbacks for modifying the settings that have been stored for state saving
     * prior to using the stored values to restore the state.
     *  @type array
     *  @default []
     */
    "aoStateLoadParams": [],
    /**
     * Callbacks for operating on the settings object once the saved state has been
     * loaded
     *  @type array
     *  @default []
     */
    "aoStateLoaded": [],
    /**
     * Cache the table ID for quick access
     *  @type string
     *  @default <i>Empty string</i>
     */
    "sTableId": "",
    /**
     * The TABLE node for the main table
     *  @type node
     *  @default null
     */
    "nTable": null,
    /**
     * Permanent ref to the thead element
     *  @type node
     *  @default null
     */
    "nTHead": null,
    /**
     * Permanent ref to the tfoot element - if it exists
     *  @type node
     *  @default null
     */
    "nTFoot": null,
    /**
     * Permanent ref to the tbody element
     *  @type node
     *  @default null
     */
    "nTBody": null,
    /**
     * Cache the wrapper node (contains all DataTables controlled elements)
     *  @type node
     *  @default null
     */
    "nTableWrapper": null,
    /**
     * Indicate if when using server-side processing the loading of data
     * should be deferred until the second draw.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type boolean
     *  @default false
     */
    "bDeferLoading": false,
    /**
     * Indicate if all required information has been read in
     *  @type boolean
     *  @default false
     */
    "bInitialised": false,
    /**
     * Information about open rows. Each object in the array has the parameters
     * 'nTr' and 'nParent'
     *  @type array
     *  @default []
     */
    "aoOpenRows": [],
    /**
     * Dictate the positioning of DataTables' control elements - see
     * {@link DataTable.model.oInit.sDom}.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default null
     */
    "sDom": null,
    /**
     * Search delay (in mS)
     *  @type integer
     *  @default null
     */
    "searchDelay": null,
    /**
     * Which type of pagination should be used.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default two_button
     */
    "sPaginationType": "two_button",
    /**
     * The state duration (for `stateSave`) in seconds.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type int
     *  @default 0
     */
    "iStateDuration": 0,
    /**
     * Array of callback functions for state saving. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the JSON string to save that has been thus far created. Returns
     *       a JSON string to be inserted into a json object
     *       (i.e. '"param": [ 0, 1, 2]')</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aoStateSave": [],
    /**
     * Array of callback functions for state loading. Each array element is an
     * object with the following parameters:
     *   <ul>
     *     <li>function:fn - function to call. Takes two parameters, oSettings
     *       and the object stored. May return false to cancel state loading</li>
     *     <li>string:sName - name of callback</li>
     *   </ul>
     *  @type array
     *  @default []
     */
    "aoStateLoad": [],
    /**
     * State that was saved. Useful for back reference
     *  @type object
     *  @default null
     */
    "oSavedState": null,
    /**
     * State that was loaded. Useful for back reference
     *  @type object
     *  @default null
     */
    "oLoadedState": null,
    /**
     * Source url for AJAX data for the table.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     *  @default null
     */
    "sAjaxSource": null,
    /**
     * Property from a given object from which to read the table data from. This
     * can be an empty string (when not server-side processing), in which case
     * it is  assumed an an array is given directly.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     */
    "sAjaxDataProp": null,
    /**
     * The last jQuery XHR object that was used for server-side data gathering.
     * This can be used for working with the XHR information in one of the
     * callbacks
     *  @type object
     *  @default null
     */
    "jqXHR": null,
    /**
     * JSON returned from the server in the last Ajax request
     *  @type object
     *  @default undefined
     */
    "json": void 0,
    /**
     * Data submitted as part of the last Ajax request
     *  @type object
     *  @default undefined
     */
    "oAjaxData": void 0,
    /**
     * Function to get the server-side data.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type function
     */
    "fnServerData": null,
    /**
     * Functions which are called prior to sending an Ajax request so extra
     * parameters can easily be sent to the server
     *  @type array
     *  @default []
     */
    "aoServerParams": [],
    /**
     * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
     * required).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type string
     */
    "sServerMethod": null,
    /**
     * Format numbers for display.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type function
     */
    "fnFormatNumber": null,
    /**
     * List of options that can be used for the user selectable length menu.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type array
     *  @default []
     */
    "aLengthMenu": null,
    /**
     * Counter for the draws that the table does. Also used as a tracker for
     * server-side processing
     *  @type int
     *  @default 0
     */
    "iDraw": 0,
    /**
     * Indicate if a redraw is being done - useful for Ajax
     *  @type boolean
     *  @default false
     */
    "bDrawing": false,
    /**
     * Draw index (iDraw) of the last error when parsing the returned data
     *  @type int
     *  @default -1
     */
    "iDrawError": -1,
    /**
     * Paging display length
     *  @type int
     *  @default 10
     */
    "_iDisplayLength": 10,
    /**
     * Paging start point - aiDisplay index
     *  @type int
     *  @default 0
     */
    "_iDisplayStart": 0,
    /**
     * Server-side processing - number of records in the result set
     * (i.e. before filtering), Use fnRecordsTotal rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     *  @type int
     *  @default 0
     *  @private
     */
    "_iRecordsTotal": 0,
    /**
     * Server-side processing - number of records in the current display set
     * (i.e. after filtering). Use fnRecordsDisplay rather than
     * this property to get the value of the number of records, regardless of
     * the server-side processing setting.
     *  @type boolean
     *  @default 0
     *  @private
     */
    "_iRecordsDisplay": 0,
    /**
     * The classes to use for the table
     *  @type object
     *  @default {}
     */
    "oClasses": {},
    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if filtering has been done in the draw. Deprecated in favour of
     * events.
     *  @type boolean
     *  @default false
     *  @deprecated
     */
    "bFiltered": false,
    /**
     * Flag attached to the settings object so you can check in the draw
     * callback if sorting has been done in the draw. Deprecated in favour of
     * events.
     *  @type boolean
     *  @default false
     *  @deprecated
     */
    "bSorted": false,
    /**
     * Indicate that if multiple rows are in the header and there is more than
     * one unique cell per column, if the top one (true) or bottom one (false)
     * should be used for sorting / title by DataTables.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @type boolean
     */
    "bSortCellsTop": null,
    /**
     * Initialisation object that is used for the table
     *  @type object
     *  @default null
     */
    "oInit": null,
    /**
     * Destroy callback functions - for plug-ins to attach themselves to the
     * destroy so they can clean up markup and events.
     *  @type array
     *  @default []
     */
    "aoDestroyCallback": [],
    /**
     * Get the number of records in the current record set, before filtering
     *  @type function
     */
    "fnRecordsTotal": function() {
      return _fnDataSource(this) == "ssp" ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length;
    },
    /**
     * Get the number of records in the current record set, after filtering
     *  @type function
     */
    "fnRecordsDisplay": function() {
      return _fnDataSource(this) == "ssp" ? this._iRecordsDisplay * 1 : this.aiDisplay.length;
    },
    /**
     * Get the display end point - aiDisplay index
     *  @type function
     */
    "fnDisplayEnd": function() {
      var len = this._iDisplayLength, start3 = this._iDisplayStart, calc = start3 + len, records = this.aiDisplay.length, features = this.oFeatures, paginate = features.bPaginate;
      if (features.bServerSide) {
        return paginate === false || len === -1 ? start3 + records : Math.min(start3 + len, this._iRecordsDisplay);
      } else {
        return !paginate || calc > records || len === -1 ? records : calc;
      }
    },
    /**
     * The DataTables object for this table
     *  @type object
     *  @default null
     */
    "oInstance": null,
    /**
     * Unique identifier for each instance of the DataTables object. If there
     * is an ID on the table node, then it takes that value, otherwise an
     * incrementing internal counter is used.
     *  @type string
     *  @default null
     */
    "sInstance": null,
    /**
     * tabindex attribute value that is added to DataTables control elements, allowing
     * keyboard navigation of the table and its controls.
     */
    "iTabIndex": 0,
    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollHead": null,
    /**
     * DIV container for the footer scrolling table if scrolling
     */
    "nScrollFoot": null,
    /**
     * Last applied sort
     *  @type array
     *  @default []
     */
    "aLastSort": [],
    /**
     * Stored plug-in instances
     *  @type object
     *  @default {}
     */
    "oPlugins": {},
    /**
     * Function used to get a row's id from the row's data
     *  @type function
     *  @default null
     */
    "rowIdFn": null,
    /**
     * Data location where to store a row's id
     *  @type string
     *  @default null
     */
    "rowId": null
  };
  DataTable.ext = _ext = {
    /**
     * Buttons. For use with the Buttons extension for DataTables. This is
     * defined here so other extensions can define buttons regardless of load
     * order. It is _not_ used by DataTables core.
     *
     *  @type object
     *  @default {}
     */
    buttons: {},
    /**
     * Element class names
     *
     *  @type object
     *  @default {}
     */
    classes: {},
    /**
     * DataTables build type (expanded by the download builder)
     *
     *  @type string
     */
    builder: "-source-",
    /**
     * Error reporting.
     * 
     * How should DataTables report an error. Can take the value 'alert',
     * 'throw', 'none' or a function.
     *
     *  @type string|function
     *  @default alert
     */
    errMode: "alert",
    /**
     * Feature plug-ins.
     * 
     * This is an array of objects which describe the feature plug-ins that are
     * available to DataTables. These feature plug-ins are then available for
     * use through the `dom` initialisation option.
     * 
     * Each feature plug-in is described by an object which must have the
     * following properties:
     * 
     * * `fnInit` - function that is used to initialise the plug-in,
     * * `cFeature` - a character so the feature can be enabled by the `dom`
     *   instillation option. This is case sensitive.
     *
     * The `fnInit` function has the following input parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     *
     * And the following return is expected:
     * 
     * * {node|null} The element which contains your feature. Note that the
     *   return may also be void if your plug-in does not require to inject any
     *   DOM elements into DataTables control (`dom`) - for example this might
     *   be useful when developing a plug-in which allows table control via
     *   keyboard entry
     *
     *  @type array
     *
     *  @example
     *    $.fn.dataTable.ext.features.push( {
     *      "fnInit": function( oSettings ) {
     *        return new TableTools( { "oDTSettings": oSettings } );
     *      },
     *      "cFeature": "T"
     *    } );
     */
    feature: [],
    /**
     * Row searching.
     * 
     * This method of searching is complimentary to the default type based
     * searching, and a lot more comprehensive as it allows you complete control
     * over the searching logic. Each element in this array is a function
     * (parameters described below) that is called for every row in the table,
     * and your logic decides if it should be included in the searching data set
     * or not.
     *
     * Searching functions have the following input parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{array|object}` Data for the row to be processed (same as the
     *    original format that was passed in as the data source, or an array
     *    from a DOM data source
     * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
     *    can be useful to retrieve the `TR` element if you need DOM interaction.
     *
     * And the following return is expected:
     *
     * * {boolean} Include the row in the searched result set (true) or not
     *   (false)
     *
     * Note that as with the main search ability in DataTables, technically this
     * is "filtering", since it is subtractive. However, for consistency in
     * naming we call it searching here.
     *
     *  @type array
     *  @default []
     *
     *  @example
     *    // The following example shows custom search being applied to the
     *    // fourth column (i.e. the data[3] index) based on two input values
     *    // from the end-user, matching the data in a certain range.
     *    $.fn.dataTable.ext.search.push(
     *      function( settings, data, dataIndex ) {
     *        var min = document.getElementById('min').value * 1;
     *        var max = document.getElementById('max').value * 1;
     *        var version = data[3] == "-" ? 0 : data[3]*1;
     *
     *        if ( min == "" && max == "" ) {
     *          return true;
     *        }
     *        else if ( min == "" && version < max ) {
     *          return true;
     *        }
     *        else if ( min < version && "" == max ) {
     *          return true;
     *        }
     *        else if ( min < version && version < max ) {
     *          return true;
     *        }
     *        return false;
     *      }
     *    );
     */
    search: [],
    /**
     * Selector extensions
     *
     * The `selector` option can be used to extend the options available for the
     * selector modifier options (`selector-modifier` object data type) that
     * each of the three built in selector types offer (row, column and cell +
     * their plural counterparts). For example the Select extension uses this
     * mechanism to provide an option to select only rows, columns and cells
     * that have been marked as selected by the end user (`{selected: true}`),
     * which can be used in conjunction with the existing built in selector
     * options.
     *
     * Each property is an array to which functions can be pushed. The functions
     * take three attributes:
     *
     * * Settings object for the host table
     * * Options object (`selector-modifier` object type)
     * * Array of selected item indexes
     *
     * The return is an array of the resulting item indexes after the custom
     * selector has been applied.
     *
     *  @type object
     */
    selector: {
      cell: [],
      column: [],
      row: []
    },
    /**
     * Internal functions, exposed for used in plug-ins.
     * 
     * Please note that you should not need to use the internal methods for
     * anything other than a plug-in (and even then, try to avoid if possible).
     * The internal function may change between releases.
     *
     *  @type object
     *  @default {}
     */
    internal: {},
    /**
     * Legacy configuration options. Enable and disable legacy options that
     * are available in DataTables.
     *
     *  @type object
     */
    legacy: {
      /**
       * Enable / disable DataTables 1.9 compatible server-side processing
       * requests
       *
       *  @type boolean
       *  @default null
       */
      ajax: null
    },
    /**
     * Pagination plug-in methods.
     * 
     * Each entry in this object is a function and defines which buttons should
     * be shown by the pagination rendering method that is used for the table:
     * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
     * buttons are displayed in the document, while the functions here tell it
     * what buttons to display. This is done by returning an array of button
     * descriptions (what each button will do).
     *
     * Pagination types (the four built in options and any additional plug-in
     * options defined here) can be used through the `paginationType`
     * initialisation parameter.
     *
     * The functions defined take two parameters:
     *
     * 1. `{int} page` The current page index
     * 2. `{int} pages` The number of pages in the table
     *
     * Each function is expected to return an array where each element of the
     * array can be one of:
     *
     * * `first` - Jump to first page when activated
     * * `last` - Jump to last page when activated
     * * `previous` - Show previous page when activated
     * * `next` - Show next page when activated
     * * `{int}` - Show page of the index given
     * * `{array}` - A nested array containing the above elements to add a
     *   containing 'DIV' element (might be useful for styling).
     *
     * Note that DataTables v1.9- used this object slightly differently whereby
     * an object with two functions would be defined for each plug-in. That
     * ability is still supported by DataTables 1.10+ to provide backwards
     * compatibility, but this option of use is now decremented and no longer
     * documented in DataTables 1.10+.
     *
     *  @type object
     *  @default {}
     *
     *  @example
     *    // Show previous, next and current page buttons only
     *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
     *      return [ 'previous', page, 'next' ];
     *    };
     */
    pager: {},
    renderer: {
      pageButton: {},
      header: {}
    },
    /**
     * Ordering plug-ins - custom data source
     * 
     * The extension options for ordering of data available here is complimentary
     * to the default type based ordering that DataTables typically uses. It
     * allows much greater control over the the data that is being used to
     * order a column, but is necessarily therefore more complex.
     * 
     * This type of ordering is useful if you want to do ordering based on data
     * live from the DOM (for example the contents of an 'input' element) rather
     * than just the static string that DataTables knows of.
     * 
     * The way these plug-ins work is that you create an array of the values you
     * wish to be ordering for the column in question and then return that
     * array. The data in the array much be in the index order of the rows in
     * the table (not the currently ordering order!). Which order data gathering
     * function is run here depends on the `dt-init columns.orderDataType`
     * parameter that is used for the column (if any).
     *
     * The functions defined take two parameters:
     *
     * 1. `{object}` DataTables settings object: see
     *    {@link DataTable.models.oSettings}
     * 2. `{int}` Target column index
     *
     * Each function is expected to return an array:
     *
     * * `{array}` Data for the column to be ordering upon
     *
     *  @type array
     *
     *  @example
     *    // Ordering using `input` node values
     *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
     *    {
     *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
     *        return $('input', td).val();
     *      } );
     *    }
     */
    order: {},
    /**
     * Type based plug-ins.
     *
     * Each column in DataTables has a type assigned to it, either by automatic
     * detection or by direct assignment using the `type` option for the column.
     * The type of a column will effect how it is ordering and search (plug-ins
     * can also make use of the column type if required).
     *
     * @namespace
     */
    type: {
      /**
       * Type detection functions.
       *
       * The functions defined in this object are used to automatically detect
       * a column's type, making initialisation of DataTables super easy, even
       * when complex data is in the table.
       *
       * The functions defined take two parameters:
       *
          *  1. `{*}` Data from the column cell to be analysed
          *  2. `{settings}` DataTables settings object. This can be used to
          *     perform context specific type detection - for example detection
          *     based on language settings such as using a comma for a decimal
          *     place. Generally speaking the options from the settings will not
          *     be required
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Data type detected, or null if unknown (and thus
       *   pass it on to the other type detection functions.
       *
       *  @type array
       *
       *  @example
       *    // Currency type detection plug-in:
       *    $.fn.dataTable.ext.type.detect.push(
       *      function ( data, settings ) {
       *        // Check the numeric part
       *        if ( ! data.substring(1).match(/[0-9]/) ) {
       *          return null;
       *        }
       *
       *        // Check prefixed by currency
       *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
       *          return 'currency';
       *        }
       *        return null;
       *      }
       *    );
       */
      detect: [],
      /**
       * Type based search formatting.
       *
       * The type based searching functions can be used to pre-format the
       * data to be search on. For example, it can be used to strip HTML
       * tags or to de-format telephone numbers for numeric only searching.
       *
       * Note that is a search is not defined for a column of a given type,
       * no search formatting will be performed.
       * 
       * Pre-processing of searching data plug-ins - When you assign the sType
       * for a column (or have it automatically detected for you by DataTables
       * or a type detection plug-in), you will typically be using this for
       * custom sorting, but it can also be used to provide custom searching
       * by allowing you to pre-processing the data and returning the data in
       * the format that should be searched upon. This is done by adding
       * functions this object with a parameter name which matches the sType
       * for that target column. This is the corollary of <i>afnSortData</i>
       * for searching data.
       *
       * The functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for searching
       *
       * Each function is expected to return:
       *
       * * `{string|null}` Formatted string that will be used for the searching.
       *
       *  @type object
       *  @default {}
       *
       *  @example
       *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
       *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
       *    }
       */
      search: {},
      /**
       * Type based ordering.
       *
       * The column type tells DataTables what ordering to apply to the table
       * when a column is sorted upon. The order for each type that is defined,
       * is defined by the functions available in this object.
       *
       * Each ordering option can be described by three properties added to
       * this object:
       *
       * * `{type}-pre` - Pre-formatting function
       * * `{type}-asc` - Ascending order function
       * * `{type}-desc` - Descending order function
       *
       * All three can be used together, only `{type}-pre` or only
       * `{type}-asc` and `{type}-desc` together. It is generally recommended
       * that only `{type}-pre` is used, as this provides the optimal
       * implementation in terms of speed, although the others are provided
       * for compatibility with existing Javascript sort functions.
       *
       * `{type}-pre`: Functions defined take a single parameter:
       *
          *  1. `{*}` Data from the column cell to be prepared for ordering
       *
       * And return:
       *
       * * `{*}` Data to be sorted upon
       *
       * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
       * functions, taking two parameters:
       *
          *  1. `{*}` Data to compare to the second parameter
          *  2. `{*}` Data to compare to the first parameter
       *
       * And returning:
       *
       * * `{*}` Ordering match: <0 if first parameter should be sorted lower
       *   than the second parameter, ===0 if the two parameters are equal and
       *   >0 if the first parameter should be sorted height than the second
       *   parameter.
       * 
       *  @type object
       *  @default {}
       *
       *  @example
       *    // Numeric ordering of formatted numbers with a pre-formatter
       *    $.extend( $.fn.dataTable.ext.type.order, {
       *      "string-pre": function(x) {
       *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
       *        return parseFloat( a );
       *      }
       *    } );
       *
       *  @example
       *    // Case-sensitive string ordering, with no pre-formatting method
       *    $.extend( $.fn.dataTable.ext.order, {
       *      "string-case-asc": function(x,y) {
       *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
       *      },
       *      "string-case-desc": function(x,y) {
       *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
       *      }
       *    } );
       */
      order: {}
    },
    /**
     * Unique DataTables instance counter
     *
     * @type int
     * @private
     */
    _unique: 0,
    //
    // Depreciated
    // The following properties are retained for backwards compatibility only.
    // The should not be used in new projects and will be removed in a future
    // version
    //
    /**
     * Version check function.
     *  @type function
     *  @depreciated Since 1.10
     */
    fnVersionCheck: DataTable.fnVersionCheck,
    /**
     * Index for what 'this' index API functions should use
     *  @type int
     *  @deprecated Since v1.10
     */
    iApiIndex: 0,
    /**
     * jQuery UI class container
     *  @type object
     *  @deprecated Since v1.10
     */
    oJUIClasses: {},
    /**
     * Software version
     *  @type string
     *  @deprecated Since v1.10
     */
    sVersion: DataTable.version
  };
  $4.extend(_ext, {
    afnFiltering: _ext.search,
    aTypes: _ext.type.detect,
    ofnSearch: _ext.type.search,
    oSort: _ext.type.order,
    afnSortData: _ext.order,
    aoFeatures: _ext.feature,
    oApi: _ext.internal,
    oStdClasses: _ext.classes,
    oPagination: _ext.pager
  });
  $4.extend(DataTable.ext.classes, {
    "sTable": "dataTable",
    "sNoFooter": "no-footer",
    /* Paging buttons */
    "sPageButton": "paginate_button",
    "sPageButtonActive": "current",
    "sPageButtonDisabled": "disabled",
    /* Striping classes */
    "sStripeOdd": "odd",
    "sStripeEven": "even",
    /* Empty row */
    "sRowEmpty": "dataTables_empty",
    /* Features */
    "sWrapper": "dataTables_wrapper",
    "sFilter": "dataTables_filter",
    "sInfo": "dataTables_info",
    "sPaging": "dataTables_paginate paging_",
    /* Note that the type is postfixed */
    "sLength": "dataTables_length",
    "sProcessing": "dataTables_processing",
    /* Sorting */
    "sSortAsc": "sorting_asc",
    "sSortDesc": "sorting_desc",
    "sSortable": "sorting",
    /* Sortable in both directions */
    "sSortableAsc": "sorting_desc_disabled",
    "sSortableDesc": "sorting_asc_disabled",
    "sSortableNone": "sorting_disabled",
    "sSortColumn": "sorting_",
    /* Note that an int is postfixed for the sorting order */
    /* Filtering */
    "sFilterInput": "",
    /* Page length */
    "sLengthSelect": "",
    /* Scrolling */
    "sScrollWrapper": "dataTables_scroll",
    "sScrollHead": "dataTables_scrollHead",
    "sScrollHeadInner": "dataTables_scrollHeadInner",
    "sScrollBody": "dataTables_scrollBody",
    "sScrollFoot": "dataTables_scrollFoot",
    "sScrollFootInner": "dataTables_scrollFootInner",
    /* Misc */
    "sHeaderTH": "",
    "sFooterTH": "",
    // Deprecated
    "sSortJUIAsc": "",
    "sSortJUIDesc": "",
    "sSortJUI": "",
    "sSortJUIAscAllowed": "",
    "sSortJUIDescAllowed": "",
    "sSortJUIWrapper": "",
    "sSortIcon": "",
    "sJUIHeader": "",
    "sJUIFooter": ""
  });
  var extPagination = DataTable.ext.pager;
  function _numbers(page, pages) {
    var numbers = [], buttons = extPagination.numbers_length, half = Math.floor(buttons / 2), i2 = 1;
    if (pages <= buttons) {
      numbers = _range(0, pages);
    } else if (page <= half) {
      numbers = _range(0, buttons - 2);
      numbers.push("ellipsis");
      numbers.push(pages - 1);
    } else if (page >= pages - 1 - half) {
      numbers = _range(pages - (buttons - 2), pages);
      numbers.splice(0, 0, "ellipsis");
      numbers.splice(0, 0, 0);
    } else {
      numbers = _range(page - half + 2, page + half - 1);
      numbers.push("ellipsis");
      numbers.push(pages - 1);
      numbers.splice(0, 0, "ellipsis");
      numbers.splice(0, 0, 0);
    }
    numbers.DT_el = "span";
    return numbers;
  }
  $4.extend(extPagination, {
    simple: function(page, pages) {
      return ["previous", "next"];
    },
    full: function(page, pages) {
      return ["first", "previous", "next", "last"];
    },
    numbers: function(page, pages) {
      return [_numbers(page, pages)];
    },
    simple_numbers: function(page, pages) {
      return ["previous", _numbers(page, pages), "next"];
    },
    full_numbers: function(page, pages) {
      return ["first", "previous", _numbers(page, pages), "next", "last"];
    },
    first_last_numbers: function(page, pages) {
      return ["first", _numbers(page, pages), "last"];
    },
    // For testing and plug-ins to use
    _numbers,
    // Number of number buttons (including ellipsis) to show. _Must be odd!_
    numbers_length: 7
  });
  $4.extend(true, DataTable.ext.renderer, {
    pageButton: {
      _: function(settings, host, idx, buttons, page, pages) {
        var classes = settings.oClasses;
        var lang = settings.oLanguage.oPaginate;
        var aria = settings.oLanguage.oAria.paginate || {};
        var btnDisplay, btnClass;
        var attach = function(container, buttons2) {
          var i2, ien, node, button;
          var disabledClass = classes.sPageButtonDisabled;
          var clickHandler = function(e2) {
            _fnPageChange(settings, e2.data.action, true);
          };
          for (i2 = 0, ien = buttons2.length; i2 < ien; i2++) {
            button = buttons2[i2];
            if (Array.isArray(button)) {
              var inner = $4("<" + (button.DT_el || "div") + "/>").appendTo(container);
              attach(inner, button);
            } else {
              var disabled = false;
              btnDisplay = null;
              btnClass = button;
              switch (button) {
                case "ellipsis":
                  container.append('<span class="ellipsis">&#x2026;</span>');
                  break;
                case "first":
                  btnDisplay = lang.sFirst;
                  if (page === 0) {
                    disabled = true;
                  }
                  break;
                case "previous":
                  btnDisplay = lang.sPrevious;
                  if (page === 0) {
                    disabled = true;
                  }
                  break;
                case "next":
                  btnDisplay = lang.sNext;
                  if (pages === 0 || page === pages - 1) {
                    disabled = true;
                  }
                  break;
                case "last":
                  btnDisplay = lang.sLast;
                  if (pages === 0 || page === pages - 1) {
                    disabled = true;
                  }
                  break;
                default:
                  btnDisplay = settings.fnFormatNumber(button + 1);
                  btnClass = page === button ? classes.sPageButtonActive : "";
                  break;
              }
              if (btnDisplay !== null) {
                var tag = settings.oInit.pagingTag || "a";
                if (disabled) {
                  btnClass += " " + disabledClass;
                }
                node = $4("<" + tag + ">", {
                  "class": classes.sPageButton + " " + btnClass,
                  "aria-controls": settings.sTableId,
                  "aria-disabled": disabled ? "true" : null,
                  "aria-label": aria[button],
                  "role": "link",
                  "aria-current": btnClass === classes.sPageButtonActive ? "page" : null,
                  "data-dt-idx": button,
                  "tabindex": disabled ? -1 : settings.iTabIndex,
                  "id": idx === 0 && typeof button === "string" ? settings.sTableId + "_" + button : null
                }).html(btnDisplay).appendTo(container);
                _fnBindAction(
                  node,
                  { action: button },
                  clickHandler
                );
              }
            }
          }
        };
        var activeEl;
        try {
          activeEl = $4(host).find(document.activeElement).data("dt-idx");
        } catch (e2) {
        }
        attach($4(host).empty(), buttons);
        if (activeEl !== void 0) {
          $4(host).find("[data-dt-idx=" + activeEl + "]").trigger("focus");
        }
      }
    }
  });
  $4.extend(DataTable.ext.type.detect, [
    // Plain numbers - first since V8 detects some plain numbers as dates
    // e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).
    function(d2, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber(d2, decimal) ? "num" + decimal : null;
    },
    // Dates (only those recognised by the browser's Date.parse)
    function(d2, settings) {
      if (d2 && !(d2 instanceof Date) && !_re_date.test(d2)) {
        return null;
      }
      var parsed = Date.parse(d2);
      return parsed !== null && !isNaN(parsed) || _empty(d2) ? "date" : null;
    },
    // Formatted numbers
    function(d2, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber(d2, decimal, true) ? "num-fmt" + decimal : null;
    },
    // HTML numeric
    function(d2, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric(d2, decimal) ? "html-num" + decimal : null;
    },
    // HTML numeric, formatted
    function(d2, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric(d2, decimal, true) ? "html-num-fmt" + decimal : null;
    },
    // HTML (this is strict checking - there must be html)
    function(d2, settings) {
      return _empty(d2) || typeof d2 === "string" && d2.indexOf("<") !== -1 ? "html" : null;
    }
  ]);
  $4.extend(DataTable.ext.type.search, {
    html: function(data) {
      return _empty(data) ? data : typeof data === "string" ? data.replace(_re_new_lines, " ").replace(_re_html, "") : "";
    },
    string: function(data) {
      return _empty(data) ? data : typeof data === "string" ? data.replace(_re_new_lines, " ") : data;
    }
  });
  var __numericReplace = function(d2, decimalPlace, re1, re2) {
    if (d2 !== 0 && (!d2 || d2 === "-")) {
      return -Infinity;
    }
    var type = typeof d2;
    if (type === "number" || type === "bigint") {
      return d2;
    }
    if (decimalPlace) {
      d2 = _numToDecimal(d2, decimalPlace);
    }
    if (d2.replace) {
      if (re1) {
        d2 = d2.replace(re1, "");
      }
      if (re2) {
        d2 = d2.replace(re2, "");
      }
    }
    return d2 * 1;
  };
  function _addNumericSort(decimalPlace) {
    $4.each(
      {
        // Plain numbers
        "num": function(d2) {
          return __numericReplace(d2, decimalPlace);
        },
        // Formatted numbers
        "num-fmt": function(d2) {
          return __numericReplace(d2, decimalPlace, _re_formatted_numeric);
        },
        // HTML numeric
        "html-num": function(d2) {
          return __numericReplace(d2, decimalPlace, _re_html);
        },
        // HTML numeric, formatted
        "html-num-fmt": function(d2) {
          return __numericReplace(d2, decimalPlace, _re_html, _re_formatted_numeric);
        }
      },
      function(key, fn2) {
        _ext.type.order[key + decimalPlace + "-pre"] = fn2;
        if (key.match(/^html\-/)) {
          _ext.type.search[key + decimalPlace] = _ext.type.search.html;
        }
      }
    );
  }
  $4.extend(_ext.type.order, {
    // Dates
    "date-pre": function(d2) {
      var ts = Date.parse(d2);
      return isNaN(ts) ? -Infinity : ts;
    },
    // html
    "html-pre": function(a2) {
      return _empty(a2) ? "" : a2.replace ? a2.replace(/<.*?>/g, "").toLowerCase() : a2 + "";
    },
    // string
    "string-pre": function(a2) {
      return _empty(a2) ? "" : typeof a2 === "string" ? a2.toLowerCase() : !a2.toString ? "" : a2.toString();
    },
    // string-asc and -desc are retained only for compatibility with the old
    // sort methods
    "string-asc": function(x2, y2) {
      return x2 < y2 ? -1 : x2 > y2 ? 1 : 0;
    },
    "string-desc": function(x2, y2) {
      return x2 < y2 ? 1 : x2 > y2 ? -1 : 0;
    }
  });
  _addNumericSort("");
  $4.extend(true, DataTable.ext.renderer, {
    header: {
      _: function(settings, cell, column, classes) {
        $4(settings.nTable).on("order.dt.DT", function(e2, ctx, sorting, columns) {
          if (settings !== ctx) {
            return;
          }
          var colIdx = column.idx;
          cell.removeClass(
            classes.sSortAsc + " " + classes.sSortDesc
          ).addClass(
            columns[colIdx] == "asc" ? classes.sSortAsc : columns[colIdx] == "desc" ? classes.sSortDesc : column.sSortingClass
          );
        });
      },
      jqueryui: function(settings, cell, column, classes) {
        $4("<div/>").addClass(classes.sSortJUIWrapper).append(cell.contents()).append(
          $4("<span/>").addClass(classes.sSortIcon + " " + column.sSortingClassJUI)
        ).appendTo(cell);
        $4(settings.nTable).on("order.dt.DT", function(e2, ctx, sorting, columns) {
          if (settings !== ctx) {
            return;
          }
          var colIdx = column.idx;
          cell.removeClass(classes.sSortAsc + " " + classes.sSortDesc).addClass(
            columns[colIdx] == "asc" ? classes.sSortAsc : columns[colIdx] == "desc" ? classes.sSortDesc : column.sSortingClass
          );
          cell.find("span." + classes.sSortIcon).removeClass(
            classes.sSortJUIAsc + " " + classes.sSortJUIDesc + " " + classes.sSortJUI + " " + classes.sSortJUIAscAllowed + " " + classes.sSortJUIDescAllowed
          ).addClass(
            columns[colIdx] == "asc" ? classes.sSortJUIAsc : columns[colIdx] == "desc" ? classes.sSortJUIDesc : column.sSortingClassJUI
          );
        });
      }
    }
  });
  var __htmlEscapeEntities = function(d2) {
    if (Array.isArray(d2)) {
      d2 = d2.join(",");
    }
    return typeof d2 === "string" ? d2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;") : d2;
  };
  function __mld(dt, momentFn, luxonFn, dateFn, arg1) {
    if (window.moment) {
      return dt[momentFn](arg1);
    } else if (window.luxon) {
      return dt[luxonFn](arg1);
    }
    return dateFn ? dt[dateFn](arg1) : dt;
  }
  var __mlWarning = false;
  function __mldObj(d2, format, locale) {
    var dt;
    if (window.moment) {
      dt = window.moment.utc(d2, format, locale, true);
      if (!dt.isValid()) {
        return null;
      }
    } else if (window.luxon) {
      dt = format && typeof d2 === "string" ? window.luxon.DateTime.fromFormat(d2, format) : window.luxon.DateTime.fromISO(d2);
      if (!dt.isValid) {
        return null;
      }
      dt.setLocale(locale);
    } else if (!format) {
      dt = new Date(d2);
    } else {
      if (!__mlWarning) {
        alert("DataTables warning: Formatted date without Moment.js or Luxon - https://datatables.net/tn/17");
      }
      __mlWarning = true;
    }
    return dt;
  }
  function __mlHelper(localeString) {
    return function(from, to, locale, def) {
      if (arguments.length === 0) {
        locale = "en";
        to = null;
        from = null;
      } else if (arguments.length === 1) {
        locale = "en";
        to = from;
        from = null;
      } else if (arguments.length === 2) {
        locale = to;
        to = from;
        from = null;
      }
      var typeName = "datetime-" + to;
      if (!DataTable.ext.type.order[typeName]) {
        DataTable.ext.type.detect.unshift(function(d2) {
          return d2 === typeName ? typeName : false;
        });
        DataTable.ext.type.order[typeName + "-asc"] = function(a2, b2) {
          var x2 = a2.valueOf();
          var y2 = b2.valueOf();
          return x2 === y2 ? 0 : x2 < y2 ? -1 : 1;
        };
        DataTable.ext.type.order[typeName + "-desc"] = function(a2, b2) {
          var x2 = a2.valueOf();
          var y2 = b2.valueOf();
          return x2 === y2 ? 0 : x2 > y2 ? -1 : 1;
        };
      }
      return function(d2, type) {
        if (d2 === null || d2 === void 0) {
          if (def === "--now") {
            var local = /* @__PURE__ */ new Date();
            d2 = new Date(Date.UTC(
              local.getFullYear(),
              local.getMonth(),
              local.getDate(),
              local.getHours(),
              local.getMinutes(),
              local.getSeconds()
            ));
          } else {
            d2 = "";
          }
        }
        if (type === "type") {
          return typeName;
        }
        if (d2 === "") {
          return type !== "sort" ? "" : __mldObj("0000-01-01 00:00:00", null, locale);
        }
        if (to !== null && from === to && type !== "sort" && type !== "type" && !(d2 instanceof Date)) {
          return d2;
        }
        var dt = __mldObj(d2, from, locale);
        if (dt === null) {
          return d2;
        }
        if (type === "sort") {
          return dt;
        }
        var formatted = to === null ? __mld(dt, "toDate", "toJSDate", "")[localeString]() : __mld(dt, "format", "toFormat", "toISOString", to);
        return type === "display" ? __htmlEscapeEntities(formatted) : formatted;
      };
    };
  }
  var __thousands = ",";
  var __decimal = ".";
  if (window.Intl !== void 0) {
    try {
      num = new Intl.NumberFormat().formatToParts(100000.1);
      for (i2 = 0; i2 < num.length; i2++) {
        if (num[i2].type === "group") {
          __thousands = num[i2].value;
        } else if (num[i2].type === "decimal") {
          __decimal = num[i2].value;
        }
      }
    } catch (e2) {
    }
  }
  var num;
  var i2;
  DataTable.datetime = function(format, locale) {
    var typeName = "datetime-detect-" + format;
    if (!locale) {
      locale = "en";
    }
    if (!DataTable.ext.type.order[typeName]) {
      DataTable.ext.type.detect.unshift(function(d2) {
        var dt = __mldObj(d2, format, locale);
        return d2 === "" || dt ? typeName : false;
      });
      DataTable.ext.type.order[typeName + "-pre"] = function(d2) {
        return __mldObj(d2, format, locale) || 0;
      };
    }
  };
  DataTable.render = {
    date: __mlHelper("toLocaleDateString"),
    datetime: __mlHelper("toLocaleString"),
    time: __mlHelper("toLocaleTimeString"),
    number: function(thousands, decimal, precision, prefix, postfix) {
      if (thousands === null || thousands === void 0) {
        thousands = __thousands;
      }
      if (decimal === null || decimal === void 0) {
        decimal = __decimal;
      }
      return {
        display: function(d2) {
          if (typeof d2 !== "number" && typeof d2 !== "string") {
            return d2;
          }
          if (d2 === "" || d2 === null) {
            return d2;
          }
          var negative = d2 < 0 ? "-" : "";
          var flo = parseFloat(d2);
          if (isNaN(flo)) {
            return __htmlEscapeEntities(d2);
          }
          flo = flo.toFixed(precision);
          d2 = Math.abs(flo);
          var intPart = parseInt(d2, 10);
          var floatPart = precision ? decimal + (d2 - intPart).toFixed(precision).substring(2) : "";
          if (intPart === 0 && parseFloat(floatPart) === 0) {
            negative = "";
          }
          return negative + (prefix || "") + intPart.toString().replace(
            /\B(?=(\d{3})+(?!\d))/g,
            thousands
          ) + floatPart + (postfix || "");
        }
      };
    },
    text: function() {
      return {
        display: __htmlEscapeEntities,
        filter: __htmlEscapeEntities
      };
    }
  };
  function _fnExternApiFunc(fn2) {
    return function() {
      var args = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(
        Array.prototype.slice.call(arguments)
      );
      return DataTable.ext.internal[fn2].apply(this, args);
    };
  }
  $4.extend(DataTable.ext.internal, {
    _fnExternApiFunc,
    _fnBuildAjax,
    _fnAjaxUpdate,
    _fnAjaxParameters,
    _fnAjaxUpdateDraw,
    _fnAjaxDataSrc,
    _fnAddColumn,
    _fnColumnOptions,
    _fnAdjustColumnSizing,
    _fnVisibleToColumnIndex,
    _fnColumnIndexToVisible,
    _fnVisbleColumns,
    _fnGetColumns,
    _fnColumnTypes,
    _fnApplyColumnDefs,
    _fnHungarianMap,
    _fnCamelToHungarian,
    _fnLanguageCompat,
    _fnBrowserDetect,
    _fnAddData,
    _fnAddTr,
    _fnNodeToDataIndex,
    _fnNodeToColumnIndex,
    _fnGetCellData,
    _fnSetCellData,
    _fnSplitObjNotation,
    _fnGetObjectDataFn,
    _fnSetObjectDataFn,
    _fnGetDataMaster,
    _fnClearTable,
    _fnDeleteIndex,
    _fnInvalidate,
    _fnGetRowElements,
    _fnCreateTr,
    _fnBuildHead,
    _fnDrawHead,
    _fnDraw,
    _fnReDraw,
    _fnAddOptionsHtml,
    _fnDetectHeader,
    _fnGetUniqueThs,
    _fnFeatureHtmlFilter,
    _fnFilterComplete,
    _fnFilterCustom,
    _fnFilterColumn,
    _fnFilter,
    _fnFilterCreateSearch,
    _fnEscapeRegex,
    _fnFilterData,
    _fnFeatureHtmlInfo,
    _fnUpdateInfo,
    _fnInfoMacros,
    _fnInitialise,
    _fnInitComplete,
    _fnLengthChange,
    _fnFeatureHtmlLength,
    _fnFeatureHtmlPaginate,
    _fnPageChange,
    _fnFeatureHtmlProcessing,
    _fnProcessingDisplay,
    _fnFeatureHtmlTable,
    _fnScrollDraw,
    _fnApplyToChildren,
    _fnCalculateColumnWidths,
    _fnThrottle,
    _fnConvertToWidth,
    _fnGetWidestNode,
    _fnGetMaxLenString,
    _fnStringToCss,
    _fnSortFlatten,
    _fnSort,
    _fnSortAria,
    _fnSortListener,
    _fnSortAttachListener,
    _fnSortingClasses,
    _fnSortData,
    _fnSaveState,
    _fnLoadState,
    _fnImplementState,
    _fnSettingsFromNode,
    _fnLog,
    _fnMap,
    _fnBindAction,
    _fnCallbackReg,
    _fnCallbackFire,
    _fnLengthOverflow,
    _fnRenderer,
    _fnDataSource,
    _fnRowAttributes,
    _fnExtend,
    _fnCalculateEnd: function() {
    }
    // Used by a lot of plug-ins, but redundant
    // in 1.10, so this dead-end function is
    // added to prevent errors
  });
  $4.fn.dataTable = DataTable;
  DataTable.$ = $4;
  $4.fn.dataTableSettings = DataTable.settings;
  $4.fn.dataTableExt = DataTable.ext;
  $4.fn.DataTable = function(opts) {
    return $4(this).dataTable(opts).api();
  };
  $4.each(DataTable, function(prop, val) {
    $4.fn.DataTable[prop] = val;
  });
  var jquery_dataTables_default = DataTable;

  // node_modules/datatables.net-bs5/js/dataTables.bootstrap5.mjs
  var import_jquery3 = __toESM(require_jquery(), 1);
  var $5 = import_jquery3.default;
  $5.extend(true, jquery_dataTables_default.defaults, {
    dom: "<'row'<'col-sm-12 col-md-6'l><'col-sm-12 col-md-6'f>><'row dt-row'<'col-sm-12'tr>><'row'<'col-sm-12 col-md-5'i><'col-sm-12 col-md-7'p>>",
    renderer: "bootstrap"
  });
  $5.extend(jquery_dataTables_default.ext.classes, {
    sWrapper: "dataTables_wrapper dt-bootstrap5",
    sFilterInput: "form-control form-control-sm",
    sLengthSelect: "form-select form-select-sm",
    sProcessing: "dataTables_processing card",
    sPageButton: "paginate_button page-item"
  });
  jquery_dataTables_default.ext.renderer.pageButton.bootstrap = function(settings, host, idx, buttons, page, pages) {
    var api = new jquery_dataTables_default.Api(settings);
    var classes = settings.oClasses;
    var lang = settings.oLanguage.oPaginate;
    var aria = settings.oLanguage.oAria.paginate || {};
    var btnDisplay, btnClass;
    var attach = function(container, buttons2) {
      var i2, ien, node, button;
      var clickHandler = function(e2) {
        e2.preventDefault();
        if (!$5(e2.currentTarget).hasClass("disabled") && api.page() != e2.data.action) {
          api.page(e2.data.action).draw("page");
        }
      };
      for (i2 = 0, ien = buttons2.length; i2 < ien; i2++) {
        button = buttons2[i2];
        if (Array.isArray(button)) {
          attach(container, button);
        } else {
          btnDisplay = "";
          btnClass = "";
          switch (button) {
            case "ellipsis":
              btnDisplay = "&#x2026;";
              btnClass = "disabled";
              break;
            case "first":
              btnDisplay = lang.sFirst;
              btnClass = button + (page > 0 ? "" : " disabled");
              break;
            case "previous":
              btnDisplay = lang.sPrevious;
              btnClass = button + (page > 0 ? "" : " disabled");
              break;
            case "next":
              btnDisplay = lang.sNext;
              btnClass = button + (page < pages - 1 ? "" : " disabled");
              break;
            case "last":
              btnDisplay = lang.sLast;
              btnClass = button + (page < pages - 1 ? "" : " disabled");
              break;
            default:
              btnDisplay = button + 1;
              btnClass = page === button ? "active" : "";
              break;
          }
          if (btnDisplay) {
            var disabled = btnClass.indexOf("disabled") !== -1;
            node = $5("<li>", {
              "class": classes.sPageButton + " " + btnClass,
              "id": idx === 0 && typeof button === "string" ? settings.sTableId + "_" + button : null
            }).append(
              $5("<a>", {
                "href": disabled ? null : "#",
                "aria-controls": settings.sTableId,
                "aria-disabled": disabled ? "true" : null,
                "aria-label": aria[button],
                "role": "link",
                "aria-current": btnClass === "active" ? "page" : null,
                "data-dt-idx": button,
                "tabindex": disabled ? -1 : settings.iTabIndex,
                "class": "page-link"
              }).html(btnDisplay)
            ).appendTo(container);
            settings.oApi._fnBindAction(
              node,
              { action: button },
              clickHandler
            );
          }
        }
      }
    };
    var hostEl = $5(host);
    var activeEl;
    try {
      activeEl = hostEl.find(document.activeElement).data("dt-idx");
    } catch (e2) {
    }
    var paginationEl = hostEl.children("ul.pagination");
    if (paginationEl.length) {
      paginationEl.empty();
    } else {
      paginationEl = hostEl.html("<ul/>").children("ul").addClass("pagination");
    }
    attach(
      paginationEl,
      buttons
    );
    if (activeEl !== void 0) {
      hostEl.find("[data-dt-idx=" + activeEl + "]").trigger("focus");
    }
  };
  var dataTables_bootstrap5_default = jquery_dataTables_default;

  // node_modules/datatables.net-responsive-bs5/js/responsive.bootstrap5.mjs
  var import_jquery5 = __toESM(require_jquery(), 1);

  // node_modules/datatables.net-responsive/js/dataTables.responsive.mjs
  var import_jquery4 = __toESM(require_jquery(), 1);
  var $6 = import_jquery4.default;
  var Responsive = function(settings, opts) {
    if (!jquery_dataTables_default.versionCheck || !jquery_dataTables_default.versionCheck("1.10.10")) {
      throw "DataTables Responsive requires DataTables 1.10.10 or newer";
    }
    this.s = {
      childNodeStore: {},
      columns: [],
      current: [],
      dt: new jquery_dataTables_default.Api(settings)
    };
    if (this.s.dt.settings()[0].responsive) {
      return;
    }
    if (opts && typeof opts.details === "string") {
      opts.details = { type: opts.details };
    } else if (opts && opts.details === false) {
      opts.details = { type: false };
    } else if (opts && opts.details === true) {
      opts.details = { type: "inline" };
    }
    this.c = $6.extend(true, {}, Responsive.defaults, jquery_dataTables_default.defaults.responsive, opts);
    settings.responsive = this;
    this._constructor();
  };
  $6.extend(Responsive.prototype, {
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Constructor
     */
    /**
     * Initialise the Responsive instance
     *
     * @private
     */
    _constructor: function() {
      var that = this;
      var dt = this.s.dt;
      var dtPrivateSettings = dt.settings()[0];
      var oldWindowWidth = $6(window).innerWidth();
      dt.settings()[0]._responsive = this;
      $6(window).on(
        "resize.dtr orientationchange.dtr",
        jquery_dataTables_default.util.throttle(function() {
          var width = $6(window).innerWidth();
          if (width !== oldWindowWidth) {
            that._resize();
            oldWindowWidth = width;
          }
        })
      );
      dtPrivateSettings.oApi._fnCallbackReg(
        dtPrivateSettings,
        "aoRowCreatedCallback",
        function(tr, data, idx) {
          if ($6.inArray(false, that.s.current) !== -1) {
            $6(">td, >th", tr).each(function(i2) {
              var idx2 = dt.column.index("toData", i2);
              if (that.s.current[idx2] === false) {
                $6(this).css("display", "none");
              }
            });
          }
        }
      );
      dt.on("destroy.dtr", function() {
        dt.off(".dtr");
        $6(dt.table().body()).off(".dtr");
        $6(window).off("resize.dtr orientationchange.dtr");
        dt.cells(".dtr-control").nodes().to$().removeClass("dtr-control");
        $6.each(that.s.current, function(i2, val) {
          if (val === false) {
            that._setColumnVis(i2, true);
          }
        });
      });
      this.c.breakpoints.sort(function(a2, b2) {
        return a2.width < b2.width ? 1 : a2.width > b2.width ? -1 : 0;
      });
      this._classLogic();
      this._resizeAuto();
      var details = this.c.details;
      if (details.type !== false) {
        that._detailsInit();
        dt.on("column-visibility.dtr", function() {
          if (that._timer) {
            clearTimeout(that._timer);
          }
          that._timer = setTimeout(function() {
            that._timer = null;
            that._classLogic();
            that._resizeAuto();
            that._resize(true);
            that._redrawChildren();
          }, 100);
        });
        dt.on("draw.dtr", function() {
          that._redrawChildren();
        });
        $6(dt.table().node()).addClass("dtr-" + details.type);
      }
      dt.on("column-reorder.dtr", function(e2, settings, details2) {
        that._classLogic();
        that._resizeAuto();
        that._resize(true);
      });
      dt.on("column-sizing.dtr", function() {
        that._resizeAuto();
        that._resize();
      });
      dt.on("column-calc.dt", function(e2, d2) {
        var curr = that.s.current;
        for (var i2 = 0; i2 < curr.length; i2++) {
          var idx = d2.visible.indexOf(i2);
          if (curr[i2] === false && idx >= 0) {
            d2.visible.splice(idx, 1);
          }
        }
      });
      dt.on("preXhr.dtr", function() {
        var rowIds = [];
        dt.rows().every(function() {
          if (this.child.isShown()) {
            rowIds.push(this.id(true));
          }
        });
        dt.one("draw.dtr", function() {
          that._resizeAuto();
          that._resize();
          dt.rows(rowIds).every(function() {
            that._detailsDisplay(this, false);
          });
        });
      });
      dt.on("draw.dtr", function() {
        that._controlClass();
      }).on("init.dtr", function(e2, settings, details2) {
        if (e2.namespace !== "dt") {
          return;
        }
        that._resizeAuto();
        that._resize();
        if ($6.inArray(false, that.s.current)) {
          dt.columns.adjust();
        }
      });
      this._resize();
    },
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Private methods
     */
    /**
     * Get and store nodes from a cell - use for node moving renderers
     *
     * @param {*} dt DT instance
     * @param {*} row Row index
     * @param {*} col Column index
     */
    _childNodes: function(dt, row, col) {
      var name = row + "-" + col;
      if (this.s.childNodeStore[name]) {
        return this.s.childNodeStore[name];
      }
      var nodes = [];
      var children = dt.cell(row, col).node().childNodes;
      for (var i2 = 0, ien = children.length; i2 < ien; i2++) {
        nodes.push(children[i2]);
      }
      this.s.childNodeStore[name] = nodes;
      return nodes;
    },
    /**
     * Restore nodes from the cache to a table cell
     *
     * @param {*} dt DT instance
     * @param {*} row Row index
     * @param {*} col Column index
     */
    _childNodesRestore: function(dt, row, col) {
      var name = row + "-" + col;
      if (!this.s.childNodeStore[name]) {
        return;
      }
      var node = dt.cell(row, col).node();
      var store = this.s.childNodeStore[name];
      var parent = store[0].parentNode;
      var parentChildren = parent.childNodes;
      var a2 = [];
      for (var i2 = 0, ien = parentChildren.length; i2 < ien; i2++) {
        a2.push(parentChildren[i2]);
      }
      for (var j2 = 0, jen = a2.length; j2 < jen; j2++) {
        node.appendChild(a2[j2]);
      }
      this.s.childNodeStore[name] = void 0;
    },
    /**
     * Calculate the visibility for the columns in a table for a given
     * breakpoint. The result is pre-determined based on the class logic if
     * class names are used to control all columns, but the width of the table
     * is also used if there are columns which are to be automatically shown
     * and hidden.
     *
     * @param  {string} breakpoint Breakpoint name to use for the calculation
     * @return {array} Array of boolean values initiating the visibility of each
     *   column.
     *  @private
     */
    _columnsVisiblity: function(breakpoint) {
      var dt = this.s.dt;
      var columns = this.s.columns;
      var i2, ien;
      var order2 = columns.map(function(col, idx) {
        return {
          columnIdx: idx,
          priority: col.priority
        };
      }).sort(function(a2, b2) {
        if (a2.priority !== b2.priority) {
          return a2.priority - b2.priority;
        }
        return a2.columnIdx - b2.columnIdx;
      });
      var display = $6.map(columns, function(col, i3) {
        if (dt.column(i3).visible() === false) {
          return "not-visible";
        }
        return col.auto && col.minWidth === null ? false : col.auto === true ? "-" : $6.inArray(breakpoint, col.includeIn) !== -1;
      });
      var requiredWidth = 0;
      for (i2 = 0, ien = display.length; i2 < ien; i2++) {
        if (display[i2] === true) {
          requiredWidth += columns[i2].minWidth;
        }
      }
      var scrolling = dt.settings()[0].oScroll;
      var bar = scrolling.sY || scrolling.sX ? scrolling.iBarWidth : 0;
      var widthAvailable = dt.table().container().offsetWidth - bar;
      var usedWidth = widthAvailable - requiredWidth;
      for (i2 = 0, ien = display.length; i2 < ien; i2++) {
        if (columns[i2].control) {
          usedWidth -= columns[i2].minWidth;
        }
      }
      var empty = false;
      for (i2 = 0, ien = order2.length; i2 < ien; i2++) {
        var colIdx = order2[i2].columnIdx;
        if (display[colIdx] === "-" && !columns[colIdx].control && columns[colIdx].minWidth) {
          if (empty || usedWidth - columns[colIdx].minWidth < 0) {
            empty = true;
            display[colIdx] = false;
          } else {
            display[colIdx] = true;
          }
          usedWidth -= columns[colIdx].minWidth;
        }
      }
      var showControl = false;
      for (i2 = 0, ien = columns.length; i2 < ien; i2++) {
        if (!columns[i2].control && !columns[i2].never && display[i2] === false) {
          showControl = true;
          break;
        }
      }
      for (i2 = 0, ien = columns.length; i2 < ien; i2++) {
        if (columns[i2].control) {
          display[i2] = showControl;
        }
        if (display[i2] === "not-visible") {
          display[i2] = false;
        }
      }
      if ($6.inArray(true, display) === -1) {
        display[0] = true;
      }
      return display;
    },
    /**
     * Create the internal `columns` array with information about the columns
     * for the table. This includes determining which breakpoints the column
     * will appear in, based upon class names in the column, which makes up the
     * vast majority of this method.
     *
     * @private
     */
    _classLogic: function() {
      var that = this;
      var calc = {};
      var breakpoints = this.c.breakpoints;
      var dt = this.s.dt;
      var columns = dt.columns().eq(0).map(function(i2) {
        var column2 = this.column(i2);
        var className = column2.header().className;
        var priority = dt.settings()[0].aoColumns[i2].responsivePriority;
        var dataPriority = column2.header().getAttribute("data-priority");
        if (priority === void 0) {
          priority = dataPriority === void 0 || dataPriority === null ? 1e4 : dataPriority * 1;
        }
        return {
          className,
          includeIn: [],
          auto: false,
          control: false,
          never: className.match(/\b(dtr\-)?never\b/) ? true : false,
          priority
        };
      });
      var add2 = function(colIdx, name) {
        var includeIn = columns[colIdx].includeIn;
        if ($6.inArray(name, includeIn) === -1) {
          includeIn.push(name);
        }
      };
      var column = function(colIdx, name, operator, matched) {
        var size, i2, ien;
        if (!operator) {
          columns[colIdx].includeIn.push(name);
        } else if (operator === "max-") {
          size = that._find(name).width;
          for (i2 = 0, ien = breakpoints.length; i2 < ien; i2++) {
            if (breakpoints[i2].width <= size) {
              add2(colIdx, breakpoints[i2].name);
            }
          }
        } else if (operator === "min-") {
          size = that._find(name).width;
          for (i2 = 0, ien = breakpoints.length; i2 < ien; i2++) {
            if (breakpoints[i2].width >= size) {
              add2(colIdx, breakpoints[i2].name);
            }
          }
        } else if (operator === "not-") {
          for (i2 = 0, ien = breakpoints.length; i2 < ien; i2++) {
            if (breakpoints[i2].name.indexOf(matched) === -1) {
              add2(colIdx, breakpoints[i2].name);
            }
          }
        }
      };
      columns.each(function(col, i2) {
        var classNames = col.className.split(" ");
        var hasClass = false;
        for (var k2 = 0, ken = classNames.length; k2 < ken; k2++) {
          var className = classNames[k2].trim();
          if (className === "all" || className === "dtr-all") {
            hasClass = true;
            col.includeIn = $6.map(breakpoints, function(a2) {
              return a2.name;
            });
            return;
          } else if (className === "none" || className === "dtr-none" || col.never) {
            hasClass = true;
            return;
          } else if (className === "control" || className === "dtr-control") {
            hasClass = true;
            col.control = true;
            return;
          }
          $6.each(breakpoints, function(j2, breakpoint) {
            var brokenPoint = breakpoint.name.split("-");
            var re = new RegExp(
              "(min\\-|max\\-|not\\-)?(" + brokenPoint[0] + ")(\\-[_a-zA-Z0-9])?"
            );
            var match = className.match(re);
            if (match) {
              hasClass = true;
              if (match[2] === brokenPoint[0] && match[3] === "-" + brokenPoint[1]) {
                column(i2, breakpoint.name, match[1], match[2] + match[3]);
              } else if (match[2] === brokenPoint[0] && !match[3]) {
                column(i2, breakpoint.name, match[1], match[2]);
              }
            }
          });
        }
        if (!hasClass) {
          col.auto = true;
        }
      });
      this.s.columns = columns;
    },
    /**
     * Update the cells to show the correct control class / button
     * @private
     */
    _controlClass: function() {
      if (this.c.details.type === "inline") {
        var dt = this.s.dt;
        var columnsVis = this.s.current;
        var firstVisible = $6.inArray(true, columnsVis);
        dt.cells(
          null,
          function(idx) {
            return idx !== firstVisible;
          },
          { page: "current" }
        ).nodes().to$().filter(".dtr-control").removeClass("dtr-control");
        dt.cells(null, firstVisible, { page: "current" }).nodes().to$().addClass("dtr-control");
      }
    },
    /**
     * Show the details for the child row
     *
     * @param  {DataTables.Api} row    API instance for the row
     * @param  {boolean}        update Update flag
     * @private
     */
    _detailsDisplay: function(row, update) {
      var that = this;
      var dt = this.s.dt;
      var details = this.c.details;
      var event = function(res2) {
        $6(row.node()).toggleClass("parent", res2 !== false);
        $6(dt.table().node()).triggerHandler("responsive-display.dt", [dt, row, res2, update]);
      };
      if (details && details.type !== false) {
        var renderer = typeof details.renderer === "string" ? Responsive.renderer[details.renderer]() : details.renderer;
        var res = details.display(
          row,
          update,
          function() {
            return renderer.call(that, dt, row[0], that._detailsObj(row[0]));
          },
          function() {
            event(false);
          }
        );
        if (typeof res === "boolean") {
          event(res);
        }
      }
    },
    /**
     * Initialisation for the details handler
     *
     * @private
     */
    _detailsInit: function() {
      var that = this;
      var dt = this.s.dt;
      var details = this.c.details;
      if (details.type === "inline") {
        details.target = "td.dtr-control, th.dtr-control";
      }
      dt.on("draw.dtr", function() {
        that._tabIndexes();
      });
      that._tabIndexes();
      $6(dt.table().body()).on("keyup.dtr", "td, th", function(e2) {
        if (e2.keyCode === 13 && $6(this).data("dtr-keyboard")) {
          $6(this).click();
        }
      });
      var target = details.target;
      var selector = typeof target === "string" ? target : "td, th";
      if (target !== void 0 || target !== null) {
        $6(dt.table().body()).on("click.dtr mousedown.dtr mouseup.dtr", selector, function(e2) {
          if (!$6(dt.table().node()).hasClass("collapsed")) {
            return;
          }
          if ($6.inArray($6(this).closest("tr").get(0), dt.rows().nodes().toArray()) === -1) {
            return;
          }
          if (typeof target === "number") {
            var targetIdx = target < 0 ? dt.columns().eq(0).length + target : target;
            if (dt.cell(this).index().column !== targetIdx) {
              return;
            }
          }
          var row = dt.row($6(this).closest("tr"));
          if (e2.type === "click") {
            that._detailsDisplay(row, false);
          } else if (e2.type === "mousedown") {
            $6(this).css("outline", "none");
          } else if (e2.type === "mouseup") {
            $6(this).trigger("blur").css("outline", "");
          }
        });
      }
    },
    /**
     * Get the details to pass to a renderer for a row
     * @param  {int} rowIdx Row index
     * @private
     */
    _detailsObj: function(rowIdx) {
      var that = this;
      var dt = this.s.dt;
      return $6.map(this.s.columns, function(col, i2) {
        if (col.never || col.control) {
          return;
        }
        var dtCol = dt.settings()[0].aoColumns[i2];
        return {
          className: dtCol.sClass,
          columnIndex: i2,
          data: dt.cell(rowIdx, i2).render(that.c.orthogonal),
          hidden: dt.column(i2).visible() && !that.s.current[i2],
          rowIndex: rowIdx,
          title: dtCol.sTitle !== null ? dtCol.sTitle : $6(dt.column(i2).header()).text()
        };
      });
    },
    /**
     * Find a breakpoint object from a name
     *
     * @param  {string} name Breakpoint name to find
     * @return {object}      Breakpoint description object
     * @private
     */
    _find: function(name) {
      var breakpoints = this.c.breakpoints;
      for (var i2 = 0, ien = breakpoints.length; i2 < ien; i2++) {
        if (breakpoints[i2].name === name) {
          return breakpoints[i2];
        }
      }
    },
    /**
     * Re-create the contents of the child rows as the display has changed in
     * some way.
     *
     * @private
     */
    _redrawChildren: function() {
      var that = this;
      var dt = this.s.dt;
      dt.rows({ page: "current" }).iterator("row", function(settings, idx) {
        that._detailsDisplay(dt.row(idx), true);
      });
    },
    /**
     * Alter the table display for a resized viewport. This involves first
     * determining what breakpoint the window currently is in, getting the
     * column visibilities to apply and then setting them.
     *
     * @param  {boolean} forceRedraw Force a redraw
     * @private
     */
    _resize: function(forceRedraw) {
      var that = this;
      var dt = this.s.dt;
      var width = $6(window).innerWidth();
      var breakpoints = this.c.breakpoints;
      var breakpoint = breakpoints[0].name;
      var columns = this.s.columns;
      var i2, ien;
      var oldVis = this.s.current.slice();
      for (i2 = breakpoints.length - 1; i2 >= 0; i2--) {
        if (width <= breakpoints[i2].width) {
          breakpoint = breakpoints[i2].name;
          break;
        }
      }
      var columnsVis = this._columnsVisiblity(breakpoint);
      this.s.current = columnsVis;
      var collapsedClass = false;
      for (i2 = 0, ien = columns.length; i2 < ien; i2++) {
        if (columnsVis[i2] === false && !columns[i2].never && !columns[i2].control && !dt.column(i2).visible() === false) {
          collapsedClass = true;
          break;
        }
      }
      $6(dt.table().node()).toggleClass("collapsed", collapsedClass);
      var changed = false;
      var visible = 0;
      dt.columns().eq(0).each(function(colIdx, i3) {
        if (columnsVis[i3] === true) {
          visible++;
        }
        if (forceRedraw || columnsVis[i3] !== oldVis[i3]) {
          changed = true;
          that._setColumnVis(colIdx, columnsVis[i3]);
        }
      });
      this._redrawChildren();
      if (changed) {
        $6(dt.table().node()).trigger("responsive-resize.dt", [dt, this.s.current]);
        if (dt.page.info().recordsDisplay === 0) {
          $6("td", dt.table().body()).eq(0).attr("colspan", visible);
        }
      }
      that._controlClass();
    },
    /**
     * Determine the width of each column in the table so the auto column hiding
     * has that information to work with. This method is never going to be 100%
     * perfect since column widths can change slightly per page, but without
     * seriously compromising performance this is quite effective.
     *
     * @private
     */
    _resizeAuto: function() {
      var dt = this.s.dt;
      var columns = this.s.columns;
      var that = this;
      if (!this.c.auto) {
        return;
      }
      if ($6.inArray(
        true,
        $6.map(columns, function(c2) {
          return c2.auto;
        })
      ) === -1) {
        return;
      }
      if (!$6.isEmptyObject(this.s.childNodeStore)) {
        $6.each(this.s.childNodeStore, function(key) {
          var idx = key.split("-");
          that._childNodesRestore(dt, idx[0] * 1, idx[1] * 1);
        });
      }
      var tableWidth = dt.table().node().offsetWidth;
      var columnWidths = dt.columns;
      var clonedTable = dt.table().node().cloneNode(false);
      var clonedHeader = $6(dt.table().header().cloneNode(false)).appendTo(clonedTable);
      var clonedBody = $6(dt.table().body()).clone(false, false).empty().appendTo(clonedTable);
      clonedTable.style.width = "auto";
      var headerCells = dt.columns().header().filter(function(idx) {
        return dt.column(idx).visible();
      }).to$().clone(false).css("display", "table-cell").css("width", "auto").css("min-width", 0);
      $6(clonedBody).append($6(dt.rows({ page: "current" }).nodes()).clone(false)).find("th, td").css("display", "");
      var footer = dt.table().footer();
      if (footer) {
        var clonedFooter = $6(footer.cloneNode(false)).appendTo(clonedTable);
        var footerCells = dt.columns().footer().filter(function(idx) {
          return dt.column(idx).visible();
        }).to$().clone(false).css("display", "table-cell");
        $6("<tr/>").append(footerCells).appendTo(clonedFooter);
      }
      $6("<tr/>").append(headerCells).appendTo(clonedHeader);
      if (this.c.details.type === "inline") {
        $6(clonedTable).addClass("dtr-inline collapsed");
      }
      $6(clonedTable).find("[name]").removeAttr("name");
      $6(clonedTable).css("position", "relative");
      var inserted = $6("<div/>").css({
        width: 1,
        height: 1,
        overflow: "hidden",
        clear: "both"
      }).append(clonedTable);
      inserted.insertBefore(dt.table().node());
      headerCells.each(function(i2) {
        var idx = dt.column.index("fromVisible", i2);
        columns[idx].minWidth = this.offsetWidth || 0;
      });
      inserted.remove();
    },
    /**
     * Get the state of the current hidden columns - controlled by Responsive only
     */
    _responsiveOnlyHidden: function() {
      var dt = this.s.dt;
      return $6.map(this.s.current, function(v2, i2) {
        if (dt.column(i2).visible() === false) {
          return true;
        }
        return v2;
      });
    },
    /**
     * Set a column's visibility.
     *
     * We don't use DataTables' column visibility controls in order to ensure
     * that column visibility can Responsive can no-exist. Since only IE8+ is
     * supported (and all evergreen browsers of course) the control of the
     * display attribute works well.
     *
     * @param {integer} col      Column index
     * @param {boolean} showHide Show or hide (true or false)
     * @private
     */
    _setColumnVis: function(col, showHide) {
      var that = this;
      var dt = this.s.dt;
      var display = showHide ? "" : "none";
      $6(dt.column(col).header()).css("display", display).toggleClass("dtr-hidden", !showHide);
      $6(dt.column(col).footer()).css("display", display).toggleClass("dtr-hidden", !showHide);
      dt.column(col).nodes().to$().css("display", display).toggleClass("dtr-hidden", !showHide);
      if (!$6.isEmptyObject(this.s.childNodeStore)) {
        dt.cells(null, col).indexes().each(function(idx) {
          that._childNodesRestore(dt, idx.row, idx.column);
        });
      }
    },
    /**
     * Update the cell tab indexes for keyboard accessibility. This is called on
     * every table draw - that is potentially inefficient, but also the least
     * complex option given that column visibility can change on the fly. Its a
     * shame user-focus was removed from CSS 3 UI, as it would have solved this
     * issue with a single CSS statement.
     *
     * @private
     */
    _tabIndexes: function() {
      var dt = this.s.dt;
      var cells = dt.cells({ page: "current" }).nodes().to$();
      var ctx = dt.settings()[0];
      var target = this.c.details.target;
      cells.filter("[data-dtr-keyboard]").removeData("[data-dtr-keyboard]");
      if (typeof target === "number") {
        dt.cells(null, target, { page: "current" }).nodes().to$().attr("tabIndex", ctx.iTabIndex).data("dtr-keyboard", 1);
      } else {
        if (target === "td:first-child, th:first-child") {
          target = ">td:first-child, >th:first-child";
        }
        $6(target, dt.rows({ page: "current" }).nodes()).attr("tabIndex", ctx.iTabIndex).data("dtr-keyboard", 1);
      }
    }
  });
  Responsive.breakpoints = [
    { name: "desktop", width: Infinity },
    { name: "tablet-l", width: 1024 },
    { name: "tablet-p", width: 768 },
    { name: "mobile-l", width: 480 },
    { name: "mobile-p", width: 320 }
  ];
  Responsive.display = {
    childRow: function(row, update, render) {
      if (update) {
        if ($6(row.node()).hasClass("parent")) {
          row.child(render(), "child").show();
          return true;
        }
      } else {
        if (!row.child.isShown()) {
          row.child(render(), "child").show();
          return true;
        } else {
          row.child(false);
          return false;
        }
      }
    },
    childRowImmediate: function(row, update, render) {
      if (!update && row.child.isShown() || !row.responsive.hasHidden()) {
        row.child(false);
        return false;
      } else {
        row.child(render(), "child").show();
        return true;
      }
    },
    // This is a wrapper so the modal options for Bootstrap and jQuery UI can
    // have options passed into them. This specific one doesn't need to be a
    // function but it is for consistency in the `modal` name
    modal: function(options) {
      return function(row, update, render, closeCallback) {
        if (!update) {
          var close = function() {
            modal2.remove();
            $6(document).off("keypress.dtr");
            $6(row.node()).removeClass("parent");
            closeCallback();
          };
          var modal2 = $6('<div class="dtr-modal"/>').append(
            $6('<div class="dtr-modal-display"/>').append(
              $6('<div class="dtr-modal-content"/>').data("dtr-row-idx", row.index()).append(render())
            ).append(
              $6('<div class="dtr-modal-close">&times;</div>').click(function() {
                close();
              })
            )
          ).append(
            $6('<div class="dtr-modal-background"/>').click(function() {
              close();
            })
          ).appendTo("body");
          $6(row.node()).addClass("parent");
          $6(document).on("keyup.dtr", function(e2) {
            if (e2.keyCode === 27) {
              e2.stopPropagation();
              close();
            }
          });
        } else {
          var modal2 = $6("div.dtr-modal-content");
          if (modal2.length && row.index() === modal2.data("dtr-row-idx")) {
            modal2.empty().append(render());
          } else {
            return null;
          }
        }
        if (options && options.header) {
          $6("div.dtr-modal-content").prepend("<h2>" + options.header(row) + "</h2>");
        }
        return true;
      };
    }
  };
  Responsive.renderer = {
    listHiddenNodes: function() {
      return function(api, rowIdx, columns) {
        var that = this;
        var ul = $6('<ul data-dtr-index="' + rowIdx + '" class="dtr-details"/>');
        var found = false;
        var data = $6.each(columns, function(i2, col) {
          if (col.hidden) {
            var klass = col.className ? 'class="' + col.className + '"' : "";
            $6(
              "<li " + klass + ' data-dtr-index="' + col.columnIndex + '" data-dt-row="' + col.rowIndex + '" data-dt-column="' + col.columnIndex + '"><span class="dtr-title">' + col.title + "</span> </li>"
            ).append(
              $6('<span class="dtr-data"/>').append(
                that._childNodes(api, col.rowIndex, col.columnIndex)
              )
            ).appendTo(ul);
            found = true;
          }
        });
        return found ? ul : false;
      };
    },
    listHidden: function() {
      return function(api, rowIdx, columns) {
        var data = $6.map(columns, function(col) {
          var klass = col.className ? 'class="' + col.className + '"' : "";
          return col.hidden ? "<li " + klass + ' data-dtr-index="' + col.columnIndex + '" data-dt-row="' + col.rowIndex + '" data-dt-column="' + col.columnIndex + '"><span class="dtr-title">' + col.title + '</span> <span class="dtr-data">' + col.data + "</span></li>" : "";
        }).join("");
        return data ? $6('<ul data-dtr-index="' + rowIdx + '" class="dtr-details"/>').append(data) : false;
      };
    },
    tableAll: function(options) {
      options = $6.extend(
        {
          tableClass: ""
        },
        options
      );
      return function(api, rowIdx, columns) {
        var data = $6.map(columns, function(col) {
          var klass = col.className ? 'class="' + col.className + '"' : "";
          return "<tr " + klass + ' data-dt-row="' + col.rowIndex + '" data-dt-column="' + col.columnIndex + '"><td>' + col.title + ":</td> <td>" + col.data + "</td></tr>";
        }).join("");
        return $6('<table class="' + options.tableClass + ' dtr-details" width="100%"/>').append(
          data
        );
      };
    }
  };
  Responsive.defaults = {
    /**
     * List of breakpoints for the instance. Note that this means that each
     * instance can have its own breakpoints. Additionally, the breakpoints
     * cannot be changed once an instance has been creased.
     *
     * @type {Array}
     * @default Takes the value of `Responsive.breakpoints`
     */
    breakpoints: Responsive.breakpoints,
    /**
     * Enable / disable auto hiding calculations. It can help to increase
     * performance slightly if you disable this option, but all columns would
     * need to have breakpoint classes assigned to them
     *
     * @type {Boolean}
     * @default  `true`
     */
    auto: true,
    /**
     * Details control. If given as a string value, the `type` property of the
     * default object is set to that value, and the defaults used for the rest
     * of the object - this is for ease of implementation.
     *
     * The object consists of the following properties:
     *
     * * `display` - A function that is used to show and hide the hidden details
     * * `renderer` - function that is called for display of the child row data.
     *   The default function will show the data from the hidden columns
     * * `target` - Used as the selector for what objects to attach the child
     *   open / close to
     * * `type` - `false` to disable the details display, `inline` or `column`
     *   for the two control types
     *
     * @type {Object|string}
     */
    details: {
      display: Responsive.display.childRow,
      renderer: Responsive.renderer.listHidden(),
      target: 0,
      type: "inline"
    },
    /**
     * Orthogonal data request option. This is used to define the data type
     * requested when Responsive gets the data to show in the child row.
     *
     * @type {String}
     */
    orthogonal: "display"
  };
  var Api = $6.fn.dataTable.Api;
  Api.register("responsive()", function() {
    return this;
  });
  Api.register("responsive.index()", function(li) {
    li = $6(li);
    return {
      column: li.data("dtr-index"),
      row: li.parent().data("dtr-index")
    };
  });
  Api.register("responsive.rebuild()", function() {
    return this.iterator("table", function(ctx) {
      if (ctx._responsive) {
        ctx._responsive._classLogic();
      }
    });
  });
  Api.register("responsive.recalc()", function() {
    return this.iterator("table", function(ctx) {
      if (ctx._responsive) {
        ctx._responsive._resizeAuto();
        ctx._responsive._resize();
      }
    });
  });
  Api.register("responsive.hasHidden()", function() {
    var ctx = this.context[0];
    return ctx._responsive ? $6.inArray(false, ctx._responsive._responsiveOnlyHidden()) !== -1 : false;
  });
  Api.registerPlural("columns().responsiveHidden()", "column().responsiveHidden()", function() {
    return this.iterator(
      "column",
      function(settings, column) {
        return settings._responsive ? settings._responsive._responsiveOnlyHidden()[column] : false;
      },
      1
    );
  });
  Responsive.version = "2.5.0";
  $6.fn.dataTable.Responsive = Responsive;
  $6.fn.DataTable.Responsive = Responsive;
  $6(document).on("preInit.dt.dtr", function(e2, settings, json) {
    if (e2.namespace !== "dt") {
      return;
    }
    if ($6(settings.nTable).hasClass("responsive") || $6(settings.nTable).hasClass("dt-responsive") || settings.oInit.responsive || jquery_dataTables_default.defaults.responsive) {
      var init = settings.oInit.responsive;
      if (init !== false) {
        new Responsive(settings, $6.isPlainObject(init) ? init : {});
      }
    }
  });

  // node_modules/datatables.net-responsive-bs5/js/responsive.bootstrap5.mjs
  var $7 = import_jquery5.default;
  var _display = dataTables_bootstrap5_default.Responsive.display;
  var _original = _display.modal;
  var _modal = $7(
    '<div class="modal fade dtr-bs-modal" role="dialog"><div class="modal-dialog" role="document"><div class="modal-content"><div class="modal-header"><button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button></div><div class="modal-body"/></div></div></div>'
  );
  var modal;
  var _bs = window.bootstrap;
  dataTables_bootstrap5_default.Responsive.bootstrap = function(bs) {
    _bs = bs;
  };
  _display.modal = function(options) {
    if (!modal) {
      modal = new _bs.Modal(_modal[0]);
    }
    return function(row, update, render, closeCallback) {
      if (!$7.fn.modal) {
        return _original(row, update, render, closeCallback);
      } else {
        if (!update) {
          if (options && options.header) {
            var header = _modal.find("div.modal-header");
            var button = header.find("button").detach();
            header.empty().append('<h4 class="modal-title">' + options.header(row) + "</h4>").append(button);
          }
          _modal.find("div.modal-body").empty().append(render());
          _modal.data("dtr-row-idx", row.index()).one("hidden.bs.modal", closeCallback).appendTo("body").modal();
          modal.show();
        } else {
          if ($7.contains(document, _modal[0]) && row.index() === _modal.data("dtr-row-idx")) {
            _modal.find("div.modal-body").empty().append(render());
          } else {
            return null;
          }
        }
        return true;
      }
    };
  };

  // app/javascript/controllers/datatable_controller.js
  var datatable_controller_default = class extends Controller {
    static dt;
    connect() {
      console.log("Entro hasta aca");
      console.log("Connecting to data-controller=datatable");
      let table_id = this.element.id;
      console.log(table_id);
      if (!this.dt) {
        this.dt = new dataTables_bootstrap5_default(`#${table_id}`, {
          "responsive": {
            "details": {
              "display": $.fn.dataTable.Responsive.display.childRowImmediate
            }
          },
          "language": {
            "url": "//cdn.datatables.net/plug-ins/1.13.6/i18n/es-ES.json"
          }
        });
      }
      var elementoExterno = document.getElementById(`${table_id}_wrapper`);
      if (elementoExterno) {
        console.log("Encontro el elemento externo");
        var elementoInterno = elementoExterno.querySelector(`#${table_id}_wrapper`);
        if (elementoInterno) {
          console.log("Encontro el elemento interno");
          var etiquetasRow = elementoExterno.querySelectorAll(".row");
          etiquetasRow[0].remove();
          etiquetasRow[1].className = "";
          etiquetasRow[5].remove();
          elementoExterno.removeAttribute("id");
        }
      }
    }
  };

  // app/javascript/controllers/index.js
  application.register("hello", hello_controller_default);
  application.register("select2", select2_controller_default);
  application.register("sweetalert", sweetalert_controller_default);
  application.register("tagify", tagify_controller_default);
  application.register("toast", toast_controller_default);
  application.register("datatable", datatable_controller_default);

  // node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js
  (function() {
    if (window.Reflect === void 0 || window.customElements === void 0 || window.customElements.polyfillWrapFlushCallback) {
      return;
    }
    const BuiltInHTMLElement = HTMLElement;
    const wrapperForTheName = {
      HTMLElement: function HTMLElement2() {
        return Reflect.construct(BuiltInHTMLElement, [], this.constructor);
      }
    };
    window.HTMLElement = wrapperForTheName["HTMLElement"];
    HTMLElement.prototype = BuiltInHTMLElement.prototype;
    HTMLElement.prototype.constructor = HTMLElement;
    Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement);
  })();
  (function(prototype) {
    if (typeof prototype.requestSubmit == "function")
      return;
    prototype.requestSubmit = function(submitter) {
      if (submitter) {
        validateSubmitter(submitter, this);
        submitter.click();
      } else {
        submitter = document.createElement("input");
        submitter.type = "submit";
        submitter.hidden = true;
        this.appendChild(submitter);
        submitter.click();
        this.removeChild(submitter);
      }
    };
    function validateSubmitter(submitter, form) {
      submitter instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
      submitter.type == "submit" || raise(TypeError, "The specified element is not a submit button");
      submitter.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
    }
    function raise(errorConstructor, message, name) {
      throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name);
    }
  })(HTMLFormElement.prototype);
  var submittersByForm = /* @__PURE__ */ new WeakMap();
  function findSubmitterFromClickTarget(target) {
    const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
    const candidate = element ? element.closest("input, button") : null;
    return (candidate === null || candidate === void 0 ? void 0 : candidate.type) == "submit" ? candidate : null;
  }
  function clickCaptured(event) {
    const submitter = findSubmitterFromClickTarget(event.target);
    if (submitter && submitter.form) {
      submittersByForm.set(submitter.form, submitter);
    }
  }
  (function() {
    if ("submitter" in Event.prototype)
      return;
    let prototype = window.Event.prototype;
    if ("SubmitEvent" in window && /Apple Computer/.test(navigator.vendor)) {
      prototype = window.SubmitEvent.prototype;
    } else if ("SubmitEvent" in window) {
      return;
    }
    addEventListener("click", clickCaptured, true);
    Object.defineProperty(prototype, "submitter", {
      get() {
        if (this.type == "submit" && this.target instanceof HTMLFormElement) {
          return submittersByForm.get(this.target);
        }
      }
    });
  })();
  var FrameLoadingStyle;
  (function(FrameLoadingStyle2) {
    FrameLoadingStyle2["eager"] = "eager";
    FrameLoadingStyle2["lazy"] = "lazy";
  })(FrameLoadingStyle || (FrameLoadingStyle = {}));
  var FrameElement = class _FrameElement extends HTMLElement {
    static get observedAttributes() {
      return ["disabled", "complete", "loading", "src"];
    }
    constructor() {
      super();
      this.loaded = Promise.resolve();
      this.delegate = new _FrameElement.delegateConstructor(this);
    }
    connectedCallback() {
      this.delegate.connect();
    }
    disconnectedCallback() {
      this.delegate.disconnect();
    }
    reload() {
      return this.delegate.sourceURLReloaded();
    }
    attributeChangedCallback(name) {
      if (name == "loading") {
        this.delegate.loadingStyleChanged();
      } else if (name == "complete") {
        this.delegate.completeChanged();
      } else if (name == "src") {
        this.delegate.sourceURLChanged();
      } else {
        this.delegate.disabledChanged();
      }
    }
    get src() {
      return this.getAttribute("src");
    }
    set src(value) {
      if (value) {
        this.setAttribute("src", value);
      } else {
        this.removeAttribute("src");
      }
    }
    get loading() {
      return frameLoadingStyleFromString(this.getAttribute("loading") || "");
    }
    set loading(value) {
      if (value) {
        this.setAttribute("loading", value);
      } else {
        this.removeAttribute("loading");
      }
    }
    get disabled() {
      return this.hasAttribute("disabled");
    }
    set disabled(value) {
      if (value) {
        this.setAttribute("disabled", "");
      } else {
        this.removeAttribute("disabled");
      }
    }
    get autoscroll() {
      return this.hasAttribute("autoscroll");
    }
    set autoscroll(value) {
      if (value) {
        this.setAttribute("autoscroll", "");
      } else {
        this.removeAttribute("autoscroll");
      }
    }
    get complete() {
      return !this.delegate.isLoading;
    }
    get isActive() {
      return this.ownerDocument === document && !this.isPreview;
    }
    get isPreview() {
      var _a, _b;
      return (_b = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.documentElement) === null || _b === void 0 ? void 0 : _b.hasAttribute("data-turbo-preview");
    }
  };
  function frameLoadingStyleFromString(style) {
    switch (style.toLowerCase()) {
      case "lazy":
        return FrameLoadingStyle.lazy;
      default:
        return FrameLoadingStyle.eager;
    }
  }
  function expandURL(locatable) {
    return new URL(locatable.toString(), document.baseURI);
  }
  function getAnchor(url) {
    let anchorMatch;
    if (url.hash) {
      return url.hash.slice(1);
    } else if (anchorMatch = url.href.match(/#(.*)$/)) {
      return anchorMatch[1];
    }
  }
  function getAction(form, submitter) {
    const action = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formaction")) || form.getAttribute("action") || form.action;
    return expandURL(action);
  }
  function getExtension(url) {
    return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
  }
  function isHTML(url) {
    return !!getExtension(url).match(/^(?:|\.(?:htm|html|xhtml|php))$/);
  }
  function isPrefixedBy(baseURL, url) {
    const prefix = getPrefix(url);
    return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);
  }
  function locationIsVisitable(location2, rootLocation) {
    return isPrefixedBy(location2, rootLocation) && isHTML(location2);
  }
  function getRequestURL(url) {
    const anchor = getAnchor(url);
    return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
  }
  function toCacheKey(url) {
    return getRequestURL(url);
  }
  function urlsAreEqual(left2, right2) {
    return expandURL(left2).href == expandURL(right2).href;
  }
  function getPathComponents(url) {
    return url.pathname.split("/").slice(1);
  }
  function getLastPathComponent(url) {
    return getPathComponents(url).slice(-1)[0];
  }
  function getPrefix(url) {
    return addTrailingSlash(url.origin + url.pathname);
  }
  function addTrailingSlash(value) {
    return value.endsWith("/") ? value : value + "/";
  }
  var FetchResponse = class {
    constructor(response) {
      this.response = response;
    }
    get succeeded() {
      return this.response.ok;
    }
    get failed() {
      return !this.succeeded;
    }
    get clientError() {
      return this.statusCode >= 400 && this.statusCode <= 499;
    }
    get serverError() {
      return this.statusCode >= 500 && this.statusCode <= 599;
    }
    get redirected() {
      return this.response.redirected;
    }
    get location() {
      return expandURL(this.response.url);
    }
    get isHTML() {
      return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
    }
    get statusCode() {
      return this.response.status;
    }
    get contentType() {
      return this.header("Content-Type");
    }
    get responseText() {
      return this.response.clone().text();
    }
    get responseHTML() {
      if (this.isHTML) {
        return this.response.clone().text();
      } else {
        return Promise.resolve(void 0);
      }
    }
    header(name) {
      return this.response.headers.get(name);
    }
  };
  function activateScriptElement(element) {
    if (element.getAttribute("data-turbo-eval") == "false") {
      return element;
    } else {
      const createdScriptElement = document.createElement("script");
      const cspNonce = getMetaContent("csp-nonce");
      if (cspNonce) {
        createdScriptElement.nonce = cspNonce;
      }
      createdScriptElement.textContent = element.textContent;
      createdScriptElement.async = false;
      copyElementAttributes(createdScriptElement, element);
      return createdScriptElement;
    }
  }
  function copyElementAttributes(destinationElement, sourceElement) {
    for (const { name, value } of sourceElement.attributes) {
      destinationElement.setAttribute(name, value);
    }
  }
  function createDocumentFragment(html) {
    const template = document.createElement("template");
    template.innerHTML = html;
    return template.content;
  }
  function dispatch(eventName, { target, cancelable, detail } = {}) {
    const event = new CustomEvent(eventName, {
      cancelable,
      bubbles: true,
      composed: true,
      detail
    });
    if (target && target.isConnected) {
      target.dispatchEvent(event);
    } else {
      document.documentElement.dispatchEvent(event);
    }
    return event;
  }
  function nextAnimationFrame() {
    return new Promise((resolve) => requestAnimationFrame(() => resolve()));
  }
  function nextEventLoopTick() {
    return new Promise((resolve) => setTimeout(() => resolve(), 0));
  }
  function nextMicrotask() {
    return Promise.resolve();
  }
  function parseHTMLDocument(html = "") {
    return new DOMParser().parseFromString(html, "text/html");
  }
  function unindent(strings, ...values) {
    const lines = interpolate(strings, values).replace(/^\n/, "").split("\n");
    const match = lines[0].match(/^\s+/);
    const indent = match ? match[0].length : 0;
    return lines.map((line) => line.slice(indent)).join("\n");
  }
  function interpolate(strings, values) {
    return strings.reduce((result, string, i2) => {
      const value = values[i2] == void 0 ? "" : values[i2];
      return result + string + value;
    }, "");
  }
  function uuid() {
    return Array.from({ length: 36 }).map((_2, i2) => {
      if (i2 == 8 || i2 == 13 || i2 == 18 || i2 == 23) {
        return "-";
      } else if (i2 == 14) {
        return "4";
      } else if (i2 == 19) {
        return (Math.floor(Math.random() * 4) + 8).toString(16);
      } else {
        return Math.floor(Math.random() * 15).toString(16);
      }
    }).join("");
  }
  function getAttribute(attributeName, ...elements) {
    for (const value of elements.map((element) => element === null || element === void 0 ? void 0 : element.getAttribute(attributeName))) {
      if (typeof value == "string")
        return value;
    }
    return null;
  }
  function hasAttribute(attributeName, ...elements) {
    return elements.some((element) => element && element.hasAttribute(attributeName));
  }
  function markAsBusy(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.setAttribute("busy", "");
      }
      element.setAttribute("aria-busy", "true");
    }
  }
  function clearBusyState(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.removeAttribute("busy");
      }
      element.removeAttribute("aria-busy");
    }
  }
  function waitForLoad(element, timeoutInMilliseconds = 2e3) {
    return new Promise((resolve) => {
      const onComplete = () => {
        element.removeEventListener("error", onComplete);
        element.removeEventListener("load", onComplete);
        resolve();
      };
      element.addEventListener("load", onComplete, { once: true });
      element.addEventListener("error", onComplete, { once: true });
      setTimeout(resolve, timeoutInMilliseconds);
    });
  }
  function getHistoryMethodForAction(action) {
    switch (action) {
      case "replace":
        return history.replaceState;
      case "advance":
      case "restore":
        return history.pushState;
    }
  }
  function isAction(action) {
    return action == "advance" || action == "replace" || action == "restore";
  }
  function getVisitAction(...elements) {
    const action = getAttribute("data-turbo-action", ...elements);
    return isAction(action) ? action : null;
  }
  function getMetaElement(name) {
    return document.querySelector(`meta[name="${name}"]`);
  }
  function getMetaContent(name) {
    const element = getMetaElement(name);
    return element && element.content;
  }
  function setMetaContent(name, content) {
    let element = getMetaElement(name);
    if (!element) {
      element = document.createElement("meta");
      element.setAttribute("name", name);
      document.head.appendChild(element);
    }
    element.setAttribute("content", content);
    return element;
  }
  function findClosestRecursively(element, selector) {
    var _a;
    if (element instanceof Element) {
      return element.closest(selector) || findClosestRecursively(element.assignedSlot || ((_a = element.getRootNode()) === null || _a === void 0 ? void 0 : _a.host), selector);
    }
  }
  var FetchMethod;
  (function(FetchMethod2) {
    FetchMethod2[FetchMethod2["get"] = 0] = "get";
    FetchMethod2[FetchMethod2["post"] = 1] = "post";
    FetchMethod2[FetchMethod2["put"] = 2] = "put";
    FetchMethod2[FetchMethod2["patch"] = 3] = "patch";
    FetchMethod2[FetchMethod2["delete"] = 4] = "delete";
  })(FetchMethod || (FetchMethod = {}));
  function fetchMethodFromString(method) {
    switch (method.toLowerCase()) {
      case "get":
        return FetchMethod.get;
      case "post":
        return FetchMethod.post;
      case "put":
        return FetchMethod.put;
      case "patch":
        return FetchMethod.patch;
      case "delete":
        return FetchMethod.delete;
    }
  }
  var FetchRequest = class {
    constructor(delegate, method, location2, body = new URLSearchParams(), target = null) {
      this.abortController = new AbortController();
      this.resolveRequestPromise = (_value) => {
      };
      this.delegate = delegate;
      this.method = method;
      this.headers = this.defaultHeaders;
      this.body = body;
      this.url = location2;
      this.target = target;
    }
    get location() {
      return this.url;
    }
    get params() {
      return this.url.searchParams;
    }
    get entries() {
      return this.body ? Array.from(this.body.entries()) : [];
    }
    cancel() {
      this.abortController.abort();
    }
    async perform() {
      const { fetchOptions } = this;
      this.delegate.prepareRequest(this);
      await this.allowRequestToBeIntercepted(fetchOptions);
      try {
        this.delegate.requestStarted(this);
        const response = await fetch(this.url.href, fetchOptions);
        return await this.receive(response);
      } catch (error2) {
        if (error2.name !== "AbortError") {
          if (this.willDelegateErrorHandling(error2)) {
            this.delegate.requestErrored(this, error2);
          }
          throw error2;
        }
      } finally {
        this.delegate.requestFinished(this);
      }
    }
    async receive(response) {
      const fetchResponse = new FetchResponse(response);
      const event = dispatch("turbo:before-fetch-response", {
        cancelable: true,
        detail: { fetchResponse },
        target: this.target
      });
      if (event.defaultPrevented) {
        this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
      } else if (fetchResponse.succeeded) {
        this.delegate.requestSucceededWithResponse(this, fetchResponse);
      } else {
        this.delegate.requestFailedWithResponse(this, fetchResponse);
      }
      return fetchResponse;
    }
    get fetchOptions() {
      var _a;
      return {
        method: FetchMethod[this.method].toUpperCase(),
        credentials: "same-origin",
        headers: this.headers,
        redirect: "follow",
        body: this.isSafe ? null : this.body,
        signal: this.abortSignal,
        referrer: (_a = this.delegate.referrer) === null || _a === void 0 ? void 0 : _a.href
      };
    }
    get defaultHeaders() {
      return {
        Accept: "text/html, application/xhtml+xml"
      };
    }
    get isSafe() {
      return this.method === FetchMethod.get;
    }
    get abortSignal() {
      return this.abortController.signal;
    }
    acceptResponseType(mimeType) {
      this.headers["Accept"] = [mimeType, this.headers["Accept"]].join(", ");
    }
    async allowRequestToBeIntercepted(fetchOptions) {
      const requestInterception = new Promise((resolve) => this.resolveRequestPromise = resolve);
      const event = dispatch("turbo:before-fetch-request", {
        cancelable: true,
        detail: {
          fetchOptions,
          url: this.url,
          resume: this.resolveRequestPromise
        },
        target: this.target
      });
      if (event.defaultPrevented)
        await requestInterception;
    }
    willDelegateErrorHandling(error2) {
      const event = dispatch("turbo:fetch-request-error", {
        target: this.target,
        cancelable: true,
        detail: { request: this, error: error2 }
      });
      return !event.defaultPrevented;
    }
  };
  var AppearanceObserver = class {
    constructor(delegate, element) {
      this.started = false;
      this.intersect = (entries) => {
        const lastEntry = entries.slice(-1)[0];
        if (lastEntry === null || lastEntry === void 0 ? void 0 : lastEntry.isIntersecting) {
          this.delegate.elementAppearedInViewport(this.element);
        }
      };
      this.delegate = delegate;
      this.element = element;
      this.intersectionObserver = new IntersectionObserver(this.intersect);
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.intersectionObserver.observe(this.element);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.intersectionObserver.unobserve(this.element);
      }
    }
  };
  var StreamMessage = class {
    static wrap(message) {
      if (typeof message == "string") {
        return new this(createDocumentFragment(message));
      } else {
        return message;
      }
    }
    constructor(fragment) {
      this.fragment = importStreamElements(fragment);
    }
  };
  StreamMessage.contentType = "text/vnd.turbo-stream.html";
  function importStreamElements(fragment) {
    for (const element of fragment.querySelectorAll("turbo-stream")) {
      const streamElement = document.importNode(element, true);
      for (const inertScriptElement of streamElement.templateElement.content.querySelectorAll("script")) {
        inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));
      }
      element.replaceWith(streamElement);
    }
    return fragment;
  }
  var FormSubmissionState;
  (function(FormSubmissionState2) {
    FormSubmissionState2[FormSubmissionState2["initialized"] = 0] = "initialized";
    FormSubmissionState2[FormSubmissionState2["requesting"] = 1] = "requesting";
    FormSubmissionState2[FormSubmissionState2["waiting"] = 2] = "waiting";
    FormSubmissionState2[FormSubmissionState2["receiving"] = 3] = "receiving";
    FormSubmissionState2[FormSubmissionState2["stopping"] = 4] = "stopping";
    FormSubmissionState2[FormSubmissionState2["stopped"] = 5] = "stopped";
  })(FormSubmissionState || (FormSubmissionState = {}));
  var FormEnctype;
  (function(FormEnctype2) {
    FormEnctype2["urlEncoded"] = "application/x-www-form-urlencoded";
    FormEnctype2["multipart"] = "multipart/form-data";
    FormEnctype2["plain"] = "text/plain";
  })(FormEnctype || (FormEnctype = {}));
  function formEnctypeFromString(encoding) {
    switch (encoding.toLowerCase()) {
      case FormEnctype.multipart:
        return FormEnctype.multipart;
      case FormEnctype.plain:
        return FormEnctype.plain;
      default:
        return FormEnctype.urlEncoded;
    }
  }
  var FormSubmission = class _FormSubmission {
    static confirmMethod(message, _element, _submitter) {
      return Promise.resolve(confirm(message));
    }
    constructor(delegate, formElement, submitter, mustRedirect = false) {
      this.state = FormSubmissionState.initialized;
      this.delegate = delegate;
      this.formElement = formElement;
      this.submitter = submitter;
      this.formData = buildFormData(formElement, submitter);
      this.location = expandURL(this.action);
      if (this.method == FetchMethod.get) {
        mergeFormDataEntries(this.location, [...this.body.entries()]);
      }
      this.fetchRequest = new FetchRequest(this, this.method, this.location, this.body, this.formElement);
      this.mustRedirect = mustRedirect;
    }
    get method() {
      var _a;
      const method = ((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("formmethod")) || this.formElement.getAttribute("method") || "";
      return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
    }
    get action() {
      var _a;
      const formElementAction = typeof this.formElement.action === "string" ? this.formElement.action : null;
      if ((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.hasAttribute("formaction")) {
        return this.submitter.getAttribute("formaction") || "";
      } else {
        return this.formElement.getAttribute("action") || formElementAction || "";
      }
    }
    get body() {
      if (this.enctype == FormEnctype.urlEncoded || this.method == FetchMethod.get) {
        return new URLSearchParams(this.stringFormData);
      } else {
        return this.formData;
      }
    }
    get enctype() {
      var _a;
      return formEnctypeFromString(((_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("formenctype")) || this.formElement.enctype);
    }
    get isSafe() {
      return this.fetchRequest.isSafe;
    }
    get stringFormData() {
      return [...this.formData].reduce((entries, [name, value]) => {
        return entries.concat(typeof value == "string" ? [[name, value]] : []);
      }, []);
    }
    async start() {
      const { initialized, requesting } = FormSubmissionState;
      const confirmationMessage = getAttribute("data-turbo-confirm", this.submitter, this.formElement);
      if (typeof confirmationMessage === "string") {
        const answer = await _FormSubmission.confirmMethod(confirmationMessage, this.formElement, this.submitter);
        if (!answer) {
          return;
        }
      }
      if (this.state == initialized) {
        this.state = requesting;
        return this.fetchRequest.perform();
      }
    }
    stop() {
      const { stopping, stopped } = FormSubmissionState;
      if (this.state != stopping && this.state != stopped) {
        this.state = stopping;
        this.fetchRequest.cancel();
        return true;
      }
    }
    prepareRequest(request) {
      if (!request.isSafe) {
        const token = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
        if (token) {
          request.headers["X-CSRF-Token"] = token;
        }
      }
      if (this.requestAcceptsTurboStreamResponse(request)) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      var _a;
      this.state = FormSubmissionState.waiting;
      (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.setAttribute("disabled", "");
      this.setSubmitsWith();
      dispatch("turbo:submit-start", {
        target: this.formElement,
        detail: { formSubmission: this }
      });
      this.delegate.formSubmissionStarted(this);
    }
    requestPreventedHandlingResponse(request, response) {
      this.result = { success: response.succeeded, fetchResponse: response };
    }
    requestSucceededWithResponse(request, response) {
      if (response.clientError || response.serverError) {
        this.delegate.formSubmissionFailedWithResponse(this, response);
      } else if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
        const error2 = new Error("Form responses must redirect to another location");
        this.delegate.formSubmissionErrored(this, error2);
      } else {
        this.state = FormSubmissionState.receiving;
        this.result = { success: true, fetchResponse: response };
        this.delegate.formSubmissionSucceededWithResponse(this, response);
      }
    }
    requestFailedWithResponse(request, response) {
      this.result = { success: false, fetchResponse: response };
      this.delegate.formSubmissionFailedWithResponse(this, response);
    }
    requestErrored(request, error2) {
      this.result = { success: false, error: error2 };
      this.delegate.formSubmissionErrored(this, error2);
    }
    requestFinished(_request) {
      var _a;
      this.state = FormSubmissionState.stopped;
      (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.removeAttribute("disabled");
      this.resetSubmitterText();
      dispatch("turbo:submit-end", {
        target: this.formElement,
        detail: Object.assign({ formSubmission: this }, this.result)
      });
      this.delegate.formSubmissionFinished(this);
    }
    setSubmitsWith() {
      if (!this.submitter || !this.submitsWith)
        return;
      if (this.submitter.matches("button")) {
        this.originalSubmitText = this.submitter.innerHTML;
        this.submitter.innerHTML = this.submitsWith;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        this.originalSubmitText = input.value;
        input.value = this.submitsWith;
      }
    }
    resetSubmitterText() {
      if (!this.submitter || !this.originalSubmitText)
        return;
      if (this.submitter.matches("button")) {
        this.submitter.innerHTML = this.originalSubmitText;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        input.value = this.originalSubmitText;
      }
    }
    requestMustRedirect(request) {
      return !request.isSafe && this.mustRedirect;
    }
    requestAcceptsTurboStreamResponse(request) {
      return !request.isSafe || hasAttribute("data-turbo-stream", this.submitter, this.formElement);
    }
    get submitsWith() {
      var _a;
      return (_a = this.submitter) === null || _a === void 0 ? void 0 : _a.getAttribute("data-turbo-submits-with");
    }
  };
  function buildFormData(formElement, submitter) {
    const formData = new FormData(formElement);
    const name = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("name");
    const value = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("value");
    if (name) {
      formData.append(name, value || "");
    }
    return formData;
  }
  function getCookieValue(cookieName) {
    if (cookieName != null) {
      const cookies = document.cookie ? document.cookie.split("; ") : [];
      const cookie = cookies.find((cookie2) => cookie2.startsWith(cookieName));
      if (cookie) {
        const value = cookie.split("=").slice(1).join("=");
        return value ? decodeURIComponent(value) : void 0;
      }
    }
  }
  function responseSucceededWithoutRedirect(response) {
    return response.statusCode == 200 && !response.redirected;
  }
  function mergeFormDataEntries(url, entries) {
    const searchParams = new URLSearchParams();
    for (const [name, value] of entries) {
      if (value instanceof File)
        continue;
      searchParams.append(name, value);
    }
    url.search = searchParams.toString();
    return url;
  }
  var Snapshot = class {
    constructor(element) {
      this.element = element;
    }
    get activeElement() {
      return this.element.ownerDocument.activeElement;
    }
    get children() {
      return [...this.element.children];
    }
    hasAnchor(anchor) {
      return this.getElementForAnchor(anchor) != null;
    }
    getElementForAnchor(anchor) {
      return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
    }
    get isConnected() {
      return this.element.isConnected;
    }
    get firstAutofocusableElement() {
      const inertDisabledOrHidden = "[inert], :disabled, [hidden], details:not([open]), dialog:not([open])";
      for (const element of this.element.querySelectorAll("[autofocus]")) {
        if (element.closest(inertDisabledOrHidden) == null)
          return element;
        else
          continue;
      }
      return null;
    }
    get permanentElements() {
      return queryPermanentElementsAll(this.element);
    }
    getPermanentElementById(id) {
      return getPermanentElementById(this.element, id);
    }
    getPermanentElementMapForSnapshot(snapshot) {
      const permanentElementMap = {};
      for (const currentPermanentElement of this.permanentElements) {
        const { id } = currentPermanentElement;
        const newPermanentElement = snapshot.getPermanentElementById(id);
        if (newPermanentElement) {
          permanentElementMap[id] = [currentPermanentElement, newPermanentElement];
        }
      }
      return permanentElementMap;
    }
  };
  function getPermanentElementById(node, id) {
    return node.querySelector(`#${id}[data-turbo-permanent]`);
  }
  function queryPermanentElementsAll(node) {
    return node.querySelectorAll("[id][data-turbo-permanent]");
  }
  var FormSubmitObserver = class {
    constructor(delegate, eventTarget) {
      this.started = false;
      this.submitCaptured = () => {
        this.eventTarget.removeEventListener("submit", this.submitBubbled, false);
        this.eventTarget.addEventListener("submit", this.submitBubbled, false);
      };
      this.submitBubbled = (event) => {
        if (!event.defaultPrevented) {
          const form = event.target instanceof HTMLFormElement ? event.target : void 0;
          const submitter = event.submitter || void 0;
          if (form && submissionDoesNotDismissDialog(form, submitter) && submissionDoesNotTargetIFrame(form, submitter) && this.delegate.willSubmitForm(form, submitter)) {
            event.preventDefault();
            event.stopImmediatePropagation();
            this.delegate.formSubmitted(form, submitter);
          }
        }
      };
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("submit", this.submitCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("submit", this.submitCaptured, true);
        this.started = false;
      }
    }
  };
  function submissionDoesNotDismissDialog(form, submitter) {
    const method = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formmethod")) || form.getAttribute("method");
    return method != "dialog";
  }
  function submissionDoesNotTargetIFrame(form, submitter) {
    if ((submitter === null || submitter === void 0 ? void 0 : submitter.hasAttribute("formtarget")) || form.hasAttribute("target")) {
      const target = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("formtarget")) || form.target;
      for (const element of document.getElementsByName(target)) {
        if (element instanceof HTMLIFrameElement)
          return false;
      }
      return true;
    } else {
      return true;
    }
  }
  var View = class {
    constructor(delegate, element) {
      this.resolveRenderPromise = (_value) => {
      };
      this.resolveInterceptionPromise = (_value) => {
      };
      this.delegate = delegate;
      this.element = element;
    }
    scrollToAnchor(anchor) {
      const element = this.snapshot.getElementForAnchor(anchor);
      if (element) {
        this.scrollToElement(element);
        this.focusElement(element);
      } else {
        this.scrollToPosition({ x: 0, y: 0 });
      }
    }
    scrollToAnchorFromLocation(location2) {
      this.scrollToAnchor(getAnchor(location2));
    }
    scrollToElement(element) {
      element.scrollIntoView();
    }
    focusElement(element) {
      if (element instanceof HTMLElement) {
        if (element.hasAttribute("tabindex")) {
          element.focus();
        } else {
          element.setAttribute("tabindex", "-1");
          element.focus();
          element.removeAttribute("tabindex");
        }
      }
    }
    scrollToPosition({ x: x2, y: y2 }) {
      this.scrollRoot.scrollTo(x2, y2);
    }
    scrollToTop() {
      this.scrollToPosition({ x: 0, y: 0 });
    }
    get scrollRoot() {
      return window;
    }
    async render(renderer) {
      const { isPreview, shouldRender, newSnapshot: snapshot } = renderer;
      if (shouldRender) {
        try {
          this.renderPromise = new Promise((resolve) => this.resolveRenderPromise = resolve);
          this.renderer = renderer;
          await this.prepareToRenderSnapshot(renderer);
          const renderInterception = new Promise((resolve) => this.resolveInterceptionPromise = resolve);
          const options = { resume: this.resolveInterceptionPromise, render: this.renderer.renderElement };
          const immediateRender = this.delegate.allowsImmediateRender(snapshot, options);
          if (!immediateRender)
            await renderInterception;
          await this.renderSnapshot(renderer);
          this.delegate.viewRenderedSnapshot(snapshot, isPreview);
          this.delegate.preloadOnLoadLinksForView(this.element);
          this.finishRenderingSnapshot(renderer);
        } finally {
          delete this.renderer;
          this.resolveRenderPromise(void 0);
          delete this.renderPromise;
        }
      } else {
        this.invalidate(renderer.reloadReason);
      }
    }
    invalidate(reason) {
      this.delegate.viewInvalidated(reason);
    }
    async prepareToRenderSnapshot(renderer) {
      this.markAsPreview(renderer.isPreview);
      await renderer.prepareToRender();
    }
    markAsPreview(isPreview) {
      if (isPreview) {
        this.element.setAttribute("data-turbo-preview", "");
      } else {
        this.element.removeAttribute("data-turbo-preview");
      }
    }
    async renderSnapshot(renderer) {
      await renderer.render();
    }
    finishRenderingSnapshot(renderer) {
      renderer.finishRendering();
    }
  };
  var FrameView = class extends View {
    missing() {
      this.element.innerHTML = `<strong class="turbo-frame-error">Content missing</strong>`;
    }
    get snapshot() {
      return new Snapshot(this.element);
    }
  };
  var LinkInterceptor = class {
    constructor(delegate, element) {
      this.clickBubbled = (event) => {
        if (this.respondsToEventTarget(event.target)) {
          this.clickEvent = event;
        } else {
          delete this.clickEvent;
        }
      };
      this.linkClicked = (event) => {
        if (this.clickEvent && this.respondsToEventTarget(event.target) && event.target instanceof Element) {
          if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url, event.detail.originalEvent)) {
            this.clickEvent.preventDefault();
            event.preventDefault();
            this.delegate.linkClickIntercepted(event.target, event.detail.url, event.detail.originalEvent);
          }
        }
        delete this.clickEvent;
      };
      this.willVisit = (_event) => {
        delete this.clickEvent;
      };
      this.delegate = delegate;
      this.element = element;
    }
    start() {
      this.element.addEventListener("click", this.clickBubbled);
      document.addEventListener("turbo:click", this.linkClicked);
      document.addEventListener("turbo:before-visit", this.willVisit);
    }
    stop() {
      this.element.removeEventListener("click", this.clickBubbled);
      document.removeEventListener("turbo:click", this.linkClicked);
      document.removeEventListener("turbo:before-visit", this.willVisit);
    }
    respondsToEventTarget(target) {
      const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
      return element && element.closest("turbo-frame, html") == this.element;
    }
  };
  var LinkClickObserver = class {
    constructor(delegate, eventTarget) {
      this.started = false;
      this.clickCaptured = () => {
        this.eventTarget.removeEventListener("click", this.clickBubbled, false);
        this.eventTarget.addEventListener("click", this.clickBubbled, false);
      };
      this.clickBubbled = (event) => {
        if (event instanceof MouseEvent && this.clickEventIsSignificant(event)) {
          const target = event.composedPath && event.composedPath()[0] || event.target;
          const link = this.findLinkFromClickTarget(target);
          if (link && doesNotTargetIFrame(link)) {
            const location2 = this.getLocationForLink(link);
            if (this.delegate.willFollowLinkToLocation(link, location2, event)) {
              event.preventDefault();
              this.delegate.followedLinkToLocation(link, location2);
            }
          }
        }
      };
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("click", this.clickCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("click", this.clickCaptured, true);
        this.started = false;
      }
    }
    clickEventIsSignificant(event) {
      return !(event.target && event.target.isContentEditable || event.defaultPrevented || event.which > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
    }
    findLinkFromClickTarget(target) {
      return findClosestRecursively(target, "a[href]:not([target^=_]):not([download])");
    }
    getLocationForLink(link) {
      return expandURL(link.getAttribute("href") || "");
    }
  };
  function doesNotTargetIFrame(anchor) {
    if (anchor.hasAttribute("target")) {
      for (const element of document.getElementsByName(anchor.target)) {
        if (element instanceof HTMLIFrameElement)
          return false;
      }
      return true;
    } else {
      return true;
    }
  }
  var FormLinkClickObserver = class {
    constructor(delegate, element) {
      this.delegate = delegate;
      this.linkInterceptor = new LinkClickObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
    }
    stop() {
      this.linkInterceptor.stop();
    }
    willFollowLinkToLocation(link, location2, originalEvent) {
      return this.delegate.willSubmitFormLinkToLocation(link, location2, originalEvent) && link.hasAttribute("data-turbo-method");
    }
    followedLinkToLocation(link, location2) {
      const form = document.createElement("form");
      const type = "hidden";
      for (const [name, value] of location2.searchParams) {
        form.append(Object.assign(document.createElement("input"), { type, name, value }));
      }
      const action = Object.assign(location2, { search: "" });
      form.setAttribute("data-turbo", "true");
      form.setAttribute("action", action.href);
      form.setAttribute("hidden", "");
      const method = link.getAttribute("data-turbo-method");
      if (method)
        form.setAttribute("method", method);
      const turboFrame = link.getAttribute("data-turbo-frame");
      if (turboFrame)
        form.setAttribute("data-turbo-frame", turboFrame);
      const turboAction = getVisitAction(link);
      if (turboAction)
        form.setAttribute("data-turbo-action", turboAction);
      const turboConfirm = link.getAttribute("data-turbo-confirm");
      if (turboConfirm)
        form.setAttribute("data-turbo-confirm", turboConfirm);
      const turboStream = link.hasAttribute("data-turbo-stream");
      if (turboStream)
        form.setAttribute("data-turbo-stream", "");
      this.delegate.submittedFormLinkToLocation(link, location2, form);
      document.body.appendChild(form);
      form.addEventListener("turbo:submit-end", () => form.remove(), { once: true });
      requestAnimationFrame(() => form.requestSubmit());
    }
  };
  var Bardo = class {
    static async preservingPermanentElements(delegate, permanentElementMap, callback) {
      const bardo = new this(delegate, permanentElementMap);
      bardo.enter();
      await callback();
      bardo.leave();
    }
    constructor(delegate, permanentElementMap) {
      this.delegate = delegate;
      this.permanentElementMap = permanentElementMap;
    }
    enter() {
      for (const id in this.permanentElementMap) {
        const [currentPermanentElement, newPermanentElement] = this.permanentElementMap[id];
        this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);
        this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
      }
    }
    leave() {
      for (const id in this.permanentElementMap) {
        const [currentPermanentElement] = this.permanentElementMap[id];
        this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
        this.replacePlaceholderWithPermanentElement(currentPermanentElement);
        this.delegate.leavingBardo(currentPermanentElement);
      }
    }
    replaceNewPermanentElementWithPlaceholder(permanentElement) {
      const placeholder = createPlaceholderForPermanentElement(permanentElement);
      permanentElement.replaceWith(placeholder);
    }
    replaceCurrentPermanentElementWithClone(permanentElement) {
      const clone = permanentElement.cloneNode(true);
      permanentElement.replaceWith(clone);
    }
    replacePlaceholderWithPermanentElement(permanentElement) {
      const placeholder = this.getPlaceholderById(permanentElement.id);
      placeholder === null || placeholder === void 0 ? void 0 : placeholder.replaceWith(permanentElement);
    }
    getPlaceholderById(id) {
      return this.placeholders.find((element) => element.content == id);
    }
    get placeholders() {
      return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
    }
  };
  function createPlaceholderForPermanentElement(permanentElement) {
    const element = document.createElement("meta");
    element.setAttribute("name", "turbo-permanent-placeholder");
    element.setAttribute("content", permanentElement.id);
    return element;
  }
  var Renderer = class {
    constructor(currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
      this.activeElement = null;
      this.currentSnapshot = currentSnapshot;
      this.newSnapshot = newSnapshot;
      this.isPreview = isPreview;
      this.willRender = willRender;
      this.renderElement = renderElement;
      this.promise = new Promise((resolve, reject) => this.resolvingFunctions = { resolve, reject });
    }
    get shouldRender() {
      return true;
    }
    get reloadReason() {
      return;
    }
    prepareToRender() {
      return;
    }
    finishRendering() {
      if (this.resolvingFunctions) {
        this.resolvingFunctions.resolve();
        delete this.resolvingFunctions;
      }
    }
    async preservingPermanentElements(callback) {
      await Bardo.preservingPermanentElements(this, this.permanentElementMap, callback);
    }
    focusFirstAutofocusableElement() {
      const element = this.connectedSnapshot.firstAutofocusableElement;
      if (elementIsFocusable(element)) {
        element.focus();
      }
    }
    enteringBardo(currentPermanentElement) {
      if (this.activeElement)
        return;
      if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {
        this.activeElement = this.currentSnapshot.activeElement;
      }
    }
    leavingBardo(currentPermanentElement) {
      if (currentPermanentElement.contains(this.activeElement) && this.activeElement instanceof HTMLElement) {
        this.activeElement.focus();
        this.activeElement = null;
      }
    }
    get connectedSnapshot() {
      return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
    }
    get currentElement() {
      return this.currentSnapshot.element;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    get permanentElementMap() {
      return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
    }
  };
  function elementIsFocusable(element) {
    return element && typeof element.focus == "function";
  }
  var FrameRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      var _a;
      const destinationRange = document.createRange();
      destinationRange.selectNodeContents(currentElement);
      destinationRange.deleteContents();
      const frameElement = newElement;
      const sourceRange = (_a = frameElement.ownerDocument) === null || _a === void 0 ? void 0 : _a.createRange();
      if (sourceRange) {
        sourceRange.selectNodeContents(frameElement);
        currentElement.appendChild(sourceRange.extractContents());
      }
    }
    constructor(delegate, currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
      super(currentSnapshot, newSnapshot, renderElement, isPreview, willRender);
      this.delegate = delegate;
    }
    get shouldRender() {
      return true;
    }
    async render() {
      await nextAnimationFrame();
      this.preservingPermanentElements(() => {
        this.loadFrameElement();
      });
      this.scrollFrameIntoView();
      await nextAnimationFrame();
      this.focusFirstAutofocusableElement();
      await nextAnimationFrame();
      this.activateScriptElements();
    }
    loadFrameElement() {
      this.delegate.willRenderFrame(this.currentElement, this.newElement);
      this.renderElement(this.currentElement, this.newElement);
    }
    scrollFrameIntoView() {
      if (this.currentElement.autoscroll || this.newElement.autoscroll) {
        const element = this.currentElement.firstElementChild;
        const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
        const behavior = readScrollBehavior(this.currentElement.getAttribute("data-autoscroll-behavior"), "auto");
        if (element) {
          element.scrollIntoView({ block, behavior });
          return true;
        }
      }
      return false;
    }
    activateScriptElements() {
      for (const inertScriptElement of this.newScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    get newScriptElements() {
      return this.currentElement.querySelectorAll("script");
    }
  };
  function readScrollLogicalPosition(value, defaultValue) {
    if (value == "end" || value == "start" || value == "center" || value == "nearest") {
      return value;
    } else {
      return defaultValue;
    }
  }
  function readScrollBehavior(value, defaultValue) {
    if (value == "auto" || value == "smooth") {
      return value;
    } else {
      return defaultValue;
    }
  }
  var ProgressBar = class _ProgressBar {
    static get defaultCSS() {
      return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${_ProgressBar.animationDuration}ms ease-out,
          opacity ${_ProgressBar.animationDuration / 2}ms ${_ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
    }
    constructor() {
      this.hiding = false;
      this.value = 0;
      this.visible = false;
      this.trickle = () => {
        this.setValue(this.value + Math.random() / 100);
      };
      this.stylesheetElement = this.createStylesheetElement();
      this.progressElement = this.createProgressElement();
      this.installStylesheetElement();
      this.setValue(0);
    }
    show() {
      if (!this.visible) {
        this.visible = true;
        this.installProgressElement();
        this.startTrickling();
      }
    }
    hide() {
      if (this.visible && !this.hiding) {
        this.hiding = true;
        this.fadeProgressElement(() => {
          this.uninstallProgressElement();
          this.stopTrickling();
          this.visible = false;
          this.hiding = false;
        });
      }
    }
    setValue(value) {
      this.value = value;
      this.refresh();
    }
    installStylesheetElement() {
      document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
    }
    installProgressElement() {
      this.progressElement.style.width = "0";
      this.progressElement.style.opacity = "1";
      document.documentElement.insertBefore(this.progressElement, document.body);
      this.refresh();
    }
    fadeProgressElement(callback) {
      this.progressElement.style.opacity = "0";
      setTimeout(callback, _ProgressBar.animationDuration * 1.5);
    }
    uninstallProgressElement() {
      if (this.progressElement.parentNode) {
        document.documentElement.removeChild(this.progressElement);
      }
    }
    startTrickling() {
      if (!this.trickleInterval) {
        this.trickleInterval = window.setInterval(this.trickle, _ProgressBar.animationDuration);
      }
    }
    stopTrickling() {
      window.clearInterval(this.trickleInterval);
      delete this.trickleInterval;
    }
    refresh() {
      requestAnimationFrame(() => {
        this.progressElement.style.width = `${10 + this.value * 90}%`;
      });
    }
    createStylesheetElement() {
      const element = document.createElement("style");
      element.type = "text/css";
      element.textContent = _ProgressBar.defaultCSS;
      if (this.cspNonce) {
        element.nonce = this.cspNonce;
      }
      return element;
    }
    createProgressElement() {
      const element = document.createElement("div");
      element.className = "turbo-progress-bar";
      return element;
    }
    get cspNonce() {
      return getMetaContent("csp-nonce");
    }
  };
  ProgressBar.animationDuration = 300;
  var HeadSnapshot = class extends Snapshot {
    constructor() {
      super(...arguments);
      this.detailsByOuterHTML = this.children.filter((element) => !elementIsNoscript(element)).map((element) => elementWithoutNonce(element)).reduce((result, element) => {
        const { outerHTML } = element;
        const details = outerHTML in result ? result[outerHTML] : {
          type: elementType(element),
          tracked: elementIsTracked(element),
          elements: []
        };
        return Object.assign(Object.assign({}, result), { [outerHTML]: Object.assign(Object.assign({}, details), { elements: [...details.elements, element] }) });
      }, {});
    }
    get trackedElementSignature() {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked).join("");
    }
    getScriptElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
    }
    getStylesheetElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
    }
    getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML)).map((outerHTML) => this.detailsByOuterHTML[outerHTML]).filter(({ type }) => type == matchedType).map(({ elements: [element] }) => element);
    }
    get provisionalElements() {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const { type, tracked, elements } = this.detailsByOuterHTML[outerHTML];
        if (type == null && !tracked) {
          return [...result, ...elements];
        } else if (elements.length > 1) {
          return [...result, ...elements.slice(1)];
        } else {
          return result;
        }
      }, []);
    }
    getMetaValue(name) {
      const element = this.findMetaElementByName(name);
      return element ? element.getAttribute("content") : null;
    }
    findMetaElementByName(name) {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const { elements: [element] } = this.detailsByOuterHTML[outerHTML];
        return elementIsMetaElementWithName(element, name) ? element : result;
      }, void 0);
    }
  };
  function elementType(element) {
    if (elementIsScript(element)) {
      return "script";
    } else if (elementIsStylesheet(element)) {
      return "stylesheet";
    }
  }
  function elementIsTracked(element) {
    return element.getAttribute("data-turbo-track") == "reload";
  }
  function elementIsScript(element) {
    const tagName = element.localName;
    return tagName == "script";
  }
  function elementIsNoscript(element) {
    const tagName = element.localName;
    return tagName == "noscript";
  }
  function elementIsStylesheet(element) {
    const tagName = element.localName;
    return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
  }
  function elementIsMetaElementWithName(element, name) {
    const tagName = element.localName;
    return tagName == "meta" && element.getAttribute("name") == name;
  }
  function elementWithoutNonce(element) {
    if (element.hasAttribute("nonce")) {
      element.setAttribute("nonce", "");
    }
    return element;
  }
  var PageSnapshot = class _PageSnapshot extends Snapshot {
    static fromHTMLString(html = "") {
      return this.fromDocument(parseHTMLDocument(html));
    }
    static fromElement(element) {
      return this.fromDocument(element.ownerDocument);
    }
    static fromDocument({ head, body }) {
      return new this(body, new HeadSnapshot(head));
    }
    constructor(element, headSnapshot) {
      super(element);
      this.headSnapshot = headSnapshot;
    }
    clone() {
      const clonedElement = this.element.cloneNode(true);
      const selectElements = this.element.querySelectorAll("select");
      const clonedSelectElements = clonedElement.querySelectorAll("select");
      for (const [index, source] of selectElements.entries()) {
        const clone = clonedSelectElements[index];
        for (const option of clone.selectedOptions)
          option.selected = false;
        for (const option of source.selectedOptions)
          clone.options[option.index].selected = true;
      }
      for (const clonedPasswordInput of clonedElement.querySelectorAll('input[type="password"]')) {
        clonedPasswordInput.value = "";
      }
      return new _PageSnapshot(clonedElement, this.headSnapshot);
    }
    get headElement() {
      return this.headSnapshot.element;
    }
    get rootLocation() {
      var _a;
      const root = (_a = this.getSetting("root")) !== null && _a !== void 0 ? _a : "/";
      return expandURL(root);
    }
    get cacheControlValue() {
      return this.getSetting("cache-control");
    }
    get isPreviewable() {
      return this.cacheControlValue != "no-preview";
    }
    get isCacheable() {
      return this.cacheControlValue != "no-cache";
    }
    get isVisitable() {
      return this.getSetting("visit-control") != "reload";
    }
    getSetting(name) {
      return this.headSnapshot.getMetaValue(`turbo-${name}`);
    }
  };
  var TimingMetric;
  (function(TimingMetric2) {
    TimingMetric2["visitStart"] = "visitStart";
    TimingMetric2["requestStart"] = "requestStart";
    TimingMetric2["requestEnd"] = "requestEnd";
    TimingMetric2["visitEnd"] = "visitEnd";
  })(TimingMetric || (TimingMetric = {}));
  var VisitState;
  (function(VisitState2) {
    VisitState2["initialized"] = "initialized";
    VisitState2["started"] = "started";
    VisitState2["canceled"] = "canceled";
    VisitState2["failed"] = "failed";
    VisitState2["completed"] = "completed";
  })(VisitState || (VisitState = {}));
  var defaultOptions = {
    action: "advance",
    historyChanged: false,
    visitCachedSnapshot: () => {
    },
    willRender: true,
    updateHistory: true,
    shouldCacheSnapshot: true,
    acceptsStreamResponse: false
  };
  var SystemStatusCode;
  (function(SystemStatusCode2) {
    SystemStatusCode2[SystemStatusCode2["networkFailure"] = 0] = "networkFailure";
    SystemStatusCode2[SystemStatusCode2["timeoutFailure"] = -1] = "timeoutFailure";
    SystemStatusCode2[SystemStatusCode2["contentTypeMismatch"] = -2] = "contentTypeMismatch";
  })(SystemStatusCode || (SystemStatusCode = {}));
  var Visit = class {
    constructor(delegate, location2, restorationIdentifier, options = {}) {
      this.identifier = uuid();
      this.timingMetrics = {};
      this.followedRedirect = false;
      this.historyChanged = false;
      this.scrolled = false;
      this.shouldCacheSnapshot = true;
      this.acceptsStreamResponse = false;
      this.snapshotCached = false;
      this.state = VisitState.initialized;
      this.delegate = delegate;
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier || uuid();
      const { action, historyChanged, referrer, snapshot, snapshotHTML, response, visitCachedSnapshot, willRender, updateHistory, shouldCacheSnapshot, acceptsStreamResponse } = Object.assign(Object.assign({}, defaultOptions), options);
      this.action = action;
      this.historyChanged = historyChanged;
      this.referrer = referrer;
      this.snapshot = snapshot;
      this.snapshotHTML = snapshotHTML;
      this.response = response;
      this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
      this.visitCachedSnapshot = visitCachedSnapshot;
      this.willRender = willRender;
      this.updateHistory = updateHistory;
      this.scrolled = !willRender;
      this.shouldCacheSnapshot = shouldCacheSnapshot;
      this.acceptsStreamResponse = acceptsStreamResponse;
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    get restorationData() {
      return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
    }
    get silent() {
      return this.isSamePage;
    }
    start() {
      if (this.state == VisitState.initialized) {
        this.recordTimingMetric(TimingMetric.visitStart);
        this.state = VisitState.started;
        this.adapter.visitStarted(this);
        this.delegate.visitStarted(this);
      }
    }
    cancel() {
      if (this.state == VisitState.started) {
        if (this.request) {
          this.request.cancel();
        }
        this.cancelRender();
        this.state = VisitState.canceled;
      }
    }
    complete() {
      if (this.state == VisitState.started) {
        this.recordTimingMetric(TimingMetric.visitEnd);
        this.state = VisitState.completed;
        this.followRedirect();
        if (!this.followedRedirect) {
          this.adapter.visitCompleted(this);
          this.delegate.visitCompleted(this);
        }
      }
    }
    fail() {
      if (this.state == VisitState.started) {
        this.state = VisitState.failed;
        this.adapter.visitFailed(this);
      }
    }
    changeHistory() {
      var _a;
      if (!this.historyChanged && this.updateHistory) {
        const actionForHistory = this.location.href === ((_a = this.referrer) === null || _a === void 0 ? void 0 : _a.href) ? "replace" : this.action;
        const method = getHistoryMethodForAction(actionForHistory);
        this.history.update(method, this.location, this.restorationIdentifier);
        this.historyChanged = true;
      }
    }
    issueRequest() {
      if (this.hasPreloadedResponse()) {
        this.simulateRequest();
      } else if (this.shouldIssueRequest() && !this.request) {
        this.request = new FetchRequest(this, FetchMethod.get, this.location);
        this.request.perform();
      }
    }
    simulateRequest() {
      if (this.response) {
        this.startRequest();
        this.recordResponse();
        this.finishRequest();
      }
    }
    startRequest() {
      this.recordTimingMetric(TimingMetric.requestStart);
      this.adapter.visitRequestStarted(this);
    }
    recordResponse(response = this.response) {
      this.response = response;
      if (response) {
        const { statusCode } = response;
        if (isSuccessful(statusCode)) {
          this.adapter.visitRequestCompleted(this);
        } else {
          this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
        }
      }
    }
    finishRequest() {
      this.recordTimingMetric(TimingMetric.requestEnd);
      this.adapter.visitRequestFinished(this);
    }
    loadResponse() {
      if (this.response) {
        const { statusCode, responseHTML } = this.response;
        this.render(async () => {
          if (this.shouldCacheSnapshot)
            this.cacheSnapshot();
          if (this.view.renderPromise)
            await this.view.renderPromise;
          if (isSuccessful(statusCode) && responseHTML != null) {
            await this.view.renderPage(PageSnapshot.fromHTMLString(responseHTML), false, this.willRender, this);
            this.performScroll();
            this.adapter.visitRendered(this);
            this.complete();
          } else {
            await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML), this);
            this.adapter.visitRendered(this);
            this.fail();
          }
        });
      }
    }
    getCachedSnapshot() {
      const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
      if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
        if (this.action == "restore" || snapshot.isPreviewable) {
          return snapshot;
        }
      }
    }
    getPreloadedSnapshot() {
      if (this.snapshotHTML) {
        return PageSnapshot.fromHTMLString(this.snapshotHTML);
      }
    }
    hasCachedSnapshot() {
      return this.getCachedSnapshot() != null;
    }
    loadCachedSnapshot() {
      const snapshot = this.getCachedSnapshot();
      if (snapshot) {
        const isPreview = this.shouldIssueRequest();
        this.render(async () => {
          this.cacheSnapshot();
          if (this.isSamePage) {
            this.adapter.visitRendered(this);
          } else {
            if (this.view.renderPromise)
              await this.view.renderPromise;
            await this.view.renderPage(snapshot, isPreview, this.willRender, this);
            this.performScroll();
            this.adapter.visitRendered(this);
            if (!isPreview) {
              this.complete();
            }
          }
        });
      }
    }
    followRedirect() {
      var _a;
      if (this.redirectedToLocation && !this.followedRedirect && ((_a = this.response) === null || _a === void 0 ? void 0 : _a.redirected)) {
        this.adapter.visitProposedToLocation(this.redirectedToLocation, {
          action: "replace",
          response: this.response,
          shouldCacheSnapshot: false,
          willRender: false
        });
        this.followedRedirect = true;
      }
    }
    goToSamePageAnchor() {
      if (this.isSamePage) {
        this.render(async () => {
          this.cacheSnapshot();
          this.performScroll();
          this.changeHistory();
          this.adapter.visitRendered(this);
        });
      }
    }
    prepareRequest(request) {
      if (this.acceptsStreamResponse) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted() {
      this.startRequest();
    }
    requestPreventedHandlingResponse(_request, _response) {
    }
    async requestSucceededWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.redirectedToLocation = response.redirected ? response.location : void 0;
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    async requestFailedWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    requestErrored(_request, _error) {
      this.recordResponse({
        statusCode: SystemStatusCode.networkFailure,
        redirected: false
      });
    }
    requestFinished() {
      this.finishRequest();
    }
    performScroll() {
      if (!this.scrolled && !this.view.forceReloaded) {
        if (this.action == "restore") {
          this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
        } else {
          this.scrollToAnchor() || this.view.scrollToTop();
        }
        if (this.isSamePage) {
          this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
        }
        this.scrolled = true;
      }
    }
    scrollToRestoredPosition() {
      const { scrollPosition } = this.restorationData;
      if (scrollPosition) {
        this.view.scrollToPosition(scrollPosition);
        return true;
      }
    }
    scrollToAnchor() {
      const anchor = getAnchor(this.location);
      if (anchor != null) {
        this.view.scrollToAnchor(anchor);
        return true;
      }
    }
    recordTimingMetric(metric) {
      this.timingMetrics[metric] = (/* @__PURE__ */ new Date()).getTime();
    }
    getTimingMetrics() {
      return Object.assign({}, this.timingMetrics);
    }
    getHistoryMethodForAction(action) {
      switch (action) {
        case "replace":
          return history.replaceState;
        case "advance":
        case "restore":
          return history.pushState;
      }
    }
    hasPreloadedResponse() {
      return typeof this.response == "object";
    }
    shouldIssueRequest() {
      if (this.isSamePage) {
        return false;
      } else if (this.action == "restore") {
        return !this.hasCachedSnapshot();
      } else {
        return this.willRender;
      }
    }
    cacheSnapshot() {
      if (!this.snapshotCached) {
        this.view.cacheSnapshot(this.snapshot).then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));
        this.snapshotCached = true;
      }
    }
    async render(callback) {
      this.cancelRender();
      await new Promise((resolve) => {
        this.frame = requestAnimationFrame(() => resolve());
      });
      await callback();
      delete this.frame;
    }
    cancelRender() {
      if (this.frame) {
        cancelAnimationFrame(this.frame);
        delete this.frame;
      }
    }
  };
  function isSuccessful(statusCode) {
    return statusCode >= 200 && statusCode < 300;
  }
  var BrowserAdapter = class {
    constructor(session2) {
      this.progressBar = new ProgressBar();
      this.showProgressBar = () => {
        this.progressBar.show();
      };
      this.session = session2;
    }
    visitProposedToLocation(location2, options) {
      this.navigator.startVisit(location2, (options === null || options === void 0 ? void 0 : options.restorationIdentifier) || uuid(), options);
    }
    visitStarted(visit2) {
      this.location = visit2.location;
      visit2.loadCachedSnapshot();
      visit2.issueRequest();
      visit2.goToSamePageAnchor();
    }
    visitRequestStarted(visit2) {
      this.progressBar.setValue(0);
      if (visit2.hasCachedSnapshot() || visit2.action != "restore") {
        this.showVisitProgressBarAfterDelay();
      } else {
        this.showProgressBar();
      }
    }
    visitRequestCompleted(visit2) {
      visit2.loadResponse();
    }
    visitRequestFailedWithStatusCode(visit2, statusCode) {
      switch (statusCode) {
        case SystemStatusCode.networkFailure:
        case SystemStatusCode.timeoutFailure:
        case SystemStatusCode.contentTypeMismatch:
          return this.reload({
            reason: "request_failed",
            context: {
              statusCode
            }
          });
        default:
          return visit2.loadResponse();
      }
    }
    visitRequestFinished(_visit) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    visitCompleted(_visit) {
    }
    pageInvalidated(reason) {
      this.reload(reason);
    }
    visitFailed(_visit) {
    }
    visitRendered(_visit) {
    }
    formSubmissionStarted(_formSubmission) {
      this.progressBar.setValue(0);
      this.showFormProgressBarAfterDelay();
    }
    formSubmissionFinished(_formSubmission) {
      this.progressBar.setValue(1);
      this.hideFormProgressBar();
    }
    showVisitProgressBarAfterDelay() {
      this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
    hideVisitProgressBar() {
      this.progressBar.hide();
      if (this.visitProgressBarTimeout != null) {
        window.clearTimeout(this.visitProgressBarTimeout);
        delete this.visitProgressBarTimeout;
      }
    }
    showFormProgressBarAfterDelay() {
      if (this.formProgressBarTimeout == null) {
        this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
      }
    }
    hideFormProgressBar() {
      this.progressBar.hide();
      if (this.formProgressBarTimeout != null) {
        window.clearTimeout(this.formProgressBarTimeout);
        delete this.formProgressBarTimeout;
      }
    }
    reload(reason) {
      var _a;
      dispatch("turbo:reload", { detail: reason });
      window.location.href = ((_a = this.location) === null || _a === void 0 ? void 0 : _a.toString()) || window.location.href;
    }
    get navigator() {
      return this.session.navigator;
    }
  };
  var CacheObserver = class {
    constructor() {
      this.selector = "[data-turbo-temporary]";
      this.deprecatedSelector = "[data-turbo-cache=false]";
      this.started = false;
      this.removeTemporaryElements = (_event) => {
        for (const element of this.temporaryElements) {
          element.remove();
        }
      };
    }
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    get temporaryElements() {
      return [...document.querySelectorAll(this.selector), ...this.temporaryElementsWithDeprecation];
    }
    get temporaryElementsWithDeprecation() {
      const elements = document.querySelectorAll(this.deprecatedSelector);
      if (elements.length) {
        console.warn(`The ${this.deprecatedSelector} selector is deprecated and will be removed in a future version. Use ${this.selector} instead.`);
      }
      return [...elements];
    }
  };
  var FrameRedirector = class {
    constructor(session2, element) {
      this.session = session2;
      this.element = element;
      this.linkInterceptor = new LinkInterceptor(this, element);
      this.formSubmitObserver = new FormSubmitObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
      this.formSubmitObserver.start();
    }
    stop() {
      this.linkInterceptor.stop();
      this.formSubmitObserver.stop();
    }
    shouldInterceptLinkClick(element, _location, _event) {
      return this.shouldRedirect(element);
    }
    linkClickIntercepted(element, url, event) {
      const frame = this.findFrameElement(element);
      if (frame) {
        frame.delegate.linkClickIntercepted(element, url, event);
      }
    }
    willSubmitForm(element, submitter) {
      return element.closest("turbo-frame") == null && this.shouldSubmit(element, submitter) && this.shouldRedirect(element, submitter);
    }
    formSubmitted(element, submitter) {
      const frame = this.findFrameElement(element, submitter);
      if (frame) {
        frame.delegate.formSubmitted(element, submitter);
      }
    }
    shouldSubmit(form, submitter) {
      var _a;
      const action = getAction(form, submitter);
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const rootLocation = expandURL((_a = meta === null || meta === void 0 ? void 0 : meta.content) !== null && _a !== void 0 ? _a : "/");
      return this.shouldRedirect(form, submitter) && locationIsVisitable(action, rootLocation);
    }
    shouldRedirect(element, submitter) {
      const isNavigatable = element instanceof HTMLFormElement ? this.session.submissionIsNavigatable(element, submitter) : this.session.elementIsNavigatable(element);
      if (isNavigatable) {
        const frame = this.findFrameElement(element, submitter);
        return frame ? frame != element.closest("turbo-frame") : false;
      } else {
        return false;
      }
    }
    findFrameElement(element, submitter) {
      const id = (submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute("data-turbo-frame")) || element.getAttribute("data-turbo-frame");
      if (id && id != "_top") {
        const frame = this.element.querySelector(`#${id}:not([disabled])`);
        if (frame instanceof FrameElement) {
          return frame;
        }
      }
    }
  };
  var History = class {
    constructor(delegate) {
      this.restorationIdentifier = uuid();
      this.restorationData = {};
      this.started = false;
      this.pageLoaded = false;
      this.onPopState = (event) => {
        if (this.shouldHandlePopState()) {
          const { turbo } = event.state || {};
          if (turbo) {
            this.location = new URL(window.location.href);
            const { restorationIdentifier } = turbo;
            this.restorationIdentifier = restorationIdentifier;
            this.delegate.historyPoppedToLocationWithRestorationIdentifier(this.location, restorationIdentifier);
          }
        }
      };
      this.onPageLoad = async (_event) => {
        await nextMicrotask();
        this.pageLoaded = true;
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("popstate", this.onPopState, false);
        addEventListener("load", this.onPageLoad, false);
        this.started = true;
        this.replace(new URL(window.location.href));
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("popstate", this.onPopState, false);
        removeEventListener("load", this.onPageLoad, false);
        this.started = false;
      }
    }
    push(location2, restorationIdentifier) {
      this.update(history.pushState, location2, restorationIdentifier);
    }
    replace(location2, restorationIdentifier) {
      this.update(history.replaceState, location2, restorationIdentifier);
    }
    update(method, location2, restorationIdentifier = uuid()) {
      const state = { turbo: { restorationIdentifier } };
      method.call(history, state, "", location2.href);
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier;
    }
    getRestorationDataForIdentifier(restorationIdentifier) {
      return this.restorationData[restorationIdentifier] || {};
    }
    updateRestorationData(additionalData) {
      const { restorationIdentifier } = this;
      const restorationData = this.restorationData[restorationIdentifier];
      this.restorationData[restorationIdentifier] = Object.assign(Object.assign({}, restorationData), additionalData);
    }
    assumeControlOfScrollRestoration() {
      var _a;
      if (!this.previousScrollRestoration) {
        this.previousScrollRestoration = (_a = history.scrollRestoration) !== null && _a !== void 0 ? _a : "auto";
        history.scrollRestoration = "manual";
      }
    }
    relinquishControlOfScrollRestoration() {
      if (this.previousScrollRestoration) {
        history.scrollRestoration = this.previousScrollRestoration;
        delete this.previousScrollRestoration;
      }
    }
    shouldHandlePopState() {
      return this.pageIsLoaded();
    }
    pageIsLoaded() {
      return this.pageLoaded || document.readyState == "complete";
    }
  };
  var Navigator = class {
    constructor(delegate) {
      this.delegate = delegate;
    }
    proposeVisit(location2, options = {}) {
      if (this.delegate.allowsVisitingLocationWithAction(location2, options.action)) {
        if (locationIsVisitable(location2, this.view.snapshot.rootLocation)) {
          this.delegate.visitProposedToLocation(location2, options);
        } else {
          window.location.href = location2.toString();
        }
      }
    }
    startVisit(locatable, restorationIdentifier, options = {}) {
      this.stop();
      this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, Object.assign({ referrer: this.location }, options));
      this.currentVisit.start();
    }
    submitForm(form, submitter) {
      this.stop();
      this.formSubmission = new FormSubmission(this, form, submitter, true);
      this.formSubmission.start();
    }
    stop() {
      if (this.formSubmission) {
        this.formSubmission.stop();
        delete this.formSubmission;
      }
      if (this.currentVisit) {
        this.currentVisit.cancel();
        delete this.currentVisit;
      }
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    formSubmissionStarted(formSubmission) {
      if (typeof this.adapter.formSubmissionStarted === "function") {
        this.adapter.formSubmissionStarted(formSubmission);
      }
    }
    async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
      if (formSubmission == this.formSubmission) {
        const responseHTML = await fetchResponse.responseHTML;
        if (responseHTML) {
          const shouldCacheSnapshot = formSubmission.isSafe;
          if (!shouldCacheSnapshot) {
            this.view.clearSnapshotCache();
          }
          const { statusCode, redirected } = fetchResponse;
          const action = this.getActionForFormSubmission(formSubmission);
          const visitOptions = {
            action,
            shouldCacheSnapshot,
            response: { statusCode, responseHTML, redirected }
          };
          this.proposeVisit(fetchResponse.location, visitOptions);
        }
      }
    }
    async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        if (fetchResponse.serverError) {
          await this.view.renderError(snapshot, this.currentVisit);
        } else {
          await this.view.renderPage(snapshot, false, true, this.currentVisit);
        }
        this.view.scrollToTop();
        this.view.clearSnapshotCache();
      }
    }
    formSubmissionErrored(formSubmission, error2) {
      console.error(error2);
    }
    formSubmissionFinished(formSubmission) {
      if (typeof this.adapter.formSubmissionFinished === "function") {
        this.adapter.formSubmissionFinished(formSubmission);
      }
    }
    visitStarted(visit2) {
      this.delegate.visitStarted(visit2);
    }
    visitCompleted(visit2) {
      this.delegate.visitCompleted(visit2);
    }
    locationWithActionIsSamePage(location2, action) {
      const anchor = getAnchor(location2);
      const currentAnchor = getAnchor(this.view.lastRenderedLocation);
      const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
      return action !== "replace" && getRequestURL(location2) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    getActionForFormSubmission({ submitter, formElement }) {
      return getVisitAction(submitter, formElement) || "advance";
    }
  };
  var PageStage;
  (function(PageStage2) {
    PageStage2[PageStage2["initial"] = 0] = "initial";
    PageStage2[PageStage2["loading"] = 1] = "loading";
    PageStage2[PageStage2["interactive"] = 2] = "interactive";
    PageStage2[PageStage2["complete"] = 3] = "complete";
  })(PageStage || (PageStage = {}));
  var PageObserver = class {
    constructor(delegate) {
      this.stage = PageStage.initial;
      this.started = false;
      this.interpretReadyState = () => {
        const { readyState } = this;
        if (readyState == "interactive") {
          this.pageIsInteractive();
        } else if (readyState == "complete") {
          this.pageIsComplete();
        }
      };
      this.pageWillUnload = () => {
        this.delegate.pageWillUnload();
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        if (this.stage == PageStage.initial) {
          this.stage = PageStage.loading;
        }
        document.addEventListener("readystatechange", this.interpretReadyState, false);
        addEventListener("pagehide", this.pageWillUnload, false);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        document.removeEventListener("readystatechange", this.interpretReadyState, false);
        removeEventListener("pagehide", this.pageWillUnload, false);
        this.started = false;
      }
    }
    pageIsInteractive() {
      if (this.stage == PageStage.loading) {
        this.stage = PageStage.interactive;
        this.delegate.pageBecameInteractive();
      }
    }
    pageIsComplete() {
      this.pageIsInteractive();
      if (this.stage == PageStage.interactive) {
        this.stage = PageStage.complete;
        this.delegate.pageLoaded();
      }
    }
    get readyState() {
      return document.readyState;
    }
  };
  var ScrollObserver = class {
    constructor(delegate) {
      this.started = false;
      this.onScroll = () => {
        this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("scroll", this.onScroll, false);
        this.onScroll();
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("scroll", this.onScroll, false);
        this.started = false;
      }
    }
    updatePosition(position) {
      this.delegate.scrollPositionChanged(position);
    }
  };
  var StreamMessageRenderer = class {
    render({ fragment }) {
      Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), () => document.documentElement.appendChild(fragment));
    }
    enteringBardo(currentPermanentElement, newPermanentElement) {
      newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));
    }
    leavingBardo() {
    }
  };
  function getPermanentElementMapForFragment(fragment) {
    const permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);
    const permanentElementMap = {};
    for (const permanentElementInDocument of permanentElementsInDocument) {
      const { id } = permanentElementInDocument;
      for (const streamElement of fragment.querySelectorAll("turbo-stream")) {
        const elementInStream = getPermanentElementById(streamElement.templateElement.content, id);
        if (elementInStream) {
          permanentElementMap[id] = [permanentElementInDocument, elementInStream];
        }
      }
    }
    return permanentElementMap;
  }
  var StreamObserver = class {
    constructor(delegate) {
      this.sources = /* @__PURE__ */ new Set();
      this.started = false;
      this.inspectFetchResponse = (event) => {
        const response = fetchResponseFromEvent(event);
        if (response && fetchResponseIsStream(response)) {
          event.preventDefault();
          this.receiveMessageResponse(response);
        }
      };
      this.receiveMessageEvent = (event) => {
        if (this.started && typeof event.data == "string") {
          this.receiveMessageHTML(event.data);
        }
      };
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    connectStreamSource(source) {
      if (!this.streamSourceIsConnected(source)) {
        this.sources.add(source);
        source.addEventListener("message", this.receiveMessageEvent, false);
      }
    }
    disconnectStreamSource(source) {
      if (this.streamSourceIsConnected(source)) {
        this.sources.delete(source);
        source.removeEventListener("message", this.receiveMessageEvent, false);
      }
    }
    streamSourceIsConnected(source) {
      return this.sources.has(source);
    }
    async receiveMessageResponse(response) {
      const html = await response.responseHTML;
      if (html) {
        this.receiveMessageHTML(html);
      }
    }
    receiveMessageHTML(html) {
      this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));
    }
  };
  function fetchResponseFromEvent(event) {
    var _a;
    const fetchResponse = (_a = event.detail) === null || _a === void 0 ? void 0 : _a.fetchResponse;
    if (fetchResponse instanceof FetchResponse) {
      return fetchResponse;
    }
  }
  function fetchResponseIsStream(response) {
    var _a;
    const contentType = (_a = response.contentType) !== null && _a !== void 0 ? _a : "";
    return contentType.startsWith(StreamMessage.contentType);
  }
  var ErrorRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      const { documentElement, body } = document;
      documentElement.replaceChild(newElement, body);
    }
    async render() {
      this.replaceHeadAndBody();
      this.activateScriptElements();
    }
    replaceHeadAndBody() {
      const { documentElement, head } = document;
      documentElement.replaceChild(this.newHead, head);
      this.renderElement(this.currentElement, this.newElement);
    }
    activateScriptElements() {
      for (const replaceableElement of this.scriptElements) {
        const parentNode = replaceableElement.parentNode;
        if (parentNode) {
          const element = activateScriptElement(replaceableElement);
          parentNode.replaceChild(element, replaceableElement);
        }
      }
    }
    get newHead() {
      return this.newSnapshot.headSnapshot.element;
    }
    get scriptElements() {
      return document.documentElement.querySelectorAll("script");
    }
  };
  var PageRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      if (document.body && newElement instanceof HTMLBodyElement) {
        document.body.replaceWith(newElement);
      } else {
        document.documentElement.appendChild(newElement);
      }
    }
    get shouldRender() {
      return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
    }
    get reloadReason() {
      if (!this.newSnapshot.isVisitable) {
        return {
          reason: "turbo_visit_control_is_reload"
        };
      }
      if (!this.trackedElementsAreIdentical) {
        return {
          reason: "tracked_element_mismatch"
        };
      }
    }
    async prepareToRender() {
      await this.mergeHead();
    }
    async render() {
      if (this.willRender) {
        await this.replaceBody();
      }
    }
    finishRendering() {
      super.finishRendering();
      if (!this.isPreview) {
        this.focusFirstAutofocusableElement();
      }
    }
    get currentHeadSnapshot() {
      return this.currentSnapshot.headSnapshot;
    }
    get newHeadSnapshot() {
      return this.newSnapshot.headSnapshot;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    async mergeHead() {
      const mergedHeadElements = this.mergeProvisionalElements();
      const newStylesheetElements = this.copyNewHeadStylesheetElements();
      this.copyNewHeadScriptElements();
      await mergedHeadElements;
      await newStylesheetElements;
    }
    async replaceBody() {
      await this.preservingPermanentElements(async () => {
        this.activateNewBody();
        await this.assignNewBody();
      });
    }
    get trackedElementsAreIdentical() {
      return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
    }
    async copyNewHeadStylesheetElements() {
      const loadingElements = [];
      for (const element of this.newHeadStylesheetElements) {
        loadingElements.push(waitForLoad(element));
        document.head.appendChild(element);
      }
      await Promise.all(loadingElements);
    }
    copyNewHeadScriptElements() {
      for (const element of this.newHeadScriptElements) {
        document.head.appendChild(activateScriptElement(element));
      }
    }
    async mergeProvisionalElements() {
      const newHeadElements = [...this.newHeadProvisionalElements];
      for (const element of this.currentHeadProvisionalElements) {
        if (!this.isCurrentElementInElementList(element, newHeadElements)) {
          document.head.removeChild(element);
        }
      }
      for (const element of newHeadElements) {
        document.head.appendChild(element);
      }
    }
    isCurrentElementInElementList(element, elementList) {
      for (const [index, newElement] of elementList.entries()) {
        if (element.tagName == "TITLE") {
          if (newElement.tagName != "TITLE") {
            continue;
          }
          if (element.innerHTML == newElement.innerHTML) {
            elementList.splice(index, 1);
            return true;
          }
        }
        if (newElement.isEqualNode(element)) {
          elementList.splice(index, 1);
          return true;
        }
      }
      return false;
    }
    removeCurrentHeadProvisionalElements() {
      for (const element of this.currentHeadProvisionalElements) {
        document.head.removeChild(element);
      }
    }
    copyNewHeadProvisionalElements() {
      for (const element of this.newHeadProvisionalElements) {
        document.head.appendChild(element);
      }
    }
    activateNewBody() {
      document.adoptNode(this.newElement);
      this.activateNewBodyScriptElements();
    }
    activateNewBodyScriptElements() {
      for (const inertScriptElement of this.newBodyScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    async assignNewBody() {
      await this.renderElement(this.currentElement, this.newElement);
    }
    get newHeadStylesheetElements() {
      return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get newHeadScriptElements() {
      return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get currentHeadProvisionalElements() {
      return this.currentHeadSnapshot.provisionalElements;
    }
    get newHeadProvisionalElements() {
      return this.newHeadSnapshot.provisionalElements;
    }
    get newBodyScriptElements() {
      return this.newElement.querySelectorAll("script");
    }
  };
  var SnapshotCache = class {
    constructor(size) {
      this.keys = [];
      this.snapshots = {};
      this.size = size;
    }
    has(location2) {
      return toCacheKey(location2) in this.snapshots;
    }
    get(location2) {
      if (this.has(location2)) {
        const snapshot = this.read(location2);
        this.touch(location2);
        return snapshot;
      }
    }
    put(location2, snapshot) {
      this.write(location2, snapshot);
      this.touch(location2);
      return snapshot;
    }
    clear() {
      this.snapshots = {};
    }
    read(location2) {
      return this.snapshots[toCacheKey(location2)];
    }
    write(location2, snapshot) {
      this.snapshots[toCacheKey(location2)] = snapshot;
    }
    touch(location2) {
      const key = toCacheKey(location2);
      const index = this.keys.indexOf(key);
      if (index > -1)
        this.keys.splice(index, 1);
      this.keys.unshift(key);
      this.trim();
    }
    trim() {
      for (const key of this.keys.splice(this.size)) {
        delete this.snapshots[key];
      }
    }
  };
  var PageView = class extends View {
    constructor() {
      super(...arguments);
      this.snapshotCache = new SnapshotCache(10);
      this.lastRenderedLocation = new URL(location.href);
      this.forceReloaded = false;
    }
    renderPage(snapshot, isPreview = false, willRender = true, visit2) {
      const renderer = new PageRenderer(this.snapshot, snapshot, PageRenderer.renderElement, isPreview, willRender);
      if (!renderer.shouldRender) {
        this.forceReloaded = true;
      } else {
        visit2 === null || visit2 === void 0 ? void 0 : visit2.changeHistory();
      }
      return this.render(renderer);
    }
    renderError(snapshot, visit2) {
      visit2 === null || visit2 === void 0 ? void 0 : visit2.changeHistory();
      const renderer = new ErrorRenderer(this.snapshot, snapshot, ErrorRenderer.renderElement, false);
      return this.render(renderer);
    }
    clearSnapshotCache() {
      this.snapshotCache.clear();
    }
    async cacheSnapshot(snapshot = this.snapshot) {
      if (snapshot.isCacheable) {
        this.delegate.viewWillCacheSnapshot();
        const { lastRenderedLocation: location2 } = this;
        await nextEventLoopTick();
        const cachedSnapshot = snapshot.clone();
        this.snapshotCache.put(location2, cachedSnapshot);
        return cachedSnapshot;
      }
    }
    getCachedSnapshotForLocation(location2) {
      return this.snapshotCache.get(location2);
    }
    get snapshot() {
      return PageSnapshot.fromElement(this.element);
    }
  };
  var Preloader = class {
    constructor(delegate) {
      this.selector = "a[data-turbo-preload]";
      this.delegate = delegate;
    }
    get snapshotCache() {
      return this.delegate.navigator.view.snapshotCache;
    }
    start() {
      if (document.readyState === "loading") {
        return document.addEventListener("DOMContentLoaded", () => {
          this.preloadOnLoadLinksForView(document.body);
        });
      } else {
        this.preloadOnLoadLinksForView(document.body);
      }
    }
    preloadOnLoadLinksForView(element) {
      for (const link of element.querySelectorAll(this.selector)) {
        this.preloadURL(link);
      }
    }
    async preloadURL(link) {
      const location2 = new URL(link.href);
      if (this.snapshotCache.has(location2)) {
        return;
      }
      try {
        const response = await fetch(location2.toString(), { headers: { "VND.PREFETCH": "true", Accept: "text/html" } });
        const responseText = await response.text();
        const snapshot = PageSnapshot.fromHTMLString(responseText);
        this.snapshotCache.put(location2, snapshot);
      } catch (_2) {
      }
    }
  };
  var Session = class {
    constructor() {
      this.navigator = new Navigator(this);
      this.history = new History(this);
      this.preloader = new Preloader(this);
      this.view = new PageView(this, document.documentElement);
      this.adapter = new BrowserAdapter(this);
      this.pageObserver = new PageObserver(this);
      this.cacheObserver = new CacheObserver();
      this.linkClickObserver = new LinkClickObserver(this, window);
      this.formSubmitObserver = new FormSubmitObserver(this, document);
      this.scrollObserver = new ScrollObserver(this);
      this.streamObserver = new StreamObserver(this);
      this.formLinkClickObserver = new FormLinkClickObserver(this, document.documentElement);
      this.frameRedirector = new FrameRedirector(this, document.documentElement);
      this.streamMessageRenderer = new StreamMessageRenderer();
      this.drive = true;
      this.enabled = true;
      this.progressBarDelay = 500;
      this.started = false;
      this.formMode = "on";
    }
    start() {
      if (!this.started) {
        this.pageObserver.start();
        this.cacheObserver.start();
        this.formLinkClickObserver.start();
        this.linkClickObserver.start();
        this.formSubmitObserver.start();
        this.scrollObserver.start();
        this.streamObserver.start();
        this.frameRedirector.start();
        this.history.start();
        this.preloader.start();
        this.started = true;
        this.enabled = true;
      }
    }
    disable() {
      this.enabled = false;
    }
    stop() {
      if (this.started) {
        this.pageObserver.stop();
        this.cacheObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkClickObserver.stop();
        this.formSubmitObserver.stop();
        this.scrollObserver.stop();
        this.streamObserver.stop();
        this.frameRedirector.stop();
        this.history.stop();
        this.started = false;
      }
    }
    registerAdapter(adapter) {
      this.adapter = adapter;
    }
    visit(location2, options = {}) {
      const frameElement = options.frame ? document.getElementById(options.frame) : null;
      if (frameElement instanceof FrameElement) {
        frameElement.src = location2.toString();
        frameElement.loaded;
      } else {
        this.navigator.proposeVisit(expandURL(location2), options);
      }
    }
    connectStreamSource(source) {
      this.streamObserver.connectStreamSource(source);
    }
    disconnectStreamSource(source) {
      this.streamObserver.disconnectStreamSource(source);
    }
    renderStreamMessage(message) {
      this.streamMessageRenderer.render(StreamMessage.wrap(message));
    }
    clearCache() {
      this.view.clearSnapshotCache();
    }
    setProgressBarDelay(delay) {
      this.progressBarDelay = delay;
    }
    setFormMode(mode) {
      this.formMode = mode;
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    historyPoppedToLocationWithRestorationIdentifier(location2, restorationIdentifier) {
      if (this.enabled) {
        this.navigator.startVisit(location2, restorationIdentifier, {
          action: "restore",
          historyChanged: true
        });
      } else {
        this.adapter.pageInvalidated({
          reason: "turbo_disabled"
        });
      }
    }
    scrollPositionChanged(position) {
      this.history.updateRestorationData({ scrollPosition: position });
    }
    willSubmitFormLinkToLocation(link, location2) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
    submittedFormLinkToLocation() {
    }
    willFollowLinkToLocation(link, location2, event) {
      return this.elementIsNavigatable(link) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link, location2, event);
    }
    followedLinkToLocation(link, location2) {
      const action = this.getActionForLink(link);
      const acceptsStreamResponse = link.hasAttribute("data-turbo-stream");
      this.visit(location2.href, { action, acceptsStreamResponse });
    }
    allowsVisitingLocationWithAction(location2, action) {
      return this.locationWithActionIsSamePage(location2, action) || this.applicationAllowsVisitingLocation(location2);
    }
    visitProposedToLocation(location2, options) {
      extendURLWithDeprecatedProperties(location2);
      this.adapter.visitProposedToLocation(location2, options);
    }
    visitStarted(visit2) {
      if (!visit2.acceptsStreamResponse) {
        markAsBusy(document.documentElement);
      }
      extendURLWithDeprecatedProperties(visit2.location);
      if (!visit2.silent) {
        this.notifyApplicationAfterVisitingLocation(visit2.location, visit2.action);
      }
    }
    visitCompleted(visit2) {
      clearBusyState(document.documentElement);
      this.notifyApplicationAfterPageLoad(visit2.getTimingMetrics());
    }
    locationWithActionIsSamePage(location2, action) {
      return this.navigator.locationWithActionIsSamePage(location2, action);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
    }
    willSubmitForm(form, submitter) {
      const action = getAction(form, submitter);
      return this.submissionIsNavigatable(form, submitter) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
    }
    formSubmitted(form, submitter) {
      this.navigator.submitForm(form, submitter);
    }
    pageBecameInteractive() {
      this.view.lastRenderedLocation = this.location;
      this.notifyApplicationAfterPageLoad();
    }
    pageLoaded() {
      this.history.assumeControlOfScrollRestoration();
    }
    pageWillUnload() {
      this.history.relinquishControlOfScrollRestoration();
    }
    receivedMessageFromStream(message) {
      this.renderStreamMessage(message);
    }
    viewWillCacheSnapshot() {
      var _a;
      if (!((_a = this.navigator.currentVisit) === null || _a === void 0 ? void 0 : _a.silent)) {
        this.notifyApplicationBeforeCachingSnapshot();
      }
    }
    allowsImmediateRender({ element }, options) {
      const event = this.notifyApplicationBeforeRender(element, options);
      const { defaultPrevented, detail: { render } } = event;
      if (this.view.renderer && render) {
        this.view.renderer.renderElement = render;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview) {
      this.view.lastRenderedLocation = this.history.location;
      this.notifyApplicationAfterRender();
    }
    preloadOnLoadLinksForView(element) {
      this.preloader.preloadOnLoadLinksForView(element);
    }
    viewInvalidated(reason) {
      this.adapter.pageInvalidated(reason);
    }
    frameLoaded(frame) {
      this.notifyApplicationAfterFrameLoad(frame);
    }
    frameRendered(fetchResponse, frame) {
      this.notifyApplicationAfterFrameRender(fetchResponse, frame);
    }
    applicationAllowsFollowingLinkToLocation(link, location2, ev) {
      const event = this.notifyApplicationAfterClickingLinkToLocation(link, location2, ev);
      return !event.defaultPrevented;
    }
    applicationAllowsVisitingLocation(location2) {
      const event = this.notifyApplicationBeforeVisitingLocation(location2);
      return !event.defaultPrevented;
    }
    notifyApplicationAfterClickingLinkToLocation(link, location2, event) {
      return dispatch("turbo:click", {
        target: link,
        detail: { url: location2.href, originalEvent: event },
        cancelable: true
      });
    }
    notifyApplicationBeforeVisitingLocation(location2) {
      return dispatch("turbo:before-visit", {
        detail: { url: location2.href },
        cancelable: true
      });
    }
    notifyApplicationAfterVisitingLocation(location2, action) {
      return dispatch("turbo:visit", { detail: { url: location2.href, action } });
    }
    notifyApplicationBeforeCachingSnapshot() {
      return dispatch("turbo:before-cache");
    }
    notifyApplicationBeforeRender(newBody, options) {
      return dispatch("turbo:before-render", {
        detail: Object.assign({ newBody }, options),
        cancelable: true
      });
    }
    notifyApplicationAfterRender() {
      return dispatch("turbo:render");
    }
    notifyApplicationAfterPageLoad(timing = {}) {
      return dispatch("turbo:load", {
        detail: { url: this.location.href, timing }
      });
    }
    notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
      dispatchEvent(new HashChangeEvent("hashchange", {
        oldURL: oldURL.toString(),
        newURL: newURL.toString()
      }));
    }
    notifyApplicationAfterFrameLoad(frame) {
      return dispatch("turbo:frame-load", { target: frame });
    }
    notifyApplicationAfterFrameRender(fetchResponse, frame) {
      return dispatch("turbo:frame-render", {
        detail: { fetchResponse },
        target: frame,
        cancelable: true
      });
    }
    submissionIsNavigatable(form, submitter) {
      if (this.formMode == "off") {
        return false;
      } else {
        const submitterIsNavigatable = submitter ? this.elementIsNavigatable(submitter) : true;
        if (this.formMode == "optin") {
          return submitterIsNavigatable && form.closest('[data-turbo="true"]') != null;
        } else {
          return submitterIsNavigatable && this.elementIsNavigatable(form);
        }
      }
    }
    elementIsNavigatable(element) {
      const container = findClosestRecursively(element, "[data-turbo]");
      const withinFrame = findClosestRecursively(element, "turbo-frame");
      if (this.drive || withinFrame) {
        if (container) {
          return container.getAttribute("data-turbo") != "false";
        } else {
          return true;
        }
      } else {
        if (container) {
          return container.getAttribute("data-turbo") == "true";
        } else {
          return false;
        }
      }
    }
    getActionForLink(link) {
      return getVisitAction(link) || "advance";
    }
    get snapshot() {
      return this.view.snapshot;
    }
  };
  function extendURLWithDeprecatedProperties(url) {
    Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
  }
  var deprecatedLocationPropertyDescriptors = {
    absoluteURL: {
      get() {
        return this.toString();
      }
    }
  };
  var Cache = class {
    constructor(session2) {
      this.session = session2;
    }
    clear() {
      this.session.clearCache();
    }
    resetCacheControl() {
      this.setCacheControl("");
    }
    exemptPageFromCache() {
      this.setCacheControl("no-cache");
    }
    exemptPageFromPreview() {
      this.setCacheControl("no-preview");
    }
    setCacheControl(value) {
      setMetaContent("turbo-cache-control", value);
    }
  };
  var StreamActions = {
    after() {
      this.targetElements.forEach((e2) => {
        var _a;
        return (_a = e2.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.templateContent, e2.nextSibling);
      });
    },
    append() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e2) => e2.append(this.templateContent));
    },
    before() {
      this.targetElements.forEach((e2) => {
        var _a;
        return (_a = e2.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(this.templateContent, e2);
      });
    },
    prepend() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e2) => e2.prepend(this.templateContent));
    },
    remove() {
      this.targetElements.forEach((e2) => e2.remove());
    },
    replace() {
      this.targetElements.forEach((e2) => e2.replaceWith(this.templateContent));
    },
    update() {
      this.targetElements.forEach((targetElement) => {
        targetElement.innerHTML = "";
        targetElement.append(this.templateContent);
      });
    }
  };
  var session = new Session();
  var cache = new Cache(session);
  var { navigator: navigator$1 } = session;
  function start2() {
    session.start();
  }
  function registerAdapter(adapter) {
    session.registerAdapter(adapter);
  }
  function visit(location2, options) {
    session.visit(location2, options);
  }
  function connectStreamSource(source) {
    session.connectStreamSource(source);
  }
  function disconnectStreamSource(source) {
    session.disconnectStreamSource(source);
  }
  function renderStreamMessage(message) {
    session.renderStreamMessage(message);
  }
  function clearCache() {
    console.warn("Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`");
    session.clearCache();
  }
  function setProgressBarDelay(delay) {
    session.setProgressBarDelay(delay);
  }
  function setConfirmMethod(confirmMethod) {
    FormSubmission.confirmMethod = confirmMethod;
  }
  function setFormMode(mode) {
    session.setFormMode(mode);
  }
  var Turbo = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    navigator: navigator$1,
    session,
    cache,
    PageRenderer,
    PageSnapshot,
    FrameRenderer,
    start: start2,
    registerAdapter,
    visit,
    connectStreamSource,
    disconnectStreamSource,
    renderStreamMessage,
    clearCache,
    setProgressBarDelay,
    setConfirmMethod,
    setFormMode,
    StreamActions
  });
  var TurboFrameMissingError = class extends Error {
  };
  var FrameController = class {
    constructor(element) {
      this.fetchResponseLoaded = (_fetchResponse) => {
      };
      this.currentFetchRequest = null;
      this.resolveVisitPromise = () => {
      };
      this.connected = false;
      this.hasBeenLoaded = false;
      this.ignoredAttributes = /* @__PURE__ */ new Set();
      this.action = null;
      this.visitCachedSnapshot = ({ element: element2 }) => {
        const frame = element2.querySelector("#" + this.element.id);
        if (frame && this.previousFrameElement) {
          frame.replaceChildren(...this.previousFrameElement.children);
        }
        delete this.previousFrameElement;
      };
      this.element = element;
      this.view = new FrameView(this, this.element);
      this.appearanceObserver = new AppearanceObserver(this, this.element);
      this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);
      this.linkInterceptor = new LinkInterceptor(this, this.element);
      this.restorationIdentifier = uuid();
      this.formSubmitObserver = new FormSubmitObserver(this, this.element);
    }
    connect() {
      if (!this.connected) {
        this.connected = true;
        if (this.loadingStyle == FrameLoadingStyle.lazy) {
          this.appearanceObserver.start();
        } else {
          this.loadSourceURL();
        }
        this.formLinkClickObserver.start();
        this.linkInterceptor.start();
        this.formSubmitObserver.start();
      }
    }
    disconnect() {
      if (this.connected) {
        this.connected = false;
        this.appearanceObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkInterceptor.stop();
        this.formSubmitObserver.stop();
      }
    }
    disabledChanged() {
      if (this.loadingStyle == FrameLoadingStyle.eager) {
        this.loadSourceURL();
      }
    }
    sourceURLChanged() {
      if (this.isIgnoringChangesTo("src"))
        return;
      if (this.element.isConnected) {
        this.complete = false;
      }
      if (this.loadingStyle == FrameLoadingStyle.eager || this.hasBeenLoaded) {
        this.loadSourceURL();
      }
    }
    sourceURLReloaded() {
      const { src } = this.element;
      this.ignoringChangesToAttribute("complete", () => {
        this.element.removeAttribute("complete");
      });
      this.element.src = null;
      this.element.src = src;
      return this.element.loaded;
    }
    completeChanged() {
      if (this.isIgnoringChangesTo("complete"))
        return;
      this.loadSourceURL();
    }
    loadingStyleChanged() {
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.appearanceObserver.stop();
        this.loadSourceURL();
      }
    }
    async loadSourceURL() {
      if (this.enabled && this.isActive && !this.complete && this.sourceURL) {
        this.element.loaded = this.visit(expandURL(this.sourceURL));
        this.appearanceObserver.stop();
        await this.element.loaded;
        this.hasBeenLoaded = true;
      }
    }
    async loadResponse(fetchResponse) {
      if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
        this.sourceURL = fetchResponse.response.url;
      }
      try {
        const html = await fetchResponse.responseHTML;
        if (html) {
          const document2 = parseHTMLDocument(html);
          const pageSnapshot = PageSnapshot.fromDocument(document2);
          if (pageSnapshot.isVisitable) {
            await this.loadFrameResponse(fetchResponse, document2);
          } else {
            await this.handleUnvisitableFrameResponse(fetchResponse);
          }
        }
      } finally {
        this.fetchResponseLoaded = () => {
        };
      }
    }
    elementAppearedInViewport(element) {
      this.proposeVisitIfNavigatedWithAction(element, element);
      this.loadSourceURL();
    }
    willSubmitFormLinkToLocation(link) {
      return this.shouldInterceptNavigation(link);
    }
    submittedFormLinkToLocation(link, _location, form) {
      const frame = this.findFrameElement(link);
      if (frame)
        form.setAttribute("data-turbo-frame", frame.id);
    }
    shouldInterceptLinkClick(element, _location, _event) {
      return this.shouldInterceptNavigation(element);
    }
    linkClickIntercepted(element, location2) {
      this.navigateFrame(element, location2);
    }
    willSubmitForm(element, submitter) {
      return element.closest("turbo-frame") == this.element && this.shouldInterceptNavigation(element, submitter);
    }
    formSubmitted(element, submitter) {
      if (this.formSubmission) {
        this.formSubmission.stop();
      }
      this.formSubmission = new FormSubmission(this, element, submitter);
      const { fetchRequest } = this.formSubmission;
      this.prepareRequest(fetchRequest);
      this.formSubmission.start();
    }
    prepareRequest(request) {
      var _a;
      request.headers["Turbo-Frame"] = this.id;
      if ((_a = this.currentNavigationElement) === null || _a === void 0 ? void 0 : _a.hasAttribute("data-turbo-stream")) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      markAsBusy(this.element);
    }
    requestPreventedHandlingResponse(_request, _response) {
      this.resolveVisitPromise();
    }
    async requestSucceededWithResponse(request, response) {
      await this.loadResponse(response);
      this.resolveVisitPromise();
    }
    async requestFailedWithResponse(request, response) {
      await this.loadResponse(response);
      this.resolveVisitPromise();
    }
    requestErrored(request, error2) {
      console.error(error2);
      this.resolveVisitPromise();
    }
    requestFinished(_request) {
      clearBusyState(this.element);
    }
    formSubmissionStarted({ formElement }) {
      markAsBusy(formElement, this.findFrameElement(formElement));
    }
    formSubmissionSucceededWithResponse(formSubmission, response) {
      const frame = this.findFrameElement(formSubmission.formElement, formSubmission.submitter);
      frame.delegate.proposeVisitIfNavigatedWithAction(frame, formSubmission.formElement, formSubmission.submitter);
      frame.delegate.loadResponse(response);
      if (!formSubmission.isSafe) {
        session.clearCache();
      }
    }
    formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      this.element.delegate.loadResponse(fetchResponse);
      session.clearCache();
    }
    formSubmissionErrored(formSubmission, error2) {
      console.error(error2);
    }
    formSubmissionFinished({ formElement }) {
      clearBusyState(formElement, this.findFrameElement(formElement));
    }
    allowsImmediateRender({ element: newFrame }, options) {
      const event = dispatch("turbo:before-frame-render", {
        target: this.element,
        detail: Object.assign({ newFrame }, options),
        cancelable: true
      });
      const { defaultPrevented, detail: { render } } = event;
      if (this.view.renderer && render) {
        this.view.renderer.renderElement = render;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview) {
    }
    preloadOnLoadLinksForView(element) {
      session.preloadOnLoadLinksForView(element);
    }
    viewInvalidated() {
    }
    willRenderFrame(currentElement, _newElement) {
      this.previousFrameElement = currentElement.cloneNode(true);
    }
    async loadFrameResponse(fetchResponse, document2) {
      const newFrameElement = await this.extractForeignFrameElement(document2.body);
      if (newFrameElement) {
        const snapshot = new Snapshot(newFrameElement);
        const renderer = new FrameRenderer(this, this.view.snapshot, snapshot, FrameRenderer.renderElement, false, false);
        if (this.view.renderPromise)
          await this.view.renderPromise;
        this.changeHistory();
        await this.view.render(renderer);
        this.complete = true;
        session.frameRendered(fetchResponse, this.element);
        session.frameLoaded(this.element);
        this.fetchResponseLoaded(fetchResponse);
      } else if (this.willHandleFrameMissingFromResponse(fetchResponse)) {
        this.handleFrameMissingFromResponse(fetchResponse);
      }
    }
    async visit(url) {
      var _a;
      const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);
      (_a = this.currentFetchRequest) === null || _a === void 0 ? void 0 : _a.cancel();
      this.currentFetchRequest = request;
      return new Promise((resolve) => {
        this.resolveVisitPromise = () => {
          this.resolveVisitPromise = () => {
          };
          this.currentFetchRequest = null;
          resolve();
        };
        request.perform();
      });
    }
    navigateFrame(element, url, submitter) {
      const frame = this.findFrameElement(element, submitter);
      frame.delegate.proposeVisitIfNavigatedWithAction(frame, element, submitter);
      this.withCurrentNavigationElement(element, () => {
        frame.src = url;
      });
    }
    proposeVisitIfNavigatedWithAction(frame, element, submitter) {
      this.action = getVisitAction(submitter, element, frame);
      if (this.action) {
        const pageSnapshot = PageSnapshot.fromElement(frame).clone();
        const { visitCachedSnapshot } = frame.delegate;
        frame.delegate.fetchResponseLoaded = (fetchResponse) => {
          if (frame.src) {
            const { statusCode, redirected } = fetchResponse;
            const responseHTML = frame.ownerDocument.documentElement.outerHTML;
            const response = { statusCode, redirected, responseHTML };
            const options = {
              response,
              visitCachedSnapshot,
              willRender: false,
              updateHistory: false,
              restorationIdentifier: this.restorationIdentifier,
              snapshot: pageSnapshot
            };
            if (this.action)
              options.action = this.action;
            session.visit(frame.src, options);
          }
        };
      }
    }
    changeHistory() {
      if (this.action) {
        const method = getHistoryMethodForAction(this.action);
        session.history.update(method, expandURL(this.element.src || ""), this.restorationIdentifier);
      }
    }
    async handleUnvisitableFrameResponse(fetchResponse) {
      console.warn(`The response (${fetchResponse.statusCode}) from <turbo-frame id="${this.element.id}"> is performing a full page visit due to turbo-visit-control.`);
      await this.visitResponse(fetchResponse.response);
    }
    willHandleFrameMissingFromResponse(fetchResponse) {
      this.element.setAttribute("complete", "");
      const response = fetchResponse.response;
      const visit2 = async (url, options = {}) => {
        if (url instanceof Response) {
          this.visitResponse(url);
        } else {
          session.visit(url, options);
        }
      };
      const event = dispatch("turbo:frame-missing", {
        target: this.element,
        detail: { response, visit: visit2 },
        cancelable: true
      });
      return !event.defaultPrevented;
    }
    handleFrameMissingFromResponse(fetchResponse) {
      this.view.missing();
      this.throwFrameMissingError(fetchResponse);
    }
    throwFrameMissingError(fetchResponse) {
      const message = `The response (${fetchResponse.statusCode}) did not contain the expected <turbo-frame id="${this.element.id}"> and will be ignored. To perform a full page visit instead, set turbo-visit-control to reload.`;
      throw new TurboFrameMissingError(message);
    }
    async visitResponse(response) {
      const wrapped = new FetchResponse(response);
      const responseHTML = await wrapped.responseHTML;
      const { location: location2, redirected, statusCode } = wrapped;
      return session.visit(location2, { response: { redirected, statusCode, responseHTML } });
    }
    findFrameElement(element, submitter) {
      var _a;
      const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      return (_a = getFrameElementById(id)) !== null && _a !== void 0 ? _a : this.element;
    }
    async extractForeignFrameElement(container) {
      let element;
      const id = CSS.escape(this.id);
      try {
        element = activateElement(container.querySelector(`turbo-frame#${id}`), this.sourceURL);
        if (element) {
          return element;
        }
        element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id}]`), this.sourceURL);
        if (element) {
          await element.loaded;
          return await this.extractForeignFrameElement(element);
        }
      } catch (error2) {
        console.error(error2);
        return new FrameElement();
      }
      return null;
    }
    formActionIsVisitable(form, submitter) {
      const action = getAction(form, submitter);
      return locationIsVisitable(expandURL(action), this.rootLocation);
    }
    shouldInterceptNavigation(element, submitter) {
      const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
      if (element instanceof HTMLFormElement && !this.formActionIsVisitable(element, submitter)) {
        return false;
      }
      if (!this.enabled || id == "_top") {
        return false;
      }
      if (id) {
        const frameElement = getFrameElementById(id);
        if (frameElement) {
          return !frameElement.disabled;
        }
      }
      if (!session.elementIsNavigatable(element)) {
        return false;
      }
      if (submitter && !session.elementIsNavigatable(submitter)) {
        return false;
      }
      return true;
    }
    get id() {
      return this.element.id;
    }
    get enabled() {
      return !this.element.disabled;
    }
    get sourceURL() {
      if (this.element.src) {
        return this.element.src;
      }
    }
    set sourceURL(sourceURL) {
      this.ignoringChangesToAttribute("src", () => {
        this.element.src = sourceURL !== null && sourceURL !== void 0 ? sourceURL : null;
      });
    }
    get loadingStyle() {
      return this.element.loading;
    }
    get isLoading() {
      return this.formSubmission !== void 0 || this.resolveVisitPromise() !== void 0;
    }
    get complete() {
      return this.element.hasAttribute("complete");
    }
    set complete(value) {
      this.ignoringChangesToAttribute("complete", () => {
        if (value) {
          this.element.setAttribute("complete", "");
        } else {
          this.element.removeAttribute("complete");
        }
      });
    }
    get isActive() {
      return this.element.isActive && this.connected;
    }
    get rootLocation() {
      var _a;
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const root = (_a = meta === null || meta === void 0 ? void 0 : meta.content) !== null && _a !== void 0 ? _a : "/";
      return expandURL(root);
    }
    isIgnoringChangesTo(attributeName) {
      return this.ignoredAttributes.has(attributeName);
    }
    ignoringChangesToAttribute(attributeName, callback) {
      this.ignoredAttributes.add(attributeName);
      callback();
      this.ignoredAttributes.delete(attributeName);
    }
    withCurrentNavigationElement(element, callback) {
      this.currentNavigationElement = element;
      callback();
      delete this.currentNavigationElement;
    }
  };
  function getFrameElementById(id) {
    if (id != null) {
      const element = document.getElementById(id);
      if (element instanceof FrameElement) {
        return element;
      }
    }
  }
  function activateElement(element, currentURL) {
    if (element) {
      const src = element.getAttribute("src");
      if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
        throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
      }
      if (element.ownerDocument !== document) {
        element = document.importNode(element, true);
      }
      if (element instanceof FrameElement) {
        element.connectedCallback();
        element.disconnectedCallback();
        return element;
      }
    }
  }
  var StreamElement = class _StreamElement extends HTMLElement {
    static async renderElement(newElement) {
      await newElement.performAction();
    }
    async connectedCallback() {
      try {
        await this.render();
      } catch (error2) {
        console.error(error2);
      } finally {
        this.disconnect();
      }
    }
    async render() {
      var _a;
      return (_a = this.renderPromise) !== null && _a !== void 0 ? _a : this.renderPromise = (async () => {
        const event = this.beforeRenderEvent;
        if (this.dispatchEvent(event)) {
          await nextAnimationFrame();
          await event.detail.render(this);
        }
      })();
    }
    disconnect() {
      try {
        this.remove();
      } catch (_a) {
      }
    }
    removeDuplicateTargetChildren() {
      this.duplicateChildren.forEach((c2) => c2.remove());
    }
    get duplicateChildren() {
      var _a;
      const existingChildren = this.targetElements.flatMap((e2) => [...e2.children]).filter((c2) => !!c2.id);
      const newChildrenIds = [...((_a = this.templateContent) === null || _a === void 0 ? void 0 : _a.children) || []].filter((c2) => !!c2.id).map((c2) => c2.id);
      return existingChildren.filter((c2) => newChildrenIds.includes(c2.id));
    }
    get performAction() {
      if (this.action) {
        const actionFunction = StreamActions[this.action];
        if (actionFunction) {
          return actionFunction;
        }
        this.raise("unknown action");
      }
      this.raise("action attribute is missing");
    }
    get targetElements() {
      if (this.target) {
        return this.targetElementsById;
      } else if (this.targets) {
        return this.targetElementsByQuery;
      } else {
        this.raise("target or targets attribute is missing");
      }
    }
    get templateContent() {
      return this.templateElement.content.cloneNode(true);
    }
    get templateElement() {
      if (this.firstElementChild === null) {
        const template = this.ownerDocument.createElement("template");
        this.appendChild(template);
        return template;
      } else if (this.firstElementChild instanceof HTMLTemplateElement) {
        return this.firstElementChild;
      }
      this.raise("first child element must be a <template> element");
    }
    get action() {
      return this.getAttribute("action");
    }
    get target() {
      return this.getAttribute("target");
    }
    get targets() {
      return this.getAttribute("targets");
    }
    raise(message) {
      throw new Error(`${this.description}: ${message}`);
    }
    get description() {
      var _a, _b;
      return (_b = ((_a = this.outerHTML.match(/<[^>]+>/)) !== null && _a !== void 0 ? _a : [])[0]) !== null && _b !== void 0 ? _b : "<turbo-stream>";
    }
    get beforeRenderEvent() {
      return new CustomEvent("turbo:before-stream-render", {
        bubbles: true,
        cancelable: true,
        detail: { newStream: this, render: _StreamElement.renderElement }
      });
    }
    get targetElementsById() {
      var _a;
      const element = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.getElementById(this.target);
      if (element !== null) {
        return [element];
      } else {
        return [];
      }
    }
    get targetElementsByQuery() {
      var _a;
      const elements = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.querySelectorAll(this.targets);
      if (elements.length !== 0) {
        return Array.prototype.slice.call(elements);
      } else {
        return [];
      }
    }
  };
  var StreamSourceElement = class extends HTMLElement {
    constructor() {
      super(...arguments);
      this.streamSource = null;
    }
    connectedCallback() {
      this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);
      connectStreamSource(this.streamSource);
    }
    disconnectedCallback() {
      if (this.streamSource) {
        disconnectStreamSource(this.streamSource);
      }
    }
    get src() {
      return this.getAttribute("src") || "";
    }
  };
  FrameElement.delegateConstructor = FrameController;
  if (customElements.get("turbo-frame") === void 0) {
    customElements.define("turbo-frame", FrameElement);
  }
  if (customElements.get("turbo-stream") === void 0) {
    customElements.define("turbo-stream", StreamElement);
  }
  if (customElements.get("turbo-stream-source") === void 0) {
    customElements.define("turbo-stream-source", StreamSourceElement);
  }
  (() => {
    let element = document.currentScript;
    if (!element)
      return;
    if (element.hasAttribute("data-turbo-suppress-warning"))
      return;
    element = element.parentElement;
    while (element) {
      if (element == document.body) {
        return console.warn(unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your applications JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `, element.outerHTML);
      }
      element = element.parentElement;
    }
  })();
  window.Turbo = Turbo;
  start2();

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable.js
  var consumer;
  async function getConsumer() {
    return consumer || setConsumer(createConsumer2().then(setConsumer));
  }
  function setConsumer(newConsumer) {
    return consumer = newConsumer;
  }
  async function createConsumer2() {
    const { createConsumer: createConsumer3 } = await Promise.resolve().then(() => (init_src(), src_exports));
    return createConsumer3();
  }
  async function subscribeTo(channel, mixin) {
    const { subscriptions } = await getConsumer();
    return subscriptions.create(channel, mixin);
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/snakeize.js
  function walk(obj) {
    if (!obj || typeof obj !== "object")
      return obj;
    if (obj instanceof Date || obj instanceof RegExp)
      return obj;
    if (Array.isArray(obj))
      return obj.map(walk);
    return Object.keys(obj).reduce(function(acc, key) {
      var camel = key[0].toLowerCase() + key.slice(1).replace(/([A-Z]+)/g, function(m2, x2) {
        return "_" + x2.toLowerCase();
      });
      acc[camel] = walk(obj[key]);
      return acc;
    }, {});
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable_stream_source_element.js
  var TurboCableStreamSourceElement = class extends HTMLElement {
    async connectedCallback() {
      connectStreamSource(this);
      this.subscription = await subscribeTo(this.channel, {
        received: this.dispatchMessageEvent.bind(this),
        connected: this.subscriptionConnected.bind(this),
        disconnected: this.subscriptionDisconnected.bind(this)
      });
    }
    disconnectedCallback() {
      disconnectStreamSource(this);
      if (this.subscription)
        this.subscription.unsubscribe();
    }
    dispatchMessageEvent(data) {
      const event = new MessageEvent("message", { data });
      return this.dispatchEvent(event);
    }
    subscriptionConnected() {
      this.setAttribute("connected", "");
    }
    subscriptionDisconnected() {
      this.removeAttribute("connected");
    }
    get channel() {
      const channel = this.getAttribute("channel");
      const signed_stream_name = this.getAttribute("signed-stream-name");
      return { channel, signed_stream_name, ...walk({ ...this.dataset }) };
    }
  };
  if (customElements.get("turbo-cable-stream-source") === void 0) {
    customElements.define("turbo-cable-stream-source", TurboCableStreamSourceElement);
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/fetch_requests.js
  function encodeMethodIntoRequestBody(event) {
    if (event.target instanceof HTMLFormElement) {
      const { target: form, detail: { fetchOptions } } = event;
      form.addEventListener("turbo:submit-start", ({ detail: { formSubmission: { submitter } } }) => {
        const body = isBodyInit(fetchOptions.body) ? fetchOptions.body : new URLSearchParams();
        const method = determineFetchMethod(submitter, body, form);
        if (!/get/i.test(method)) {
          if (/post/i.test(method)) {
            body.delete("_method");
          } else {
            body.set("_method", method);
          }
          fetchOptions.method = "post";
        }
      }, { once: true });
    }
  }
  function determineFetchMethod(submitter, body, form) {
    const formMethod = determineFormMethod(submitter);
    const overrideMethod = body.get("_method");
    const method = form.getAttribute("method") || "get";
    if (typeof formMethod == "string") {
      return formMethod;
    } else if (typeof overrideMethod == "string") {
      return overrideMethod;
    } else {
      return method;
    }
  }
  function determineFormMethod(submitter) {
    if (submitter instanceof HTMLButtonElement || submitter instanceof HTMLInputElement) {
      if (submitter.hasAttribute("formmethod")) {
        return submitter.formMethod;
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
  function isBodyInit(body) {
    return body instanceof FormData || body instanceof URLSearchParams;
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/index.js
  addEventListener("turbo:before-fetch-request", encodeMethodIntoRequestBody);

  // app/javascript/controllers/app.js
  var import_jquery6 = __toESM(require_jquery());
  var import_tinymce = __toESM(require_tinymce());
  window.jQuery = import_jquery6.default;
  window.$ = import_jquery6.default;
  $(document).on("turbo:load", function() {
    console.log("Turbolinks loaded");
    const select = (el, all = false) => {
      el = el.trim();
      if (all) {
        return [...document.querySelectorAll(el)];
      } else {
        return document.querySelector(el);
      }
    };
    const on = (type, el, listener, all = false) => {
      if (all) {
        select(el, all).forEach((e2) => e2.addEventListener(type, listener));
      } else {
        select(el, all).addEventListener(type, listener);
      }
    };
    const onscroll = (el, listener) => {
      el.addEventListener("scroll", listener);
    };
    if (select(".toggle-sidebar-btn")) {
      on("click", ".toggle-sidebar-btn", function(e2) {
        select("body").classList.toggle("toggle-sidebar");
      });
    }
    if (select(".search-bar-toggle")) {
      on("click", ".search-bar-toggle", function(e2) {
        select(".search-bar").classList.toggle("search-bar-show");
      });
    }
    let navbarlinks = select("#navbar .scrollto", true);
    const navbarlinksActive = () => {
      let position = window.scrollY + 200;
      navbarlinks.forEach((navbarlink) => {
        if (!navbarlink.hash)
          return;
        let section = select(navbarlink.hash);
        if (!section)
          return;
        if (position >= section.offsetTop && position <= section.offsetTop + section.offsetHeight) {
          navbarlink.classList.add("active");
        } else {
          navbarlink.classList.remove("active");
        }
      });
    };
    window.addEventListener("load", navbarlinksActive);
    onscroll(document, navbarlinksActive);
    let selectHeader = select("#header");
    if (selectHeader) {
      const headerScrolled = () => {
        if (window.scrollY > 100) {
          selectHeader.classList.add("header-scrolled");
        } else {
          selectHeader.classList.remove("header-scrolled");
        }
      };
      window.addEventListener("load", headerScrolled);
      onscroll(document, headerScrolled);
    }
    let backtotop = select(".back-to-top");
    if (backtotop) {
      const toggleBacktotop = () => {
        if (window.scrollY > 100) {
          backtotop.classList.add("active");
        } else {
          backtotop.classList.remove("active");
        }
      };
      window.addEventListener("load", toggleBacktotop);
      onscroll(document, toggleBacktotop);
    }
    var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    var tooltipList = tooltipTriggerList.map(function(tooltipTriggerEl) {
      return new Tooltip(tooltipTriggerEl);
    });
    if (select(".quill-editor-default")) {
      new Quill(".quill-editor-default", {
        theme: "snow"
      });
    }
    if (select(".quill-editor-bubble")) {
      new Quill(".quill-editor-bubble", {
        theme: "bubble"
      });
    }
    if (select(".quill-editor-full")) {
      new Quill(".quill-editor-full", {
        modules: {
          toolbar: [
            [{
              font: []
            }, {
              size: []
            }],
            ["bold", "italic", "underline", "strike"],
            [
              {
                color: []
              },
              {
                background: []
              }
            ],
            [
              {
                script: "super"
              },
              {
                script: "sub"
              }
            ],
            [
              {
                list: "ordered"
              },
              {
                list: "bullet"
              },
              {
                indent: "-1"
              },
              {
                indent: "+1"
              }
            ],
            ["direction", {
              align: []
            }],
            ["link", "image", "video"],
            ["clean"]
          ]
        },
        theme: "snow"
      });
    }
    const useDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches;
    const isSmallScreen = window.matchMedia("(max-width: 1023.5px)").matches;
    tinymce.init({
      selector: "textarea.tinymce-editor",
      plugins: "preview importcss searchreplace autolink autosave save directionality code visualblocks visualchars fullscreen image link media template codesample table charmap pagebreak nonbreaking anchor insertdatetime advlist lists wordcount help charmap quickbars emoticons",
      editimage_cors_hosts: ["picsum.photos"],
      menubar: "file edit view insert format tools table help",
      toolbar: "undo redo | bold italic underline strikethrough | fontfamily fontsize blocks | alignleft aligncenter alignright alignjustify | outdent indent |  numlist bullist | forecolor backcolor removeformat | pagebreak | charmap emoticons | fullscreen  preview save print | insertfile image media template link anchor codesample | ltr rtl",
      toolbar_sticky: true,
      toolbar_sticky_offset: isSmallScreen ? 102 : 108,
      autosave_ask_before_unload: true,
      autosave_interval: "30s",
      autosave_prefix: "{path}{query}-{id}-",
      autosave_restore_when_empty: false,
      autosave_retention: "2m",
      image_advtab: true,
      link_list: [
        {
          title: "My page 1",
          value: "https://www.tiny.cloud"
        },
        {
          title: "My page 2",
          value: "http://www.moxiecode.com"
        }
      ],
      image_list: [
        {
          title: "My page 1",
          value: "https://www.tiny.cloud"
        },
        {
          title: "My page 2",
          value: "http://www.moxiecode.com"
        }
      ],
      image_class_list: [
        {
          title: "None",
          value: ""
        },
        {
          title: "Some class",
          value: "class-name"
        }
      ],
      importcss_append: true,
      file_picker_callback: (callback, value, meta) => {
        if (meta.filetype === "file") {
          callback("https://www.google.com/logos/google.jpg", {
            text: "My text"
          });
        }
        if (meta.filetype === "image") {
          callback("https://www.google.com/logos/google.jpg", {
            alt: "My alt text"
          });
        }
        if (meta.filetype === "media") {
          callback("movie.mp4", {
            source2: "alt.ogg",
            poster: "https://www.google.com/logos/google.jpg"
          });
        }
      },
      templates: [
        {
          title: "New Table",
          description: "creates a new table",
          content: '<div class="mceTmpl"><table width="98%%"  border="0" cellspacing="0" cellpadding="0"><tr><th scope="col"> </th><th scope="col"> </th></tr><tr><td> </td><td> </td></tr></table></div>'
        },
        {
          title: "Starting my story",
          description: "A cure for writers block",
          content: "Once upon a time..."
        },
        {
          title: "New list with dates",
          description: "New List with dates",
          content: '<div class="mceTmpl"><span class="cdate">cdate</span><br><span class="mdate">mdate</span><h2>My List</h2><ul><li></li><li></li></ul></div>'
        }
      ],
      template_cdate_format: "[Date Created (CDATE): %m/%d/%Y : %H:%M:%S]",
      template_mdate_format: "[Date Modified (MDATE): %m/%d/%Y : %H:%M:%S]",
      height: 600,
      image_caption: true,
      quickbars_selection_toolbar: "bold italic | quicklink h2 h3 blockquote quickimage quicktable",
      noneditable_class: "mceNonEditable",
      toolbar_mode: "sliding",
      contextmenu: "link image table",
      skin: useDarkMode ? "oxide-dark" : "oxide",
      content_css: useDarkMode ? "dark" : "default",
      content_style: "body { font-family:Helvetica,Arial,sans-serif; font-size:16px }"
    });
    var needsValidation = document.querySelectorAll(".needs-validation");
    Array.prototype.slice.call(needsValidation).forEach(function(form) {
      form.addEventListener("submit", function(event) {
        if (!form.checkValidity()) {
          event.preventDefault();
          event.stopPropagation();
        }
        form.classList.add("was-validated");
      }, false);
    });
    const mainContainer = select("#main");
    if (mainContainer) {
      setTimeout(() => {
        new ResizeObserver(function() {
          select(".echart", true).forEach((getEchart) => {
            echarts.getInstanceByDom(getEchart).resize();
          });
        }).observe(mainContainer);
      }, 200);
    }
  });

  // app/javascript/application.js
  var import_jquery7 = __toESM(require_jquery());
  window.jQuery = import_jquery7.default;
  window.$ = import_jquery7.default;
})();
/*! Bundled license information:

jquery/dist/jquery.js:
  (*!
   * jQuery JavaScript Library v3.7.1
   * https://jquery.com/
   *
   * Copyright OpenJS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2023-08-28T13:37Z
   *)

select2/dist/js/select2.js:
  (*!
   * Select2 4.1.0-rc.0
   * https://select2.github.io
   *
   * Released under the MIT license
   * https://github.com/select2/select2/blob/master/LICENSE.md
   *)
  (**
   * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.
   * Released under MIT license, http://github.com/requirejs/almond/LICENSE
   *)

sweetalert2/dist/sweetalert2.all.js:
  (*!
  * sweetalert2 v11.12.4
  * Released under the MIT License.
  *)

bootstrap/dist/js/bootstrap.esm.js:
  (*!
    * Bootstrap v5.3.3 (https://getbootstrap.com/)
    * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
    * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
    *)

datatables.net/js/jquery.dataTables.mjs:
  (*! DataTables 1.13.11
   * 2008-2024 SpryMedia Ltd - datatables.net/license
   *)

datatables.net-bs5/js/dataTables.bootstrap5.mjs:
  (*! DataTables Bootstrap 5 integration
   * 2020 SpryMedia Ltd - datatables.net/license
   *)

datatables.net-responsive/js/dataTables.responsive.mjs:
  (*! Responsive 2.5.0
   *  SpryMedia Ltd - datatables.net/license
   *)

datatables.net-responsive-bs5/js/responsive.bootstrap5.mjs:
  (*! Bootstrap 5 integration for DataTables' Responsive
   *  SpryMedia Ltd - datatables.net/license
   *)
*/
//# sourceMappingURL=/assets/application.js.map
